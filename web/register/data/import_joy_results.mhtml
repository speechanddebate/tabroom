<%args>
	$tourn
	$tourn_settings
	$person
	$person_settings
	$from  => undef
</%args>
<%init>

	use POSIX;
	use Text::CSV::Encoded;

	my $csv = Text::CSV::Encoded->new ({
		sep_char     => ',',
		encoding_in  => "iso-8859-1", # the encoding that comes into Perl
		encoding_out => "iso-8859-1", # the encoding that comes out of Perl
	});

    use Tab::NSDA::Login;
    use Tab::NSDA::Person;
    use Tab::NSDA::PersonSchool;
    use Tab::NSDA::MemberSchool;

	my %ignore_me = map {$_ => 1} (
		"fees",
		"judcommit",
		"outcomes",
		"pairopts",
		"restrictions",
		"roomavails",
		"rsvps",
		"seeds",
		"seqstrs",
		"sweeps",
		"team4s",
		"todos",
		"actions",
		"bag"
	);

	my %fucked_joy_rounds = (
		1  => "prelim",
		2  => "prelim",
		3  => "prelim",
		4  => "prelim",
		5  => "prelim",
		11 => "prelim",
		12 => "prelim",
		13 => "prelim",
		14 => "prelim",
		15 => "prelim",
		17 => "runoff",
		10 => "elim",
		9  => "elim",
		6  => "elim",
		7  => "elim",
		16 => "elim",
		8  => "final"
	);

	Tab::Student->set_sql( entry => "
		select student.*
		from student, entry_student
		where student.id = entry_student.student
		and entry_student.entry = ?
	");

	Tab::Ballot->set_sql( "fakes" => "
		select ballot.*
		from ballot, score
		where ballot.panel = ?
		and ballot.id = score.ballot
		and not exists (
			select b2.id
			from ballot b2, score s2
			where b2.judge = ballot.judge
			and b2.panel = ballot.panel
			and b2.id = s2.ballot
			and s2.tag = 'rank'
			and s2.value != 9
		)
		and not exists (
			select b3.id
			from ballot b3, score s3
			where b3.judge = ballot.judge
			and b3.panel = ballot.panel
			and b3.id = s3.ballot
			and s3.tag = 'ballot'
		)
	");

    # Get the upload and create the file handle.
    my $req = Apache2::Request->new($r);
    my @csv_handles = $r->upload;

    my $csv_file = $req->upload($csv_handles[0]);
    my $io = $csv_file->io;

    my @lines = <$io>;
    my @all_lines;

	my $now = DateTime->now();
	my $this_year = $now->year;
	$this_year++ if $now->month > 7;

    foreach (@lines) {
        $_ =~ s/[\r]+/\n/g;
        $_ =~ s/[\r\n]+/\n/g;
        $_ =~ s/[\n]+/\n/g;
        push @all_lines, split (/\n/, $_);
    }

	my @results;
	my @changes;
	my %segments;

	my $next_header;
	my $segment_key;
	my $segment_label;

	my $district_id = $tourn_settings->{"nsda_district"};
	my $district = Tab::District->retrieve($district_id);

	my $tz = $tourn->tz;
	$tz = "UTC" unless $tz;

	# I cannot believe I have to worry about the order this file is in but in
	# some cases the order of the data actually friggin matters.  I was Hitler
	# in a past life or something.

	my $order = 0;

	foreach my $line (@lines) {
		chomp $line;
		if ($line eq '!#:----------:#!') {
			$next_header++;
		} elsif ($next_header) {
			($segment_label, $segment_label) = split(':', $line);
			undef $next_header;
		} elsif ($ignore_me{$segment_label}) {
			# DO NOTHING I TELL YOU.  NOTHING.
		} else {
			$segments{$segment_label}{$order++} = $line;
		}
	}

	my %tourn_settings;

	foreach my $linekey (sort keys %{$segments{"TRN"}}) {
		my $line = $segments{"TRN"}{$linekey};
		my ($key, $value) = split("=", $line);
		next unless $value;
		$tourn_settings{$key} = $value;
		$ignore_me{"TRN"}++;
	}

	Tab::TournSite->set_sql( delete_blanks => "
		delete from tourn_site
		where tourn = ?
		and site = 0
	");

	Tab::TournSite->sql_delete_blanks->execute($tourn->id);

	my @sites = $tourn->sites;

	my $default_site;
	$default_site = shift @sites if @sites;

	my $default_weekend_site;

	unless ($default_site > 0) {

		$default_site = Tab::Site->create({
			name => $tourn->name." site",
			host => $person->id
		});

		Tab::TournSite->create({
			tourn => $tourn->id,
			site  => $default_site->id
		});

	}

	undef $segments{"actions"};
	undef $segments{"bag"};
	undef $segments{"fees"};
	undef $segments{"TRN"};

	my %judge_pools;

	#JUDGE CATEGORIES OR POOLS OR SOMESUCH.
	foreach my $linekey (sort keys %{$segments{"judprefs"}}) {
		my $line = $segments{"judprefs"}{$linekey};

		next unless $csv->parse($line);

		my (
			$judge_id, $category
		) = $csv->fields();

		next if $judge_id eq "Judge ID";
		$judge_id = int($judge_id);
		$category = int($category);

		$judge_pools{$judge_id}{$category}++;

	}

	$ignore_me{"judprefs"}++;

	my $counter = 0;
	my %event_categories;

	$m->print('<div class="main">');

	$m->print("<h5>Importing for district ".$district->code." ".$district->name." </h5>") if $district;

	foreach my $judge (sort keys %judge_pools) {

		my $standing_category;

		foreach my $event (sort keys %{$judge_pools{$judge}}) {

			next if $event eq "Event ID";

			unless ($event_categories{$event}) {

				unless ($standing_category) {
					$counter++;
					$standing_category = $counter;
				}

				$event_categories{$event} = $standing_category;
			}
		}
	}

	foreach my $category (1 .. $counter) {

		my @events;

		foreach my $key (sort keys %event_categories) {
			push @events, $event_categories{$key};
		}
	}

	my @all_events = $tourn->events;

	my %events;

	foreach my $test (@all_events) {
		my $jot_id = int($test->setting('jot_id'));
		$events{$jot_id} = $test;
	}

	my $found = 0;
	my $created = 0;
	my %categories;
	my %event_web_ids;

	$m->flush_buffer();
	$m->print("<h6 class='redtext semibold'>Importing events</h6>");

	my %weekends;
	my %sites;
	my %event_site;
	my %event_house_section;
	my %section_round_type;

	my $house = $tourn->events( abbr => "HOU")->first;
	my %house_sections;
	my $house_section_counter;

	$m->print("<p class='semibold marleft'>");
	my $description = "Uploaded JOT generated results ";

	#EVENTS CATEGORIES
	LINE:
	foreach my $linekey (sort keys %{$segments{"events"}}) {
		my $line = $segments{"events"}{$linekey};

		next unless $csv->parse($line);

		my (
			$internal_event_id, $event_name, $attributes, $entry_fee, $pattern,
			$duration, $copies, $complete, $method, $drop_fee, $team_count,
			$entry_blank, $drop_fee2, $drop_fee3, $drop_fee4, $speaker_goal,
			$flags, $min_points, $max_points, $nfl, $tab_method, $rows,
			$columns, $event_id, $performance, $web_type, $ballot_style,
			$type, $prelim_method
		) = $csv->fields();

		next LINE if $internal_event_id eq "Event ID";

		# Fucking JOT inconsistency
		$event_name = "US Extemp" if $event_name eq "Domestic Extemp";
		$entry_blank = "USX" if $entry_blank eq "DX";

		$event_name = "International Extemp" if $event_name eq "Foreign Extemp";
		$entry_blank = "IX" if $entry_blank eq "FX";

		$internal_event_id = int($internal_event_id);

		if (index($attributes, "CONGRESS") != -1) {
			$house_sections{$internal_event_id} = $event_name;
			$event_web_ids{$internal_event_id} = "HOUSE";

			$events{"HOUSE"} = $house;
			$event_id = -1;
		} else {
			$event_web_ids{$internal_event_id} = $event_id;
		}

		my $event;

		if ($event_id < 0) {

			$house_section_counter++;
			my $section_number = $house_section_counter;
			$event_house_section{$internal_event_id} = $section_number;
			$event = $house;
			$description .= " ".$entry_blank." to ".$event->abbr;
			$m->print("<span class='redtext half'>Congress: $event_name map to ".$house->abbr." for now</span>");

		} else {

			if ($events{$event_id}) {

				$found++;
				$m->print("<span class='half bluetext'>Found ".$events{$event_id}->abbr."</span>");

				my $category_code = $event_categories{$internal_event_id};
				$categories{$category_code} = $events{$event_id}->category;
				$categories{$category_code}->setting("jot_id", $category_code);

				$events{$event_id}->setting('code_style', "numbers");
				$description .= " ".$entry_blank." to ".$events{$event_id}->abbr;
				next LINE;
			}

			$m->print("<span class='half'>Searching for $event_name by name:");

			if ($tourn_settings{"NFL"} == 1) {

				$event = Tab::Event->search(
					tourn => $tourn->id,
					abbr  => $entry_blank
				)->first;

			} else {

				$event = Tab::Event->search(
					tourn => $tourn->id,
					name  => $event_name
				)->first;

				unless ($event) {
					$event = Tab::Event->search(
						tourn => $tourn->id,
						abbr => $entry_blank
					)->first;
				}

			}

			if ($event) {
				$found++;
				$m->print("Found </span>");
			}

			my $category;

			unless ($event) {

				unless ($tourn_settings->{"nsda_district"}) {

					$m->print("Nope.  Creating new:");

					my $category_code = $event_categories{$internal_event_id};
					$category = $categories{$category_code};

					unless ($category) {

						$category = Tab::Category->create({
							tourn => $tourn->id,
							name  => "Judges ".$category_code,
							abbr  => "J".$category_code,
						});

						$category->setting('jot_id', $category_code);
						$categories{$category_code} = $category;
					}

					my ($team, $type) = split(",", $attributes);

					if ($type eq "CONGRESS") {
						$house_sections{$internal_event_id} = $event_name;
						$type = "congress";
					} elsif ($type eq "PAIR") {
						$type = "debate";
					} elsif ($type eq "SECTION") {
						$type = "speech";
					}

					$entry_fee = $entry_fee / 100;

					$event = Tab::Event->create({
						name     => $event_name,
						abbr     => $entry_blank,
						tourn    => $tourn->id,
						category => $category->id,
						type     => $type,
						fee      => $entry_fee
					});

					if ($team eq "TEAM") {
						$event->setting("min_entry", 2);
						$event->setting("max_entry", 2);
					} else {
						$event->setting("min_entry", 1);
						$event->setting("max_entry", 1);
					}

					$created++;

					$m->print("</span>");

				}
			}
		}

		if ($event) {

			$description .". Imported ".$entry_blank." to ".$event->abbr;
			$event->setting('code_style', "numbers");

			my $category = $event->category;

			my $category_code = $event_categories{$internal_event_id};
			$categories{$category_code} = $category;
			$category->setting("jot_id", $category_code);

			$event->setting("jot_id", $event_id);
			$events{$event_id} = $event;

			if ($event->setting('weekend')) {

				my $weekend = Tab::Weekend->retrieve($event->setting("weekend"));

				if ($weekend) {

					$weekends{$weekend->id} = $weekend;

					my $site = $weekend->site;

					if ($site && $site > 0) {

						unless ($default_weekend_site) {
							$default_site = $site;
							$default_weekend_site++;
						}

						$event_site{$event_id} = $site;
						$sites{$site->id} = $site;
					}
				}

			}

			if ($event->type eq "congress") {
				foreach ($event->rounds()) {
					$_->delete();
				}
			}

		} else {
			$m->print("<span class='semibold redtext full'> I was not able to find ");
			$m->print("or create $entry_blank: $entry_blank in Tabroom.</span>");
		}

	}

	Tab::ChangeLog->create({
		type        => "tabbing",
		tourn       => $tourn,
		description => $description,
		person      => $person,
		created     => $now
	});

	$m->print("</p>");

	my $unpooled = $tourn->categories(
		abbr => "XX",
		name => "Unpooled Judges"
	)->first;

	unless ($unpooled) {
		$unpooled = Tab::Category->create({
			tourn => $tourn->id,
			abbr  => "XX",
			name  => "Unpooled Judges"
		});
	}

	# Fill in any un-sited events
	foreach my $event_id (sort keys %events) {
		unless ($event_site{$event_id}) {
			$event_site{$event_id} = $default_site;
			$sites{$default_site->id} = $default_site;
		}
	}

	undef $segments{"events"};
	$ignore_me{"events"}++;

	$m->print("<p class='semibold'>$found events found, $created events created</p>");

	$m->print("<h6 class='redtext semibold'>Importing schools</h6>");

	my %schools = map{ $_->setting("jot_id") => $_} $tourn->schools;
	my %school_web_ids;

	$found = 0;
	$created = 0;

	LINE:
	foreach my $linekey (sort keys %{$segments{"schools"}}) {

		my $line = $segments{"schools"}{$linekey};

		next unless $csv->parse($line);

		my (
			$school_id, $code, $name, $coach, $squad_count,
			$arrived, $division, $city, $phone, $fax, $coach_phone,
			$notes, $status, $addr1, $addr2, $state, $zip, $email,
			$flags, $district_code, $region, $other_coaches, $trophy_points,
			$web_school_id, $cell_phone, $alt_email
		) = $csv->fields();

		next LINE if $school_id eq "School ID";

		$web_school_id = int($web_school_id);
		$found++ if $schools{$web_school_id};

		$school_id = int($school_id);
		$school_web_ids{$school_id} = $web_school_id;

		$m->print("<div class='full nospace bordertop borderbottom'>");
		$m->print("<span class='semibold half'>Importing school $name: </span>");

		if ($schools{$web_school_id}) {
			$m->print("<span class='greentext semibold half'>Already exists in tournament</span>");
			$m->print("</div>");
			next LINE;
		}

		if ($district) {

			my $school = Tab::School->search(
				name     => $name,
				tourn    => $tourn->id,
				district => $district->id
			)->first;

			if ($school) {
				$m->print("<span class='half'>School ".$school->name." exists</span>");
			}

			unless ($school) {

				# Chapter with the same name in the same district?
				my $chapter;

				$chapter = Tab::Chapter->search(
					name     => $name,
					district => $district->id
				)->first;

				unless ($chapter) {

					my $cs = Tab::ChapterSetting->search(
						tag   => "jot_id",
						value => $web_school_id
					)->first if $web_school_id > 0;

					$chapter = $cs->chapter if $cs;
				}

				my $tabroom_account;

				if ($chapter) {

					$m->print("<span class='greentext half'>Found Tabroom school $chapter ".$chapter->name);
					$m->print(" from a previous import</span>");

				} else {

					$tabroom_account = Tab::Person->search(
						email => $email
					)->first;

					unless ($tabroom_account) {

						my $tabroom_login = Tab::Login->search(
							username => $email
						)->first;

						$tabroom_account = $tabroom_login->person
							if $tabroom_login;
					}

					if ($tabroom_account) {

						my @permissions = $tabroom_account->permissions( tag => "chapter" );

						my $short_name = Tab::short_name($name);

						foreach my $perm (@permissions) {
							$chapter = $perm->chapter
								if $short_name eq $perm->chapter->short_name;
						}
					}

					if ($chapter && $tabroom_account) {
						$m->print("<span class='greentext half'>Found Tabroom school ");
						$m->print("$chapter ".$chapter->name." belonging ");
						$m->print("to the Tabroom account $email </span>");
					}

					if ($chapter && ($chapter->nsda < 1)) {

						my $nsda_school = $m->comp(
							"/funclib/nsda_school.mas",
							name        => $name,
							district_id => $district->id
						);

						$chapter->nsda($nsda_school->school_id)
							if $nsda_school;

						$chapter->district($district->id);
						$chapter->update();

						push @changes, $chapter->id." linked to this district and NSDA school ".$chapter->nsda;
					}
				}

				unless ($chapter) {

					my $nsda_school = $m->comp(
						"/funclib/nsda_school.mas",
						name        => $name,
						district_id => $district->id
					);

					if ($nsda_school) {

						$chapter = Tab::Chapter->search(
							nsda => $nsda_school->school_id
						)->first;

						unless ($chapter) {

							my $nome;
							$nome++ unless $tabroom_account;

							$chapter = $m->comp(
								"/funclib/chapter_import.mas",
								nsda_school => $nsda_school,
								person      => $tabroom_account,
								nome        => $nome
							);

							my $change_result = $district->name." imported NSDA chapter $chapter ".$chapter->name;
							$change_result   .= " for NSDA School ID ".$chapter->nsda;

							foreach my $admin ($chapter->admins) {
								$change_result .= "Account ".$admin->email." (".$admin->first." ".$admin->last.") has access <br />";
							}

							$m->print("<span class='half semibold bluetext'>".$change_result."</span>");
							push @changes, $change_result;

						}
					}
				}

				unless ($chapter) {

					$chapter = Tab::Chapter->create({
						name     => $name,
						street   => $addr1,
						city     => $city,
						state    => $state,
						zip      => $zip,
						country  => "US",
						coaches  => $coach,
						district => $district_id
					});

					if ($tabroom_account) {
						Tab::Permission->create({
							person  => $tabroom_account->id,
							tag     => "chapter",
							chapter => $chapter->id
						});
					}

					$m->print("<span class='semibold redtext half'>No school found.");
					$m->print(" Created Tabroom school for $name ");
					$m->print(" and gave admin access to $email") if $tabroom_account;
					$m->print("</span>");

				}


				if ($chapter) {

					$school = $chapter->schools(
						tourn   => $tourn->id,
						chapter => $chapter->id
					)->first;

					unless ($school) {
						$school = Tab::School->create({
							name     => $name,
							code     => $code,
							onsite   => $arrived,
							chapter  => $chapter->id,
							tourn    => $tourn->id,
							state    => $state,
							district => $district->id
						});

						$created++;
					}

					$chapter->setting("jot_id", $web_school_id) if $web_school_id > 0;

					$school->setting("state", $state);
					$school->setting("contact_name", $coach);
					$school->setting("contact_phone", $coach);
					$school->setting("contact_email", $email)

				}

			}

			if ($school) {
				$school->setting("jot_id", $web_school_id);
				$schools{$web_school_id} = $school;
			} else {
				$m->print("<span class='half redtext semibold'>Failed utterly with $name $web_school_id</span>");
			}

			$m->comp("/user/nsda/import_nsda_roster.mhtml",
				chapter_id => $school->chapter->id,
				person     => $person,
				confirm    => 1,
				return     => 1
			) if $school && $school->chapter;
		}

		$m->print("</div>");
	}

	undef $segments{"schools"};
	$ignore_me{"schools"}++;

	my %tiebreak_sets =
		map {$_->name => $_}
		$tourn->tiebreak_sets();

	$m->print("<p class='semibold'>$found schools found, $created created</p>");

	my %timeslots =
		map {$_->start->epoch => $_}
		$tourn->timeslots();

	undef $counter;
	$counter = scalar(keys %timeslots);

	$m->flush_buffer();
	$m->print("<h6 class='redtext semibold martopmore'>Importing rounds and timeblocks</h6>");

	my %rounds;
	my %rounds_by_name;
	my %had_final;

	my %congress_rounds;
	my $congress_counter = 0;

	if ($house) {
		foreach my $existing ($house->rounds) {
			next unless $existing->timeslot;
			next unless $existing->timeslot->start;
			$congress_rounds{$existing->timeslot->start->epoch} = $existing;
			$congress_counter++;
		}
	}

	my $runoff;
	my $current_event;

	#Clear Congress because otherwise duplicates happen.
	if (keys %event_house_section) {
		foreach my $event ($tourn->events(type => "congress")) {
			foreach my $round ($event->rounds) {
				foreach my $section ($round->panels) {
					$section->delete();
				}
			}
		}
	}

	# ROUNDS TIMEBLOCKS:
	ROUND:
	foreach my $linekey (sort keys %{$segments{"evrd"}}) {

		my $line = $segments{"evrd"}{$linekey};
		next unless $csv->parse($line);

		my (
			$internal_event_id, $round_id, $no, $idea, $round_name,
			$date, $time, $draw,
			$flip, $panel, $flight, $panel_size,
			$auto_flight, $attr, $user_flags
		) = $csv->fields();

		next if $internal_event_id eq "Event ID";

		$flight = int($flight);
		$round_id = int($round_id);
		$round_name = int($round_name);
		$internal_event_id = int($internal_event_id);

		my $event_id = $event_web_ids{$internal_event_id};
		my $event = $events{$event_id};

		next unless $event && $event->id;

		unless ($event_id eq $current_event) {
			$m->print("</span></div>") if $current_event;
			$current_event = $event_id;

			$m->print('<div class="full nospace bordertop borderbottom">');
			$m->print("<span class='tenth semibold bluetext'>".$event->abbr);
			$m->print(":</span><span class='ninetenths'>");
		}

		if ($event_id eq "HOUSE" && $house) {

			foreach ($date, $time, $draw) {
				$_ =~ s/^\s+//;
				$_ =~ s/\s+$//;
			}

			$date =~ s/-/\//g;

			my ($hour, $minutes) = split(":", $time);

			# Motherfucker
			my $ampm = substr($minutes, -2);
			$minutes = substr($minutes, 0, -2);

			my $start_time = eval {
				return Tab::dtme($date, "$hour:$minutes".uc($ampm), $tz);
			};

			my $end_time = $start_time->clone;
			$end_time->add( hours => 2 );

			my $round = $congress_rounds{$start_time->epoch};

			unless ($round) {

				$congress_counter++;

				my $timeslot = Tab::Timeslot->create({
					tourn => $tourn,
					name  => "Congress $congress_counter",
					start => $start_time,
					end   => $end_time
				});

				$timeslots{$start_time->epoch} = $timeslot;

				my $round_type = "prelim";
				my $tiebreak_set = $tiebreak_sets{"Congress Prelim"};

				$round = Tab::Round->create({
					name         => $congress_counter,
					type         => "prelim",
					flighted     => 1,
					published    => 0,
					post_results => 0,
					start_time   => $start_time,
					event        => $house->id,
					timeslot     => $timeslot->id,
					tiebreak_set => $tiebreak_set->id,
					site         => $event_site{$event_id}
				});

				$m->print("<span class='third'>Created Congress ".$round->realname."</span>");

			}

			$m->comp("/funclib/round_dump.mas",
				person => $person,
				round  => $round
			);

			$congress_rounds{$start_time->epoch} = $round;
			$congress_rounds{$internal_event_id}{$round_id} = $round;

			next ROUND;

		}

		unless ($event) {
			$m->print("<span class='redtext semibold half'>Event $event_id is not found</span>");
			next ROUND;
		}

		foreach ($date, $time, $draw) {
			$_ =~ s/^\s+//;
			$_ =~ s/\s+$//;
		}

		$date =~ s/-/\//g;
		my ($hour, $minutes) = split(":", $time);

		unless ($rounds_by_name{$event_id}) {
			%{$rounds_by_name{$event_id}} =
				map {$_->name => $_}
				$event->rounds();
		}

		unless ($rounds{$event_id}) {
			%{$rounds{$event_id}} =
				map {$_->setting("jot_id") => $_}
				$event->rounds();
		}

		# Motherfucker
		my $ampm = substr($minutes, -2);
		$minutes = substr($minutes, 0, -2);

		my $start_time = eval {
			return Tab::dtme($date, "$hour:$minutes".uc($ampm), $tz);
		};

		unless ($timeslots{$start_time->epoch}) {

			my $end_time = $start_time->clone();
			$end_time->add( hours => 1);

			$counter++;

			my $timeslot = Tab::Timeslot->create({
				tourn => $tourn,
				name  => "Timeslot $counter",
				start => $start_time,
				end   => $end_time
			});

			$timeslots{$start_time->epoch} = $timeslot;
		}

		my $round_type;

		if ($district
			&& $event->type eq "speech"
			&& $tourn_settings->{"nsda_speech_method"} eq "doubledown"
		) {
			$round_type = $fucked_joy_rounds{$round_id};
			$round_type = "prelim" if $round_id < 6;
			$round_type = "elim" if $round_id > 10 && $round_id < 16;
		} else {
			$round_type = $fucked_joy_rounds{$round_id};
		}

		my $round;
		my $tiebreak_set;
		my $debate_final;
		my $speech_final;

		if ($event->type eq "congress") {

			$round_type = $section_round_type{$internal_event_id}
				if $section_round_type{$internal_event_id};

			if ($round_type eq "prelim") {
				$tiebreak_set = $tiebreak_sets{"Congress Prelim"};
			} elsif ($round_type eq "elim" || $round_type eq "final") {
				$tiebreak_set = $tiebreak_sets{"Congress Elim"};
			}

		} elsif ($event->type eq "speech") {

			if ($round_type eq "prelim") {
				$tiebreak_set = $tiebreak_sets{"IE Prelim"};
			} elsif ($round_type eq "elim") {
				$tiebreak_set = $tiebreak_sets{"IE Semi"};
				$tiebreak_set = $tiebreak_sets{"IE Elim"} unless $tiebreak_set;
				$tiebreak_set = $tiebreak_sets{"IE Prelim"} unless $tiebreak_set;
			} elsif ($round_type eq "final") {
				$tiebreak_set = $tiebreak_sets{"IE Final"};
				$tiebreak_set = $tiebreak_sets{"IE Elim"} unless $tiebreak_set;
			}

		} else {

			if ($round_type eq "elim" || $round_type eq "runoff") {
				$tiebreak_set = $tiebreak_sets{"Debate Elim"};
				$tiebreak_set = $tiebreak_sets{"Debate Elims"} unless $tiebreak_set;
			} elsif ($round_type eq "final") {
				$tiebreak_set = $tiebreak_sets{"Debate Final"};
				$tiebreak_set = $tiebreak_sets{"Debate Finals"} unless $tiebreak_set;
				$tiebreak_set = $tiebreak_sets{"Debate Elim"} unless $tiebreak_set;
				$tiebreak_set = $tiebreak_sets{"Debate Elims"} unless $tiebreak_set;
			} else {
				$tiebreak_set = $tiebreak_sets{"Debate Prelim"};
				$tiebreak_set = $tiebreak_sets{"Debate"} unless $tiebreak_set;
			}
		}

		$m->print('<span class="sixth">');
		$m->print(ucfirst($round_type)." $round_name: ");

		if ($rounds_by_name{$event_id}{$round_name}
			|| $rounds{$event_id}{$round_id}
		) {

			$round = $rounds{$event_id}{$round_id};

			unless ($round) {
				$round = $rounds_by_name{$event_id}{$round_name};
				$round->setting("jot_id", $round_id);
			}

			my $timeslot = $timeslots{$start_time->epoch};

			unless ($round->timeslot->id == $timeslot->id) {
				$round->timeslot($timeslot->id);
			}

			$round->type($round_type);
			$round->site($event_site{$event_id});
			$round->tiebreak_set($tiebreak_set);
			$round->update();
			$m->print("exists");

		} else {

			$round = Tab::Round->create({
				name         => $round_name,
				type         => $round_type,
				flighted     => $flight,
				published    => 0,
				post_results => 0,
				start_time   => $start_time,
				event        => $event->id,
				tiebreak_set => $tiebreak_set->id,
				timeslot     => $timeslots{$start_time->epoch}->id,
				site         => $event_site{$event_id}
			});

			$m->print($round_type." round $round_name created in ".$event->abbr);

			$round->setting("jot_id", $round_id);
			$rounds{$event_id}{$round_id} = $round;
			$rounds_by_name{$event_id}{$round_name} = $round;

		}

		$m->print("</span>");

		if ($event->type eq "congress") {
			$congress_rounds{$internal_event_id}{$round_id} = $round;
		}

		# Dump the round's current sections and results if any
		$m->comp("/funclib/round_dump.mas",
			person => $person,
			round  => $round
		);

		$runoff = $round if $round->type eq "runoff";
		$had_final{$event->id}++ if $round->type eq "final";
		$m->flush_buffer();

	}

	$m->print(" </span> </div>") if $current_event;

	if ($district) {

		foreach my $event_id ( keys %rounds_by_name) {

			next if $had_final{$event_id};

			my @round_names = sort keys %{$rounds_by_name{$event_id}};
			my $last_round_name  = pop @round_names;

			my $round = $rounds_by_name{$event_id}{$last_round_name};

			unless ($round->event->type eq "congress") {

				$round->type("final");

				my $tiebreak_set;

				if ($round->event->type eq "speech") {
					$tiebreak_set = $tiebreak_sets{"IE Final"};
					$tiebreak_set = $tiebreak_sets{"IE Elim"} unless $tiebreak_set;
				} else {
					$tiebreak_set = $tiebreak_sets{"Debate Final"};
					$tiebreak_set = $tiebreak_sets{"Debate Finals"} unless $tiebreak_set;
					$tiebreak_set = $tiebreak_sets{"Debate Elim"} unless $tiebreak_set;
					$tiebreak_set = $tiebreak_sets{"Debate Elims"} unless $tiebreak_set;
				}

				$round->tiebreak_set($tiebreak_set) if $tiebreak_set;
				$round->update;

			}
		}
	}

	$m->print("</span>");

	$m->flush_buffer();

	undef $segments{"evrd"};
	$ignore_me{"evrd"}++;

	undef $counter;

	foreach my $key (sort keys %timeslots) {
		$counter++;
		$timeslots{$key}->name("Timeslot ".$counter);
		$timeslots{$key}->update();
	}

	my %rooms;
	my %site_rooms;

	$m->flush_buffer();
	$m->print("<h6 class='redtext semibold'>Importing rooms and sites </h6>");
	$m->print("<p class='bluetext bigger semibold'>The default site for new rooms ");
	$m->print("is ".$default_site." ".$default_site->name."</p>");

	# ROOMS
	foreach my $linekey (sort keys %{$segments{"rooms"}}) {
		my $line = $segments{"rooms"}{$linekey};

		next unless $csv->parse($line);

		my (
			$room_id, $room_name, $hall, $notes, $flags, $other_flags
		) = $csv->fields();

		next if $room_id eq "Room ID";

		$room_id = int($room_id);

		# Hunt for an existing room named this:
		foreach my $key (sort keys %sites) {

			last if $rooms{$room_id};

			my $site = $sites{$key};

			unless ($site_rooms{$key}) {
				@{$site_rooms{$key}} = $site->rooms();
			}

			foreach my $room (@{$site_rooms{$key}}) {

				if (
					$room->notes == $room_id
				 	|| $room_name eq $room->name
				) {
					$rooms{$room_id} = $room;
					last;
				}
			}
		}

		#If it isn't found create one:

		if ($rooms{$room_id}) {

			if ($rooms{$room_id}->deleted) {
				$rooms{$room_id}->deleted(0);
				$rooms{$room_id}->update();
			}

			$m->print("<span class='quarter'>Room ".$rooms{$room_id}->name." exists </span>");

		} else {

			$rooms{$room_id} = eval {
				return Tab::Room->create({
					name     => $room_name,
					site     => $default_site->id,
					notes    => $room_id,
					capacity => 0,
					quality  => 10,
					inactive => 0,
					deleted  => 0
				});
			};

			if ($rooms{$room_id}) {
				$m->print("<span class='quarter greentext'>Created room $room_name </span>");
			} else {
				$m->print("<span class='quarter'>No room $room_name</span>");
			}
		}
	}

	$m->print("<br />");

	undef $segments{"rooms"};
	$ignore_me{"rooms"}++;

	$m->flush_buffer();
	$m->print("<h6 class='redtext semibold'>Importing judges</h6>");

	my @all_judges = $m->comp("/funclib/tourn_judges.mas", tourn => $tourn);

	my %judges;
	my %judge_category;
	my %judge_web_ids = ();

	foreach my $judge (@all_judges) {
		my $jot_id = $judge->setting("jot_id");
		push @{$judges{$jot_id}}, $judge if $jot_id;
	}

	foreach my $linekey (sort keys %{$segments{"judges"}}) {

		my $line = $segments{"judges"}{$linekey};

		next unless $csv->parse($line);

		my (
			$internal_judge_id, $internal_school_id, $name, $message, $options, $round_limit,
			$flags, $private_note, $phone1, $phone2, $email, $region, $district,
			$obligation, $base_priority, $rating, $user_flags, $cell_phone,
			$pager, $code, $judge_id, @bullshit
		) = $csv->fields();


		$judge_id = int($judge_id);
		$internal_judge_id = int($internal_judge_id);
		$internal_school_id = int($internal_school_id);

		next if $internal_judge_id eq "Judge ID";

		$judge_id = $tourn->id."-".$internal_judge_id if $judge_id == -1;
		$judge_web_ids{$internal_judge_id} = $judge_id;

		my @already;
		@already = @{$judges{$judge_id}} if $judges{$judge_id};

		my $chapter_judge;
		my $hired;
		my $school_id;
		my $school;

		if ($internal_school_id == -1) {
			$hired++;
			$school_id = 0;
		} else {
			$school_id = $school_web_ids{$internal_school_id};
			$school = $schools{$school_id};
		}

		my $person;

		if ($email) {

			$person = Tab::Person->search(
				email => $email
			)->first;

			unless ($person) {
				my $login = Tab::Login->search(
					username => $email
				)->first;
				$person = $login->person if $login;
			}
		}

		# So someone who stores middle names and salutations in the database
		# munges them all into one field in the application.  Sigh.

		# I'm going to only use first and last for searching because otherwise
		# this will reach a higher level of ridiculous than it already has.

		my @names = split(/\ /, $name);
		my $first;
		my $last;
		my $middle;

		$first = shift @names if @names;
		$last = pop @names if @names;
		$middle = join(" ", @names);

		if ($school) {

			if (@already) {

				$chapter_judge = $already[0]->chapter_judge;

			} else {

				my $chapter = $school->chapter;

				$chapter_judge = $chapter->chapter_judges(
					person => $person->id
				)->first if $person;

				$chapter_judge = $chapter->chapter_judges(
					first => $first,
					last  => $last
				)->first unless $chapter_judge;

				unless ($chapter_judge) {

					$chapter_judge = Tab::ChapterJudge->create({
						first   => $first,
						middle  => $middle,
						last    => $last,
						retired => 0,
						phone   => $cell_phone,
						email   => $email,
						person  => $person,
						chapter => $chapter
					});
				}
			}

			if ($chapter_judge && $person) {

				unless ($chapter_judge->person) {
					$chapter_judge->person($person->id);
					$chapter_judge->update();
				}
			}
		} else {
			$school = 0;
			$chapter_judge = 0;
		}

		my %already;
		my $judge;

		foreach my $internal_event_id (sort keys %{$judge_pools{$internal_judge_id}}) {

			my $category_code = $event_categories{$internal_event_id};
			my $category = $categories{$category_code};

			next unless $category;

			unless ($already{$category}++) {

				$m->print("<span class='greentext quarter'>Judge $judge_id $first $last: ".$category->abbr."</span>");

				$judge = Tab::Judge->search(
					person => $person->id
				)->first if $person;

				$judge = Tab::Judge->search(
					school        => $school,
					category      => $category,
					chapter_judge => $chapter_judge,
					first         => $first,
					middle        => $middle,
					last          => $last,
				)->first unless $judge;

				if ($judge) {

					if ($person && $person != $judge->person) {
						$judge->person($person->id);
						$judge->update();
					}
				} else {

					$judge = Tab::Judge->create({
						first         => $first,
						middle        => $middle,
						last          => $last,
						active        => 1,
						obligation    => 9,
						hired         => 0,
						school        => $school,
						category      => $category,
						chapter_judge => $chapter_judge
					});

				}

				if ($judge) {
					$judge->setting("jot_id", $judge_id);
					push @{$judges{$judge_id}}, $judge;
					$judge_category{$judge_id}{$category->id} = $judge;
				}
			}
		}

		unless (keys %{$judge_pools{$internal_judge_id}}) {

			$judge = Tab::Judge->search(
				person => $person->id
			)->first if $person;

			$judge = Tab::Judge->search(
				school        => $school,
				category      => $unpooled,
				chapter_judge => $chapter_judge,
				first         => $first,
				middle        => $middle,
				last          => $last,
			)->first unless $judge;

			$judge = Tab::Judge->create({
				first         => $first,
				middle        => $middle,
				last          => $last,
				active        => 1,
				obligation    => 9,
				hired         => 0,
				school        => $school,
				category      => $unpooled,
				chapter_judge => $chapter_judge
			}) unless $judge;

			$judge->setting("jot_id", $judge_id);

			push @{$judges{$judge_id}}, $judge;
			$judge_category{$judge_id}{$unpooled->id} = $judge;

			$m->print("<span class='quarter semibold bluetext'>Judge $judge_id $first $last ");
			$m->print("".$unpooled->name." category</span>");
		}

		unless ($judge) {
			$m->print("<span class='quarter semibold redtext'>Unable to import Judge ".$first." ".$last."</span>");
		}
	}

	$m->print("<br />");

	undef $segments{"judges"};
	$ignore_me{"judges"}++;

	$m->flush_buffer();
	$m->print("<h6 class='redtext semibold'>Importing competitors</h6>");

	my @all_students = $m->comp( "/funclib/tourn_chapter_students.mas", tourn => $tourn);

	my %students;
	my %student_web_ids;
	my %student_tags;

	foreach my $student (@all_students) {
		$students{$student->student_jot} = $student;
		$student_tags{$student->schoolid}{$student->first}{$student->last} = $student;
	}

	my %name_codes;
	my $notfirst;

	NAME:
	foreach my $linekey (sort keys %{$segments{"names"}}) {

		my $line = $segments{"names"}{$linekey};
		next unless $csv->parse($line);

		my (
			$internal_student_id, $internal_school_id, $name, $code, $student_id
		) = $csv->fields();

		next if $internal_student_id eq "Name ID";

		$name_codes{int($internal_student_id)} = $code;
		$name_codes{int($internal_student_id)} = $name unless $code;

		# This function filters out some nonsense about pairs/teams:
		next if (index($name, ' - ') != -1);

		$student_id = int($student_id);
		$internal_student_id = int($internal_student_id);

		$student_id = $internal_student_id if $student_id == -1;
		$student_web_ids{$internal_student_id} = $student_id;


		$internal_school_id = int($internal_school_id);
		my $school_id = $school_web_ids{$internal_school_id};
		my $school = $schools{$school_id};

		my $first;
		my $last;
		my $middle;
		my @names = split(/\ /, $name);

		$first = shift @names if @names;
		$last = pop @names if @names;
		$middle = join(" ", @names);

		$m->print("</span>") if $notfirst++;
		$m->print("<div class='full row nospace'>");
		$m->print("<span class='third nospace'>$student_id $name <br />".$school->name.": </span>");

		if ($student_tags{$school_id}{$first}{$last}) {

			my $student = $student_tags{$school_id}{$first}{$last};
			$m->print("Found.</span>");

			$student->setting("jot_id", $student_id);
			$students{$student_id} = $student;

		} else {

			my $candidate;
			my $chapter = $school->chapter;
			my @students = $chapter->students(
				first => $first,
				last  => $last
			);

			foreach my $student (@students) {

				next if $student->retired;
				next if $student->grad_year > 1900 && $student->grad_year < $this_year;

				if ($student->ualt_id
					&& $candidate && (not defined $candidate->ualt_id)
				) {
					$candidate = $student;
				}

				$candidate = $student unless $candidate;
			}

			my $search_nsda;

			unless ($candidate > 0) {

				$m->print("<span class='orangetext semibold third'>$first $last Not found.  Creating:");

				$first = "Unknown" unless $first;
				$last = "Unknown" unless $last;

				$candidate = Tab::Student->create({
					first   => $first,
					middle  => $middle,
					last    => $last,
					chapter => $chapter,
					novice  => 0,
					retired => 0
				});

				$search_nsda++;

				$m->print("done</span> <span class='semibold bluetext third nospace'> Linking to NSDA Member:");

			} elsif ($candidate > 0 && $candidate->nsda < 1) {

				$m->print("<span class='redtext semibold third'>Tabroom record $candidate found but no NSDA ID.  Searching:</span>");
				$search_nsda++;
			}

			if ($search_nsda) {

				my $nsda = $m->comp(
					"/funclib/nsda_student_search.mas",
					chapter => $chapter,
					first   => $first,
					last    => $last
				);

				if ($nsda) {

					$m->print("<span class='inline greentext semibold'>Found NSDA ");
					$m->print("member ".$nsda->ualt_id."</span></span>");

					$candidate->grad_year($nsda->grad_yr);
					$candidate->ualt_id($nsda->ualt_id);
					$candidate->nsda($nsda->user_id);
					$candidate->update();

					if ($nsda->paid_status) {
						$candidate->setting("nsda_paid", 1);
					} else {
						$candidate->setting("nsda_paid", "X");
					}

					if ($nsda->total_pts) {
						$candidate->setting("nsda_points", $nsda->total_pts);
					} else {
						$candidate->setting("nsda_points", "X");
					}

					my $joined = eval{
						return DateTime::Format::MySQL->parse_datetime($nsda->high_joined);
					};

					if ($joined) {
						$candidate->setting("nsda_joined", "date", $joined);
					} else {
						$candidate->setting("nsda_joined", "X");
					}

					my $test_person;

					if ($candidate->person) {

						$candidate->setting("student_email", $candidate->person->email);

					} elsif ($nsda->demo) {

						$candidate->setting("student_email", $nsda->demo);
						$test_person = $nsda->demo;

					} elsif ($nsda->login) {

						$test_person = $nsda->login;
						$candidate->setting("student_email", $nsda->login);

					} else {
						$candidate->setting("student_email", "X");
					}

					if ($test_person) {
						my $person = Tab::Person->search(
							email => $test_person
						)->first;

						unless ($person) {
							my $login = Tab::Login->search(
								username => $test_person
							)->first;
						}
					}

				} elsif ($district) {

					$m->print("<span class='inline redtext semibold'>No NSDA match.");
					$m->print("Manual match will be needed.</span>");
				}

			} else {

				$m->print("<span class='semibold greentext twothirds'>OK! Found competitor $candidate ");
				$m->print("with NSDA membership ".$candidate->ualt_id." linked.</span>");

			}

			$candidate->setting("jot_id", $student_id);
			$students{$student_id} = $candidate;

		}

		$m->print("</div>");
	}

	$m->print("</span>");
	$m->print("<br />");

	undef $segments{"names"};
	$ignore_me{"names"}++;

	my %teams = ();

	foreach my $linekey (sort keys %{$segments{"teams"}}) {
		my $line = $segments{"teams"}{$linekey};

		next unless $csv->parse($line);

		my (
			$internal_entry_id, $internal_student_id
		) = $csv->fields();

		next if $internal_entry_id eq "Entry ID";

		my $student_id = $student_web_ids{int($internal_student_id)};
		push @{$teams{int($internal_entry_id)}}, $student_id;
	}

	undef $segments{"teams"};
	$ignore_me{"teams"}++;

	my %entry_web_ids;
	my %entries;
	my %entry_tags;
	my %existing;

	my @all_entries = $m->comp(
		"/funclib/tourn_entries.mas",
		tourn => $tourn,
		all   => 1
	);

	foreach my $entry (@all_entries) {
		push @{$entry_tags{$entry->school->id}{$entry->event->id}}, $entry;
		$existing{$entry->entry_jot} = $entry;
	}

	$m->flush_buffer();
	$m->print("<h6 class='redtext semibold'>Importing entries</h6>");

	my %already;

	my %done;

	# Can't spell entries apparently.
	ENTRY:
	foreach my $linekey (sort keys %{$segments{"entrys"}}) {

		my $line = $segments{"entrys"}{$linekey};

		next unless $csv->parse($line);

		my (
			$internal_entry_id, $internal_school_id, $internal_event_id, $squad_seq,
			$internal_student_id, $flags, $apparently_not_a_code, $user_flags,
			$entry_id, $seed
		) = $csv->fields();

		next if $internal_entry_id eq "Entry ID";

		my $event_id = $event_web_ids{int($internal_event_id)};
		my $school_id = $school_web_ids{int($internal_school_id)};
		my $student_id = $student_web_ids{int($internal_student_id)};

		unless ($entry_id) {
			$entry_id = $tourn->id."-".$internal_entry_id;
		}

		$entry_web_ids{int($internal_entry_id)} = $entry_id;

		my $code = $name_codes{int($internal_student_id)};
		my $event = $events{$event_id};

		next unless $event;

		my $jot_id = $internal_student_id."-".$event->id;
		my $entry = $entries{$entry_id};

		unless ($entry) {
			$entry = $existing{$jot_id};
			$entries{$entry_id} = $entry;
		}

		my %entry_students;
		my $school = $schools{$school_id};

		if ($teams{int($internal_entry_id)}) {
			foreach my $student_id (@{$teams{int($internal_entry_id)}}) {
				$entry_students{$students{$student_id}->id} = $students{$student_id} if $students{$student_id};
			}
		} else {
			my $student = $students{$student_id};
			$entry_students{$student->id} = $students{$student_id} if $student;
		}

		unless ($entry) {

			EXISTS:
			foreach my $existing_entry (@{$entry_tags{$school->id}{$event->id}}) {

				my %existing_students = map {$_->id => 1} $existing_entry->students;

				foreach my $student_id (keys %existing_students) {
					# Advance along if I do not exist in this entry
					next EXISTS unless $entry_students{$student_id};
				}

				foreach my $student_id (keys %entry_students) {
					# Advance along if I do not exist at all
					next EXISTS unless $existing_students{$student_id};
				}

				$entry = $existing_entry;
				last EXISTS if $entry;
			}

			if ($entry) {

				$m->print("<p>ID $internal_entry_id Entry $code already exists! ");

			} else {

				$m->print("<p>ID $internal_entry_id Entry $code in ".$event->abbr." for $internal_entry_id does not exist.  Importing to Tabroom: ");

				$entry = Tab::Entry->create({
					code          => $code,
					tba           => 0,
					dropped       => 0,
					waitlist      => 0,
					unconfirmed   => 0,
					dq            => 0,
					created_at    => $now,
					tourn         => $tourn->id,
					event         => $event->id,
					school        => $school->id,
					registered_by => $person->id,
				});
			}

		} else {

			$m->print("<p>ID $internal_entry_id Entry $code already existed!");
			$entry->code($code);
			$entry->update();
		}

		# Reconcile entries and their competitor members

		if ($entry) {

			my %already_students = map {$_->student->id => $_} Tab::EntryStudent->search(entry => $entry->id);

			foreach my $key (keys %entry_students) {

				my $student = $entry_students{$key};

				if ($already_students{$student->id}) {
					delete $already_students{$student->id};
				} else {
					Tab::EntryStudent->create({
						entry   => $entry->id,
						student => $student->id
					});
				}
			}

			#Prune the spares
			foreach my $es (keys %already_students) {
				$already_students{$es}->delete();
			}

			$entry->name($m->comp("/funclib/entry_name.mas", entry => $entry));
			$entry->setting("jot_id", $jot_id);
			$entries{$entry_id} = $entry;
			$existing{$jot_id} = $entry;

			$m->print("<span class='inline semibold greentext marleft'>Import Succeeded!</span></p>");

		} else {
			$m->print(" <span class='inline semibold redtext'>Import failed!</span>");
		}

		my @flags = parse_flags_bullshit($flags);

		if ($flags[0] && $flags[0] == 1) {
			#Drops
			$entry->dropped(1);
		} else {
			$entry->dropped(0);
		}

		if ($flags[1] && $flags[1] == 1) {
			#DQs
			$entry->dq(1);
			$entry->dropped(1);
		} else {
			$entry->dq(0);
			unless ($flags[0] && $flags[0] == 1) {
				$entry->dropped(0);
			}
		}

		# 2 and 3 are "Experienced" and "Novice."  Novice is per-student in
		# Tabroom and there's no Experienced.  Therefore, toss them both.

		#On sweeps, yes is no and stuff.
		if ($flags[4] && $flags[4] == 1) {
			$entry->setting('exclude_from_sweeps', 1);
		} else {
			$entry->setting('exclude_from_sweeps', 0);
		}

		# 5 means a web entry thinger is missing which I compensate for in an
		# unnecessarily complicated bit of code later

		if ($flags[6] && $flags[6] == 1) {
			$entry->setting('nsda_vacate', 1);
		} else {
			$entry->setting('nsda_vacate', 0);
		}

		if ($flags[7] && $flags[7] == 1) {
			$entry->ada(1);
		} else {
			$entry->ada(0);
		}

		$entry->update();
		$done{$entry->id}++;
	}


	undef $segments{"entrys"};
	$ignore_me{"entrys"}++;

	my %sections;
	my %section_by_id;
	my %section_data;
	my %sections_by_tag;

	$m->flush_buffer();
	$m->print("<h6 class='redtext semibold marbottom'>Importing sections/debates/chambers</h6>");

	my %event_counter;
	my $overall;

	# I hate that this is necessary.  It looks unnecessary.  But wait until you
	# see the judge nightmare below.

	my %section_translator;
	my %section_event;
	my %section_type;

	SECTION:
	foreach my $linekey (sort keys %{$segments{"sections"}}) {

		my $line = $segments{"sections"}{$linekey};

		next unless $csv->parse($line);

		my (
			$section_id, $internal_event_id, $round_id, $room_id,
			$letter, $num_judges, $dunno, $noclue
		) = $csv->fields();

		next if $section_id eq "Section ID";

		$section_id = int($section_id);
		$room_id = int($room_id);
		$letter =~ s/\s+//g;

		my $event_id = $event_web_ids{int($internal_event_id)};

		my $room = $rooms{$room_id};
		my $event = $events{$event_id};

		next SECTION unless $event;

		my $round;
		my $round_type;
		my $round_label;

		$round_id = int($round_id);

		if ($event->type eq "congress") {

			my $internal_round_id = abs($round_id);
			my $actual = $internal_event_id."-".$internal_round_id;

			$section_translator{$section_id} = $actual;
			$section_id = $actual;

			next SECTION unless($letter == 1 && $round_id > 0);

			$letter = $event_house_section{$internal_event_id}
				if $event_house_section{$internal_event_id};

			$round = $congress_rounds{$internal_event_id}{$internal_round_id};

			$round_label = $house_sections{$internal_event_id};

		} else {

			$round = $rounds{$event_id}{$round_id};
			unless ($round) {
				next SECTION unless $round;
			}
		}

		unless ($round) {
			$m->print("<p class='redtext semibold'> NO ROUND FOUND FOR $round_id of ".$event->name."</p>");
			next SECTION;

		}

		my $section = Tab::Panel->create({
			round  => $round->id,
			letter => $letter,
			bye    => 0,
			room   => $room,
			label  => $round_label,
			score  => $section_id
		});

		$event_counter{$event->abbr}++;

		$section_by_id{$section->id} = $section;
		$sections{$section_id} = $section;

		$section_event{$section->id} = $event;
		$section_type{$section->id} = $event->type;

		$sections_by_tag{$event_id}{$round_id}{"object"} = $section;
		$sections_by_tag{$event_id}{$round_id}{"id"}     = $section_id;

		$section_data{$section->id}{"room"}      = $room;
		$section_data{$section->id}{"event"}     = $event;
		$section_data{$section->id}{"round"}     = $round;
		$section_data{$section->id}{"roundname"} = $round->name;

	}

	undef $segments{"sections"};
	$ignore_me{"sections"}++;

	foreach my $abbr (sort keys %event_counter) {
		$m->print("<p class='semibold bluetext'> ");
		$m->print("Created $event_counter{$abbr} sections of $abbr</p>");
	}

	$m->flush_buffer();
	my %section_judges;

	# Sure let's needlessly renumber all the judges for NO APPARENT REASON

	SECTION:
	foreach my $linekey (sort keys %{$segments{"judsects"}}) {

		my $line = $segments{"judsects"}{$linekey};

		next unless $csv->parse($line);

		my (
			$internal_judge_id, $section_id, $yafjid
		) = $csv->fields();

		next if $internal_judge_id eq "Judge ID";

		my $original_section = $section_id;

		$section_id = $section_translator{$section_id}
			if $section_translator{$section_id};

		my $section = $sections{$section_id};

		next unless $section;

		next if $section_judges{$section->id}{"yafj"}{$yafjid};

		my $round = $section->round;
		my $event = $round->event;
		my $category = $event->category;

		my $judge_id = $judge_web_ids{int($internal_judge_id)};

		my $judge = $judge_category{$judge_id}{$category->id};

		$judge = $judge_category{$judge_id}{$unpooled->id}
			unless $judge;

		unless ($judge) {

			foreach my $other_judge (@{$judges{$judge_id}}) {
				$judge = $other_judge if $other_judge > 0;
				last if $judge;
			}
		}

		unless ($judge) {

			$judge = $judge_category{$internal_judge_id}{$category->id} = $judge;

			if ($judge) {
				$judge_web_ids{int($internal_judge_id)} = $judge->id;
				$judge_category{$judge->id}{$category->id} = $judge;
			}
		}

		if ($judge) {
			$section_judges{$section->id}{"yafj"}{$yafjid} = $judge if $yafjid;
			$section_judges{$section->id}{"real"}{$judge_id} = $judge;
		}
	}

	$ignore_me{"judsects"}++;

	my %section_byes;
	my %section_entries;

	SECTION:
	foreach my $linekey (sort keys %{$segments{"sectents"}}) {

		my $line = $segments{"sectents"}{$linekey};

		next unless $csv->parse($line);

		my (
			$section_id, $internal_entry_id, $speaker_order, $speaker_actual,$id
		) = $csv->fields();

		next if $section_id eq "Section ID";

		$section_id = $section_translator{$section_id}
			if $section_translator{$section_id};

		my $section = $sections{$section_id};
		next unless $section;

		my $entry_id = $entry_web_ids{int($internal_entry_id)};
		my $entry = $entries{$entry_id};
		my $event = $section_event{$section->id};

		if ($event->type eq "congress") {
			while ($section_entries{$section->id}{$speaker_order}) {
				$speaker_order++;
			}

			push @{$section_entries{$section->id}{$speaker_order}}, $entry;

		} else {
			push @{$section_entries{$section->id}{$speaker_order}}, $entry;
			$section_byes{$section->id}++ if $internal_entry_id < 0;
		}
	}

	$ignore_me{"sectents"}++;
	my %section_results;

	$m->flush_buffer();
	$m->print("<h6 class='redtext semibold marbottom'>Parsing and importing results</h6>");

	my %fake_judges;

	SECTION:
	foreach my $linekey (sort keys %{$segments{"jse"}}) {

		my $line = $segments{"jse"}{$linekey};

		next unless $csv->parse($line);

		my (
			$internal_judge_id, $section_id, $internal_entry_id,
			$points, $rank, $points1, $points2, $points3, $points4, $extra
		) = $csv->fields();

		next if $internal_judge_id eq "Judge ID";
		$internal_judge_id = int($internal_judge_id);

		$section_id = $section_translator{$section_id} if $section_translator{$section_id};
		my $section = $sections{$section_id};

		next unless $section;

		my $judge;
		my $judge_id = $judge_web_ids{int($internal_judge_id)};
		$judge = $section_judges{$section->id}{"real"}{$judge_id} if $judge_id;

		unless ($judge) {
			$judge = $section_judges{$section->id}{"yafj"}{$internal_judge_id};
		}

		my $entry = $entries{$entry_web_ids{int($internal_entry_id)}};
		next unless $entry;

		my $event = $section_event{$section->id};

		if ($event->type eq "congress") {

			$rank = int($rank) - 1000000;
			$points = int($points);

			next SECTION unless ($rank > 0 || $points > 0);

			$judge = create_fake_judge($internal_judge_id, $event->category, \%fake_judges)
				unless $judge;

			$section_judges{$section->id}{"real"}{"fake-".$internal_judge_id} = $judge;

			next SECTION unless $judge;

			$section_results{$section->id}{$judge->id}{$entry->id}{"rank"} = int($points);

			my $actual_points = parse_congress_bullshit($rank);

			$points1 = int($points1);
			my $spare_points;

			if ($points1 > 0) {
				$spare_points = parse_congress_bullshit($points1);
			}

			if ($spare_points) {

				my @originals = split(',', $actual_points);
				my @adds = split (',', $spare_points);

				undef $actual_points;

				while (@originals) {
					my $stuff = shift @originals;

					my $extra;
					$extra = shift @adds if @adds;
					$stuff = $stuff + $extra if $extra;
					$actual_points .= "," if $actual_points;
					$actual_points .= $stuff;
				}
			}

			$section_results{$section->id}{$judge->id}{$entry->id}{"points"} = $actual_points;


		} elsif ($event->type eq "speech") {

			$judge = create_fake_judge($internal_judge_id, $event->category, \%fake_judges)
				unless $judge;

			next SECTION unless $judge;

			$section_judges{$section->id}{"real"}{"fake-".$internal_judge_id} = $judge;

			if ($rank < 0)  {
				$section_results{$section->id}{$judge->id}{$entry->id}{"forfeit"}++;
			} else {
				$section_results{$section->id}{$judge->id}{$entry->id}{"rank"} = int($rank);
				$section_results{$section->id}{$judge->id}{$entry->id}{"points"} = $points;
			}

		} else {

			$judge = create_fake_judge($internal_judge_id, $event->category, \%fake_judges)
				unless $judge;

			next SECTION unless $judge;

			$section_judges{$section->id}{"real"}{"fake-".$internal_judge_id} = $judge;

			$section_results{$section->id}{$judge->id}{$entry->id}{"winloss"} = 0;

			# The actual value is 65536.  I am not making this up.
			$section_results{$section->id}{$judge->id}{$entry->id}{"winloss"} = 1
				if $points > 0;

			$section_results{$section->id}{$judge->id}{$entry->id}{"points1"} = $points1;
			$section_results{$section->id}{$judge->id}{$entry->id}{"points2"} = $points2;
			$section_results{$section->id}{$judge->id}{$entry->id}{"line"} = $line;
		}
	}

	$ignore_me{"jse"}++;

	my @section_keys = keys %section_entries;

	@section_keys =
		sort {$section_by_id{$a}->letter <=> $section_by_id{$b}->letter}
		@section_keys;

	@section_keys =
		sort {$section_data{$a}{"roundname"} <=> $section_data{$b}{"roundname"}}
		@section_keys;

	@section_keys =
		sort {$section_data{$a}{"event"} cmp $section_data{$b}{"event"}}
		@section_keys;

	my %round_spares;
	my %round_letter;

	my %entry_last_round;
	my @runoff_entries;
	my %entry_students;

	SECTION:
	foreach my $section_id (@section_keys) {

		my $section = $section_by_id{$section_id};
		next unless $section;

		my $bye = $section_byes{$section_id};

		my $event = $section_data{$section_id}{"event"};
		my $round = $section_data{$section_id}{"round"};
		my $room  = $section_data{$section_id}{"room"};

		$round_letter{$round->id} = $section->letter
			if $round_letter{$round->id} < $section->letter;

		my %used;
		my %first_at_order;
		my %actual_judge;

		$m->print("<span class='semibold bluetext quarter'>Importing ".$event->abbr." ".$round->realname." section ".$section->letter."</span>");

		foreach my $order (
			sort {$a <=> $b}
			keys %{$section_entries{$section->id}}
		) {

			next unless $section_entries{$section->id}{$order};

			foreach my $entry (@{$section_entries{$section->id}{$order}}) {

				next unless $entry;
				next if $used{$entry}++;

				if ($first_at_order{$order}) {
					push @{$round_spares{$round->id}{"entries"}}, $entry;
				} else {
					$first_at_order{$order} = $entry;
				}
			}

			my $entry = $first_at_order{$order};
			next unless $entry;

			if ($round->type eq "runoff") {
				push @runoff_entries, $entry;
			} else {

				$entry_last_round{$entry->id} = $round unless $entry_last_round{$entry->id};
				$entry_last_round{$entry->id} = $round if $entry_last_round{$entry->id}->name < $round->name;
			}

			if ($section_byes{$section_id}) {

				$section->bye(1);
				$section->update();

				my $ballot = Tab::Ballot->create({
					entry         => $entry,
					judge         => 0,
					panel         => $section,
					speakerorder  => 0,
					side          => 0,
					chair         => 0,
					bye           => 0,
					forfeit       => 0,
					audit         => 1
				});

			}

			JUDGEKEY:
			foreach my $judgekey (keys %{$section_judges{$section->id}{"real"}}) {

				my $judge = $section_judges{$section->id}{"real"}{$judgekey};
				next unless $judge;

				next if $used{$judge}{$entry}{$section}++;

				my $fft = $section_results{$section->id}{$judge->id}{$entry->id}{"forfeit"};
				$fft = 0 unless $fft;

				my $bye = $section_byes{$section_id};
				$bye = 0 unless $bye;

				my $ballot = Tab::Ballot->create({
					entry         => $entry,
					judge         => $judge,
					panel         => $section,
					speakerorder  => $order,
					side          => $order,
					bye           => $bye,
					forfeit       => $fft,
					audit         => 1,
				});

				my $win = $section_results{$section->id}{$judge->id}{$entry->id}{"winloss"};
				my $rank = $section_results{$section->id}{$judge->id}{$entry->id}{"rank"};
				my $points = $section_results{$section->id}{$judge->id}{$entry->id}{"points"};
				my $points1 = $section_results{$section->id}{$judge->id}{$entry->id}{"points1"};
				my $points2 = $section_results{$section->id}{$judge->id}{$entry->id}{"points2"};
				my $line = $section_results{$section->id}{$judge->id}{$entry->id}{"line"};

				my $chair;

				if ($section_type{$section_id} eq "congress") {

					$actual_judge{$judge->id}++ if $rank > 0;

					if ($rank && $rank > 9 && (not defined $chair)) {
						$chair++;
						$ballot->chair($chair);
						$ballot->update();
					}

					$rank = 9 unless $rank;
					next JUDGEKEY unless $rank;

					Tab::Score->create({
						ballot => $ballot,
						tag    => "rank",
						value  => $rank
					});

					if ($points) {

						my $speech;

						my @points = split(',', $points);

						foreach my $point (@points) {
							next unless $point;
							$speech++;

							Tab::Score->create({
								ballot => $ballot,
								tag    => "congress_speech",
								value  => $point,
								speech => $speech
							});

						}
					}

				} elsif ($section_type{$section_id} eq "speech") {

					Tab::Score->create({
						ballot => $ballot,
						tag    => "rank",
						value  => $rank
					}) if $rank;

				} else {

					$win = 0 unless $win;

					Tab::Score->create({
						ballot => $ballot,
						tag    => "ballot",
						value  => $win
					}) if defined $win;

					if ($points1) {

						unless ($entry_students{$entry} && @{$entry_students{$entry}}) {
							@{$entry_students{$entry}} = $entry->students;
						}

						my $student1 = ${$entry_students{$entry}}[0]
							if $entry_students{$entry}
							&& @{$entry_students{$entry}};

						if ($points1 && $student1) {
							Tab::Score->create({
								ballot  => $ballot,
								tag     => "points",
								value   => $points1,
								student => $student1
							});
						}

						my $student2 = ${$entry_students{$entry}}[1]
							if $entry_students{$entry}
							&& @{$entry_students{$entry}};

						if ($points2 && $student2) {
							Tab::Score->create({
								ballot  => $ballot,
								tag     => "points",
								value   => $points2,
								student => $student2
							});
						}
					}
				}
			}
		}


		foreach my $order (
			sort {$a <=> $b}
			keys %{$section_entries{$section->id}}
		) {

			next unless $section_entries{$section->id}{$order};
			if ($section_type{$section_id} eq "congress") {

				foreach my $entry (@{$section_entries{$section_id}{$order}}) {

					next unless $entry;

					foreach my $judgekey (keys %{$section_judges{$section->id}{"real"}}) {

						my $judge = $section_judges{$section->id}{"real"}{$judgekey};
						next unless $judge;

						unless ($actual_judge{$judge->id}) {
							foreach my $ballot ($judge->ballots( panel => $section_id)) {
								$ballot->delete();
							}
						}
					}
				}
			}
		}
	}

	if ($runoff && @runoff_entries) {

		my $last_round = $entry_last_round{$runoff_entries[0]->id};

		$last_round->runoff($runoff->id);
		$last_round->update();
	}

	foreach my $round_id (sort keys %round_spares) {

		# These are people who bye through the various rounds

		my $letter = $round_letter{$round_id};

		if ($round_spares{$round_id}{"entries"}) {

			foreach my $spare (@{$round_spares{$round_id}{"entries"}}) {

				$letter++;

				my $section = Tab::Panel->create({
					round  => $round_id,
					letter => $letter,
					bye    => 1,
					room   => 0,
				});

				my $ballot = Tab::Ballot->create({
					judge        => 0,
					entry        => $spare,
					audit        => 1,
					panel        => $section,
					chair        => 0,
					bye          => 0,
					forfeit      => 0,
					audit        => 1,
				});

			}
		}
	}

	Tab::Round->set_sql( delete_empties => "
		delete round.*
			from round, event
			where event.tourn = ?
			and event.id = round.event
			and not exists (
				select ballot.id
				from ballot, panel
				where panel.round = round.id
				and ballot.panel = panel.id
			)
	");

	Tab::Round->sql_delete_empties->execute($tourn->id);

	foreach my $linekey (sort keys %{$segments{"selections"}}) {

		my $line = $segments{"selections"}{$linekey};
		next unless $csv->parse($line);

		my (
			$selection_id, $internal_entry_id, $author, $title, $source
		) = $csv->fields();

		my $entry_id = $entry_web_ids{int($internal_entry_id)};
		my $entry = $entries{$entry_id};

		if ($entry) {
			$entry->setting("author", $author);
			$entry->setting("title", $title);
			$entry->setting("publisher", $source);
		}

		next if $entry_id eq "Entry ID";

	}

	$ignore_me{"selections"}++;

	foreach my $label (sort {$a cmp $b} keys %segments) {

		next if $ignore_me{$label};

		$m->print("<h5>".$label."</h5>");

		foreach my $linekey (sort keys %{$segments{$label}}) {

			my $line = $segments{$label}{$linekey};
			$m->print("<pre>".$line."</pre>");
		}

	}

	sub parse_flags_bullshit {
		my $decimal = shift;
		my $binary = sprintf ("%b", $decimal);
		my @flags = reverse split(//, $binary);
		return @flags;
	}

	sub parse_congress_bullshit {

		my $score = shift;

		my $points = $score;

		my $steps;

		while ($points > 6) {
			$steps++;
			$points = $points / 7;
			$points = floor($points);
		}

		my %results;

		while ($steps) {

			my $points = $score;

			$points = $points / (7 ** $steps);
			$points = floor($points);

			my $remainder = $score - ((7 ** $steps) * $points);

			$results{$steps} = $points;
			$score = $remainder;
			$steps--;
		}

		$results{0} = $score if defined $score;

		my $result_string;

		foreach my $key (sort {$a <=> $b} keys %results) {

			$result_string .= "," if defined $result_string;
			$result_string .= $results{$key};
		}

		return $result_string;

	}

	sub create_fake_judge {

		my ($internal_id, $category, $fake_judgeref) = @_;

		return $fake_judgeref->{$internal_id}{$category->id}
			if $fake_judgeref->{$internal_id}{$category->id};

		my $judge;

		$judge = Tab::Judge->search(
			category => $category->id,
			first    => "Unknown",
			last     => "Judge $internal_id"
		)->first;

		$judge = Tab::Judge->create({
			school     => 0,
			category   => $category->id,
			first      => "Unknown",
			last       => "Judge $internal_id",
			code       => $internal_id,
			active     => 0,
			obligation => 9,
			hired      => 0,
		}) unless $judge;

		if ($judge) {
			$fake_judgeref->{$internal_id}{$category->id} = $judge;
			return $judge;
		}

		return;
	}

</%init>

	</div>

	<div class="menu">

		<div class="sidenote">

			<h5>Return</h5>

%			if ($house_section_counter) {

				<a
					class = "yellow full martop marbottommore"
					href  = "/tabbing/publish/joydistrict.mhtml?function=Congress Chambers"
				>Return to Districts Import</a>

%			} else {

				<a
					class = "yellow full martop marbottommore"
					href  = "/tabbing/publish/joydistrict.mhtml?function=Confirm NSDA Memberships"
				>Return to Districts Import</a>
%			}

		</div>

	</div>


