<%args>
	$student     => undef
	$ualt_id     => undef
	$nsda        => undef
	$nsda_person => undef
</%args>
<%init>

	# Officially NSDA rules require an email address or whatever in the points
	# database in order to register for nationals or districts.
	#
	# However, this is not actually a rule because it's not enforced, non-email
	# usernames are accepted, and the database is not validated so non emails
	# are used all the time.  Therefore the membership database is full of
	# lies.  and when I try to enforce truth, the string "1234" isn't accepted
	# by tabroom as an email people send me mailbombs and whatever.
	#
	# I am hereby Done With This Shit.  Tabroom will only accept valid emails,
	# but now will report that EVERY student has an email address, whether or
	# not they do, because this is functionally the same as claiming you
	# require an email but accepting 1234 as an email.

	use Tab::NSDA::Person;
	use Tab::NSDA::Login;

	return unless $student;

	Tab::log("Attempting to link student ".$student->id." with ualt $ualt_id nsda $nsda person $nsda_person");

	unless ($ualt_id || $nsda || $nsda_person) {
		unless ($nsda) {
			$nsda = $student->nsda;
		}
		unless ($nsda || $ualt_id) {
			$ualt_id = $student->ualt_id;
		}
	}

	unless ($ualt_id || $nsda || $nsda_person) {
		return;
	}


	my $now = DateTime->now();
	my $nowstring = DateTime::Format::MySQL->format_datetime($now);

	my $search_string;
	my $search_value;

	if ($nsda_person) {
		$search_string = " person.user_id = ? ";
		$search_value  = $nsda_person->user_id;

		#otherwise the object will not contain the custom values.
		undef $nsda_person;

	} elsif ($nsda) {
		$search_string = " person.user_id = ? ";
		$search_value  = $nsda;
	} elsif ($ualt_id) {
		$search_string = " person.ualt_id = ? ";
		$search_value  = $ualt_id;
	}

	Tab::NSDA::Person->columns(TEMP => "high_joined");
	Tab::NSDA::Person->columns(TEMP => "middle_joined");
	Tab::NSDA::Person->columns(TEMP => "student_email");
	Tab::NSDA::Person->columns(TEMP => "username");

	Tab::NSDA::Person->set_sql( whodunnit => "

		select distinct person.*,
			person_school.school_id as school_id,
			middle_joined.dateacquired as middle_joined,
			high_joined.dateacquired as high_joined,
			DEMOGRAPHICS.student_email,
			login.username as username

		from (NEW_USERS_TO_SCHOOLS person_school, NEW_USERS person)

		left join DEMOGRAPHICS on DEMOGRAPHICS.person_id = person.user_id

		left join NEW_USERS_TO_DEGREES middle_joined
			on middle_joined.degree_id = 21
			and middle_joined.ualt_id  = person.ualt_id

		left join NEW_USERS_TO_DEGREES high_joined
			on high_joined.degree_id = 51
			and high_joined.ualt_id  = person.ualt_id

		left join logins login on login.person_id = person.user_id

		where $search_string

		and (
			person_school.enddate = '0000-00-00 00:00:00'
			or person_school.enddate > ?
		)

		and person_school.ualt_id = person.ualt_id
		and person.utype like '%Student'
		group by person.user_id
	");

	my $student_person = Tab::NSDA::Person->search_whodunnit($search_value, $now)->first;

	return unless $student_person;

	if ($student_person->umname && (not defined $student->middle)) {
		$student->middle($student_person->umname);
	}

	if ($student_person->ufname ne $student->first) {
		$student->first($student_person->ufname);
	}

	if ($student_person->ulname ne $student->first) {
		$student->last($student_person->ulname);
	}

	if ($student_person->grad_yr > 2000 && $student_person->grad_yr != $student->grad_year) {
		$student->grad_year($student_person->grad_yr);
	}

	$student->ualt_id($student_person->ualt_id);
	$student->nsda($student_person->user_id);
	$student->update();

	my $sperson = $student->person if $student->person > 0;
	my $candidate_email = $student_person->uemail;
	my $fake_email = $candidate_email;

	unless ($candidate_email) {
		$candidate_email = $student->setting("student_email");
		undef $candidate_email unless Email::Valid->address(
			-address => $candidate_email,
			-mxcheck => 0
		);
	}

	unless ($candidate_email) {
		$candidate_email = $student_person->username;
		undef $candidate_email unless Email::Valid->address(
		   -address => $candidate_email,
		   -mxcheck => 0
		);
	}

	unless ($candidate_email) {
		$candidate_email = $student_person->student_email;
		undef $candidate_email unless Email::Valid->address(
		  -address => $candidate_email,
		  -mxcheck => 0
		);
	}

	unless ($candidate_email) {
		$candidate_email = $sperson->email if $sperson;
	}

	unless ($candidate_email) {
		foreach my $login ( Tab::NSDA::Login->search( person_id => $student_person->user_id)) {
			$candidate_email = $login->username;
			$candidate_email = $login->username if Email::Valid->address(
				-address => $login->username,
				-mxcheck => 0
			);
		}
	}

	unless ($student_person->uemail) {

		if ($candidate_email) {
			$student_person->uemail($candidate_email);
			$student_person->update();

			Tab::NSDA::Person->set_sql(update_demo => "
				update DEMOGRAPHICS
				set student_email = ?
				where person_id = ?
			");

			Tab::NSDA::Person->sql_update_demo->execute($candidate_email, $student_person->user_id);
		}

	}

	unless ($sperson) {

		$sperson = Tab::Person->search(
			email => $candidate_email
		)->first;

		if ($sperson) {
			undef $sperson
			unless $sperson->first eq $student->first
				|| $sperson->last eq $student->last;
		}

		if ($sperson) {
			undef $sperson
			unless Email::Valid->address(
				-address => $candidate_email,
				-mxcheck => 0
			);
		}

		if ($sperson) {
			$student->person($sperson->id);
			$student->update();
		}
	}

	if ($candidate_email) {
		$student->setting('student_email', $candidate_email);
	}

	if ($sperson && (not defined $sperson->nsda)) {

		my $uperson = Tab::Person->search( nsda => $student_person->user_id)->first;
		my $uaperson = Tab::Person->search( ualt_id => $student_person->ualt_id)->first;

		unless ($uperson  || $uaperson) {
			$sperson->nsda($student_person->user_id);
			$sperson->ualt_id($student_person->ualt_id);
			$sperson->update();
		}
	}

	$student->setting('nsda_paid', $student_person->paid_status);
	$student->setting('nsda_points', int($student_person->total_pts));

	my $high_datetime = eval{
  		return DateTime::Format::MySQL->parse_datetime($student_person->high_joined);
	};

	my $middle_datetime = eval{
  		return DateTime::Format::MySQL->parse_datetime($student_person->middle_joined);
	};

	if ($high_datetime) {
		$student->setting('nsda_joined', "date", $high_datetime);
	} elsif ($middle_datetime) {
		$student->setting('nsda_joined', "date", $middle_datetime);
	}

	return;

</%init>
