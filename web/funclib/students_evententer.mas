<%args>
	$event
	$school  => undef
	$chapter => undef
	$drops   => undef
	$retired => undef
</%args>
<%init>

	my $tourn = $event->tourn;
	$m->redirect('/user/home.mhtml') unless $tourn;
	
	my $tz = $tourn->tz;
	$tz = "UTC" unless $tz;

	my %tourn_settings = $tourn->all_settings;
	my %event_settings = $event->all_settings;

	my $double_entry = $tourn_settings{"double_entry"};
	my $double_max = $tourn_settings{"double_max"};

	my $nsda_district_id = $tourn_settings{"nsda_district"};
	my $nsda_district;

	$nsda_district = 
		Tab::District->retrieve($nsda_district_id) 
		if $nsda_district_id;

	my $enter_me_twice = $event_settings{"enter_me_twice"};

	if (defined $double_max && $double_max == 0) { 
		undef $double_entry;
		undef $double_max;
	}

	my $alumni = $event_settings{"alumni"};
	my $supp = $event_settings{"supp"};
	undef $supp if $event_settings{"open_supp"};

    my @patterns = $tourn->patterns;
    my %pattern_by_id = map {$_->id => $_} @patterns;

	my $pattern = $event->pattern;

	my %excludeds = (); 

	foreach my $other (@patterns) { 

		my $exclude = $other->exclude;

		if ($exclude && ($pattern_by_id{$exclude})) { 

			$excludeds{$other->id}{$exclude}++;
			$other->exclude(JSON::encode_json($excludeds{$other->id}));
			$other->update;

		} elsif ($exclude) { 

			eval{ $excludeds{$other->id} = JSON::decode_json($exclude); };

			foreach my $only_one (keys %{$excludeds{$other->id}}) { 

				if ($excludeds{$other->id}{$only_one} eq "same_pattern_only") { 

					$excludeds{$other->id."_sameonly"} .= "," if $excludeds{$other->id."_sameonly"};
					$excludeds{$other->id."_sameonly"} .= $only_one;

					delete($excludeds{$other->id}{$only_one});
				}

			}

		}

	}
	
	my @clean_students;
	my @students;

	my $wsdc = $tourn_settings{"usa_wsdc"};

	if ($wsdc && not defined $school->chapter) { 

		foreach my $entry ($school->entries) { 
			push @students, $entry->students;
		}

	} else { 

		$chapter = $school->chapter if $school;

		@students = 
			sort {ucfirst $a->last cmp ucfirst $b->last} 
			$chapter->students 
			if $chapter;
	}

	unless ($chapter) { 
		$m->print("No valid institution/team was found.  Please try again");
		$m->abort();
	}

	# Check the students to be sure that they're not entered in an event
	# restricted against this one.

	my $now = DateTime->now;
	$now->set_time_zone($tz);

	my $year = $now->year;
	$year++ if $now->month > 6;

	my $nsda_deadline = $tourn->start;
	$nsda_deadline->set_time_zone($tz);
	$nsda_deadline->subtract( days => 7 );

	my %entry_by_id = ();

	my @entries = $school->entries if $school;

	foreach my $entry (@entries) { 
		$entry_by_id{$entry->id} = $entry;
	}

	Tab::EntryStudent->set_sql(by_chapter => "
		select distinct entry_student.*
		from entry_student, entry, student, event
		where entry.id = entry_student.entry
		and entry_student.student = student.id 
		and student.chapter = ?
		and entry.event = event.id
		and event.tourn = ? 
	");

	my %entries_by_student = ();

	unless ($wsdc) { 

		foreach my $entry_student (
			Tab::EntryStudent->search_by_chapter($chapter->id, $tourn->id)
		) { 

			push (@{$entries_by_student{$entry_student->student->id}}, 
				$entry_by_id{$entry_student->entry->id});
		}
	}

	my %pattern_by_event = map {$_->id => $_->pattern} $tourn->events;

	my %done;
	my %district_entry;

	if ($nsda_district) { 

		%district_entry = $m->comp(
			"/funclib/district_entry.mas", 
			chapter => $chapter
		);

	}

	my $count;

	STUDENT:
	foreach my $student (@students) { 

		my $student_id = $student->id;

		next if $done{$student_id}++;

		# If this is districts, students who are not NSDA members in good
		# standing and with linked email addresses

		if ($nsda_district) { 

			my %student_settings = $student->all_settings;

			next STUDENT unless $student_settings{"nsda_paid"};
			next STUDENT unless $student_settings{"nsda_points"} > 24;

			next STUDENT unless $student_settings{"nsda_joined"}
								&& $nsda_deadline;
								&& $nsda_deadline > $student_settings{"nsda_joined"};

			next STUDENT unless $student_settings{"student_email"};

			if ($event->type eq "congress") { 

				next STUDENT if $district_entry{"in_event"}{$student_id}{"HOU"};
				next STUDENT if $district_entry{"in_event"}{$student_id}{"SEN"};

			} else { 

				if ($event->abbr eq "PF" || $event->abbr eq "CX") { 
					next STUDENT if $district_entry{"in_event"}{$student_id}{"CX"};
					next STUDENT if $district_entry{"in_event"}{$student_id}{"PF"};
				}

				next STUDENT if $district_entry{"student_count"}{$student_id} > 1;
			}

		}

		# Students who aren't students anymore.

		unless ($retired) { 

			next STUDENT if $student->retired;

			next STUDENT unless $student->first 
				&& $student->last;

			next STUDENT if $student->grad_year 
				&& $student->grad_year < $year 
				&& not defined $alumni;
		}

		# Class specific double entry restrictions 
		my @entries = @{$entries_by_student{$student_id}} 
			if $entries_by_student{$student_id};

		# Supplementals are only open to students entered in the tournament
		next STUDENT if $supp &! @entries;

		my %pattern_scoreboard = ();

		foreach my $entry (@entries) { 
			next unless $entry && $entry->id;
			$pattern_scoreboard{$pattern_by_event{$entry->event->id}}++;
		}

		my $entered;

		foreach my $entry (@entries) { 

			next unless $entry && $entry->id;

			my $this_event_id = $entry->event->id;
			my $this_event = $entry->event;

			unless ($entry->dropped || $entry->waitlist) { 

				# Am I already entered in this event?

				next STUDENT if $this_event_id == $event->id 
					&& not defined $enter_me_twice;

				# Am I already entered in the tournament and in off the
				# waitlist? 

				$entered++;

				# No double entry permitted if you're entered in this pattern
				# and that's not ok

				next STUDENT if $pattern && $pattern->type == 2 && $entered;  

				# No double entry with a mutually-excluded group

				next STUDENT if $pattern 
					&& $excludeds{$pattern->id}
					&& $this_event->pattern 
					&& $excludeds{$pattern->id}{$this_event->pattern->id};


				if ($pattern && $excludeds{$pattern->id."_sameonly"}) { 

					my $search_pattern = $excludeds{$pattern->id."_sameonly"}.",".$pattern->id;

					# This implements the nonsense around the only_one exclusions I have to
					# Pull a Bruschke on this one and define this one hard coded instead of
					# using the proper calls because the SQL injection guards won't let me auto
					# define a self expanding array. 

					# I hate computers. 

					Tab::Student->set_sql("clash_on_only_one" => "

						select student.*

						from student, student as me,  
							entry_student, entry_student as my_es, entry_student as other_es,
							entry, entry as my_entry, entry as other_entry,
							event as my_event, event as other_event

						where entry.event = ?

							and me.id = ? 
							and my_es.student = me.id
							and my_es.entry = my_entry.id
							and my_es.entry != entry.id
							and my_entry.event = my_event.id
							and my_event.pattern in (".$search_pattern.")

						and student.id != me.id

							and student.id = entry_student.student
							and entry_student.entry = entry.id
							and student.id = other_es.student
							and other_es.entry = other_entry.id
							and other_entry.id != entry.id
							and other_entry.event = other_event.id
							and my_event.pattern in (".$search_pattern.")
					");


					my $other_student = Tab::Student->search_clash_on_only_one(
						$event->id, 
						$student_id, 
					)->first;

					next STUDENT if $other_student;

				}

				if ($pattern_by_event{$this_event_id}) { 

					# No double entry permitted if you're already entered and
					# the new pattern forbids double entry

					next STUDENT if $pattern_by_event{$this_event_id}->type == 2;

					# No double entry within the pattern

					next STUDENT if 
						$pattern_by_event{$this_event_id}->type == 1 
						&& (
							$pattern 
							&& $pattern_by_event{$this_event_id}->id == $pattern->id
						);  

					# No double entry beyond a limit within the pattern

					next STUDENT if 
						$pattern_by_event{$this_event_id}->type == 3
						&& (
							$pattern 
							&& $pattern_by_event{$this_event_id}->id == $pattern->id 
							&& $pattern_scoreboard{$pattern->id} >= $pattern->max
						); 

					# No double entry if the other pattern excludes mine

					next STUDENT if ( 
						$pattern 
						&& $excludeds{$pattern_by_event{$this_event_id}}
						&& $excludeds{$pattern_by_event{$this_event_id}}{$pattern->id} == 1
					);

				}
			}
		}

		# Unlimited double entry

		if ($double_entry eq "unlimited") { 
			push (@clean_students, $student);
			next STUDENT;
		}

		# No double entry

		next STUDENT if ($entered > 0 && $double_entry eq "none"); 

		# One event double entry

		next STUDENT if ($double_entry eq "max_events" && $entered >= $double_max);
	
		push (@clean_students, $student);
	}	

	return @clean_students;
	
</%init>
