<%args>
	$school
	$tourn_settings    => undef
	$event_settings    => undef
	$category_settings => undef
</%args>
<%init>

	return unless $school && $school->id;

	my %reasons;
	my $reasons_text;

	# Rules only apply until the right person asks, then who gives a shit

	if ($school->setting("no_judge_warnings")) {

	} else {

		foreach my $category (
			$m->comp("/funclib/school_categories.mas",
				school => $school
			)
		) {

			my %owed;

			if ($category->setting("nats_category")) {

				my ($provided, $burden) = $m->comp(
					"/funclib/judgemath/nats_judging.mas",
					category          => $category,
					school            => $school,
					category_settings => $category_settings,
					tourn_settings    => $tourn_settings,
					event_settings    => $event_settings,
				);

				if ($provided->{'minimum_unmet'}) {
					$reasons{$category->id} .= "<p>".$provided->{"minimum_unmet"}." rounds short of minimum required</p>";
					$reasons_text .= $category->abbr." ".$provided->{"minimum_unmet"}." rounds short of minimum required\n";
					$reasons{"nope"}++;
				}

				$owed{$category->id} = $burden->{"total"};
				$owed{$category->id} -= $provided->{"total"};

				$reasons{"obligation"}{$category->id} = $burden->{'total'};
				$reasons{"provided"}{$category->id} += $provided->{"total"};

				my $judge_hire = Tab::JudgeHire->search(
					category => $category->id,
					school   => $school->id
				)->first;

				if ($judge_hire) {
					$owed{$category->id} -= $judge_hire->rounds_accepted();
					$reasons{"provided"}{$category->id} += $judge_hire->rounds_accepted();
				}

				if ($burden->{'amt'}) {

					my $amt_total;

					foreach my $jpool_id (keys %{$burden->{"amt"}}) {
						$reasons{$category->id} .= "<p>Short ".$burden->{"amt"}{$jpool_id}." rounds in ";
						$reasons{$category->id} .= $burden->{"jpools"}{$jpool_id}{"name"};

						$reasons_text .= $category->abbr." Short ".$burden->{"amt"}{$jpool_id}." rounds in ";
						$reasons_text .= $burden->{"jpools"}{$jpool_id}{"name"};

						$amt_total += $burden->{"amt"}{$jpool_id};
					}

					if ($amt_total > $owed{$category->id}) {
						$owed{$category->id} = $amt_total;
					}
				}

				if ($owed{$category->id} < 0) {
					$owed{$category->id} = 0 ;
				} elsif ($owed{$category->id} > 0) {
					$reasons{$category->id} .= "<p>".$owed{$category->id}." rounds still owed </p>";
					$reasons_text .= $category->abbr." ".$owed{$category->id}." rounds still owed \n";
					$reasons{"nope"}++;
				}

				my @incomplete_judges = $m->comp(
					"/funclib/nats_incomplete_judges.mas",
					school => $school
				);

				foreach my $judge (@incomplete_judges) {

					$reasons{$category->id} .= "<p>".$judge->first." ".$judge->last." incomplete: ".$judge->reason."</p>";
					$reasons_text .= $category->abbr." ".$judge->first." ".$judge->last." incomplete: ".$judge->reason."\n";
					$reasons{"nope"}++;
				}

			} else {

				my ($uncovered, $overage, $response) = $m->comp(
					"/funclib/judgemath/uncovered_burden_by_category.mas",
					category          => $category,
					school            => $school,
					category_settings => $category_settings,
					tourn_settings    => $tourn_settings,
					event_settings    => $event_settings,

				);

				$reasons{"provided"}{$category->id} = $response->{"provided"};
				$reasons{"obligation"}{$category->id} = $response->{"burden"};

				if ($uncovered) {
					$reasons{$category->id} .= "<p> $uncovered uncovered entries</p>";
					$reasons_text .= $category->abbr." $uncovered uncovered entries\n";
					$reasons{"nope"}++;
				}
			}
		}
	}

	if ($reasons{"nope"}) {
		$school->setting("judging_unmet", "text", $reasons_text);
	} else {
		$school->setting("judging_unmet", 0);
	}

	return %reasons;

</%init>
