<%args>
    $round_id
</%args>
<%init>

    my $round = Tab::Round->retrieve($round_id);
    my $timeslot = $round->timeslot;
	my $tourn = $timeslot->tourn;
	
    my $any_problem;
    my $double_booked_judges;
    my $sides_uneven;
    my $unscheduled_teams;
    my $double_scheduled_teams;
    my $same_school_debates;
    my $judgeless_debates;
    my $roomless_panels;
    my $hit_before;
    my $judge_preclusion;
    my $judge_timestrike;
    
    my $dbh = Tab::DBI->db_Main();
    
    #DOUBLE-BOOKED JUDGES

    my $double_judges_sth = $dbh->prepare("
        select distinct judge.* from judge, panel, panel clonepanel, ballot, ballot cloneballot
        where panel.round = $round_id
        and clonepanel.round = panel.round
        and panel.flight = clonepanel.flight
        and panel.id != clonepanel.id
        and panel.id = ballot.panel
        and ballot.judge = judge.id
        and clonepanel.id = cloneballot.panel
        and cloneballot.judge = judge.id
    ");

    $double_judges_sth->execute();

    while (my ($judge, $panel, $clonepanel, $ballot, $cloneballot)  = $double_judges_sth->fetchrow_array() ) {
        my $judge_info = Tab::Judge->retrieve($judge);
        $double_booked_judges .= $judge_info->first." ".$judge_info->last." is double-booked!<br>";
    }
    
    #RIGHT NUMBER OF AFF/NEGS
    
    unless ($round->name%2) {
        #pull last 2 rounds
        my $event_id = $round->event;
        my $last_rd = $round->name - 1;
        my $curr_rd = $round->name;
        my $sides_sth = $dbh->prepare("
            select entry, side, panel.bye, round.name
            from ballot, panel, round
            where panel.round = round.id
            and round.event = $event_id
            and round.name >= $last_rd
            and round.name <= $curr_rd
            and ballot.panel=panel.id
            and round.type != 'prelim'
            and round.type != 'final'
            order by entry, round.name
        ");
    
        $sides_sth->execute();
    
        my %sides; my $rd1; my $rd2;
        
        while (my ($entry, $side, $bye, $name)  = $sides_sth->fetchrow_array() ) {
            $sides{$entry}{$name} = $side; 
            if ( $bye == 1 ) { $sides{$entry}{$name} = "bye"; }
            if ( $rd1 && $name != $rd1 ) { $rd2 = $name; }
            $rd1 = $name unless $rd1;
        }
        
        #print "Round 1 is $rd1 and Round 2 is $rd2<br>";
        
        foreach my $key (keys %sides ) {
            if ($sides{$key}{$rd1} == $sides{$key}{$rd2} && $sides{$key}{$rd1} ne "bye" && $sides{$key}{$rd2} ne "bye" ) {
                my $entry_rec = Tab::Entry->retrieve($key);
                #print $entry_rec->code." ".$key." ".$sides{$key}{$rd1}." ".$sides{$key}{$rd2}."<br>";
                $sides_uneven .= $entry_rec->code." should be on the opposite side this round!<br>";
            }
        }
    }
    #UNSCHEDULED TEAMS
   
    my @entries = Tab::Entry->search( event => $round->event, dropped => 0, dq => 0 );
    my @ballots = $m->comp('/funclib/round_ballots.mas', round => $round);
    foreach my $entry (@entries) {
        my $ok=0;
        foreach my $ballot (@ballots) {
            $ok=1 if $ballot->entry == $entry;
        }
        if ( $ok == 0 ) { $unscheduled_teams.= $entry->code. " is NOT scheduled<br>"; }
    }
        
    #TEAMS SCHEDULED TOO MANY TIMES
    
    my $last_entry; my $last_flight; my $last_panel;
    @ballots = sort {$b->entry <=> $a->entry } @ballots;

	my %entry_panel;
    foreach my $ballot (@ballots) {
        if ( $ballot->entry->id == $last_entry && $ballot->panel->flight == $last_flight && $ballot->entry->id > 0 && $ballot->panel != $last_panel ) {
            my $entry_rec = Tab::Entry->retrieve($ballot->entry->id) if $ballot->entry;
            $double_scheduled_teams.= $entry_rec->code. " is scheduled twice in the same flight<br>";
        }
        $last_entry = $ballot->entry->id;
        $last_flight = $ballot->panel->flight;
        $last_panel = $ballot->panel;
    }
    
    #MEETING OWN SCHOOL & DEBATES WITH NO JUDGES
    my $last_school; 
    @ballots = sort {$b->panel <=> $a->panel } @ballots;
    foreach my $ballot (@ballots) {
        if ( $ballot->entry->school == $last_school && $ballot->panel == $last_panel && $ballot->entry != $last_entry ) {
            my $entry_rec = Tab::Entry->retrieve($ballot->entry->id) if $ballot->entry;
            my $entry_rec_2 = Tab::Entry->retrieve($last_entry) if $last_entry;
            $same_school_debates.= $entry_rec->code." and ".$entry_rec_2->code." are from the same school!<br>";
        }
        if ( $ballot->judge == 0 && $ballot->bye == 0 && $ballot->panel->bye == 0 && $ballot->panel ==  $last_panel ) {
            $judgeless_debates.= $ballot->entry->code." vs. ".$last_entry->code." have no judge!<br>";
        }
        $last_entry = $ballot->entry->id;
        $last_school = $ballot->entry->school;
        $last_panel = $ballot->panel;
    }

    #ROOMS: DEBATES WITH NO ROOMS    
    my @panels = $m->comp('/funclib/round_panels.mas', round => $round);
    my $dummy=0;
    foreach my $panel (@panels) {
        if ( $panel->room == 0 && $panel->bye == 0 ) {
            $dummy ++;
        }
    }
    $roomless_panels = $dummy." panels without rooms<br>" if $dummy;
    
    #TEAMS PREVIOUS MET
    my ($entry_by_id_hash_ref, $precluded_hash_ref) = $m->comp("/funclib/make_pairing_hash.mas", round_id => $round->id);			

    my %entry_by_id = %{$entry_by_id_hash_ref};
    my %precluded = %{$precluded_hash_ref};
    foreach my $panel (@panels) {
        my @entries = $m->comp("/funclib/panel_entries.mas", panel => $panel);
        #print $entries[0]->code." vs ".$entries[1]->code."<br>";
        if ( $precluded{$entries[0]}{$entries[1]} == 1 || $precluded{$entries[1]}{$entries[0]} == 1 ) {
            $hit_before .= $entries[0]->code." and ".$entries[1]->code." have hit before<br>";        
        }
    }

    #JUDGES: HEARING A BLOCKED TEAM/SCHOOL
    #check to make sure this honors school preclusions
    my $strikes_sth = $dbh->prepare("
        select strike.judge, strike.entry, strike.school, entry.school as entry_school, strike.type, strike.start, strike.end
        from strike
        left join entry on strike.entry=entry.id
        where strike.tourn = ".$tourn."
        order by strike.id
    ");

    $strikes_sth->execute();
        
    while (my ($judge, $entry, $school, $entry_school, $type, $start, $end)  = $strikes_sth->fetchrow_array() ) {
        foreach my $ballot (@ballots) {
            if ($judge == $ballot->judge) {
                if ( $entry == $ballot->entry || $school == $ballot->entry->school ) {
                    $judge_preclusion.= $ballot->judge->first." ".$ballot->judge->last." is judging ".$ballot->entry->code." but there is a school or entry preclusion!<br>";
                }
            }
        }
    }

    my $time_strikes_sth = $dbh->prepare("
        select strike.tourn, strike.start, strike.end, strike.type, strike.judge from strike, timeslot
        where strike.tourn = ".$tourn."
        and strike.type = 'time'
        and timeslot.id=".$round->timeslot."
	and strike.start <= timeslot.end 		
	and strike.end >= timeslot.start
    ");

    $time_strikes_sth->execute();

    while (my ($tourn, $start, $end, $type, $judge)  = $time_strikes_sth->fetchrow_array() ) {
        foreach my $ballot (@ballots) {
            if ($judge == $ballot->judge) {
                $judge_timestrike.= $ballot->judge->first." ".$ballot->judge->last." is judging but is unavailable for this timeslot!<br>";
            }
        }
    }

	my $hired_judging_me;

	if ($round->event->judge_group->setting("auto_conflict_hires")) { 

		Tab::JudgeHire->set_sql( "hires_judging_me" => "
			select distinct judge_hire.*
			from judge, ballot, judge_hire, entry, panel
			where panel.round = ? 
			and panel.id = ballot.panel
			and ballot.judge = judge.id
			and ballot.entry = entry.id
			and entry.school = judge_hire.school
			and judge.id = judge_hire.judge
			group by entry.id
		");

		my @judge_hire_conflict = Tab::JudgeHire->search_hires_judging_me($round_id);

		foreach my $conflict (@judge_hire_conflict) { 
			$hired_judging_me = $conflict->judge->first." ".$conflict->judge->last." is judging ".$conflict->school->name." who has hired them.";
		}

	}
    
    #JUDGES: HEARD TEAM BEFORE
    #JUDGES: SHOULD HAVE ROUND OFF
    #JUDGES: HEARING BLOCKED DIVISION
    #ROOMS: ROOMS USED TOO MANY TIMES
    #ROOMS: NOT AVAILABLE
    
    #print $double_booked_judges."<br>" if $double_booked_judges;
    #print $sides_uneven."<br>" if $sides_uneven;
    $any_problem = "OK";
    $any_problem = "NEED TO FIX THIS!" if $double_booked_judges || $sides_uneven || $unscheduled_teams || $double_scheduled_teams || $judgeless_debates || $roomless_panels || $hit_before;
    $any_problem = "NEED TO FIX THIS!" if $judge_preclusion || $judge_timestrike;
        
    return $any_problem, $double_booked_judges, $sides_uneven, $unscheduled_teams, $double_scheduled_teams, $same_school_debates, $judgeless_debates, $roomless_panels, $hit_before, $judge_preclusion, $judge_timestrike, $hired_judging_me;
        
</%init>

