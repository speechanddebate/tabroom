<%args>
	$school_id
	$debug => undef
	$names => undef
</%args>
<%init>

	use POSIX;

	my $total;
	my @felines;

	my $school = Tab::School->retrieve($school_id);

	my $tourn =  $school->tourn if $school;

	if ($tourn->setting("per_student_fee")) { 

		my @students = $school->students;
		my %student_line = ();
		$student_line{"name"} = scalar @students.' individual students at x $'.$tourn->method->per_student_fee;
		$student_line{"fee"} = scalar @students * $tourn->method->per_student_fee;
		$total += $student_line{"fee"};
		push (@felines, {%student_line});
	}

	EVENT:
	foreach my $event ($m->comp("/funclib/school_events.mas", school => $school)) { 

		my @entries = Tab::Entry->search( school => $school->id, event => $event->id);

		my $fee_per = $event->fee;
		my $fee_total = $fee_per * scalar @entries;

		my $name = scalar @entries. " entries in ".$event->abbr.' x $'.$fee_per;

		my %line_hash= ();
		$line_hash{"name"} = $name;
		$line_hash{"fee"} = $fee_total;

		push (@felines, {%line_hash});

		$total += $fee_total;

	}

	GROUP:
	foreach my $group (sort {$a->name cmp $b->name} $tourn->groups) { 

		my $uncovered = $m->comp("/funclib/judgemath/uncovered_burden_by_group.mas",
								group => $group,
								school => $school);

		if ($group->setting("track_judge_hires")) {

			my $request = $school->requests_by_group($group);
			my $accepted = $request->accepted if $request;

			my %hired_fee = ();

			if ($group->hired_fee) { 

				$accepted = ceil($accepted / $group->setting("judge_per")) if $group->setting("judge_per");

				if ($accepted ) { 
					$hired_fee{"name"} = $accepted." hired judges for ".$group->name.' at $'.$group->hired_fee." each";
					$hired_fee{"fee"} = $accepted * $group->hired_fee;
					$total += $accepted * $group->hired_fee;
					push (@felines, {%hired_fee});
				}

			} elsif ($group->uncovered_entry_fee) { 
			
				if ($accepted ) { 
					my $entry = "entries";
					$entry = "entry" if $accepted == 1;
					$hired_fee{"name"} = "$accepted $entry covered by hires in ".$group->name.' at $'.$group->uncovered_entry_fee." each";
					$hired_fee{"fee"} = $accepted * $group->uncovered_entry_fee;
					$total += $accepted * $group->uncovered_entry_fee;
					push (@felines, {%hired_fee});
				}

			}

			# If there are still missing judges despite the hires, warn the
			# user and invalidate the invoice if that's not OK

			if ($uncovered > 0) {

				my %judge_fee_hash = ();

				$uncovered = ceil($uncovered / $group->setting("judge_per")) if $group->setting("judge_per");

				my $judge = "judge";
				$judge .= "s" if $uncovered != 1;

				if ($group->missing_judge_fee) { 

					$judge_fee_hash{"name"} = "Missing $uncovered $judge in ".$group->name;
					$judge_fee_hash{"fee"} = $uncovered * $group->missing_judge_fee;
					$total += $judge_fee_hash{"fee"};

				} else { 

					$judge_fee_hash{"name"} = "WARNING: You are short
					$uncovered $judge in ".$group->abbr.". Hire or register more judges to cover your obligation.";
					$judge_fee_hash{"warn"}++;
				}

				push (@felines, {%judge_fee_hash});
		
			}

		} elsif ($uncovered > 0) {

			my %judge_fee_hash = ();

			$uncovered = ceil($uncovered / $group->setting("judge_per")) if $group->setting("judge_per");

			$judge_fee_hash{"name"} = "WARNING: You are missing $uncovered judge(s) in ".$group->abbr.".  This tournament does not provide hired judging; register judges or reduce your entry.";

			$judge_fee_hash{"fee"} = $uncovered * $group->missing_judge_fee;

			$judge_fee_hash{"warn"} = 1;

			push (@felines, {%judge_fee_hash});

			$total += $judge_fee_hash{"fee"};
		}

		my %bins_under = $m->comp("/funclib/judgemath/judge_bins_short.mas",
							group => $group,
							school => $school);

		foreach my $key (keys %bins_under) {

			my $bin = Tab::Bin->retrieve($key);
			my %bin_fine = ();

			$bin_fine{"name"} = $bins_under{$bin->id}." ".$group->abbr." judges under in ".$bin->name." at \$".$bin->fine." each";
			$bin_fine{"fee"}  =  $bin->fine * $bins_under{$bin->id};
			$total += $bin->fine * $bins_under{$bin->id};
					
			push (@felines, {%bin_fine});
	
		}	

	} #end of foreach group

	FINE: 
	foreach my $fine (Tab::SchoolFine->search( school => $school->id ) ) 	{ 
		my %fine_hash;
		$fine_hash{"name"} = $fine->reason;
		$fine_hash{"name"} .= " at ". &Tab::niceshortdt($fine->levied_on->set_time_zone($tourn->tz)) if $fine->levied_on;
		$fine_hash{"name"} .= " by ". $fine->levied_by->first." ".$fine->levied_by->last  if $fine->levied_by && $names;
		$fine_hash{"fee"} = $fine->amount;
		$fine_hash{"fine_id"} = $fine->id;
		$total +=  $fine->amount;
		push (@felines, {%fine_hash});
	} #end of foreach fine



return ($total, \@felines);

</%init>
