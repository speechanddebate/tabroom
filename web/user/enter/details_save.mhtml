<%args>
	$entry_id           => undef
	$school_id          => undef
	$code               => undef
	$name               => undef
	$ada                => undef
	$seed               => undef
	$atlarge            => undef
	$from               => undef
	$title              => undef
	$bibliography       => undef
	$author             => undef
	$publisher          => undef
	$publish_date       => undef
	$publish_isbn       => undef
	$publish_print_date => undef
	$publish_url        => undef
</%args>
<%init>

	my $entry = Tab::Entry->retrieve($entry_id);
	$m->abort unless $entry;

	my $school = Tab::School->retrieve($school_id);
	$school = $entry->school unless $school;

	unless ($entry->school == $school) { 
	
		my $hyb_ok;

		foreach my $student ($entry->students) { 
			$hyb_ok++ if $student->chapter->id == $school->chapter->id;
		}

		unless ($hyb_ok) { 
			$m->comp("/funclib/abort.mas", message => "You are not authorized to edit that entry.  Hit back and try again");
		}

	}

	my $event = $entry->event;
	my $tourn = $event->tourn;
	my $housed;

	my %event_settings = $event->all_settings();

	my $code_style = $event_settings{"code_style"};

	my $max = $event_settings{"max_entry"};
	my $min = $event_settings{"min_entry"};

	my %entry_settings = $entry->all_settings;
	my %tourn_settings = $tourn->all_settings();

	my $now = DateTime->now();
	my $tz = $tourn->tz;
	$tz = "UTC" unless $tz;

	my $drop_deadline = $tourn_settings{"drop_deadline"};
	$drop_deadline = $tourn->reg_end unless $drop_deadline;
	$drop_deadline->set_time_zone($tz);

	my $script_deadline = $tourn_settings{"script_deadline"};
	$script_deadline = $drop_deadline unless $script_deadline;

	my $err;

	if ($now < $script_deadline) { 

		if ($tourn->setting('nsda_district') 
			&& $event_settings{'ask_for_titles'}
		) { 
			$err = "Piece title required" unless $title;
		}

		if (
			(	$tourn->setting('nsda_district') 
				|| $tourn->setting('nsda_ms_nats')
			) && $event_settings{'ask_for_authors'}) { 

			$err = "Piece author required" unless $author;

			$err = "You must provide either print publication information or a web URL"
				unless ( 
					( $publisher && $publish_date) 
					|| $publish_isbn
					|| ( $publish_print_date && $publish_url) );

			$entry->setting("title", $title);
			$entry->setting("author", $author);
			$entry->setting("publisher", $publisher);
			$entry->setting("publish_date", $publish_date);
			$entry->setting("publish_url", $publish_url);
			$entry->setting("publish_isbn", $publish_isbn);

			if ($publish_print_date) { 
				my $tz = $tourn->tz;
				$tz = "UTC" unless $tz;
				my $time = "12:00 PM";

				my $published_dt;
				
				eval { $published_dt = Tab::dtme($publish_print_date, $time, $tz); };

				if ($published_dt) { 
					$entry->setting("publish_print_date", "date", $published_dt);
				} else { 
					$err = "Invalid publication date: $publish_print_date at $time";
				}

			} else { 
				$entry->setting("publish_print_date", 0);
			}

		} elsif ($event_settings{"ask_for_titles"}) {

			unless ($title) { 
				$err = "You must enter a piece title (and/or ISBN number)";
			}

			unless ($title eq $entry_settings{"title"}) { 
				$entry->setting("title", $title);
			}

			unless ($author eq $entry_settings{"author"}) { 
				$entry->setting("author", $author);
			}

		}

		if ($event_settings{"ask_for_bibliography"}) {
			unless ($bibliography) { 
				$err = "You must enter a performance bibliography";
			} else { 
				my $text = $m->comp("/funclib/save_editor.mas", text => $bibliography);
				$entry->setting("bibliography", "text", $text);
			}
		}
	}

	if ($now < $drop_deadline) { 

		my @quals = $entry->qualifiers;
		my %used_quals;

		my $quals = $event_settings{'ask_quals'};
		my $required = $quals;
		$quals = 15 if $event_settings{"more_quals"};

		foreach my $step (1 .. $quals) { 

			my $name = $ARGS{"qual_".$step};
			my $result = $ARGS{"qualpts_".$step};

			$err = "Qualifier $step missing" 
				unless $name || $step > $required || $atlarge;

			next unless $name;

			my $foundit;

			foreach my $qual (@quals) {
				if ($qual->name eq $name) { 
					$used_quals{$qual->id}++ ;
					$qual->result($result);
					$qual->update;
					$foundit++;
				}
			}

			unless ($foundit) { 
				Tab::Qualifier->create({
					entry => $entry->id,
					name => $name,
					result => $result
				});
			}
		}

		foreach my $qual (@quals) {
			$qual->delete unless $used_quals{$qual->id};
		}

		my $other = Tab::Entry->search_where({ 
			name   => $name,
			school => $school->id,
			event  => $event->id,
			id     => {'!=', $entry->id} }
		)->first;

		if ($other) { 
			$err .= "Name $name is already taken.  Choose another";
		} else { 
			$entry->name($name);
		}

		my %used_student = ();
		my %students_by_id = ();

		my @students = $entry->students;

		foreach my $student (@students) {
			$students_by_id{$student->id} = $student;
		}

		my $first_name;
		my $last_name;
		my $notfirst;

		foreach my $step (1 .. $max) { 

			my $student_id = $ARGS{"student_".$step};
			next unless $student_id;
			next if $used_student{$student_id};

			my $student = Tab::Student->retrieve($student_id);
			next unless $student;

			if ($students_by_id{$student_id}) { 

				$used_student{$student_id}++;

			} else { 

				eval {

					my @already = Tab::EntryStudent->search( 
						entry => $entry->id, 
						student => $student_id
					);

					unless (@already) { 
						Tab::EntryStudent->create({
							entry   => $entry->id,
							student => $student_id
						});
					}
				};

			}

			$first_name = $student->first;
			$last_name .= " & " if $notfirst;
			$last_name .= $student->last;
			$notfirst++;

		}

		if ($notfirst == 1) { 
			$name = $first_name." ".$last_name unless $name;
		} else { 
			$name = $last_name unless $name;
		}


		foreach my $student (@students) { 

			next if $used_student{$student->id};

			my $es = Tab::EntryStudent->search( 
				entry   => $entry->id,
				student => $student->id
			)->first;

			$es->delete if $es;

			my @housing = $m->comp(
				"/funclib/student_housing.mas", 
					student => $student,
					tourn   => $tourn
				);

			if (@housing) { 
				$housed .= "-" if $housed;
				$housed .= $student->id;
			}

		}

		my @count = $entry->students;
		$err .= "You don't have the minimum students to fill this entry." if scalar @count < $min;

		if ($code && $code ne $entry->code) { 

			my $other = Tab::Entry->search_where({
				code => $code, 
				school => $school->id, 
				event => $event->id,
				id => {'!=', $entry->id}	
			})->first;

			if ($other) { 
				$err .= "Code $code is already taken.  Choose another";
			} else { 
				$entry->code($code);
			}

		} elsif ($code ne $entry->code) { 

			$entry->code($m->comp("/funclib/entry_code.mas", entry => $entry));

		}
		
		$entry->name($name);
		$entry->ada($ada);

		unless ($seed eq $entry_settings{"registered_seed"}) { 
			$entry->setting("registered_seed", $seed);
		}

		if ($seed eq "full") { 

			$entry->setting("pairing_seed", 1) 
				unless $entry_settings{"pairing_seed"} == 1;

		} elsif ($seed eq "half") { 

			$entry->setting("pairing_seed", 2)
				unless $entry_settings{"pairing_seed"} == 2;

		} elsif ($seed eq "free") { 

			$entry->setting("pairing_seed", 3)
				unless $entry_settings{"pairing_seed"} == 3;

		} elsif ($event_settings{"apda"}) { 

			$entry->setting("pairing_seed", 4)
				unless $entry_settings{"pairing_seed"} == 4;

		}

		if ($event_settings{"waitlist_rank"}) { 

			my @waitlisted = $school->entries(
				event    => $event->id,
				waitlist => 1
			);

			my %waitlist_rank;

			foreach my $waitlist (@waitlisted) { 
				my $rank = $waitlist->setting("waitlist_rank");
				$rank = scalar @waitlisted unless $rank;
				$waitlist_rank{$waitlist->id} = $rank;
			}

			$waitlist_rank{$entry->id} = $ARGS{"waitlist_rank"} - .01;

			@waitlisted = sort {$waitlist_rank{$a->id} <=> $waitlist_rank{$b->id}} @waitlisted;

			my $counter;

			foreach my $waitlist (@waitlisted) { 

				next if $waitlist->id == $entry->id;

				$counter++;
				$counter++ if $counter == $ARGS{'waitlist_rank'};
				$waitlist->setting("waitlist_rank", $counter);
			}

			$entry->setting("waitlist_rank", $ARGS{"waitlist_rank"});
			$entry->setting("waitlist_rank", $counter) unless $ARGS{"waitlist_rank"};

		}

		unless ($atlarge eq $entry_settings{"atlarge"}) {
			$entry->setting("atlarge", $atlarge);
		}

		unless ($code_style eq "numbers" 
			|| $code_style eq "school_number" 
			|| $code_style eq "schoolname_code" 
			|| $code_style eq "school_name_only" 
			|| $code_style eq "register") { 

			$entry->code($m->comp("/funclib/entry_code.mas", entry => $entry));
		}

		
		$entry->update;

	}

	$m->redirect("details.mhtml?school_id=".$school->id."&entry_id=".$entry->id."&err=$err") if $err;

	if ($housed) { 
		my $msg = "One of the removed entries had housing.  Transfer or drop housing request?";
		$m->redirect("details_housing.mhtml?school_id=".$school->id."&entry_id=".$entry->id."&housed=$housed&msg=$msg");
	}

	my $msg = "Entry ".$entry->name." details saved";

	$m->redirect("onsite.mhtml?school_id=".$school->id."&event_id=".$event->id."&msg=$msg") if $from eq "onsite";
	$m->redirect("students.mhtml?school_id=".$school->id."&event_id=".$event->id."&msg=$msg");

</%init>
