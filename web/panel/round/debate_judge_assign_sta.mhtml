<%args>
	$account
	$round_id
	$pref_wt => undef
	$mut_wt => undef
	$mut_wt_panel => undef
	$pref_wt_panel => undef
	$pref_left => undef
	$max_pref_above => undef
	$max_mut_above => undef
	$max_pref_at => undef
	$max_mut_at => undef
	$max_pref_below => undef
	$max_mut_below => undef
	$break_line => undef
	
</%args>
<%init>
	
	#DOESN'T SUPPORT REGION STRIKES, or can't judge in elims if you voted against before
	
	use Data::Dumper;
	use Time::HiRes qw( time );
	my $start = time(); 
	my $debug_time = 0; #set to 1 to print load times
	my $debug_display = "style='display:none;'";
	$debug_display = ""; 
			
	my $round = Tab::Round->retrieve($round_id);
	my $is_elim = 0;
	if ( $round->type eq "elim" || $round->type eq "final" ) { $is_elim = 1; }
	my $n_judges = int($round->judges);
	my $event_id = int($round->event); 
	my $event = Tab::Event->retrieve($event_id);
	my $default_mjp = $event->judge_group->setting("default_mjp");

	#DEFAULTS
	$max_pref_above=50 unless $max_pref_above;
	$max_mut_above=30 unless $max_mut_above;
	$max_pref_at=50 unless $max_pref_at;
	$max_mut_at=30 unless $max_mut_at;
	$max_pref_below=70 unless $max_pref_below;
	$max_mut_below=50 unless $max_mut_below;
	$pref_wt=1.2 unless $pref_wt;
	$mut_wt=.8 unless $mut_wt;
	$pref_wt_panel=1 unless $pref_wt_panel;
	$mut_wt_panel=1 unless $mut_wt_panel;
	$break_line=3 unless $break_line;
	$pref_left=2 unless $pref_left;
	
	#ASSIGN WEIGHTS TO HASH
	my %max_pref; my %max_mut;
	$max_pref{'above'} = $max_pref_above;
	$max_mut{'above'} = $max_mut_above;
	$max_pref{'at'} = $max_pref_at;
	$max_mut{'at'} = $max_mut_at;
	$max_pref{'below'} = $max_pref_below;
	$max_mut{'below'} = $max_mut_below;

	#LOAD, PAIRINGS, JUDGE, PREF, AND ENTRY INFO
	my @panels = Tab::Panel->search( round => $round_id );
	my %pan_entry;	
	foreach my $panel (@panels) {
		my @entries = $m->comp("/funclib/panel_entries.mas", panel => $panel);
		my $ctr=0;
		foreach my $entry (@entries) {
			$ctr++;
			$pan_entry{$panel->id}{$ctr} = $entry->id;
		}
	}
	
	my $last_round_name = $round->name - 1;
	my $last_round = Tab::Round->search( event => $round->event->id, name => $last_round_name)->first;
	my %entry_wins = $m->comp("/funclib/entry_wins.mas", event => $round->event, round => $last_round);
	my %entry_losses = $m->comp("/funclib/entry_losses.mas", event => $round->event, round => $last_round);
	my @judge_ref = Tab::Judge->search( judge_group => $event->judge_group);
	my %judge; my $rds_left;
	foreach my $judges (@judge_ref) {
		$judge{$judges->id}{'name'} = $judges->last.", ".$judges->first;
		$judge{$judges->id}{'avg_pref'} = $m->comp("/funclib/judge_avg_rating.mas", judge => $judges, avg_field => "percentile" );
	}
	my %entry_code = map {$_->id => $_->code} $round->event->entries;
	my %pref_record = $m->comp("/funclib/round_ordinals.mas", round => $round);
	my %all_pref = $m->comp("/funclib/event_judgeprefs.mas", event => $round->event, style => "victorian" );
		
	#DIAGNOSTICS
	#Ok, so the first of these uses the deprecated function but is the only one that shows lost judges in current round
	#The second call is to the one that show.mhtml calls, which is accurate for the entire judge group
	my ($dummyy_1, $dummy_2, $dummy_3, $dummy_4, $dummy_5, $dummy_6, $dummy_7, $dummy_8, $dummy_9, $dummy_10, $dummy_11, $dummy_12, $burned_current, $dummy_13, $lost_rounds_current, $lost_rounds_total, $event_rds_left) = $m->comp("/funclib/judge_oblig_count.mas", event_id => $event_id, current_rd_id => $round_id );
	my ($assigned_judges_past, $paired_panels_current, $assigned_judges_current, $needed_panels_current, $needed_judges_current, $paired_panels_future, $assigned_judges_future, $needed_panels_future, $needed_judges_future, $group_rds_left, $assigned_to_last, $unassigned_burned_already, $unassigned_one_plus_left, $unassigned_one_left, $total_in_group) = $m->comp("/funclib/judge_oblig_count_by_group.mas", current_rd_id => $round->id );				

	my ($avg_pref, $avg_mut, $worst_pref, $worst_mut, $deciles) = $m->comp("/funclib/mjp_diagnostics.mas", round => $round );
	my %deciles = %{$deciles};
	my @avg_pref = @{$avg_pref}; my @worst_pref = @{$worst_pref}; my @avg_mut = @{$avg_mut}; my @worst_mut = @{$worst_mut};

		#remaining pref calculation
	my $tot_pref; my $tot_rds; 
	my $judge_hash = $m->comp("/funclib/judge_use.mas", round_id => $round->id);
	foreach my $judge (@judge_ref) {
		my $key = $judge->id;
		my $dummy = ${$judge_hash}{$key}{'oblig'} - ${$judge_hash}{$key}{'judged_already'};
		$dummy = ${$judge_hash}{$key}{'future_possible'} if $dummy > ${$judge_hash}{$key}{'future_possible'};
		$dummy = 0 if $dummy < 0 ;
		$tot_rds += $dummy;
		$tot_pref += ( $dummy * $judge{$key}{'avg_pref'} ) ;
	}
	$tot_rds = 1 if $tot_rds == 0;

	if ($round->pool > 0) {
	print $round->pool." pool in use for this round<br>";
	
			foreach my $judge (@judge_ref) {
				my $key = $judge->id;
				${$judge_hash}{$key}{'avail_current'} = 0;
			}

			my @judge_pool = Tab::PoolJudge->search( pool => $round->pool);

			foreach my $pool_judge (@judge_pool) {
				my $key = $pool_judge->judge;
				${$judge_hash}{$key}{'avail_current'} = 1;
			}
			
	}
	
	my @cohort; $cohort[1]="Above"; $cohort[2]="At"; $cohort[3]="Below";
	
	#JUDGE CONFLICTS
	
	my $allow_judge_own = $round->event->setting("allow_judge_own");
	my $region_constrain = $round->event->setting("region_constraints"); #not testing for this yet

	# - conflicts pass #1; check for school conflicts
	my @entry_recs = $m->comp("/funclib/round_entries.mas", round => $round);
	foreach my $judges (@judge_ref) {
		foreach my $entry_rec (@entry_recs) {
			if ($judges->school == $entry_rec->school && not defined $allow_judge_own) { 
				$all_pref{$entry_rec."-".$judges} = 9999;
			}
		}
	}

	# - conflicts pass #2; judged before or will in the future
	my $allow_repeat_elims = $round->event->setting("allow_repeat_elims");
	my $allow_repeat_judging = $round->event->setting("allow_repeat_judging");
	my $allow_repeat_prelim_side = $round->event->setting("allow_repeat_prelim_side");

	Tab::Ballot->set_sql(pull_ballots => "
		select ballot.entry, ballot.judge 
		from ballot, panel, round
		where panel.id=ballot.panel
		and round.id=panel.round
		and round.name != ".$round->name."
		and round.event = ".$event_id."
		and ballot.bye = 0
		and ballot.noshow = 0
	");
	my @event_ballots = Tab::Ballot->search_pull_ballots;
	
	my $ok_to_strike=1;
	if ($allow_repeat_judging == 1) { $ok_to_strike = 0; }
	if ( ($round->type eq "elim" or $round->type eq "final") and $allow_repeat_elims == 1 ) { $ok_to_strike = 0; }
	
	if ($ok_to_strike == 1) {
		foreach my $event_ballot (@event_ballots) {
			$all_pref{$event_ballot->entry."-".$event_ballot->judge} = 9999;
		}
	}
		

	# - conflicts pass #3; entered conflicts
	my $dbh = Tab::DBI->db_Main();
	my $strikes_sth = $dbh->prepare("
		select distinct strike.id, strike.judge, strike.type, strike.event, strike.entry, 
			strike.school, strike.region, strike.start, strike.end
		from strike
		where strike.tourn = ".$round->event->tourn->id."
	");

	$strikes_sth->execute();

	while (my ($id, $judge, $type, $event, $entry, $school, $region, $start, $end) = $strikes_sth->fetchrow_array() ) {

		foreach my $entry_rec (@entry_recs) {
		
			if ($type eq "conflict" || $type eq "entry") { 
				if ($school) {
					if ( $entry_rec->school == $school ) { $all_pref{$entry_rec."-".$judge} = 9999 };
				} else {  
					$all_pref{$entry."-".$judge} = 9999 ;
				}
			} 

			if ($type eq "hybrid") { 
				if ( $entry_rec->school == $school ) { $all_pref{$entry_rec."-".$judge} = 9999 };
			}

			if ($type eq "region") { 
				if ( $entry_rec->school->region == $region ) { $all_pref{$entry_rec."-".$judge} = 9999 };
			}

			if ($type eq "school") { 
				if ( $entry_rec->school == $school ) { $all_pref{$entry_rec."-".$judge} = 9999 };
			}

		}

	}

	sub prefdata {

		my ($pref_str) = @_;
		my $pref;
		
		my $slash_spot = index($pref_str, "/");
		my $pref_one= substr($pref_str, 0, $slash_spot);
		my $pref_two = substr($pref_str, $slash_spot+1, length($pref_str)-$slash_spot);
		return ($pref_one, $pref_two);
		
	}

</%init>

<style>
table,th,td
{
border:1px solid black;
}
</style>

	<div class="right small">
		<div class="sidenote">
			<a onclick='show_help()' >Click for help</a>
		</div>

		<div class="sidenote">
			<a class="blue half sep" href="/schemat/show.mhtml?round_id=<% $round->id %>">
				Return to Pairings
			</a>
		</div>
	</div>

	<div class="left huge" >

%				my $end = time(); if ($debug_time) {
				Total load time: <% printf("%.2f\n", $end - $start) %>
%				}				
	
	<script>
	
		show_help = function() {
			var str = "This page is for tournaments using ordinal prefs, and incorporates Gary Larson's STA judge placement system.\n\n";
			str = str + "WEIGHTS are relative to each other, and an average value is 1.  Weights can be as high as 10 but should ";
			str = str + "generally be between 0 and 2 and are sensitive in increments of .1. \n\n";
			str = str + "CONSTRAINTS set maximum pref (ordinal percentile) and mutuality targets.\n\n";
			str = str + "After entering the settings click the green 'Place Judges With These Settings' buttons.  Wait 3-5 seconds, ";
			str = str + "and the pairings and diagnostics will update; the save button will turn red.  ";
			str = str + "If you like the placements, click the save button.\n\n";
			str = str + "If things go terribly wrong, click the 'Delete Placements and reload' button, and all the placements ";
			str = str + "will be deleted and reset, and the page will reload.\n\n";
			str = str + "Click the blue link in the top right to return to the pairings.";
			window.alert(str);
		}
		
		$(window).load(function () {
			var panels_over = panels_over_target();
			var dummy = document.getElementById("SavedPanelsOver"); 
			dummy.textContent = panels_over;
		});
		
		MoveDiagnostic = function(dummy_str) {
			var dummy = document.getElementById("Saved"+dummy_str); 
			var dummy2 = document.getElementById(dummy_str); 
			var current_score = dummy.textContent;
			var new_score = dummy2.textContent
			dummy.textContent = new_score;
			dummy2.textContent = "";
		}

		DoTheFuckingSave = function(panel_id, judge_id) {
			$.post("/funclib/panel_judgeadd.mas",{ panel_id: panel_id, judge_id: judge_id }, function(result){ var dummy=result; } );
			//$.post("/funclib/panel_judgeadd.mas",{ panel_id: panel_id, judge_id: judge_id } );
		}
		
		PerformSaveLoop = function() {
			var n_judges = parseFloat(document.getElementById("n_judges").value); 		

			var MasterTable = document.getElementById("current_pairing");
			var TableRows = MasterTable.getElementsByTagName("tr");
			for (var j = 1; j <= n_judges; j++) {
				for (var x = 1; x < TableRows.length ; x++) {
					var panel_id = TableRows[x].cells[0].textContent;
    				var deferred = $.Deferred();

						var dummy = document.getElementById(panel_id+"Judge"+j+"ID");
						var judge_id = dummy.textContent;
						//$.post("/funclib/panel_judgeadd.mas",{ panel_id: panel_id, judge_id: judge_id }); 					
						//setTimeout(function(){ ; }, 9000);
						//$.post("/funclib/round_clear_judges.mas",{ round_id: round_id, nobye: 1 },function(result){ PerformSaveLoop() });  
						//$.post("/funclib/panel_judgeadd.mas",{ panel_id: panel_id, judge_id: judge_id } );

						DoTheFuckingSave(panel_id, judge_id);

				}	  
			}
			
			//update the diagnostics
			MoveDiagnostic("AvgAbove");
			MoveDiagnostic("WorstAbove");
			MoveDiagnostic("AvgMutAbove");
			MoveDiagnostic("WorstMutAbove");
			MoveDiagnostic("AvgAt");
			MoveDiagnostic("WorstAt");
			MoveDiagnostic("AvgMutAt");
			MoveDiagnostic("WorstMutAt");
			MoveDiagnostic("AvgBelow");
			MoveDiagnostic("WorstBelow");
			MoveDiagnostic("AvgMutBelow");
			MoveDiagnostic("WorstMutBelow");
			MoveDiagnostic("RdsLost");
			MoveDiagnostic("PrefLeft");
			MoveDiagnostic("PanelsOver");
			
			//update the judge use table to reflect what just got saved
			var MasterTable = document.getElementById("judge_use");
			var TableRows = MasterTable.getElementsByTagName("tr");
			for (var i = 1; i < TableRows.length; i++) {
				var tr = TableRows[i];
				var judge_id = parseFloat(tr.cells[0].textContent);
				var col_5 = parseFloat(TableRows[i].cells[5].textContent);
				var col_6 = parseFloat(TableRows[i].cells[6].textContent);
				var col_8 = parseFloat(tr.cells[8].textContent);
				var col_10 = parseFloat(tr.cells[10].textContent);
				tr.cells[5].textContent = col_5 - col_8 + col_10 ;
				tr.cells[6].textContent = col_6 + col_8 - col_10;
				tr.cells[8].textContent = col_10;
			}

			window.alert("Save Completed");			

		}
		
		SavePairing = function(round_id) {
			
			//delete existing placements
			$.post("/funclib/round_clear_judges.mas",{ round_id: round_id, nobye: 1 },function(result){ PerformSaveLoop() });  
			//window.alert("Cleared current panels -- click to continue");
			
			//update buttons			
			var dummy = document.getElementById("save_button");
			dummy.value = "Placements Saved"
			dummy.style.backgroundColor = "Green" ;
			
			var time_display = document.getElementById("status_box");
			time_display.textContent = "Wait for dialogue to alert you that the save is complete.";
			
			//reload
			//window.alert("Judge placements saved -- hit enter to reload page");
			//window.location.reload();
		}
		
		DeletePairing = function(round_id) {
			$.post("/funclib/round_clear_judges.mas",{ round_id: round_id, nobye: 1 }); 
			window.alert("All judge placements have been deleted; hit OK to reload page");
			window.location.reload();
		}
		
		sortTest2 = function() {
			
			//window.alert("IN sort sub");
			
			var eval = [];

			var MasterTable = document.getElementById("STAData");
			var TableRows = MasterTable.getElementsByTagName("tr");
			for (var i = 1; i < TableRows.length; i++) {
				eval[i] = [];
				eval[i][0] = TableRows[i].cells[0].textContent; //judge id
				eval[i][1] = TableRows[i].cells[2].textContent; //panel id
				eval[i][2] = TableRows[i].cells[5].textContent; //mutpref score
			}
			
			eval.sort(function(a, b) { return (a[2] < b[2] ? -1 : (a[2] > b[2] ? 1 : 0)); });
			
			//for (var i = 0; i < 10; i++) {
			//	window.alert(i +" " + eval[i][0] + " " + eval[i][1] + " " + eval[i][2]);
			//}
			
			//window.alert("END of sort sub");
			
		}

		sortTable = function(sort_col) {

    		var tbl = document.getElementById("STAData").tBodies[0];
    		var store = [];
    		for(var i=0, len=tbl.rows.length; i<len; i++){
        		var row = tbl.rows[i];
        		var sortnr = parseFloat(row.cells[sort_col].textContent || row.cells[sort_col].innerText);
        		if(!isNaN(sortnr)) store.push([sortnr, row]);
    		}
    		store.sort(function(x,y){
        		return x[0] - y[0];
    		});
    		for(var i=0, len=store.length; i<len; i++){
        		tbl.appendChild(store[i][1]);
    		}
    		store = null;

		}

		//clears the pairings table of all judge assignments
		clear_current_placements = function() {
		
			var n_cols = document.getElementById('current_pairing').rows[0].cells.length;
			var MasterTable = document.getElementById("current_pairing");
			var TableRows = MasterTable.getElementsByTagName("tr");
			for (var i = 1; i < TableRows.length; i++) {
				for (var c = 5; c <= n_cols-2; c++) {
					if ( TableRows[i].cells[c] == undefined ) {} else {
					TableRows[i].cells[c].textContent = ""; }
				}
			}

			//clear also from the judge_use table; will need to update later
			var MasterTable = document.getElementById("judge_use");
			var TableRows = MasterTable.getElementsByTagName("tr");
			for (var i = 1; i < TableRows.length; i++) {
					TableRows[i].cells[10].textContent = "0";
			}
			
		}

		commitment_left = function(judge_id) {
		
			//accounts for current placement, even if not saved
			
			var dummy = document.getElementById("Judge"+judge_id); 
			var is_elim = parseFloat(document.getElementById("is_elim").value);
			if ( is_elim == 1 ) { return 1; }
			var rds_left = 0;
			rds_left = parseFloat(dummy.cells[6].textContent);
			rds_left = rds_left + parseFloat(dummy.cells[8].textContent); //add if in the saved pairing
			rds_left = rds_left - parseFloat(dummy.cells[10].textContent); //subtract if on displayed pairings
			return parseFloat(rds_left);
		}
		
		//updates STAData table based on current mut and pref weights
		recalc_mutpref = function() {

			var pref_weight = parseFloat(document.getElementById("pref_weight").value);
			var mut_weight = parseFloat(document.getElementById("mut_weight").value);

			var MasterTable = document.getElementById("STAData");
			var TableRows = MasterTable.getElementsByTagName("tr");
			for (var i = 1; i < TableRows.length; i++) {
				var pref1 = parseFloat(TableRows[i].cells[3].textContent);
				var pref2 = parseFloat(TableRows[i].cells[4].textContent);
				var MutPref = pref1 * (pref_weight + .5);
				MutPref = MutPref + (pref2 * (pref_weight + .5));
				var mut = Math.abs(pref1 - pref2);
				MutPref = MutPref + (mut * mut_weight);
				TableRows[i].cells[5].textContent = MutPref.toFixed(1);
				//exclude if one team didn't rate
				if ( isNaN(MutPref) ) { TableRows[i].cells[5].textContent = "9999"; }
				//exclude if no oblig left
				if ( commitment_left(TableRows[i].cells[0].textContent) <= 0 ) { TableRows[i].cells[5].textContent = "9999"; }
			}
		
		}
		
		pairing_panel_update = function(panel_id) {

			var n_judges = parseFloat(document.getElementById("n_judges").value); 
			var panel_row = document.getElementById("panel_pairing"+panel_id);
			var tot_pref = 0; var tot_judges = 0; var panel_balance = 0; var pref1; var pref2;
			for (var i = 1; i <= n_judges; i++) {
				var dummy = document.getElementById(panel_id+"Judge"+i+"Pref1"); 
				pref1 = parseFloat(dummy.textContent);
				tot_pref = tot_pref + pref1;
				tot_judges = tot_judges + 1;
				panel_balance = panel_balance + pref1;
				var dummy = document.getElementById(panel_id+"Judge"+i+"Pref2"); 
				pref2= parseFloat(dummy.textContent);
				tot_pref = tot_pref + pref2;
				tot_judges = tot_judges + 1;
				panel_balance = panel_balance - pref2;
			}
			dummy = document.getElementById(panel_id+"Avg");
			dummy.textContent = (tot_pref/tot_judges).toFixed(1)
			dummy = document.getElementById(panel_id+"Bal");
			dummy.textContent = (panel_balance).toFixed(1)

		}
		
		IsObligated = function(judge_id) {
			var judge_row = document.getElementById("Judge"+judge_id);
			var fut_poss = parseFloat(judge_row.cells[7].textContent) + parseFloat(judge_row.cells[4].textContent);
			var ob_left = parseFloat(judge_row.cells[6].textContent) + parseFloat(judge_row.cells[8].textContent);
			if ( ob_left >= fut_poss ) { return true; }
			return false;
		}

		add_judge_to_panel = function (judge_id, panel_id, judge_number) {

			//note that this just over-writes the existing placement
			var judge_row = document.getElementById("STA"+judge_id+"-"+panel_id);

			var dummy = document.getElementById(panel_id+"Judge"+judge_number+"ID");
			dummy.textContent = judge_row.cells[0].textContent;
			var judge_name = document.getElementById(panel_id+"Judge"+judge_number+"Name");
			
			var pref1 = document.getElementById(panel_id+"Judge"+judge_number+"Pref1");
			pref1.textContent = judge_row.cells[3].textContent;
			
			var pref2 = document.getElementById(panel_id+"Judge"+judge_number+"Pref2");
			pref2.textContent = judge_row.cells[4].textContent;

			judge_name.textContent = judge_row.cells[1].textContent + " " + pref1.textContent+"-"+pref2.textContent;
						
			var dummy = document.getElementById(panel_id+"Judge"+judge_number+"Mut");
			dummy.textContent = Math.abs(parseFloat(judge_row.cells[3].textContent) - parseFloat(judge_row.cells[4].textContent) ).toFixed(1);
			//update panel to show balance and avg
			pairing_panel_update(panel_id);
			//mark as being used in current pairing, not the saved one
			var dummy = document.getElementById("Judge"+judge_id);
			dummy.cells[10].textContent = 1;
			
		}

		recalc_panel_balance = function(panel_id, judge_to_remove, judge_to_add) {

			var n_judges = parseFloat(document.getElementById("n_judges").value); 

			var bal=0;
			var panel_row = document.getElementById("pairing_panel"+panel_id);
			if (panel_row == null ) { return 0; }
			for (var j = 1; j <= n_judges; j++) {
				var row_judge = document.getElementById(panel_row.cells[0].textContent+"Judge"+j+"ID").textContent;
				if ( row_judge != judge_to_add && row_judge != judge_to_remove && parseFloat(row_judge)>0 ) {
					var dummy = document.getElementById(panel_row.cells[0].textContent+"Judge"+j+"Pref1").textContent;
					bal = bal + parseFloat(dummy);
					var dummy = document.getElementById(panel_row.cells[0].textContent+"Judge"+j+"Pref2").textContent;
					bal = bal - parseFloat(dummy);
				}
			}
			
			if ( judge_to_add > 0 ) {
				var judge_STA = document.getElementById("STA"+judge_to_add+"-"+panel_id);
				bal = bal + parseFloat(judge_STA.cells[3].textContent) - parseFloat(judge_STA.cells[4].textContent);
			}
			
			return bal;

		}
		
		get_eval_score = function (judge1, panel1, judge2, panel2) {

			//returns the eval score for this combo of judges on panels; judge and panel input values are ids
			//uses MutPref scores and weights for overall panel mutuality
			
			var n_judges = parseFloat(document.getElementById("n_judges").value); 
			var panel_mut_weight = parseFloat(document.getElementById("panel_mut_weight").value);			

			var judge_1_STA = document.getElementById("STA"+judge1+"-"+panel1);
			var judge_1_mutpref = parseFloat(judge_1_STA.cells[5].textContent);
			var judge_1_rawmut = Math.abs(parseFloat(judge_1_STA.cells[7].textContent));
			if ( judge_1_mutpref == 9999 ) { return 9999; }
			var bal1=0;
			if ( n_judges > 1 ) { 
				bal1 = recalc_panel_balance(panel1, judge2, judge1); 
			} else { 
				bal1 = judge_1_rawmut; 
			}
						
			//bail if you only want the first score
			if ( judge2 == -999 ) {
				var score = judge_1_mutpref;
				if ( !isNaN(bal1) ) { score = score + ( Math.abs(bal1) * panel_mut_weight ) };
				return parseFloat(score.toFixed(1));
			}
			
			var judge_2_STA = document.getElementById("STA"+judge2+"-"+panel2);
			var judge_2_mutpref= parseFloat(judge_2_STA.cells[5].textContent);
			var judge_2_rawmut = Math.abs(parseFloat(judge_2_STA.cells[7].textContent));
			if ( judge_2_mutpref == 9999 ) { return 9999; }
			var bal2=0;
			if ( n_judges > 1) { 
				bal2 = recalc_panel_balance(panel2, judge1, judge2) ; 
			} else { 
				bal2 = judge_2_rawmut; 
			}
			if ( isNaN(bal2) ) { bal2 =0; }			

			var score = judge_1_mutpref + judge_2_mutpref + (Math.abs(bal1) * panel_mut_weight) + (Math.abs(bal2) * panel_mut_weight);
			
			return parseFloat(score.toFixed(1));

		}
		
		over_max = function(judge_id, panel_id) {

			if ( parseFloat(judge_id) == 0 ) { return false; }
			
			var dummy=false;
			var cohort_str = document.getElementById(panel_id+"Cohort").textContent;
			if ( cohort_str != null ) {
				var dummy2 = "max_mut_"+cohort_str.toLowerCase();
				var max_mut = document.getElementById( "max_mut_"+cohort_str.toLowerCase() );
				var max_pref = document.getElementById( "max_pref_"+cohort_str.toLowerCase() );
				var judge_STA = document.getElementById("STA"+judge_id+"-"+panel_id);
				var pref1 = parseFloat(judge_STA.cells[3].textContent);
				var pref2 = parseFloat(judge_STA.cells[4].textContent);
				var mutpref = parseFloat(judge_STA.cells[5].textContent);
				if ( pref1 > max_pref.value ) { dummy = true; }
				if ( pref2 > max_pref.value ) { dummy = true; }
				if ( mutpref > 9000 ) { dummy = true; }
				if ( Math.abs(pref1 - pref2) > max_mut.value ) { dummy = true; }
				if ( isNaN(pref1) || isNaN(pref2) ) { dummy = true; }
			}

			return dummy;
		}
		
		double_swap = function(just_fix) {

			//just-fix is boolean, and if true, it will fix an over-max panels even if it hurts the overall pairing
			var start = new Date();
			var n_judges = parseFloat(document.getElementById("n_judges").value); 
			var made_change = false;
			
			var MasterTable = document.getElementById("current_pairing");
			var TableRows = MasterTable.getElementsByTagName("tr");
			for (var x = 1; x < TableRows.length - 1; x++) {
				for (var y = (x + 1); y < TableRows.length; y++) {
					for (var j = 1; j <= n_judges; j++) {
						for (var j2 = 1; j2 <= n_judges; j2++) {

							var panel_x = TableRows[x].cells[0].textContent;
							var panel_y = TableRows[y].cells[0].textContent;
							var judge_x_id = document.getElementById(panel_x+"Judge"+j+"ID").textContent;
							var judge_y_id = document.getElementById(panel_y+"Judge"+j2+"ID").textContent;
							judge_x_id = parseFloat(judge_x_id);
							judge_y_id = parseFloat(judge_y_id);
							var dummy = over_max(judge_x_id, panel_y);

							if (dummy == false) {
								var dummy = over_max(judge_y_id, panel_x);

								if ( dummy == false ) {

									var score_before = get_eval_score(judge_x_id, panel_x, judge_y_id, panel_y);						
									var score_after = get_eval_score(judge_x_id, panel_y, judge_y_id, panel_x);						
									var x_over_max = false;
									if (just_fix == true) { x_over_max = over_max(judge_x_id, panel_x); }

									if ( score_after < score_before || ( just_fix == true && x_over_max == true) ) {
										add_judge_to_panel(judge_y_id, panel_x, j);		
										add_judge_to_panel(judge_x_id, panel_y, j2);
										made_change = true;
									}
								}
							}
						}
					}
				}
			}
			var end = new Date(); var duration_toclear = end - start; 
			return made_change;
		}

		triple_swap = function (just_fix) {
		
			//just-fix is boolean, and if true, it will fix an over-max panels even if it hurts the overall pairing
			var made_change = false;
			var n_judges = parseFloat(document.getElementById("n_judges").value); 
			var panel_mut_weight = parseFloat(document.getElementById("panel_mut_weight").value);			
			var MasterTable = document.getElementById("current_pairing");
			var TableRows = MasterTable.getElementsByTagName("tr");
			for (var x = 1; x < TableRows.length - 2; x++) {
				for (var j = 1; j <= n_judges; j++) {
				var panel_x = TableRows[x].cells[0].textContent;
				var x_over = false; var judge_x_id = document.getElementById(panel_x+"Judge"+j+"ID").textContent;
				if (just_fix == true) { x_over = over_max(judge_x_id, panel_x); }
				if ( just_fix == true && x_over == false ) { break; }

					for (var y = (x + 1); y < TableRows.length - 1 ; y++) {
						for (var j2 = 1; j2 <= n_judges; j2++) {
						var panel_y = TableRows[y].cells[0].textContent;
						var judge_x_id = document.getElementById(panel_x+"Judge"+j+"ID").textContent;
						var judge_y_id = document.getElementById(panel_y+"Judge"+j2+"ID").textContent;
							if ( over_max(judge_y_id, panel_x) == false ) {
								var curr_x_score = get_eval_score(judge_x_id, panel_x, -999, -999);					
								var y_to_x_panel = get_eval_score(judge_y_id, panel_x, -999, -999);
								if ( y_to_x_panel > curr_x_score ) { break; }

								for (var z = (x + 2); z < TableRows.length; z++) {
									var panel_z = TableRows[z].cells[0].textContent;
									for (var j3 = 1; j3 <= n_judges; j3++) {
									var judge_z_id = document.getElementById(panel_z+"Judge"+j3+"ID").textContent;
										if ( over_max(judge_z_id, panel_y) == false ) {
											if ( over_max(judge_x_id, panel_z) == false ) {
												if ( just_fix == false ) {
													var curr_y_score = get_eval_score(judge_y_id, panel_y, -999, -999);
													var curr_z_score = get_eval_score(judge_z_id, panel_z, -999, -999);
													var z_to_y_panel = get_eval_score(judge_z_id, panel_y, -999, -999);
													if ( z_to_y_panel > curr_y_score) { break; }
													var x_to_z_panel = get_eval_score(judge_x_id, panel_z, -999, -999);
													if ( x_to_z_panel > curr_z_score) { break; }
												}
												//didn't exit, so the switch works.  Execute it.
												add_judge_to_panel(judge_y_id, panel_x, j);		
												add_judge_to_panel(judge_z_id, panel_y, j2);		
												add_judge_to_panel(judge_x_id, panel_z, j3);		
												made_change = true;
											}	
										}
									}
								}
							}	
						}
					}
				}	
			}
			
			return made_change;
			
		}
		
		can_place_now = function(judge_id, check_commitment) {
			var judge_row = document.getElementById("Judge"+judge_id);
			//see if already assigned
			if ( parseFloat(judge_row.cells[10].textContent) == 1 ) { return false; }
			//see if available for current round			
			if ( parseFloat(judge_row.cells[4].textContent) == 0 ) { return false; }
			//see if assigned to another event in the same timeslot
			if ( parseFloat(judge_row.cells[9].textContent) == 1 ) { return false; }
			//check remaining commitment
			if (check_commitment == true) {
				var dummy = commitment_left(judge_id);
				if (dummy <= 0 ) { return false; } 
			}
			return true;

		}

		fix_with_extra = function() {
		
			var n_judges = parseFloat(document.getElementById("n_judges").value); 
			var pref_left = parseFloat(document.getElementById("pref_left").value);
			var n = 0; // n eligible
			
			//loop through all panels and see if the judge exceeds the targets
			var MasterTable = document.getElementById("current_pairing");
			var TableRows = MasterTable.getElementsByTagName("tr");
			for (var x = 1; x < TableRows.length; x++) {
				var panel_id = TableRows[x].cells[0].textContent;
				for (var j = 1; j <= n_judges; j++) {
					var judge_id = document.getElementById(panel_id+"Judge"+j+"ID").textContent; 
					if ( over_max(judge_id, panel_id) == true ) {
						//if so, create a new array of judges and sort
						var eval = [];
						var JudgeTable = document.getElementById("judge_use");
						var JudgeRows = JudgeTable.getElementsByTagName("tr");
						for (var i = 1; i < JudgeRows.length; i++) {
							var judge_dummy = parseFloat(JudgeRows[i].cells[0].textContent); 
							if ( can_place_now(parseFloat(JudgeRows[i].cells[0].textContent), true) == true ) {
								//give a score
								eval[n] = [];
								eval[n][0] = parseFloat(JudgeRows[i].cells[0].textContent); //judge id
								eval[n][1] = get_eval_score(eval[n][0], panel_id, -999, -999);
								eval[n][1] = eval[n][1] - (2 * parseFloat(JudgeRows[i].cells[2].textContent) * pref_left);
								if ( isNaN(eval[n][1]) ) { eval[n][1] = 9999; }
								if ( over_max(eval[n][0], panel_id) == true ) { eval[n][1] = 9999; }
								n = n + 1;
							}
						
						}
						eval.sort(function(a, b) { return (a[1] < b[1] ? -1 : (a[1] > b[1] ? 1 : 0)); });
						var judge_score = eval[0][1];
						if ( eval[0][0] != undefined ) { 
							var dummy_1 = get_eval_score(judge_id, panel_id, -999, -999);
							var dummy_2 = get_eval_score(eval[0][0], panel_id, -999, -999);
							if ( dummy_2 < dummy_1 && over_max(eval[0][0], panel_id) == false ) {
								var judge_out = document.getElementById("Judge"+judge_id);
								var judge_out_name = judge_out.cells[0].textContent;
								judge_out.cells[10].textContent = 0 ;
								var new_judge = eval[0][0];
								add_judge_to_panel(eval[0][0], panel_id, j);
							}
						}			
					}
				}
			}
		}

		panels_over_target = function () {
			var n = 0;
			var n_judges = parseFloat(document.getElementById("n_judges").value); 
			var MasterTable = document.getElementById("current_pairing");
			var TableRows = MasterTable.getElementsByTagName("tr");
			for (var x = 1; x < TableRows.length; x++) {
				var panel_id = TableRows[x].cells[0].textContent;
				for (var j = 1; j <= n_judges; j++) {
					var judge_id = document.getElementById(panel_id+"Judge"+j+"ID").textContent; 
					if ( over_max(judge_id, panel_id) == true ) { n = n + 1; }
				}
			}	
			return n;
		}
		
		fix_with_extra_and_doub = function () {
			
			var n_judges = parseFloat(document.getElementById("n_judges").value); 
			var pref_left = parseFloat(document.getElementById("pref_left").value);
			var n=0; var n_fixed=0;
			
			//loop through all panels and see if the judge exceeds the targets
			var MasterTable = document.getElementById("current_pairing");
			var TableRows = MasterTable.getElementsByTagName("tr");
			for (var x = 1; x < TableRows.length; x++) {
				var best_judge_steal_score = 9999; var best_replacement_score = 9999;
				var panel_id = TableRows[x].cells[0].textContent;
				var judge_to_steal = 0; var replacement_judge_id = 0; var replacement_judge_n = 0;
				for (var j = 1; j <= n_judges; j++) {
					var judge_id = document.getElementById(panel_id+"Judge"+j+"ID").textContent; 
					if ( over_max(judge_id, panel_id) == true ) {
						n = n + 1;
						var MasterTable_2 = document.getElementById("current_pairing");
						var TableRows_2 = MasterTable_2.getElementsByTagName("tr");
						for (var x_2 = 1; x_2 < TableRows_2.length; x_2++) {
							var panel_id_2 = TableRows_2[x_2].cells[0].textContent;
							for (var j_2 = 1; j_2 <= n_judges; j_2++) {
								var judge_id_2 = document.getElementById(panel_id_2+"Judge"+j_2+"ID").textContent;
								if ( over_max(judge_id_2, panel_id) == false ) {
									var dummy = get_eval_score(judge_id_2, panel_id, -999, -999);
									var JudgeTable = document.getElementById("judge_use");
									var JudgeRows = JudgeTable.getElementsByTagName("tr");
									for (var i = 1; i < JudgeRows.length; i++) {
										if ( can_place_now(JudgeRows[i].cells[0].textContent, true) == true ) {
											var dummy_2 = get_eval_score(JudgeRows[i].cells[0].textContent, panel_id_2, -999, -999);
											dummy = parseFloat(dummy); dummy_2 = parseFloat(dummy_2);
											var new_over_max = over_max(JudgeRows[i].cells[0].textContent, panel_id_2, -999, -999);
											if ( (dummy + dummy_2) < (best_replacement_score + best_judge_steal_score) &&  new_over_max == false ) {
												best_replacement_score = dummy_2;
												best_judge_steal_score = dummy;
												judge_to_steal = judge_id_2;
												replacement_judge_id = JudgeRows[i].cells[0].textContent;
												replacement_judge_n = j_2;
											}
										}
									}
								}
							}	
						}
					}
					//put chang here
					if ( replacement_judge_id > 0 ) {
						add_judge_to_panel(judge_to_steal, panel_id, j);
						add_judge_to_panel(replacement_judge_id, panel_id_2, replacement_judge_n);
						var dummy = document.getElementById("Judge"+judge_id); 
						dummy.cells[10].textContent=0;
						n_fixed = n_fixed + 1;
					}

				}	
			}
		}				

		push_obligated_back_in = function() {

			var n_judges = parseFloat(document.getElementById("n_judges").value); 
			
			var MasterTable = document.getElementById("judge_use");
			var TableRows = MasterTable.getElementsByTagName("tr");
			for (var x = 1; x < TableRows.length; x++) {
				var judge_to_add = TableRows[x].cells[0].textContent;
				var judging_now = parseFloat(TableRows[x].cells[10].textContent);
				if ( IsObligated(judge_to_add) == true && judging_now == 0 ) {
					var panel_to_add=0;
					var judge_to_remove=0;
					var judge_n_spot = 0;
					var test_score = 9999;
					var PairingTable = document.getElementById("current_pairing");
					var PairingRows = PairingTable.getElementsByTagName("tr");
					for (var i = 1; i < PairingRows.length; i++) {
						var panel_id = PairingRows[i].cells[0].textContent;
						for (var j = 1; j <= n_judges; j++) {
							var curr_judge_id = document.getElementById(panel_id+"Judge"+j+"ID").textContent;
							if ( IsObligated(curr_judge_id) == false && over_max(judge_to_add, panel_id) == false ) {
								var score = get_eval_score(judge_to_add, panel_id, -999, -999);
								if (score < test_score ) {
									test_score = score;
									panel_to_add=panel_id;
									judge_n_spot=j;
									judge_to_remove = curr_judge_id;
								}
							}
						}
					}
					if ( panel_to_add > 0 ) {
						add_judge_to_panel(judge_to_add, panel_to_add, judge_n_spot);
						var dummy = document.getElementById("Judge"+judge_to_remove); 
						dummy.cells[10].textContent=0;
					}
				}
			}
		
		}

		salvage_below = function() {
		
			//if there's a top-50 judge in an out-of-it debate, replace them with a bottom-50 judge if there is one
			//who fits.
			
			var n_judges = parseFloat(document.getElementById("n_judges").value); 
			
			var MasterTable = document.getElementById("current_pairing");
			var TableRows = MasterTable.getElementsByTagName("tr");
			for (var x = 1; x < TableRows.length; x++) {
				var panel_id = TableRows[x].cells[0].textContent;
				var cohort = document.getElementById( panel_id+"Cohort" ).textContent; 
				if ( cohort == "Below" ) {
					for (var j = 1; j <= n_judges; j++) {
						var judge_id = document.getElementById(panel_id+"Judge"+j+"ID").textContent;
						judrow = document.getElementById("Judge"+judge_id);
						if (judrow.cells[6].textContent == 1 && judrow.cells[2].textContent < 50 ) {
							var JudgeTable = document.getElementById("judge_use");
							var JudgeRows = JudgeTable.getElementsByTagName("tr");
							for (var i = 1; i < JudgeRows.length; i++) {
								if ( JudgeRows[i].cells[2].textContent > 50 && JudgeRows[i].cells[10].textContent == 0 && can_place_now(JudgeRows[i].cells[0].textContent, true) ) {
									if ( over_max(JudgeRows[i].cells[0].textContent, panel_id) == false) {
										add_judge_to_panel(JudgeRows[i].cells[0].textContent, panel_id, j);
										var dummy = document.getElementById("Judge"+judge_id); 
										dummy.cells[10].textContent=0;
									}
								}
							}
						}
					}
				}
			}
		}
										
		PlaceJudges = function() {
			
			var n_judges = parseFloat(document.getElementById("n_judges").value); 
			var pref_left = parseFloat(document.getElementById("pref_left").value);
			var is_elim = document.getElementById("is_elim").value;
			
			var start = new Date();
			
			clear_current_placements();
						
			var time_display = document.getElementById("status_box");
			var end = new Date(); var duration_toclear = end - start; 

			recalc_mutpref();		
			var end = new Date(); var duration_torecalc = end - start; 
						
			//sortTest2(); 
			//sortTable(5); //original sort test functions; sorting a javascript array is faster than
			

			//  FIRST PASS -------

			//figure out how many non_obligated judges you gotta use
			var MasterTable = document.getElementById("judge_use");
			var TableRows = MasterTable.getElementsByTagName("tr");
			var n_obligated=0;
			for (var i = 1; i < TableRows.length; i++) {
				if ( IsObligated( parseFloat(TableRows[i].cells[0].textContent) ) == true ) { n_obligated = n_obligated + 1; }
			}
			var MasterTable = document.getElementById("current_pairing");
			var TableRows = MasterTable.getElementsByTagName("tr");
			var n_debates = TableRows.length - 1;
			var non_ob_needed =  n_debates - n_obligated;

			//get the weights you'll need & mark time						
			var panel_mut_weight = parseFloat(document.getElementById("panel_mut_weight").value);			
			var end = new Date(); var duration_sorttest = end - start; 

			var cohort_str = ["At", "Above", "Below"];
			for (var cohort = 0; cohort <=2; cohort ++ ) {
				for (var judge = 1; judge <= n_judges; judge++) {
	
					//need to recalc eval here for multi-judge panels
					var eval = [];
					var MasterTable = document.getElementById("STAData");
					var TableRows = MasterTable.getElementsByTagName("tr");
					var STAData_length = TableRows.length;
					for (var i = 1; i < STAData_length; i++) {
						eval[i] = [];
						eval[i][0] = TableRows[i].cells[0].textContent; //judge id
						eval[i][1] = TableRows[i].cells[2].textContent; //panel id
						eval[i][2] = get_eval_score(eval[i][0], eval[i][1], -999, -999); //mutpref score adj for panel mut
						var rating = document.getElementById(TableRows[i].cells[0].textContent+"Rating").textContent;
						eval[i][3] = eval[i][2]-(rating * pref_left); //mutpref w/avg pref remaining weight				
						eval[i][4] = TableRows[i].cells[1].textContent; //judge name
						eval[i][5] = IsObligated( TableRows[i].cells[0].textContent ); //obligated to hear round
						//if ( over_max(eval[i][0], eval[i][1]) == true ) { eval[i][3] = 9999; }
					}
					eval.sort(function(a, b) { return (a[3] < b[3] ? -1 : (a[3] > b[3] ? 1 : 0)); });
							
					//now loop panels and put in the best judge		
					for (var j = 0; j < eval.length-1; j++) {

						judrow = document.getElementById("Judge"+eval[j][0]);
						var in_cohort = false;
						var dummy = document.getElementById(eval[j][1]+"Cohort");
						if ( dummy.textContent == cohort_str[cohort] ) { in_cohort = true;}
						var panel_assigned_already = false;
						var dummy = document.getElementById(eval[j][1]+"Judge"+judge+"ID");
						if ( parseFloat(dummy.textContent) > 0 ) { panel_assigned_already = true; }
						if ( in_cohort == true && panel_assigned_already == false ) {
							var check_commit = true;
							if ( is_elim == true ) { check_commit = false; }
							if ( judrow.cells[10].textContent == 0 && can_place_now(eval[j][0], check_commit) == true ) {
								var eval_score = eval[j][3];
								var judge_num = eval[j][0];
								var is_oblig = eval[j][5];
								var panel_id_num =eval[j][1];
								if ( non_ob_needed > 0 || eval[j][5] == true || is_elim == 1 ) {
									add_judge_to_panel(eval[j][0], eval[j][1], judge);		
									if ( eval[j][5] == false ) { non_ob_needed = non_ob_needed - 1; }
								}
							}
						}
					}
				}
			}
			
			//SECOND PASS; fill in any empty spots
			var MasterTable = document.getElementById("current_pairing");
			var TableRows = MasterTable.getElementsByTagName("tr");
			for (var x = 1; x < TableRows.length; x++) {
				for (var judge = 1; judge <= n_judges; judge++) {
					var dummy = document.getElementById(TableRows[x].cells[0].textContent+"Judge"+judge+"ID");
					if ( !dummy.textContent ) { 
						//loop through the remaining eval scores
						for (var j = 0; j < eval.length-1; j++) {
							if ( parseFloat(eval[j][1]) == parseFloat(TableRows[x].cells[0].textContent) ) {
								judrow = document.getElementById("Judge"+eval[j][0]);
								if ( judrow.cells[10].textContent == 0 && can_place_now(eval[j][0], true) == true ) {
									add_judge_to_panel(eval[j][0], eval[j][1], judge);
									break;
								}
							}
						}
					}
				}
			}

			var end = new Date(); var duration_first_pass = end - start; 
						
			var made_change = true;
			var any_triple = false;

			//double and triple swaps
			var n_tries=0;
			var n_2x_swaps=0;
			do {
				made_change = double_swap(false); if (made_change == true ) { n_2x_swaps = n_2x_swaps +1; }
				n_tries++;
			} while ( n_tries < 50 && made_change == true );	
			var end = new Date(); var duration_doub_swap = end - start; 

			n_tries=0;
			do {
				made_change = triple_swap(false); if (made_change == true ) { n_2x_swaps = n_2x_swaps +1; }
				n_tries++;

			} while ( n_tries < 10 && made_change == true );
			var end = new Date(); var duration_trip_swap = end - start; 

			fix_with_extra();
			var end = new Date(); var duration_fix_w_extra = end - start; 

			//time_display.textContent = "Done and bailed after fix with extra."; current_diagnostics();
			//return;
			
			fix_with_extra_and_doub();
			var end = new Date(); var duration_fix_w_extra_and_doub = end - start; 

			//repeat double and triple swaps
			var n_tries=0;
			do {
				made_change = double_swap(false); if (made_change == true ) { n_2x_swaps = n_2x_swaps +1; }
				n_tries++;
			} while ( n_tries < 50 && made_change == true );	
			var end = new Date(); var duration_doub_swap_2 = end - start; 
			
			n_tries=0;
			do {
				made_change = triple_swap(false); if (made_change == true ) { n_2x_swaps = n_2x_swaps +1; }
				n_tries++;

			} while ( n_tries < 10 && made_change == true );
			var end = new Date(); var duration_trip_swap_2 = end - start; 

			push_obligated_back_in();
			var end = new Date(); var duration_push_back_in = end - start;
			
			//just fix double-swaps
			if (panels_over_target() > 0 ) {
				var n_tries=0;
				do {
					made_change = double_swap(true); if (made_change == true ) { n_2x_swaps = n_2x_swaps +1; }
					n_tries++;
				} while ( n_tries < 50 && made_change == true );	
			}
			
			if (panels_over_target() > 0 ) {
				n_tries=0;
				do {
					made_change = triple_swap(true); if (made_change == true ) { n_2x_swaps = n_2x_swaps +1; }
					n_tries++;

				} while ( n_tries < 10 && made_change == true );
			}

			//Don't burn good judges in out of it debates
			salvage_below();
			
			time_display.textContent = "Time to clear screen is:" + duration_toclear/1000; 
//			time_display.textContent=time_display.textContent + " Time to recalc screen is:" + duration_torecalc/1000; 
//			time_display.textContent=time_display.textContent + " Time for sort is:" + duration_sorttest/1000; 
			time_display.textContent=time_display.textContent + " Time to first pass is:" + duration_first_pass/1000; 
//			time_display.textContent=time_display.textContent + " Time to double swap is:" + duration_doub_swap/1000; 
			time_display.textContent=time_display.textContent + " " + n_2x_swaps + " total 2x & 3x swaps. " + duration_doub_swap/1000; 
//			time_display.textContent=time_display.textContent + " Time to triple swap is:" + duration_trip_swap/1000; 
//			time_display.textContent=time_display.textContent + " Time to fix with extra:" + duration_fix_w_extra/1000; 
//			time_display.textContent=time_display.textContent + " Time to fix with extra & 2x:" + duration_fix_w_extra_and_doub/1000; 
//			time_display.textContent=time_display.textContent + " Time to push back oblig judges:" + duration_push_back_in/1000;
//			time_display.textContent=time_display.textContent + " Finish second 2x, 3x swaps:" + duration_trip_swap_2/1000;
			time_display.textContent=time_display.textContent + " Time to finish placements:" + duration_push_back_in/1000;
			var panels_over = panels_over_target();
			time_display.textContent=time_display.textContent + " - " + panels_over + " panels over target"; 

			var dummy = document.getElementById("PanelsOver");
			dummy.textContent = panels_over;
			current_diagnostics();
			
			var dummy = document.getElementById("save_button");
			dummy.value = "Click to Save Placements Below";
			dummy.style.backgroundColor = "Red" ;
			
		}
		
		judge_test = function() {
		
			//window.alert("in test");
			var dummy = document.getElementById("321912Judge1Pref1");
			dummy.textContent = "1.3";
			var dummy = document.getElementById("321912Judge1Pref2");
			dummy.textContent = "2.1";
			var dummy = document.getElementById("321912Judge1Name");
			dummy.textContent = "Bruschke, Cricket 1.3-2.1";
			var dummy = document.getElementById("321912Judge1Mut");
			dummy.textContent = ".8";
			var dummy = document.getElementById("321912Avg");
			dummy.textContent = "1.7";
			var dummy = document.getElementById("321912Bal");
			dummy.textContent = "-.8";

		}
		
		//only called from within the current_pairings diagnostics
		judge_diagnostics = function() {

			var n_judges = parseFloat(document.getElementById("n_judges").value); 
			
			//update columns in table to reflect the displayed pairings; shows whether they are judging in the current pairings
			var MasterTable = document.getElementById("current_pairing");
			var TableRows = MasterTable.getElementsByTagName("tr");
			for (var i = 1; i < TableRows.length; i++) {
				for (var j = 1; j <= n_judges; j++) {
					var judge_id = document.getElementById(TableRows[i].cells[0].textContent+"Judge"+j+"ID");
					if ( judge_id != null ) {
						var judge_use = document.getElementById(judge_id.textContent+"DisplayAssigned");
						if ( judge_use != null ) { judge_use.textContent = 1; }
					}
				}
			}
			
			//Count up rounds lost and average pref left
			var NewRdsLost = 0;
			var TotPref = 0; var PrefNum = 0;
			var MasterTable = document.getElementById("judge_use");
			var TableRows = MasterTable.getElementsByTagName("tr");
			for (var i = 1; i < TableRows.length; i++) {
				var oblig = commitment_left(TableRows[i].cells[0].textContent);
				var FutPoss = parseFloat(TableRows[i].cells[7].textContent); 
				var AvailCurrent = parseFloat(TableRows[i].cells[4].textContent); 
				var SaveAssignedTimeslot = parseFloat(TableRows[i].cells[9].textContent); 
				var AssignedCurrent = parseFloat(TableRows[i].cells[10].textContent); 
				TableRows[i].cells[13].textContent = 0;
				
				if ( AvailCurrent == 1 && SaveAssignedTimeslot == 0 && AssignedCurrent == 0 && oblig >= (FutPoss + 1) ) {
					TableRows[i].cells[13].textContent = "1";
					NewRdsLost++ ;
				}
				var Rating = parseFloat(TableRows[i].cells[2].textContent);
				var dummy = oblig;
				if ( FutPoss < dummy) { dummy = FutPoss; }
				if ( dummy < 0 ) { dummy = 0; }
				TotPref = TotPref + (dummy * Rating);
				PrefNum = PrefNum + dummy ;
			}
			
			var dummy = document.getElementById("RdsLost");
			dummy.textContent = NewRdsLost + "/" + PrefNum;
			var dummy = document.getElementById("PrefLeft");
			var dummy2 = TotPref / PrefNum;
			dummy.textContent = dummy2.toFixed(1);
			
		}
		
		//updates the diagnostics based on the current set of judge assignments; 
		//earlier I had typed the comment "gotta run judge_diagnostics first" but I think I'm insane
		current_diagnostics = function() {

			var n_judges = parseFloat(document.getElementById("n_judges").value); 
			var MasterTable = document.getElementById("current_pairing");
			var TableRows = MasterTable.getElementsByTagName("tr");
			var TotPref = [0,0,0]; var PrefCt = [0,0,0]; var Cohort_num;
			var WorstPref = [0,0,0]; 
			var TotMut = [0,0,0]; 
			var MutCt = [0,0,0];
			var WorstMut = [0,0,0];
			for (var i = 1; i < TableRows.length; i++) {
				var Cohort = document.getElementById(TableRows[i].cells[0].textContent+"Cohort");
				if ( Cohort != null ) {
					if ( Cohort.textContent == "Above" ) { Cohort_num = 0; }
					if ( Cohort.textContent == "At" ) { Cohort_num = 1; }
					if ( Cohort.textContent == "Below" ) { Cohort_num = 2; }				
				}
				for (var j = 1; j <= n_judges; j++) {
					var id_to_get = TableRows[i].cells[0].textContent+"Judge"+j+"Mut";
					var mut = document.getElementById(id_to_get);
					if ( mut != null ) {
						TotMut[Cohort_num] = TotMut[Cohort_num] + parseFloat(mut.textContent);
						MutCt[Cohort_num] = MutCt[Cohort_num] + 1;
						if ( parseFloat(mut.textContent) > WorstMut[Cohort_num] ) { WorstMut[Cohort_num] = parseFloat(mut.textContent); }
					}	
					
					for (var tm = 1; tm <= 2; tm++) {
						var id_to_get = TableRows[i].cells[0].textContent+"Judge"+j+"Pref"+tm;
						var pref = document.getElementById(id_to_get);
						if ( pref != null ) {
							TotPref[Cohort_num] = TotPref[Cohort_num] + parseFloat(pref.textContent) ; 
							PrefCt[Cohort_num] = PrefCt[Cohort_num] + 1;
							if ( parseFloat(pref.textContent) > WorstPref[Cohort_num] ) { WorstPref[Cohort_num] = parseFloat(pref.textContent) };
//							window.alert("Panel/Judge=" + id_to_get + " Pref=" + parseFloat(pref.textContent) + " TotPref=" + TotPref[Cohort_num] + " PrefCt=" + PrefCt[Cohort_num]);
						}
					}	
				}
			}
			
			var dum_str;
			for (var i = 0; i <= 2; i++) {
				if ( i == 0 ) { dum_str = "Above"; }
				if ( i == 1 ) { dum_str = "At"; }
				if ( i == 2 ) { dum_str = "Below"; }
				dummy = document.getElementById("Avg"+dum_str);
				dummy.textContent=parseFloat(TotPref[i]/PrefCt[i]).toFixed(1);
				dummy = document.getElementById("Worst"+dum_str);
				dummy.textContent=WorstPref[i].toFixed(1);
				dummy = document.getElementById("AvgMut"+dum_str);
				dummy.textContent=parseFloat(TotMut[i]/MutCt[i]).toFixed(1);
				dummy = document.getElementById("WorstMut"+dum_str);
				dummy.textContent=WorstMut[i].toFixed(1);
			}
			
			//update judge situation
			judge_diagnostics();

		}
		
	</script>
	

		<h2>STA Judge Placement (Gary Larson) MPJ Settings for <% $event->name %> <% $round->label %> (<% $round->name %>) </h2>
		<form action="debate_judge_assign_sta.mhtml" method="post">
		<input type="hidden" value="<% $round_id %>" name="round_id">
		<input type="hidden" value="<% $is_elim %>" name="is_elim" id="is_elim">
		<input id="n_judges" type="hidden" value="<% $round->judges %>" >

		<& /funclib/tablesorter.mas, table => "tbl_weights" &> 
		<table id="tbl_weights" class="smallish" cellpadding="0" cellspacing="1">
		
			<caption><h4>Weights</h4></caption>
			<tr>
				<td>
					Preference per judge
					<input id="pref_weight" type="number" step="0.1" class="smaller" min=0 max=99 size=4  name="pref_wt" value="<% $pref_wt %>">
				</td>
				<td>
					Mutuality per judge
					<input id="mut_weight" type="number" step="0.1" class="smaller" min=0 max=99 size=4  name="mut_wt" value="<% $mut_wt %>">
				</td>
				<td >
					Remaining Pref
					<input id="pref_left" type="number" step="0.1" class="smaller" min=0 max=99 size=4  name="pref_left" value="<% $pref_left %>">
				</td>
				<td style='display:none;'>
					Preference per panel
					<input type="number" step="0.1" class="smaller" min=0 max=99 size=4  name="pref_wt_panel" value="<% $pref_wt_panel %>">
				</td>
				<td style='display:none;'>
					Mutuality per panel
					<input id="panel_mut_weight" type="number" step="0.1" class="smaller" min=0 max=99 size=4  name="mut_wt_panel" value="<% $mut_wt_panel %>">
				</td>

			</tr>
		</table>
		<table class="smallish" cellpadding="0" cellspacing="1">	
			<caption>
				<h4>Constraints</h4>
			</caption>
			<tr>
				<td colspan="3">
					Max losses a team can have and still clear (break line):
					<input type="number" class="smaller" min=0 max=99 size=4  name="break_line" value="<% $break_line %>">
				</td>
			</tr>
			<tr>
				<td>
					ABOVE the break line
				</td>
				<td>
					Max Preference
					<input id="max_pref_above" type="number" class="smaller" min=0 max=99 size=4  name="max_pref_above" value="<% $max_pref{'above'} %>">
				</td>
				<td>
					Max Mutuality
					<input id="max_mut_above" type="number" class="smaller" min=0 max=99 size=4  name="max_mut_above" value="<% $max_mut{'above'} %>">
				</td>

			</tr>
			<tr>
				<td>
					AT the break line
				</td>
				<td>
					Max Preference
					<input id="max_pref_at" type="number" class="smaller" min=0 max=99 size=4  name="max_pref_at" value="<% $max_pref{'at'} %>">
				</td>
				<td>
					Max Mutuality
					<input id="max_mut_at" type="number" class="smaller" min=0 max=99 size=4  name="max_mut_at" value="<% $max_mut{'at'} %>">
				</td>

			</tr>
			<tr>
				<td>
					BELOW the break line
				</td>
				<td>
					Max Preference
					<input id="max_pref_below" type="number" class="smaller" min=0 max=99 size=4  name="max_pref_below" value="<% $max_pref{'below'} %>">
				</td>
				<td>
					Max Mutuality
					<input id="max_mut_below" type="number" class="smaller" min=0 max=99 size=4  name="max_mut_below" value="<% $max_mut{'below'} %>">
				</td>

			</tr>


			</tr>

		</table>

		
		<div class="liblrow leftalign">
					<input id="place_button" type="button" value="Place judges with these settings" onclick="PlaceJudges()">
					<input id="save_button" type="button" value="Save Placements Below" onclick="SavePairing(<% $round_id %>)">
					<input id="delete_button" type="button" value="Delete Placements & Reload" onclick="DeletePairing(<% $round_id %>)">
					<textarea id="status_box" cols="70" rows="3"></textarea>
			</form>
		</div>
		
		<table>	
			<caption>
				<h4>Diagnostics</h4>
			</caption>
			<tr class="smallish">
				<td>Scheme</td>
				<td colspan="4" align="center">ABOVE break</td>
				<td colspan="4" align="center">AT break</td>
				<td colspan="4" align="center">BELOW break</td>								
				<td>Rounds Lost/Left*</td>
				<td>Avg Pref Remaining</td>
				<td>Panels over targets</td>
			</tr>
			<tr class="smallish">
				<td></td>
				<td>Avg Pref</td>
				<td>Worst Pref</td>
				<td>Avg Mut</td>
				<td>Worst Mut</td>												
				<td>Avg Pref</td>
				<td>Worst Pref</td>
				<td>Avg Mut</td>
				<td>Worst Mut</td>												
				<td>Avg Pref</td>
				<td>Worst Pref</td>
				<td>Avg Mut</td>
				<td>Worst Mut</td>												
				<td></td>
				<td></td>
				<td></td>
			</tr>
			<tr class="smallish">
				<td>Saved Pairings</td>
				<td id="SavedAvgAbove"><% sprintf("%.1f", $avg_pref[1]) %></td>
				<td id="SavedWorstAbove"><% sprintf("%.1f", $worst_pref[1]) %></td>
				<td id="SavedAvgMutAbove"><% sprintf("%.1f", $avg_mut[1]) %></td>
				<td id="SavedWorstMutAbove"><% sprintf("%.1f", $worst_mut[1]) %></td>
				<td id="SavedAvgAt"><% sprintf("%.1f", $avg_pref[2]) %></td>
				<td id="SavedWorstAt"><% sprintf("%.1f", $worst_pref[2]) %></td>
				<td id="SavedAvgMutAt"><% sprintf("%.1f", $avg_mut[2]) %></td>
				<td id="SavedWorstMutAt"><% sprintf("%.1f", $worst_mut[2]) %></td>
				<td id="SavedAvgBelow"><% sprintf("%.1f", $avg_pref[3]) %></td>
				<td id="SavedWorstBelow"><% sprintf("%.1f", $worst_pref[3]) %></td>
				<td id="SavedAvgMutBelow"><% sprintf("%.1f", $avg_mut[3]) %></td>
				<td id="SavedWorstMutBelow"><% sprintf("%.1f", $worst_mut[3]) %></td>
				<td id="SavedRdsLost"><% $lost_rounds_current %>/<% $tot_rds %></td>
				<td id="SavedPrefLeft"><% sprintf("%.1f", $tot_pref/$tot_rds) %></td>
				<td id="SavedPanelsOver"></td>
			</tr>
			<tr class="smallish">
				<td>Pairings Below</td>
				<td id="AvgAbove"></td>
				<td id="WorstAbove"></td>
				<td id="AvgMutAbove"></td>
				<td id="WorstMutAbove"></td>				
				<td id="AvgAt"></td>
				<td id="WorstAt"></td>
				<td id="AvgMutAt"></td>
				<td id="WorstMutAt"></td>				
				<td id="AvgBelow"></td>
				<td id="WorstBelow"></td>
				<td id="AvgMutBelow"></td>
				<td id="WorstMutBelow"></td>				
				<td id="RdsLost"></td>				
				<td id="PrefLeft"></td>								
				<td id="PanelsOver"></td>								
			</tr>
			<tr class="smallish" >
				<td colspan="16">*<% $needed_judges_future %> rounds of judging needed to complete prelims after this one,
				including all events (divisions) using this judge group.</td>
			</tr>

		</table>


		<table id="current_pairing" >
			<caption>
				<h4>Current Pairings</h4> 
<!--				
				<a onclick='current_diagnostics()' >Run Diagnostics on Pairings Below</a>
				<a onclick='judge_test()' >Test Judge Placement</a>
-->				
			</caption>
		<tr class="yellowrow" >
		<td <% $debug_display %>>panel</td>
		<td <% $debug_display %>>aff ID</td>
		<td>aff name</td>
		<td <% $debug_display %>>neg ID</td>
		<td>neg name</td>
%#		my $n_judges = $round->judges; print "Using ".$n_judges." judges<br>";
%		for (my $i=1; $i <= $n_judges; $i++) {
 		  <td <% $debug_display %>>Judge<% $i %> ID</td>
   		  <td>Judge<% $i %> Name</td>
   		  <td <% $debug_display %>>Judge<% $i %>Pref1</td>
  		  <td <% $debug_display %>>Judge<% $i %>Pref2</td>
  		  <td <% $debug_display %>>Judge<% $i %> Mut</td>		  
%		}
		<td>Panel Avg</td>
		<td>Panel Balance</td>
		<td>Break Line (cohort)</td>
		</tr>
%		my %live_panels; 
%		foreach my $panel (@panels) {

%			my $co;	my $pan_tot; my $pan_ct; my $pan_bal; my $ctr;	
%			my @showed_side;	
%			my @ballots = Tab::Ballot->search( panel => $panel->id);
%			@ballots = sort {$a->side cmp $b->side} @ballots; 
%			if ( $panel->bye == 0 and scalar(@ballots)>1 ) {
%				$live_panels{$panel->id} = 1;
				<tr id="pairing_panel<% $panel->id %>" class="smaller" >
				<td <% $debug_display %>><% $panel->id %></td>	
%					foreach my $ballot (@ballots) {
%					if ( $break_line ==  $entry_losses{$ballot->entry} ) { $co = 2; }
%					if ( $break_line >  $entry_losses{$ballot->entry} and ($co == 0 or $co == 1) ) { $co = 1; }
%					if ( $break_line <  $entry_losses{$ballot->entry} and ($co == 0 or $co == 3) ) { $co = 3; }
%					if ($round->type eq "elim") { $co = 2; }
%						if ( $showed_side[$ballot->side] != 1 ) {
						<td <% $debug_display %>><% $ballot->entry %></td>
						<td><% $entry_code{$ballot->entry} %> <% $entry_wins{$ballot->entry} %>-<% $entry_losses{$ballot->entry} %></td>
%						$showed_side[$ballot->side] = 1;						
%						}				
%					}		
%					foreach my $ballot (@ballots) {
%						if ($ballot->side == 1 ) {
%						$ctr++;	$showed_side[$ballot->side] = 1;
						<td <% $debug_display %> id="<% $panel %>Judge<% $ctr %>ID"><% $ballot->judge %></td> 
						<td id=<% $panel %>Judge<% $ctr %>Name>
							<% $judge{$ballot->judge}{'name'} %> <% $pref_record{$ballot->judge."-".$panel->id} %>
						</td>
%						my ($pref1, $pref2) = prefdata( $pref_record{$ballot->judge."-".$panel->id} ) ;
						<td <% $debug_display %> id="<% $panel %>Judge<% $ctr %>Pref1"><% $pref1 %></td>
						<td <% $debug_display %> id="<% $panel %>Judge<% $ctr %>Pref2"><% $pref2 %></td>
%						$pan_tot += $pref1; $pan_tot += $pref2; $pan_ct += 2;
%						my $mut = abs($pref1 - $pref2); $pan_bal = $pan_bal + ($pref1 - $pref2);
%						$mut = sprintf("%.1f", $mut);
						<td <% $debug_display %> id="<% $panel %>Judge<% $ctr %>Mut"><% $mut %></td>
%						}											
%					}
%					if ($ctr < $n_judges ) {
%						for (my $i=$ctr+1; $i <= $n_judges; $i++) {
							<td <% $debug_display %> id="<% $panel %>Judge<% $i %>ID">0</td> 
							<td id=<% $panel %>Judge<% $i %>Name>
								Unassigned
							</td>
							<td <% $debug_display %> id="<% $panel %>Judge<% $i %>Pref1">0</td>
							<td <% $debug_display %> id="<% $panel %>Judge<% $i %>Pref2">0</td>
							<td <% $debug_display %> id="<% $panel %>Judge<% $i %>Mut">0</td>
%					    }
%					}

					<td id="<% $panel %>Avg">
%					if ($pan_ct) { printf("%.1f", $pan_tot/$pan_ct) ; }
					</td>
					<td id="<% $panel %>Bal">
%					printf("%.1f", $pan_bal);
					</td>
					<td id="<% $panel %>Cohort"><% $cohort[$co] %></td>			
%			}
%		}

		</table>

		<table <% $debug_display %> id="judge_use">
			<caption>
			Judge Use Situation <a onclick='judge_diagnostics()' >Run Diagnostics on Judge Data Below</a>
			</caption>
			<tr>
				<td>0 - ID</td>			
				<td>1 - Judge</td>
				<td>2 - Avg Rating</td>
				<td>3 - Obligation</td>
				<td>4 - Available for Current RD</td>
				<td>5 - Saved: Judged so far</td>				
				<td>6 - Saved: Oblig Left</td>								
				<td>7 - Saved: Future Possible</td>
				<td>8 - Saved: Assigned to this rd</td>				
				<td>9 - Saved: Assigned elsewhere in timeslot</td>				
				<td>10 - Display: Assigned</td>
				<td>11 - Display: Oblig Left</td>
				<td>12 - Display: Lost</td>				
				<td>13 - Display: Lost Current</td>				
			</tr>
%		foreach my $judges (@judge_ref) {
%				my $key = $judges->id;
			<tr id="Judge<% $judges->id %>" >
				<td><% $key %></td>
				<td><% $judge{$judges->id}{'name'} %></td>
				<td id="<% $judges->id%>Rating" ><% $judge{$judges->id}{'avg_pref'} %></td>				
				<td id="<% $judges->id%>Oblig" ><% ${$judge_hash}{$key}{'oblig'} %></td>
				<td><% ${$judge_hash}{$key}{'avail_current'} %></td>				
%				my $judged_already = ${$judge_hash}{$key}{'judged_already'}; $judged_already = 0 unless $judged_already;				
				<td><% $judged_already %></td>
				<td id="<% $judges->id%>ObligLeft"><% ${$judge_hash}{$key}{'oblig'} - ${$judge_hash}{$key}{'judged_already'} %></td>
				<td id="<% $judges->id%>FutPoss"><% ${$judge_hash}{$key}{'future_possible'} %></td>				
				<td>
%				my $assign_to_rd = ${$judge_hash}{$key}{'in_round'};
%				$assign_to_rd = 0 unless $assign_to_rd;				
				<% $assign_to_rd %></td>								
				<td>
%				my $in_other_event = ${$judge_hash}{$key}{'in_timeslot'};
%				if ($assign_to_rd == 1) { $in_other_event = 0; }
%				$in_other_event = 0 unless $in_other_event;
				<% $in_other_event %></td>								
				<td id="<% $key %>DisplayAssigned">0</td>
				<td id="<% $key %>DisplayObligLeft">0</td>
				<td id="<% $key %>DisplayLost">0</td>		
				<td><% ${$judge_hash}{$key}{'lost_current'} %></td>				
			</tr>
%			}

		</table>

%		$end = time(); if ($debug_time) {
		Total time before STA Data Table: <% printf("%.2f\n", $end - $start) %>
%		}		

		<table <% $debug_display %> id="STAData">
			<caption>
				STA Data
			</caption>
			<tr>
				<td>Judge ID</td>			
				<td>Judge Name</td>
				<td>Panel ID</td>
				<td>Pref 1</td>
				<td>Pref 2</td>
				<td>MutualPref</td>				
				<td>Below Max</td>								
				<td>Panel Impact</td>
			</tr>
%		foreach my $judges (@judge_ref) {
%			my $key = $judges->id;
%			foreach my $panel (@panels) {
%				if ( $live_panels{$panel->id} == 1 ) {
					<tr id="STA<% $key %>-<% $panel->id %>">
						<td><% $key %></td>
						<td><% $judge{$judges->id}{'name'} %> </td>
						<td><% $panel->id %></td>
%						my $pref1 = $all_pref{$pan_entry{$panel->id}{1}."-".$key}; 
%						my $pref2 = $all_pref{$pan_entry{$panel->id}{2}."-".$key}; 
%						#if ( $pref1 == 0 && $pref2 == 0 && $default_mjp == -1 ) { $pref1 = 1; $pref2=1; }
%						#if ( $pref1 == 0 && $default_mjp == -1 ) { $pref1 = $pref2; }
%						#if ( $pref1 == 0 && $default_mjp > 0 ) { $pref1 = $default_mjp; }
%						#if ( $pref2 == 0 && $default_mjp == -1 ) { $pref2 = $pref1; }
%						#if ( $pref1 == 0 && $default_mjp > 0 ) { $pref2 = $default_mjp; }
%						if ( $pref1 == 0 ) { $pref1 = 9999; }
%						if ( $pref2 == 0 ) { $pref2 = 9999; }
						<td><% $pref1 %></td>				
						<td><% $pref2 %></td>								
						<td>Magic Number</td>
%						my $dummy = $pref1;
%						if ( $pref2 > $pref1 ) { $dummy = $pref2; }
						<td><% $dummy %></td>				
%						my $mut = $pref1 - $pref2;
%						$mut = sprintf("%.1f", $mut);
						<td><% $mut %></td>
					</tr>
%				}
%			}
%		}

		</table>
		
%		$end = time(); if ($debug_time) {
		Total time after tables rendered: <% printf("%.2f\n", $end - $start) %>
%		}		

	</div>
