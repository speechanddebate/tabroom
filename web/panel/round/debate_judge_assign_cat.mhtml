<%args>
	$person
	$round_id
	$certain        => undef
	$max_pref_above => undef
	$max_mut_above  => undef
	$max_pref_at    => undef
	$max_mut_at     => undef
	$max_pref_below => undef
	$max_mut_below  => undef
	$break_line     => undef
	$max_avg_pref   => undef
	$panel_mut_pct  => undef
</%args>
<%init>

	# DOESN'T SUPPORT REGION STRIKES, or can't judge in elims if you voted
	# against before

	use Data::Dumper;
	use Time::HiRes qw( time );

	my $page_start = time();

	my $debug_time = 0; #set to 1 to print load times
	my $debug_display = "style='display:none;'";
	$debug_display = "" unless $Tab::hostname eq "www.tabroom.com";  #Don't display debugging on production server

	my $round = Tab::Round->retrieve($round_id);

	my $round_start = $round->timeslot->start;
	my $round_end = $round->timeslot->end;

	my $is_elim++ if $round->type eq "elim" || $round->type eq "final" || $round->type eq "runoff";

	my $n_judges = $round->setting("num_judges");
	my $event = $round->event;
	my $event_id = $event->id;

	my %event_settings = $event->all_settings();

	my $aff_string = $event_settings{"aff_label"};
	my $neg_string = $event_settings{"neg_label"};
	$aff_string = "Aff" unless $aff_string;
	$neg_string = "Neg" unless $neg_string;

	my $default_mjp = $event->category->setting("default_mjp");

	#DEFAULTS

	$max_pref_above = $event_settings{"max_pref"} unless $max_pref_above;

	$max_pref_above = 50 unless $max_pref_above;
	$max_mut_above = 30 unless $max_mut_above;
	$panel_mut_pct = 1 unless $panel_mut_pct;

	$max_pref_at = $event_settings{"max_pref"} unless $max_pref_at;

	$max_pref_at=50 unless $max_pref_at;
	$max_mut_at=30 unless $max_mut_at;

	$max_pref_below = $event_settings{"max_nobreak_pref"} unless $max_pref_below;

	$max_pref_below=70 unless $max_pref_below;
	$max_mut_below=50 unless $max_mut_below;

	if ( $event_settings{"break_point"} ) {
		$break_line = $event_settings{"break_point"}-1 unless $break_line;
	}

	# print "the fucking break line is $break_line and event setting is
	# ".$event_settings{"break_point");

	$break_line = 3 unless $break_line;

	#print "NOW the fucking break line is $break_line<br>";

	$max_avg_pref=50 unless $max_avg_pref;

	#ASSIGN WEIGHTS TO HASH
	my %max_pref; my %max_mut;
	$max_pref{'above'} = $max_pref_above;
	$max_mut{'above'} = $max_mut_above;
	$max_pref{'at'} = $max_pref_at;
	$max_mut{'at'} = $max_mut_at;
	$max_pref{'below'} = $max_pref_below;
	$max_mut{'below'} = $max_mut_below;

	#LOAD, PAIRINGS, JUDGE, PREF, AND ENTRY INFO
	my @panels = Tab::Panel->search( round => $round_id );
	my %pan_entry;
	foreach my $panel (@panels) {
		my @entries = $m->comp("/funclib/panel_entries.mas", panel => $panel);
		my $ctr=0;
		foreach my $entry (@entries) {
			$ctr++;
			$pan_entry{$panel->id}{$ctr} = $entry->id;
		}
	}

	my $last_round_name = $round->name - 1;
	my $last_round = Tab::Round->search( event => $event->id, name => $last_round_name)->first;
	my %entry_wins = $m->comp("/funclib/entry_wins.mas", event => $event, round => $last_round);
	my %entry_losses = $m->comp("/funclib/entry_losses.mas", event => $event, round => $last_round);
	my @judge_ref = Tab::Judge->search( category => $event->category, active => 1);
	my %judge;
	my $rds_left;

	foreach my $judges (@judge_ref) {
		$judge{$judges->id}{'name'} = $judges->last.", ".$judges->first;
		$judge{$judges->id}{'diverse'} = $judges->setting("diverse");
		$judge{$judges->id}{'avg_pref'} = $m->comp("/funclib/judge_avg_rating.mas", judge => $judges, avg_field => "percentile" );
	}

	my %entry_code = map {$_->id => $_->code} $event->entries(active => 1);

	my %pref_record = $m->comp("/funclib/round_ordinals.mas", round => $round);

	my %all_pref = $m->comp("/funclib/event_judgeprefs.mas", event => $event, round => $round);

	#DIAGNOSTICS

	# Ok, so the first of these uses the deprecated function but is the only
	# one that shows lost judges in current round The second call is to the one
	# that show.mhtml calls, which is accurate for the entire judge category

	my (
		$dummy1, $dummy2, $dummy3, $dummy4, $dummy5, $dummy6, $dummy7, $dummy8, $dummy9, $dummy10, $dummy11, $dummy12,
		$burned_current,
		$dummy13,
		$lost_rounds_current, $lost_rounds_total, $event_rds_left, $live_bodies_left, $burned_top50
	) = $m->comp("/funclib/judge_oblig_count.mas",
		event_id => $event_id,
		current_rd_id => $round_id
	);

	my (
		$assigned_judges_past, $paired_panels_current, $assigned_judges_current,
		$needed_panels_current, $needed_judges_current, $paired_panels_future,
		$assigned_judges_future, $needed_panels_future, $needed_judges_future,
		$category_rds_left, $assigned_to_last, $unassigned_burned_already,
		$unassigned_one_plus_left, $unassigned_one_left, $total_in_category
	) = $m->comp("/funclib/judge_oblig_count_by_category.mas",
		current_rd_id => $round->id
	);

	my ($avg_pref, $avg_mut, $worst_pref, $worst_mut, $deciles)
		= $m->comp("/funclib/mjp_diagnostics.mas", round => $round );

	my %deciles = %{$deciles};

	my @avg_pref = @{$avg_pref};
	my @worst_pref = @{$worst_pref};
	my @avg_mut = @{$avg_mut};
	my @worst_mut = @{$worst_mut};

	#remaining pref calculation
	my $tot_pref; my $tot_rds;

	my $judge_hash = $m->comp("/funclib/judge_use.mas", round_id => $round->id);

	foreach my $judge (@judge_ref) {
		my $dummy = ${$judge_hash}{$judge->id}{'left'};
		${$judge_hash}{$judge->id}{'future_possible'} = 0 if $judge->active == 0;
		${$judge_hash}{$judge->id}{'future_possible'} = ${$judge_hash}{$judge->id}{'future_possible'} - ${$judge_hash}{$judge->id}{'will_judge'};
		$dummy = ${$judge_hash}{$judge->id}{'future_possible'} if ${$judge_hash}{$judge->id}{'future_possible'} < ${$judge_hash}{$judge->id}{'left'};
		#print $judge{$judge->id}{'name'}." can still hear $dummy rounds<br>";
		$tot_rds += $dummy;
		$tot_pref += ( $dummy * $judge{$judge->id}{'avg_pref'} ) ;
		#judge_use.mas includes judging in this event, which you don't want, so this clears it and it gets
		#set correctly below
		${$judge_hash}{$judge}{'in_timeslot'} = 0;
	}
	$tot_rds = 1 if $tot_rds == 0;
	#print "tot rounds are $tot_rds and tot pref is $tot_pref<br>";

	my @jpools = $round->jpools;

	if (@jpools) {

		foreach my $judge (@judge_ref) {
			${$judge_hash}{$judge}{'avail_current'} = 0;
		}

		foreach my $jpool (@jpools) {
			foreach my $judge ($jpool->judges) {
				${$judge_hash}{$judge}{'avail_current'} = 1;
			}
		}

	}

	my @cohort;
	$cohort[1]="Above";
	$cohort[2]="At";
	$cohort[3]="Below";

	#JUDGE CONFLICTS

	#not testing for this yet
	my $allow_judge_own = $event_settings{"allow_judge_own"};
	my $region_constrain = $event_settings{"region_constrain"};

	# - conflicts pass #1; check for school conflicts
	my @entry_recs = $m->comp("/funclib/round_entries.mas", round => $round);
	foreach my $judges (@judge_ref) {
		foreach my $entry_rec (@entry_recs) {
			if ($judges->school == $entry_rec->school && not defined $allow_judge_own) {
				$all_pref{$entry_rec."-".$judges} = 9999;
			}
		}
	}

	# - conflicts pass #1.5; check for hires
	if ( $event->category->setting("auto_conflict_hires")) {
		my @judge_hires = Tab::JudgeHire->search( tourn => $event->tourn );
		foreach my $judge_hire (@judge_hires) {
			foreach my $entry_rec (@entry_recs) {
				if ($judge_hire->school == $entry_rec->school && not defined $allow_judge_own) {
					$all_pref{$entry_rec."-".$judge_hire->judge} = 9999;
				}
			}
		}
	}

	# - conflicts pass #2; judged before or will in the future
	my $allow_repeat_elims       = $event_settings{"allow_repeat_elims"};
	my $allow_repeat_judging     = $event_settings{"allow_repeat_judging"};
	my $allow_repeat_prelim_side = $event_settings{"allow_repeat_prelim_side"};

	Tab::Ballot->set_sql(pull_ballots => "
		select ballot.entry, ballot.judge
		from ballot, panel, round
		where panel.id=ballot.panel
		and round.id=panel.round
		and round.name != ".$round->name."
		and round.event = ".$event_id."
		and ballot.bye = 0
		and ballot.forfeit = 0
	");

	my @event_ballots = Tab::Ballot->search_pull_ballots;

	my $ok_to_strike=1;

	if ($allow_repeat_judging == 1) {
		$ok_to_strike = 0;
	}

 	if ( $is_elim && $allow_repeat_elims == 1 ) {
		$ok_to_strike = 0;
	}

	if ($ok_to_strike == 1) {
		foreach my $event_ballot (@event_ballots) {
			$all_pref{$event_ballot->entry."-".$event_ballot->judge} = 9999;
		}
	}


	# - conflicts pass #3; entered conflicts
	my $dbh = Tab::DBI->db_Main();
	my $strikes_sth = $dbh->prepare("
		select distinct strike.id, strike.judge, strike.type, strike.event, strike.entry,
		strike.school, strike.region, strike.start, strike.end
		from strike
		where strike.tourn = ?
	");

	# - conflicts pass #3.5; conflicts teams entered themselves

	foreach my $entry_rec (@entry_recs) {
		foreach my $conflicted_judge ($m->comp("/funclib/judge_entry_rating.mas", entry => $entry_rec, type => "conflicted")) {
			$all_pref{$entry_rec."-".$conflicted_judge} = 9999 ;
		}
	}

	$strikes_sth->execute($event->tourn->id);
	my %struck_in_other_events;

	while (my ($id, $judge, $type, $event, $entry, $school, $region, $start, $end) = $strikes_sth->fetchrow_array() ) {

		foreach my $entry_rec (@entry_recs) {

			if ($type eq "conflict" || $type eq "entry") {
				if ($school) {
					if ( $entry_rec->school == $school ) { $all_pref{$entry_rec."-".$judge} = 9999 };
				} else {
					$all_pref{$entry."-".$judge} = 9999 ;
				}
			}

			if ($type eq "hybrid") {
				if ( $entry_rec->school == $school ) { $all_pref{$entry_rec."-".$judge} = 9999 };
			}

			if ($type eq "region") {
				if ( $entry_rec->school->region == $region ) { $all_pref{$entry_rec."-".$judge} = 9999 };
			}

			if ($type eq "school") {
				if ( $entry_rec->school == $school ) { $all_pref{$entry_rec."-".$judge} = 9999 };
			}

		}

     	if ($type eq "event" && $event != $event_id) {
			# print $judge." is struck from ".$event."<br>" if $debug_display;
	    	$struck_in_other_events{$judge} = 1;
		}

		if ($type eq "time" && $start ne "0000-00-00 00:00:00" ) {

			my $start_dt = eval {
				return DateTime::Format::MySQL->parse_datetime($start);
			};

			my $end_dt = eval {
				DateTime::Format::MySQL->parse_datetime($end);
			};

			if ( $start_dt && $end_dt ) {

				if ( ($start_dt->epoch < $round_end->epoch) && ($end_dt->epoch > $round_start->epoch) ) {
					$all_pref{$entry."-".$judge} = 9999;
					${$judge_hash}{$judge}{'avail_current'} = 0;
				}
			}
		}
	}

	#assigned elsewhere
	my $other_events_sth = $dbh->prepare("
		select distinct ballot.judge
		from ballot, panel, round
		where ballot.panel=panel.id
		and panel.round=round.id
		and round.event != ".$event."
		and round.timeslot = ".$round->timeslot."
	");
	$other_events_sth->execute();
	while (my ($judge) = $other_events_sth->fetchrow_array() ) {
		${$judge_hash}{$judge}{'in_timeslot'} = 1;
	}

	sub prefdata {

		my ($pref_str) = @_;
		my $pref;
		my $slash_spot = index($pref_str, ">");
		my $slash_end = index($pref_str, "<", $slash_spot);
		#print $slash_spot." ".$slash_end." ".substr($pref_str, $slash_spot+1, $slash_end-$slash_spot-1)."<br>";
		my $pref_one= substr($pref_str, $slash_spot+1, $slash_end-$slash_spot-1);
		$slash_spot = index($pref_str, ">", $slash_end);
		$slash_end = index($pref_str, "<", $slash_spot+10);
		#my $pref_two = substr($pref_str, $slash_spot+1, length($pref_str)-$slash_spot);
		my $pref_two = substr($pref_str, $slash_end-2, 2);
		$pref_two =~ tr/>//d;
		#print $slash_spot." ".$slash_end." ".$pref_two." is pref_two with a length of ".length($pref_two)."<br>";
		return ($pref_one, $pref_two, $pref_one - $pref_two);

	}

# Tell the user to run away if there are existing results for the round

	my $results_sth = $dbh->prepare("
		select score.id, score.tag, score.value
		from score, ballot, panel
		where score.value > 0
		and score.ballot = ballot.id
		and panel.id = ballot.panel
		and panel.round = ?
	");

	$results_sth->execute($round->id);

	my $results_ref = $results_sth->fetchall_arrayref;
	#print "Number of rows returned is ", 0 + @{$results_ref}, "\n";

	#$strikes_sth->fetchrow_array()

 	#my @scores = $m->comp("/funclib/round_scores.mas", round => $round);

#figure out how many prelims left so you can put it on the page and read it for diagnostics

	my $prelims_left;
	my @rounds = $event->rounds;
	foreach my $rd (@rounds) {
		next if $rd->type eq "elim";
		next if $rd->type eq "final";
		next if $rd->type eq "runoff";
		if ( $rd->name > $round->name ) {
			$prelims_left++;
		}
	}

</%init>

%       if ( @{$results_ref} > 0 and $certain ne "Please delete results" and $Tab::hostname eq "www.tabroom.com" ) {

                <div class="blankfull centeralign">

					<h1 class="alert">
						DISASTER STALKS YOU.  RUN AWAY.  NOW.
					</h1>

						<p>
							There are not only ballots assigned to this round
							already, but there are already
						</p>

						<h4>RESULTS ENTERED</h4>

						<p>
							You must surely be looking at the
						</p>

						<h4>WRONG ROUND</h4>

						<h4>This is <% $round->realname %> you're messing with </h4>

						<p>
							 If you proceed, as soon as you click the save
							 judges button, all the current results in this
							 round will be erased.
						</p>

						<p>

							STOP NOW and return to the pairings screen.  Or
							your round, your results, and quite possibly your
							life will all be royally horked.

						</p>

						<p class="explain martop smaller">

							 Type "Please delete results" in the box below if
							 you are sure you want to do this.  Which you
							 aren't.  Admit it.

						</p>

						<br />
						<br />

						<form
							action="debate_judge_assign_cat.mhtml"
							method="post"
							class="warning"
						>

							<input
								type="hidden"
								value="<% $round_id %>"
								name="round_id"
							>

							<input
								type="text"
								name="certain"
								size="20"
								autocomplete="off"
								autocorrect="off"
								autocapitalize="off"
								spellcheck="false"
								class="martop notfirst"
							>
							<br>
							<input
								type="submit"
								class="martopmore padmore wrap"
								value="I gleefully want to delete my data and will not come crying to you to get it back"
							>

						</form>
               </div>

%       } else {



	<div class="blankfull">

%		my $page_end = time();

%		if ($debug_time) {
			Total load time: <% printf("%.2f\n", $page_end - $page_start) %>
%		}

	<script>

	display_toggle = function(table_id) {
        var MasterTable = document.getElementById(table_id);
        if ( MasterTable.style.display == "none" ) {
            MasterTable.style.display = "table" ;
        } else {
            MasterTable.style.display = "none" ;
        }
    }

		show_help = function() {
			var str = "This page is for tournaments using ordinal prefs, and incorporates modifictaions of the STA and CAT judge placement system.\n\n";
			str = str + "See that first button there?  It says 'Pref weight.' \n";
			str = str + "Give it a value between 0 and 1 in increments of .01. \n";
			str = str + "Bigger numbers mean emphasize pref -- shove in the best judges -- \n";
			str = str + "and don't save judges for later.  Lower numbers mean the opposite. \n\n";
			str = str + "The number right below it says 'future pref' and it sets how much \n";
			str = str + "to focus on losing rounds versus losing overall average pref. \n";
			str = str + "It's also a number between 0 and 1. \n\n";
			str = str + "So question #1 is how much to focus on pref vs. saving judges, \n";
			str = str + "and question #2 is, when saving judges, to focus on rounds or avg pref. \n\n";
			str = str + "That Panel mut % is the panel mutality as a percentage of individual mutuality. \n";
			str = str + "So if the individual mutuality is 30 and you don't want a panel bigger than \n";
			str = str + "60, enter a 2.  If you don't want them bigger than 45, enter 1.5.\n";
			str = str + "For 1-judge panels (like prelims at most tournaments) it should always be 1. \n";
			str = str + "The rest works like the STA and the values should be intuitive. \n\n ";
			str = str + "This system incorporates some elements of the logic in Gary Larson's code for the STA software but it is \n";
			str = str + "coded for use here by Jon Bruschke.  Gary gets credit for the core algorithm; the tweaks and errors are mine.\n\n";
			window.alert(str);
		}

		describe_judgemax = function() {
			var str = "These functions will help you get difficult-to-place judges into rounds; you might use them ";
		      	str = str + " in lower divisions where you want to avoid losing rounds of commitment and pref targets might ";
		      	str = str + "be relaxed.\n\n";
		    	str = str + "Clicking the 'Use committed' button will use only judges who have a full commitment or who must ";
		      	str = str + "judge the current round (that is, they must hear the debate or they will lose a ";
		      	str = str + "round of commitment).\n\n";
		      	str = str + "Clicking on the 'Fill with LPJ' button will fill the remaining spots with judges who have low ";
		      	str = str + "average preference rankings; filling in the box will define what counts as a low-rated judge.  ";
		      	str = str + "For example, entering a 50 in the box will treat all judgse with an average pref rating of ";
		      	str = str + "50 or worse (higher) as low-preffed judges to try to place.\n\n";
		    	str = str + "Clicking on the 'Struck in other events' button will place judges who are struck from other events; ";
		    	str = str + "this usually happens when a judge is precluded from open division, for example.\n\n";
		    	str = str + "In any case, the placements will still follow the weights and constraints settings on the ";
		      	str = str + "top portion of the page, so you may wish to set those first.\n\n";
		    	str = str + "If the 'Erase Existing Placements' box is checked all placements will be deleted when you click ";
		    	str = str + "click any button, so you probalby only want it checked the first time you click a button.\n\n" ;
		    	str = str + "Make sure you click save when you are done.\n\n";
		    	str = str + "When you are finished, you should return to the pairings and use the manual judge placement ";
		      	str = str + "options to complete the judge placements for the event.\n\n";
		      	window.alert(str);
		}

		describe_tightness = function() {
			var str = "These functions will help you when your judge situation is tight, which will happen if you have ";
		      	str = str + "a large entry from a single school -- if you have 10 debates but 8 entries from one school ";
		      	str = str + "judges from that school will fit in only 2 debates.\n\n";
		    	str = str + "There are other variations on this circumstance, and this judge placement option is designed for ";
		    	str = str + "all situations where there are debates that only a few judges fit in or when judges have ";
		    	str = str + "a large number of constraints.\n\n";
		    	str = str + "Clicking the 'Reality Check' button will show you which debates are hardest to place judges in ";
		      	str = str + "and that number may be zero; if a number of rounds are very tight then you might try ";
		      	str = str + "to relax your pref targets (lowering defaults from 60 to 50, for instance).\n\n";
		      	str = str + "Clicking on the 'Just Get a Judge In Every Debate' button will place judges with an eye ";
		      	str = str + "to making sure you get as many debates with judges who fit the pref criteria as possible  ";
		      	str = str + "and then putting judges in the remainder of the rounds as best as possible.\n\n";
		    	str = str + "Usually this will result in lower prefs overall but more debates with judges who fit the ";
		    	str = str + "placement criteria.\n\n";
		    	str = str + "To use this function you might first run the Reality Check and then try a normal placement ";
		    	str = str + "with lower pref criteria.  If even that doesn't work, the 'Judge Get a Judge In Every Debate' ";
		    	str = str + "button is your last chance to do judges with auto-placement.  Remmeber that you can always ";
		    	str = str + "accept a partial judge placement from this page, save the results, and make manual changes ";
		    	str = str + "from the pairings pages.";

				window.alert(str);

		}

		$(window).load(function () {

			var panels_over = panels_over_target("At");
			var dummy = document.getElementById("SavedPanelsOverAt");
			dummy.textContent = panels_over;

			var panels_over = panels_over_target("Above");
			var dummy = document.getElementById("SavedPanelsOverAbove");
			dummy.textContent = panels_over;

			var panels_over = panels_over_target("Below");
			var dummy = document.getElementById("SavedPanelsOverBelow");
			dummy.textContent = panels_over;

			do_stddev("Saved");
		});

		MoveDiagnostic = function(dummy_str) {
			var dummy = document.getElementById("Saved"+dummy_str);
			var dummy2 = document.getElementById(dummy_str);
			var current_score = dummy.textContent;
			var new_score = dummy2.textContent
			dummy.textContent = new_score;
			dummy2.textContent = "";
		}

		DoTheFuckingSave = function(panel_id, judge_id) {
			$.post("/funclib/panel_judgeadd.mas",
				{ panel_id: panel_id, judge_id: judge_id },
				function(result){ var dummy=result; }
			);

			//$.post("/funclib/panel_judgeadd.mas",{ panel_id: panel_id, judge_id: judge_id } );
		}

		PerformSaveLoop = function() {
			var n_judges = parseFloat(document.getElementById("n_judges").value);

			var MasterTable = document.getElementById("current_pairing");
			var TableRows = MasterTable.getElementsByTagName("tr");
			for (var j = 1; j <= n_judges; j++) {
				for (var x = 1; x < TableRows.length ; x++) {
					var panel_id = TableRows[x].cells[0].textContent;
    				var deferred = $.Deferred();

						var dummy = document.getElementById(panel_id+"Judge"+j+"ID");
						var judge_id = dummy.textContent;
						//$.post("/funclib/panel_judgeadd.mas",{ panel_id: panel_id, judge_id: judge_id });
						//setTimeout(function(){ ; }, 9000);
						//$.post("/funclib/round_clear_judges.mas",{ round_id: round_id, nobye: 1 },function(result){ PerformSaveLoop() });
						//$.post("/funclib/panel_judgeadd.mas",{ panel_id: panel_id, judge_id: judge_id } );

						DoTheFuckingSave(panel_id, judge_id);

				}
			}

			//update the diagnostics
			MoveDiagnostic("AvgAbove");
			MoveDiagnostic("WorstAbove");
			MoveDiagnostic("AvgMutAbove");
			MoveDiagnostic("WorstMutAbove");
			MoveDiagnostic("PanelsOverAbove");
			MoveDiagnostic("Plus1SDAbove");
			MoveDiagnostic("Plus2SDAbove");
			MoveDiagnostic("AvgAt");
			MoveDiagnostic("WorstAt");
			MoveDiagnostic("AvgMutAt");
			MoveDiagnostic("WorstMutAt");
			MoveDiagnostic("PanelsOverAt");
			MoveDiagnostic("Plus1SDAt");
			MoveDiagnostic("Plus2SDAt");
			MoveDiagnostic("AvgBelow");
			MoveDiagnostic("WorstBelow");
			MoveDiagnostic("AvgMutBelow");
			MoveDiagnostic("WorstMutBelow");
			MoveDiagnostic("PanelsOverBelow");
			MoveDiagnostic("Plus1SDBelow");
			MoveDiagnostic("Plus2SDBelow");

			MoveDiagnostic("RdsLost");
			MoveDiagnostic("PrefLeft");
			MoveDiagnostic("BurnedCurrent");
			MoveDiagnostic("BurnedTop50");
			MoveDiagnostic("BodiesLeft");

			//update the judge use table to reflect what just got saved
			var MasterTable = document.getElementById("judge_use");
			var TableRows = MasterTable.getElementsByTagName("tr");
			for (var i = 1; i < TableRows.length; i++) {
				var tr = TableRows[i];
				var judge_id = parseFloat(tr.cells[0].textContent);
				var col_5 = parseFloat(TableRows[i].cells[5].textContent);
				var col_6 = parseFloat(TableRows[i].cells[6].textContent);
				var col_8 = parseFloat(tr.cells[8].textContent);
				var col_10 = parseFloat(tr.cells[10].textContent);
				tr.cells[5].textContent = col_5 - col_8 + col_10 ;
				tr.cells[6].textContent = col_6 + col_8 - col_10;
				tr.cells[8].textContent = col_10;
			}

			window.alert("Save Completed");

		}

		SavePairing = function(round_id) {

			//check for existing saved placements and confirm
		    var any_placements_saved = false;
			var MasterTable = document.getElementById("judge_use");
            var TableRows = MasterTable.getElementsByTagName("tr");
            for (var i = 1; i < TableRows.length; i++) {
				if ( parseFloat(TableRows[i].cells[8].textContent) == 1 ) { any_placements_saved = true; }
            }
			if ( any_placements_saved == true ) {
				var conf = confirm("Click OK to confirm over-write of existing placements:");
                if ( conf == false ) { return; }
			}

			//delete existing placements and save
			var just_test = document.getElementById("just_test").checked;
			if ( just_test == true ) {
				PerformSaveLoop();
			} else {
				$.post("/funclib/round_clear_judges.mas",{ round_id: round_id, nobye: 1 },function(result){ PerformSaveLoop() });
			}

			//update buttons
			var dummy = document.getElementById("save_button");
			dummy.value = "Placements Saved"
			dummy.style.backgroundColor = "Green" ;

			var time_display = document.getElementById("status_box");
			time_display.textContent = "Wait for dialogue to alert you that the save is complete.";

			//reload
			//window.alert("Judge placements saved -- hit enter to reload page");
			//window.location.reload();
		}

		DeletePairing = function(round_id) {
			$.post("/funclib/round_clear_judges.mas",{ round_id: round_id, nobye: 1 });
			window.alert("All judge placements have been deleted; hit OK to reload page");
			window.location.reload();
		}

		//clears the pairings table of all judge assignments
		clear_current_placements = function() {

			var n_cols = document.getElementById('current_pairing').rows[0].cells.length;
			var MasterTable = document.getElementById("current_pairing");
			var TableRows = MasterTable.getElementsByTagName("tr");
			for (var i = 1; i < TableRows.length; i++) {
				for (var c = 5; c <= n_cols-2; c++) {
					if ( TableRows[i].cells[c] == undefined ) {} else {
					TableRows[i].cells[c].textContent = 0; }
				}
			}

			//clear also from the judge_use table; will need to update later
			var MasterTable = document.getElementById("judge_use");
			var TableRows = MasterTable.getElementsByTagName("tr");
			for (var i = 1; i < TableRows.length; i++) {
					TableRows[i].cells[10].textContent = "0";
			}

		}

		commitment_left = function(judge_id) {

			//accounts for current placement, even if not saved

			var dummy = document.getElementById("Judge"+judge_id);
			var is_elim = parseFloat(document.getElementById("is_elim").value);
			if ( is_elim == 1 ) { return 1; }
			var rds_left = 0;
			rds_left = parseFloat(dummy.cells[6].textContent);
			rds_left = rds_left + parseFloat(dummy.cells[8].textContent); //add if in the saved pairing
			rds_left = rds_left - parseFloat(dummy.cells[10].textContent); //subtract if on displayed pairings
			return parseFloat(rds_left);
		}

		pairing_panel_update = function(panel_id) {

			var n_judges = parseFloat(document.getElementById("n_judges").value);
			var panel_row = document.getElementById("panel_pairing"+panel_id);
			var tot_pref = 0; var tot_judges = 0; var panel_balance = 0; var pref1; var pref2;
			for (var i = 1; i <= n_judges; i++) {
				var dummy = document.getElementById(panel_id+"Judge"+i+"Pref1");
				pref1 = parseFloat(dummy.textContent);
				tot_pref = tot_pref + pref1;
				tot_judges = tot_judges + 1;
				panel_balance = panel_balance + pref1;
				var dummy = document.getElementById(panel_id+"Judge"+i+"Pref2");
				pref2= parseFloat(dummy.textContent);
				tot_pref = tot_pref + pref2;
				tot_judges = tot_judges + 1;
				panel_balance = panel_balance - pref2;
			}
			dummy = document.getElementById(panel_id+"Avg");
			dummy.textContent = (tot_pref/tot_judges).toFixed(1)
			dummy = document.getElementById(panel_id+"Bal");
			dummy.textContent = (panel_balance).toFixed(1)

		}

		IsObligated = function(judge_id) {
			var judge_row = document.getElementById("Judge"+judge_id);
			var fut_poss = parseFloat(judge_row.cells[7].textContent) + parseFloat(judge_row.cells[4].textContent);
			var ob_left = parseFloat(judge_row.cells[6].textContent) + parseFloat(judge_row.cells[8].textContent);
			if ( ob_left >= fut_poss ) { return true; }
			return false;
		}

		add_judge_to_panel = function (judge_id, panel_id, judge_number) {

			if ( judge_id == 0 ) { return; }
			//note that this just over-writes the existing placement
			var judge_row = document.getElementById("STA"+judge_id+"-"+panel_id);
			var dummy = document.getElementById(panel_id+"Judge"+judge_number+"ID");
			dummy.textContent = judge_row.cells[0].textContent;
			var judge_name = document.getElementById(panel_id+"Judge"+judge_number+"Name");

			var pref1 = document.getElementById(panel_id+"Judge"+judge_number+"Pref1");
			pref1.textContent = judge_row.cells[3].textContent;

			var pref2 = document.getElementById(panel_id+"Judge"+judge_number+"Pref2");
			pref2.textContent = judge_row.cells[4].textContent;

			judge_name.textContent = judge_row.cells[1].textContent + " " + pref1.textContent+"-"+pref2.textContent;

			var dummy = document.getElementById(panel_id+"Judge"+judge_number+"Mut");
			dummy.textContent = Math.abs(parseFloat(judge_row.cells[3].textContent) - parseFloat(judge_row.cells[4].textContent) ).toFixed(1);
			//update panel to show balance and avg
			pairing_panel_update(panel_id);
			//mark as being used in current pairing, not the saved one
			var dummy = document.getElementById("Judge"+judge_id);
			dummy.cells[10].textContent = 1;

		}

		get_higher_pref = function (judge, panel) {

			if ( judge == 0 ) { return 9999; }
			//returns the higher pref score for the judge
			var judge_STA = document.getElementById("STA"+judge+"-"+panel);
			var pref1 = parseFloat(judge_STA.cells[3].textContent);
			var pref2 = parseFloat(judge_STA.cells[4].textContent);
			if (pref1 > pref2) { return pref1; } else { return pref2; }

		}

		over_max = function(judge_id, panel_id, existing) {
		//if existing==true, you are testing to see if an existing panel is over
		//if existing==false, you are testing to see if a judge would push the panel over if added

			if ( parseFloat(judge_id) == 0 ) { return true; }

			var dummy=false;
			var cohort_str = document.getElementById(panel_id+"Cohort").textContent;
			if ( cohort_str != null ) {
				var dummy2 = "max_mut_"+cohort_str.toLowerCase();
				var max_mut = document.getElementById( "max_mut_"+cohort_str.toLowerCase() );
				var max_pref = document.getElementById( "max_pref_"+cohort_str.toLowerCase() );
				var judge_STA = document.getElementById("STA"+judge_id+"-"+panel_id);
				if (judge_STA == null ) {
					return true;
				}
				var pref1 = parseFloat(judge_STA.cells[3].textContent);
				var pref2 = parseFloat(judge_STA.cells[4].textContent);
				if ( pref1 > max_pref.value ) { dummy = true; }
				if ( pref2 > max_pref.value ) { dummy = true; }
				if ( Math.abs(pref1 - pref2) > max_mut.value ) { dummy = true; }
				if ( isNaN(pref1) || isNaN(pref2) ) { dummy = true; }
			}

			//figure panel mutuality
			var panel_bal = parseFloat(document.getElementById(panel_id+"Bal").textContent);
			if ( existing==false ) { panel_bal += (pref1-pref2); }
			var hi_mut = max_mut.value * parseFloat(document.getElementById("panel_mut_pct").value);
			if ( Math.abs(panel_bal) > hi_mut ) { dummy = true; };

			return dummy;
		}

		double_swap = function(just_fix) {

			// just-fix is boolean, and if true, it will fix an over-max panels
			// even if it hurts the overall pairing

			var start = new Date();
			var n_judges = parseFloat(document.getElementById("n_judges").value);
			var made_change = false;

			var MasterTable = document.getElementById("current_pairing");
			var TableRows = MasterTable.getElementsByTagName("tr");
			for (var x = 1; x < TableRows.length - 1; x++) {
				for (var y = (x + 1); y < TableRows.length; y++) {
					for (var j = 1; j <= n_judges; j++) {
						for (var j2 = 1; j2 <= n_judges; j2++) {

							var panel_x = TableRows[x].cells[0].textContent;
							var panel_y = TableRows[y].cells[0].textContent;
							var judge_x_id = document.getElementById(panel_x+"Judge"+j+"ID").textContent;
							var judge_y_id = document.getElementById(panel_y+"Judge"+j2+"ID").textContent;
							judge_x_id = parseFloat(judge_x_id);
							judge_y_id = parseFloat(judge_y_id);
							var dummy;
							if ( judge_x_id == 0 || judge_y_id == 0 ) { dummy = true; } else {
								dummy = over_max(judge_x_id, panel_y, false);
							}

							if (dummy == false) {
								var dummy = over_max(judge_y_id, panel_x, false);

								if ( dummy == false ) {

									var score_before = get_higher_pref(judge_x_id, panel_x);
									score_before = score_before + get_higher_pref(judge_y_id, panel_y);
									var score_after = get_higher_pref(judge_x_id, panel_y);
									score_after = score_after + get_higher_pref(judge_y_id, panel_x);
									var x_over_max = false;
									if (just_fix == true) { x_over_max = over_max(judge_x_id, panel_x, false); }

									if ( score_after < score_before || ( just_fix == true && x_over_max == true) ) {
										add_judge_to_panel(judge_y_id, panel_x, j);
										add_judge_to_panel(judge_x_id, panel_y, j2);
										made_change = true;
									}
								}
							}
						}
					}
				}
			}
			var end = new Date(); var duration_toclear = end - start;
			return made_change;
		}

		triple_swap = function (just_fix) {

			//just-fix is boolean, and if true, it will fix an over-max panels even if it hurts the overall pairing
			var made_change = false;
			var n_judges = parseFloat(document.getElementById("n_judges").value);
			var MasterTable = document.getElementById("current_pairing");
			var TableRows = MasterTable.getElementsByTagName("tr");
			for (var x = 1; x < TableRows.length - 2; x++) {
				for (var j = 1; j <= n_judges; j++) {
				var panel_x = TableRows[x].cells[0].textContent;
				var x_over = false;
				var judge_x_id = document.getElementById(panel_x+"Judge"+j+"ID").textContent;
				if (just_fix == true) { x_over = over_max(judge_x_id, panel_x, true); }
				if ( just_fix == true && x_over == false ) { break; }

					for (var y = (x + 1); y < TableRows.length - 1 ; y++) {
						for (var j2 = 1; j2 <= n_judges; j2++) {
						var panel_y = TableRows[y].cells[0].textContent;
						var judge_x_id = parseFloat(document.getElementById(panel_x+"Judge"+j+"ID").textContent);
						var judge_y_id = parseFloat(document.getElementById(panel_y+"Judge"+j2+"ID").textContent);
							if ( over_max(judge_y_id, panel_x, false) == false && judge_x_id > 0 && judge_y_id > 0 ) {
								var curr_x_score = get_higher_pref(judge_x_id, panel_x);
								var y_to_x_panel = get_higher_pref(judge_y_id, panel_x);
								if ( y_to_x_panel > curr_x_score ) { break; }

								for (var z = (x + 2); z < TableRows.length; z++) {
									var panel_z = TableRows[z].cells[0].textContent;
									for (var j3 = 1; j3 <= n_judges; j3++) {
									var judge_z_id = parseFloat(document.getElementById(panel_z+"Judge"+j3+"ID").textContent);
										if ( over_max(judge_z_id, panel_y, false) == false ) {
											if ( over_max(judge_x_id, panel_z, false) == false && judge_z_id > 0 ) {
												if ( just_fix == false ) {
													var curr_y_score = get_higher_pref(judge_y_id, panel_y);
													var curr_z_score = get_higher_pref(judge_z_id, panel_z);
													var z_to_y_panel = get_higher_pref(judge_z_id, panel_y);
													if ( z_to_y_panel > curr_y_score) { break; }
													var x_to_z_panel = get_higher_pref(judge_x_id, panel_z);
													if ( x_to_z_panel > curr_z_score) { break; }
												}
												//didn't exit, so the switch works.  Execute it.
												add_judge_to_panel(judge_y_id, panel_x, j);
												add_judge_to_panel(judge_z_id, panel_y, j2);
												add_judge_to_panel(judge_x_id, panel_z, j3);
												made_change = true;
											}
										}
									}
								}
							}
						}
					}
				}
			}

			return made_change;

		}

		can_place_now = function(judge_id, check_commitment) {
			var judge_row = document.getElementById("Judge"+judge_id);
			//see if already assigned
			if ( parseFloat(judge_row.cells[10].textContent) == 1 ) { return false; }
			//see if available for current round
			if ( parseFloat(judge_row.cells[4].textContent) == 0 ) { return false; }
			//see if assigned to another event in the same timeslot
			if ( parseFloat(judge_row.cells[9].textContent) > 0 ) { return false; }
			//check remaining commitment
			if (check_commitment == true) {
				var dummy = commitment_left(judge_id);
				if (dummy <= 0 ) { return false; }
			}
			return true;

		}

		fix_with_extra = function() {

			var n_judges = parseFloat(document.getElementById("n_judges").value);
			var n = 0; // n eligible

			//loop through all panels and see if the judge exceeds the targets
			var MasterTable = document.getElementById("current_pairing");
			var TableRows = MasterTable.getElementsByTagName("tr");
			for (var x = 1; x < TableRows.length; x++) {
				var panel_id = TableRows[x].cells[0].textContent;
				for (var j = 1; j <= n_judges; j++) {
					var judge_id = document.getElementById(panel_id+"Judge"+j+"ID").textContent;
					if ( over_max(judge_id, panel_id, true) == true ) {
						//if so, create a new array of judges and sort
						var eval = [];
						var JudgeTable = document.getElementById("judge_use");
						var JudgeRows = JudgeTable.getElementsByTagName("tr");
						for (var i = 1; i < JudgeRows.length; i++) {
							var judge_dummy = parseFloat(JudgeRows[i].cells[0].textContent);
							if ( can_place_now(parseFloat(JudgeRows[i].cells[0].textContent), true) == true ) {
								//give a score
								eval[n] = [];
								eval[n][0] = parseFloat(JudgeRows[i].cells[0].textContent); //judge id
								eval[n][1] = get_higher_pref(eval[n][0], panel_id);
								eval[n][1] = eval[n][1] - ( 2 * parseFloat(JudgeRows[i].cells[2].textContent) );
								if ( isNaN(eval[n][1]) ) { eval[n][1] = 9999; }
								if ( over_max(eval[n][0], panel_id, false) == true ) { eval[n][1] = 9999; }
								n = n + 1;
							}

						}
						eval.sort(function(a, b) { return (a[1] < b[1] ? -1 : (a[1] > b[1] ? 1 : 0)); });
						var judge_score = eval[0][1];
						if ( eval[0][0] != undefined ) {
							var dummy_1 = get_higher_pref(judge_id, panel_id);
							var dummy_2 = get_higher_pref(eval[0][0], panel_id);
							if ( dummy_2 < dummy_1 && over_max(eval[0][0], panel_id, false) == false ) {
								var judge_out = document.getElementById("Judge"+judge_id);
								var judge_out_name = judge_out.cells[0].textContent;
								judge_out.cells[10].textContent = 0 ;
								var new_judge = eval[0][0];
								add_judge_to_panel(eval[0][0], panel_id, j);
							}
						}
					}
				}
			}
		}

		panels_over_target = function (strCohort) {
			var n = 0;
			var n_judges = parseFloat(document.getElementById("n_judges").value);
			var MasterTable = document.getElementById("current_pairing");
			var TableRows = MasterTable.getElementsByTagName("tr");
			for (var x = 1; x < TableRows.length; x++) {
				var panel_id = TableRows[x].cells[0].textContent;
				for (var j = 1; j <= n_judges; j++) {
					var judge_id = document.getElementById(panel_id+"Judge"+j+"ID").textContent;
					var cohort = document.getElementById(panel_id+"Cohort").textContent;
					if ( over_max(judge_id, panel_id, true) == true && strCohort == cohort ) { n = n + 1; }
				}
			}
			return n;
		}

		fix_with_extra_and_doub = function () {

			var n_judges = parseFloat(document.getElementById("n_judges").value);
			var n=0; var n_fixed=0;

			//loop through all panels and see if the judge exceeds the targets
			var MasterTable = document.getElementById("current_pairing");
			var TableRows = MasterTable.getElementsByTagName("tr");
			for (var x = 1; x < TableRows.length; x++) {
				var best_judge_steal_score = 9999; var best_replacement_score = 9999;
				var panel_id = TableRows[x].cells[0].textContent;
				var judge_to_steal = 0; var replacement_judge_id = 0; var replacement_judge_n = 0;
			    var panel_to_steal_from=0;
				for (var j = 1; j <= n_judges; j++) {
					var judge_id = document.getElementById(panel_id+"Judge"+j+"ID").textContent;
					if ( judge_id > 0 && over_max(judge_id, panel_id, true) == true ) {
						n = n + 1;
						var MasterTable_2 = document.getElementById("current_pairing");
						var TableRows_2 = MasterTable_2.getElementsByTagName("tr");
						for (var x_2 = 1; x_2 < TableRows_2.length; x_2++) {
							var panel_id_2 = TableRows_2[x_2].cells[0].textContent;
							for (var j_2 = 1; j_2 <= n_judges; j_2++) {
								var judge_id_2 = document.getElementById(panel_id_2+"Judge"+j_2+"ID").textContent;
								if ( over_max(judge_id_2, panel_id, false) == false ) {
									var dummy = get_higher_pref(judge_id_2, panel_id);
									var JudgeTable = document.getElementById("judge_use");
									var JudgeRows = JudgeTable.getElementsByTagName("tr");
									for (var i = 1; i < JudgeRows.length; i++) {
										if ( can_place_now(JudgeRows[i].cells[0].textContent, true) == true ) {
											var dummy_2 = get_higher_pref(JudgeRows[i].cells[0].textContent, panel_id_2);
											dummy = parseFloat(dummy); dummy_2 = parseFloat(dummy_2);
											var new_over_max = over_max(JudgeRows[i].cells[0].textContent, panel_id_2, false);
											if ( (dummy + dummy_2) < (best_replacement_score + best_judge_steal_score) &&  new_over_max == false ) {
												best_replacement_score = dummy_2;
												best_judge_steal_score = dummy;
												judge_to_steal = judge_id_2;
											    panel_to_steal_from = panel_id_2;
												replacement_judge_id = JudgeRows[i].cells[0].textContent;
												replacement_judge_n = j_2;
											}
										}
									}
								}
							}
						}
					}
					//put change here
					if ( replacement_judge_id > 0 && judge_to_steal > 0 ) {
					    //move judge from panel 2 to panel 1
						add_judge_to_panel(judge_to_steal, panel_id, j);
					    //move currently unassigned judge to panel 2
						add_judge_to_panel(replacement_judge_id, panel_to_steal_from, replacement_judge_n);
					    //mark original judge as not in use
						var dummy = document.getElementById("Judge"+judge_id);
						dummy.cells[10].textContent=0;
						n_fixed = n_fixed + 1;
						replacement_judge_id=0;
					}

				}
			}
		}

		push_obligated_back_in = function() {

			var n_judges = parseFloat(document.getElementById("n_judges").value);

			var MasterTable = document.getElementById("judge_use");
			var TableRows = MasterTable.getElementsByTagName("tr");
			for (var x = 1; x < TableRows.length; x++) {
				var judge_to_add = TableRows[x].cells[0].textContent;
				var judging_now = parseFloat(TableRows[x].cells[10].textContent);
				if ( IsObligated(judge_to_add) == true && judging_now == 0 && can_place_now(judge_to_add) == true ) {
					var panel_to_add=0;
					var judge_to_remove=0;
					var judge_n_spot = 0;
					var test_score = 9999;
					var PairingTable = document.getElementById("current_pairing");
					var PairingRows = PairingTable.getElementsByTagName("tr");
					for (var i = 1; i < PairingRows.length; i++) {
						var panel_id = PairingRows[i].cells[0].textContent;
						for (var j = 1; j <= n_judges; j++) {
							var curr_judge_id = document.getElementById(panel_id+"Judge"+j+"ID").textContent;
							var check_switch = false;
							if ( curr_judge_id == 0 ) {
								check_switch = true;
							} else {
								if ( IsObligated(curr_judge_id) == false && over_max(judge_to_add, panel_id, false) == false ) { check_switch = true; }
							}
							if ( check_switch == true ) {
								var score = get_higher_pref(judge_to_add, panel_id);
								if (score < test_score ) {
									test_score = score;
									panel_to_add=panel_id;
									judge_n_spot=j;
									judge_to_remove = curr_judge_id;
								}
							}
						}
					}
					if ( panel_to_add > 0 ) {
						add_judge_to_panel(judge_to_add, panel_to_add, judge_n_spot);
						var dummy = document.getElementById("Judge"+judge_to_remove);
						if (dummy != null) { dummy.cells[10].textContent=0; }
					}
				}
			}

		}

		salvage_below = function() {

			//if there's a top-50 judge in an out-of-it debate, replace them with a bottom-50 judge if there is one
			//who fits.

			var n_judges = parseFloat(document.getElementById("n_judges").value);

			var MasterTable = document.getElementById("current_pairing");
			var TableRows = MasterTable.getElementsByTagName("tr");
			for (var x = 1; x < TableRows.length; x++) {
				var panel_id = TableRows[x].cells[0].textContent;
				var cohort = document.getElementById( panel_id+"Cohort" ).textContent;
				if ( cohort == "Below" ) {
					for (var j = 1; j <= n_judges; j++) {
						var judge_id = document.getElementById(panel_id+"Judge"+j+"ID").textContent;
						judrow = document.getElementById("Judge"+judge_id);
						if (judrow.cells[6].textContent <= 1 && judrow.cells[2].textContent < 50 && IsObligated(judge_id) == false ) {
							var JudgeTable = document.getElementById("judge_use");
							var JudgeRows = JudgeTable.getElementsByTagName("tr");
							for (var i = 1; i < JudgeRows.length; i++) {
								if ( JudgeRows[i].cells[2].textContent > 50 && JudgeRows[i].cells[10].textContent == 0 && can_place_now(JudgeRows[i].cells[0].textContent, true) ) {
									if ( over_max(JudgeRows[i].cells[0].textContent, panel_id, false) == false) {
										add_judge_to_panel(JudgeRows[i].cells[0].textContent, panel_id, j);
										var dummy = document.getElementById("Judge"+judge_id);
										dummy.cells[10].textContent=0;
									}
								}
							}
						}
					}
				}
			}
		}

		TightMaxPlacement = function() {

			var n_judges = parseFloat(document.getElementById("n_judges").value);
			var is_elim = document.getElementById("is_elim").value;
			if (n_judges>1 || is_elim == true ) {
				window.alert("This only works for 1-judge prelims.  Place judges using a different method.");
			}

			var clear_first = document.getElementById("clear_first").checked;
			if ( clear_first == true ) { clear_current_placements(); }

			//make judges array -- sorted from lowest to highest ranking
			var judge_arr = [];
			var JudgeTable = document.getElementById("judge_use");
			var JudgeRows = JudgeTable.getElementsByTagName("tr");
			var n_judges_in_array = JudgeRows.length-2;
			for (var i = 1; i < n_judges_in_array; i++) {
				judge_arr[i-1] = [];
				judge_arr[i-1][0] = JudgeRows[i].cells[0].textContent; //judge id
				var fut_poss = parseFloat(JudgeRows[i].cells[7].textContent);
				var ob_left = parseFloat(JudgeRows[i].cells[6].textContent);
				if (fut_poss>0) {
					judge_arr[i-1][1] = 100 * (ob_left/fut_poss); //% commitment left
				} else {
					judge_arr[i-1][1] = 0;
				}
				if (judge_arr[i-1][1] > 100) { judge_arr[i-1][1] = 101; } // now on a 0-101 scale
 				judge_arr[i-1][2] = JudgeRows[i].cells[2].textContent; //avg rating
				judge_arr[i-1][3] = JudgeRows[i].cells[1].textContent; //judge name
				if ( JudgeRows[i].cells[4].textContent == "0" ) { judge_arr[i-1][1] = 0; }
			}
			judge_arr.sort(function(a, b) { return (a[2] > b[2] ? -1 : (a[2] < b[2] ? 1 : 0)); });

			//Set debate variables for the loop
			var MasterTable = document.getElementById("current_pairing");
			var TableRows = MasterTable.getElementsByTagName("tr");
			var n_debates = TableRows.length-1;
			var debate_arr = [];
			for (var x = 1; x < TableRows.length; x++) {
				debate_arr[x-1] = [];
				debate_arr[x-1][0] = TableRows[x].cells[0].textContent; //panel_id
				debate_arr[x-1][2] = document.getElementById(debate_arr[x-1][0]+"Cohort").textContent;
				debate_arr[x-1][3] = 0; //current judge placement
			}

			//lOOP BY JUDGES PER PANEL
			var debates_with_judges=0;
			var trials = 0;
			do {

				trials++;

				//Sort debates from hardest to easiest to fill
				for (var x = 1; x < TableRows.length; x++) {
					debate_arr[x-1][1] = 0; //debate_arr[x][1] will be number of judges who fit
					for (var j = 0; j < n_judges-1; j++) {
						var does_fit = true;
						if ( can_place_now(judge_arr[j][0], true) == false ) { does_fit = false; }
						if ( over_max(judge_arr[j][0], debate_arr[x-1][0], false) == true ) { does_fit = false; }
						if ( does_fit == true ) { debate_arr[x-1][1]++; }
					}
				}
				debate_arr.sort(function(a, b) { return (a[1] < b[1] ? -1 : (a[1] > b[1] ? 1 : 0)); });

				var did_place=false;
				for (var x = 0; x < n_debates; x++) {
					if ( debate_arr[x][3] == 0 ) {
						for (var j = 0; j < n_judges_in_array; j++) {
							if ( can_place_now(judge_arr[j][0], true) == true ) {
								//place judge if they fit criteria OR trials exceed debates, which means you're in disaster mode
								if (over_max(judge_arr[j][0], debate_arr[x][0], false) == false || trials > n_debates ) {
									add_judge_to_panel(judge_arr[j][0], debate_arr[x][0], 1);
									did_place=true;
									debate_arr[x][3] = judge_arr[j][0];
									debates_with_judges++;
									break;
								}
							}
						}
						if ( did_place == true ) { break; }
					}
				}

			}
			while (debates_with_judges < n_debates && trials < (n_debates * 2) );

			current_diagnostics();
			var dummy = document.getElementById("save_button");
			dummy.value = "Click to Save Placements Below";
			dummy.style.backgroundColor = "Red" ;

			window.alert("Done");
		}

		JudgeMaxPlacement = function(round_id, just_place) {

		    //just_place=0 means from Use Committed, 1=LPJ, 2=struck in other events, 3=diverse
		    var clear_first = document.getElementById("clear_first").checked;
			if ( clear_first == true ) { clear_current_placements(); }
			var n_judges = parseFloat(document.getElementById("n_judges").value);
			var max_avg_pref = parseFloat(document.getElementById("max_avg_pref").value);

			var eval = [];
			var MasterTable = document.getElementById("judge_use");
			var TableRows = MasterTable.getElementsByTagName("tr");
			for (var i = 1; i < TableRows.length; i++) {
				eval[i] = [];
				eval[i][0] = TableRows[i].cells[0].textContent; //judge id
				eval[i][1] = TableRows[i].cells[2].textContent; //rating
				eval[i][2] = TableRows[i].cells[1].textContent; //judge name
				eval[i][3] = TableRows[i].cells[10].textContent; //judging now
				eval[i][4] = IsObligated( TableRows[i].cells[0].textContent ); //obligated to hear round
				eval[i][5] = can_place_now( TableRows[i].cells[0].textContent ); //obligated to hear round
			    eval[i][6] = parseFloat(TableRows[i].cells[14].textContent); //ineligible in other events
				eval[i][7] = parseFloat(TableRows[i].cells[15].textContent); //diverse
			}
			eval.sort(function(a, b) { return (a[1] > b[1] ? -1 : (a[1] < b[1] ? 1 : 0)); });

			for (var i = 1; i < TableRows.length-1; i++) {

				var judge_to_add = eval[i][0];
				var judge_rating = eval[i][1];
				var consider_judge=0;
				if ( just_place == 0 && eval[i][4] == true ) { consider_judge=1; }
				if ( just_place == 1 && eval[i][1] > max_avg_pref ) { consider_judge = 1; }
			    if ( just_place == 2 && eval[i][6] == 1 ) { consider_judge = 1; }
				if ( just_place == 3 && eval[i][7] == 1 ) { consider_judge = 1; }
				if ( consider_judge == 1 && eval[i][3] == 0 && eval[i][5] == true ) {
					var panel_to_add=0;
					var judge_n_spot=0;
					var PairingTable = document.getElementById("current_pairing");
					var PairingRows = PairingTable.getElementsByTagName("tr");
					for (var x = 1; x < PairingRows.length; x++) {
						var panel_id = PairingRows[x].cells[0].textContent;
						var cohort = document.getElementById(PairingRows[x].cells[0].textContent+"Cohort").textContent
						for (var j = 1; j <= n_judges; j++) {
							var curr_judge_id = parseFloat(document.getElementById(panel_id+"Judge"+j+"ID").textContent);
							if ( isNaN(curr_judge_id) ) { curr_judge_id = 0; }
							if ( just_place == 3 && cohort == "Below" ) { curr_judge_id = 99; } //don't process if diverse & out of it
							if ( curr_judge_id == 0 && over_max(judge_to_add, panel_id, false) == false ) {
								panel_to_add=panel_id;
								judge_n_spot=j;
							}
						}
					}
					if ( panel_to_add > 0 ) {
						add_judge_to_panel(judge_to_add, panel_to_add, judge_n_spot);
					}
				}
			}

			current_diagnostics();
			var dummy = document.getElementById("save_button");
			dummy.value = "Click to Save Placements Below";
			dummy.style.backgroundColor = "Red" ;
			//window.alert("placements done");
		}

		PlaceJudges = function(strSpecial) {

			var n_judges = parseFloat(document.getElementById("n_judges").value);
			var is_elim = document.getElementById("is_elim").value;

			var pref_wt = parseFloat(document.getElementById("hi_pref_wt").value);
			var fut_pref_wt = parseFloat(document.getElementById("fut_pref_wt").value);
			var holder = (1-pref_wt);
			var fut_wt = holder * fut_pref_wt;
			var use_wt = holder - fut_wt;
			var start = new Date();

		    var clear_first = document.getElementById("clear_first").checked;
			if ( clear_first == true ) { clear_current_placements(); }

			var time_display = document.getElementById("status_box");
			var end = new Date(); var duration_toclear = end - start;

			var end = new Date(); var duration_torecalc = end - start;

			// FIRST PASS ------- place judges to max judge use

			//figure out how many non_obligated judges you gotta use
			var MasterTable = document.getElementById("judge_use");
			var TableRows = MasterTable.getElementsByTagName("tr");
			var n_obligated=0;
			for (var i = 1; i < TableRows.length; i++) {
				if ( IsObligated( parseFloat(TableRows[i].cells[0].textContent) ) == true ) { n_obligated = n_obligated + 1; }
			}
			var MasterTable = document.getElementById("current_pairing");
			var TableRows = MasterTable.getElementsByTagName("tr");
			var n_debates = TableRows.length - 1;
			var non_ob_needed =  n_debates - n_obligated;

			//mark time
			var end = new Date(); var duration_sorttest = end - start;

			//make judges array
			var judge_arr = [];
			var JudgeTable = document.getElementById("judge_use");
			var JudgeRows = JudgeTable.getElementsByTagName("tr");
			var judge_use_length = JudgeRows.length;
			for (var i = 1; i < judge_use_length; i++) {
				judge_arr[i-1] = [];
				judge_arr[i-1][0] = JudgeRows[i].cells[0].textContent; //judge id
				var fut_poss = parseFloat(JudgeRows[i].cells[7].textContent);
				var ob_left = parseFloat(JudgeRows[i].cells[6].textContent);
				if (fut_poss>0) {
					judge_arr[i-1][1] = 100 * (ob_left/fut_poss); //% commitment left
				} else {
					judge_arr[i-1][1] = 0;
				}
				if (judge_arr[i-1][1] > 100) { judge_arr[i-1][1] = 101; } // now on a 0-101 scale
 				judge_arr[i-1][2] = JudgeRows[i].cells[2].textContent; //avg rating
				judge_arr[i-1][3] = JudgeRows[i].cells[1].textContent; //judge name
				if ( JudgeRows[i].cells[4].textContent == "0" ) { judge_arr[i-1][1] = 0; }
			}
			//sort now happens below, just saving these for future syntax refernce
			//judge_arr.sort(function(a, b) { return (a[2] > b[2] ? -1 : (a[2] < b[2] ? 1 : 0)); });
			//judge_arr.sort(function(a, b) { return (a[1] > b[1] ? -1 : (a[1] < b[1] ? 1 : 0)); });

			//figure out n fits per debate
			var check_commit = true;
			if ( is_elim == true ) { check_commit = false; }
			var debate_arr = [];
			var MasterTable = document.getElementById("current_pairing");
			var TableRows = MasterTable.getElementsByTagName("tr");
			for (var x = 1; x < TableRows.length; x++) {
				debate_arr[x-1] = [];
				debate_arr[x-1][0] = TableRows[x].cells[0].textContent; //panel_id
				debate_arr[x-1][1] = 0; //debate_arr[x][1] will be number of judges who fit
				debate_arr[x-1][2] = document.getElementById(debate_arr[x-1][0]+"Cohort").textContent;
				for (var j = 0; j < judge_use_length-1; j++) {
					var does_fit = true;
					if ( can_place_now(judge_arr[j][0], check_commit) == false ) { does_fit = false; }
					if ( over_max(judge_arr[j][0], debate_arr[x-1][0], false) == true ) { does_fit = false; }
					if ( does_fit == true ) { debate_arr[x-1][1]++; }
				}
			}
			debate_arr.sort(function(a, b) { return (a[1] < b[1] ? -1 : (a[1] > b[1] ? 1 : 0)); });

			if ( strSpecial == "Reality" ) {
				var dummy_display = document.getElementById("status_box");
				dummy_display.textContent = "Using these MPJ criteria the tightest debate has " + debate_arr[0][1] + " judges who fit.  Fits by debate are shown below with debates ranked from the fewest to the most fits. ";
				dummy_display.textContent = dummy_display.textContent + "If you relax the placement criteria you should get more judge fits.  Here are the debate-by-debate results:\n";
				for (var x = 0; x < n_debates; x++) {
					dummy_display.textContent = dummy_display.textContent + "In debate #" + (x+1) + " there are " + debate_arr[x][1] + " judges(s) who fit, debate is " + debate_arr[x][2] + " break line\n";
				}
				window.alert("Process done; check the message box in the diagnostics section of this page");
				return;
			}

			//LOOP COHORTS
			var cohort_str = ["At", "Above", "Below"];
			var current_judge;
			for (var cohort = 0; cohort <=2; cohort ++ ) {

				for (var judge = 1; judge <= n_judges; judge++) {
					//LOOP PANELS
					for (var x = 0; x < n_debates; x++) {

						//don't erase an existing judge
						current_judge = document.getElementById(TableRows[x].cells[0].textContent+"Judge"+judge+"ID");

						//window.alert( current_judge.textContent + " val=" + parseFloat(current_judge.textContent) + " on panel " + x);
						// 						if ( debate_arr[x][2] == cohort_str[cohort] && parseFloat(current_judge.textContent) == 0 ) {

						if ( debate_arr[x][2] == cohort_str[cohort]  ) {

							//window.alert("yeah, so I'm placing a judge");

							//add pref scores per judge and panel
							for (var i = 0; i < judge_use_length-1; i++) {
								//for judge_arr, 0=id, 1=% commit left, 2=avg rating, 3=name, 4=higher pref for this debate, 5=weight
								judge_arr[i][4] = 100 - get_higher_pref(judge_arr[i][0], debate_arr[x][0]) ;
								//commt left, rating, and fit are now all on a 1-100 scale; weight 'em
								judge_arr[i][5] = (judge_arr[i][1]*use_wt) + (judge_arr[i][2]*fut_wt) + (judge_arr[i][4]*pref_wt)
							}
							judge_arr.sort(function(a, b) { return (a[5] > b[5] ? -1 : (a[5] < b[5] ? 1 : 0)); });

							var dummy = document.getElementById(debate_arr[x][0]+"Judge"+judge+"ID").textContent;
							if ( parseFloat(dummy) == 0 || dummy == "" ) {
								//LOOP JUDGES
								for (var j = 0; j < judge_use_length-1; j++) {
									if ( can_place_now(judge_arr[j][0], check_commit) == true ) {
										if (over_max(judge_arr[j][0], debate_arr[x][0], false) == false ) {
											add_judge_to_panel(judge_arr[j][0], debate_arr[x][0], judge);
											break;
										}
									}
								}
							}
						}
					}
				}
			}

			//window.alert("bailing after first pass"); return;
			//windoe.alert("failed");

			//SECOND PASS; fill in any empty spots

			//sort judges by obligation left, worst avg pref rating
			judge_arr.sort(function(a, b) { return (a[2] > b[2] ? -1 : (a[2] < b[2] ? 1 : 0)); });
			judge_arr.sort(function(a, b) { return (a[1] > b[1] ? -1 : (a[1] < b[1] ? 1 : 0)); });

			var MasterTable = document.getElementById("current_pairing");
			var TableRows = MasterTable.getElementsByTagName("tr");
			for (var x = 1; x < TableRows.length; x++) {
				for (var judge = 1; judge <= n_judges; judge++) {
					var dummy = document.getElementById(TableRows[x].cells[0].textContent+"Judge"+judge+"ID");
					if ( parseFloat(dummy.textContent) == 0 ) {
						//loop through the remaining judges and place one that fits
						for (var j = 0; j < judge_use_length-1; j++) {
							if ( can_place_now(judge_arr[j][0], check_commit) == true ) {
								if (over_max(judge_arr[j][0], debate_arr[x-1][0], false) == false ) {
									add_judge_to_panel(judge_arr[j][0], debate_arr[x-1][0], judge);
									break;
								}
							}
						}
					}
				}
			}

			var end = new Date(); var duration_first_pass = end - start;

			var made_change = true;
			var any_triple = false;

			var MasterTable = document.getElementById("current_pairing");
			var TableRows = MasterTable.getElementsByTagName("tr");
			for (var x = 1; x < TableRows.length; x++) {
				var dummy = document.getElementById(TableRows[x].cells[0].textContent+"Judge1ID").textContent;
				//if ( parseFloat(dummy) == 0 ) { window.alert("no judge at panel " + TableRows[x].cells[0].textContent); }
			}


			//THIRD PASS ------ double swaps to improve panels

			var n_tries=0;
			var n_2x_swaps=0;
			do {
				made_change = double_swap(false); if (made_change == true ) { n_2x_swaps = n_2x_swaps +1; }
				n_tries++;
			} while ( n_tries < 50 && made_change == true );
			var end = new Date();
			var duration_doub_swap = end - start;

			//FOURTH PASS ------ triple swaps to improve panels

			n_tries=0;
			do {
				made_change = triple_swap(false); if (made_change == true ) { n_2x_swaps = n_2x_swaps +1; }
				n_tries++;
			} while ( n_tries < 10 && made_change == true );
			var end = new Date(); var duration_trip_swap = end - start;

			//window.alert("bailing after fourth pass"); return;
			//windoe.alert("failed");

			//FIFTH PASS ------ fix panels over constraints with extra judges

			fix_with_extra();
			var end = new Date(); var duration_fix_w_extra = end - start;

			//SIXTH PASS ------ fix panels over constriants with extra judges and double swaps

			fix_with_extra_and_doub();
			var end = new Date(); var duration_fix_w_extra_and_doub = end - start;

			//SEVENTH PASS ---- repeat double-swaps

			var n_tries=0;
			do {
				made_change = double_swap(false); if (made_change == true ) { n_2x_swaps = n_2x_swaps +1; }
				n_tries++;
			} while ( n_tries < 50 && made_change == true );
			var end = new Date(); var duration_doub_swap_2 = end - start;

			//EIGTH PASS ------ repeat triple swaps

			n_tries=0;
			do {
				made_change = triple_swap(false); if (made_change == true ) { n_2x_swaps = n_2x_swaps +1; }
				n_tries++;
			} while ( n_tries < 10 && made_change == true );
			var end = new Date(); var duration_trip_swap_2 = end - start;

			//NINTH PASS ----- push obligated judges back in

			push_obligated_back_in();
			var end = new Date();
			var duration_push_back_in = end - start;

			//TENTH PASS ------ fix over_max panels with double swaps, even if both panels don't improve so long as both meet targets

			if ( panels_over_target("At") + panels_over_target("Above") > 0 ) {
				var n_tries=0;
				do {
					made_change = double_swap(true); if (made_change == true ) { n_2x_swaps = n_2x_swaps +1; }
					n_tries++;
				} while ( n_tries < 50 && made_change == true );
			}

			//ELEVENTH PASS ------ fix over_max panels with triple swaps, even if both panels don't improve so long as both meet targets

			//THIS IS DOUBLE PLACING A TON OF JUDGES

			//if ( panels_over_target("At") + panels_over_target("Above") > 0 ) {
			//	n_tries=0;
			//	do {
			//		made_change = triple_swap(true); if (made_change == true ) { n_2x_swaps = n_2x_swaps +1; }
			//		n_tries++;
			//	} while ( n_tries < 10 && made_change == true );
			//}

			//TWELFTH PASS ------ don't burn good judges in bad debates

			//should probably not do this for elims or last prelim
			salvage_below();

			time_display.textContent = "Time to clear screen is:" + duration_toclear/1000;
//			time_display.textContent=time_display.textContent + " Time to recalc screen is:" + duration_torecalc/1000;
//			time_display.textContent=time_display.textContent + " Time for sort is:" + duration_sorttest/1000;
			time_display.textContent=time_display.textContent + " Time to first pass is:" + duration_first_pass/1000;
//			time_display.textContent=time_display.textContent + " Time to double swap is:" + duration_doub_swap/1000;
			time_display.textContent=time_display.textContent + " " + n_2x_swaps + " total 2x & 3x swaps. " + duration_doub_swap/1000;
//			time_display.textContent=time_display.textContent + " Time to triple swap is:" + duration_trip_swap/1000;
//			time_display.textContent=time_display.textContent + " Time to fix with extra:" + duration_fix_w_extra/1000;
//			time_display.textContent=time_display.textContent + " Time to fix with extra & 2x:" + duration_fix_w_extra_and_doub/1000;
//			time_display.textContent=time_display.textContent + " Time to push back oblig judges:" + duration_push_back_in/1000;
//			time_display.textContent=time_display.textContent + " Finish second 2x, 3x swaps:" + duration_trip_swap_2/1000;
			time_display.textContent=time_display.textContent + " Time to finish placements:" + duration_push_back_in/1000;

			var panels_over = panels_over_target("At");
			var dummy = document.getElementById("PanelsOverAt");
			dummy.textContent = panels_over;

			var panels_over = panels_over_target("Above");
			var dummy = document.getElementById("PanelsOverAbove");
			dummy.textContent = panels_over;

			var panels_over = panels_over_target("Below");
			var dummy = document.getElementById("PanelsOverBelow");
			dummy.textContent = panels_over;

			current_diagnostics();
			do_stddev("");

			var dummy = document.getElementById("save_button");
			dummy.value = "Click to Save Placements Below";
			dummy.style.backgroundColor = "Red" ;

		}

		judge_test = function() {

			//window.alert("in test");
			var dummy = document.getElementById("321912Judge1Pref1");
			dummy.textContent = "1.3";
			var dummy = document.getElementById("321912Judge1Pref2");
			dummy.textContent = "2.1";
			var dummy = document.getElementById("321912Judge1Name");
			dummy.textContent = "Bruschke, Cricket 1.3-2.1";
			var dummy = document.getElementById("321912Judge1Mut");
			dummy.textContent = ".8";
			var dummy = document.getElementById("321912Avg");
			dummy.textContent = "1.7";
			var dummy = document.getElementById("321912Bal");
			dummy.textContent = "-.8";

		}

		//only called from within the current_pairings diagnostics
		judge_diagnostics = function() {

			var n_judges = parseFloat(document.getElementById("n_judges").value);

			//update columns in table to reflect the displayed pairings; shows whether they are judging in the current pairings
			var MasterTable = document.getElementById("current_pairing");
			var TableRows = MasterTable.getElementsByTagName("tr");
			var n_debates = TableRows.length - 1;
			for (var i = 1; i < TableRows.length; i++) {
				for (var j = 1; j <= n_judges; j++) {
					var judge_id = document.getElementById(TableRows[i].cells[0].textContent+"Judge"+j+"ID");
					if ( judge_id != null ) {
						var judge_use = document.getElementById(judge_id.textContent+"DisplayAssigned");
						if ( judge_use != null ) { judge_use.textContent = 1; }
					}
				}
			}

			//Count up rounds lost and average pref left
			var NewRdsLost = 0;
			var TotPref = 0; var PrefNum = 0;
			var MasterTable = document.getElementById("judge_use");
			var TableRows = MasterTable.getElementsByTagName("tr");
			var LostList="";
			var burned = 0; var burned_top50 = 0; var bodies_left = 0;
			var BurnedList=""; var BurnedTop50List="";
			for (var i = 1; i < TableRows.length; i++) {
				var oblig = commitment_left(TableRows[i].cells[0].textContent);
				var FutPoss = parseFloat(TableRows[i].cells[7].textContent);
				if ( oblig > 0 && FutPoss > 0 ) { bodies_left++; }
				var AvailCurrent = parseFloat(TableRows[i].cells[4].textContent);
				var Assigned_Saved = parseFloat(TableRows[i].cells[8].textContent);
				var SaveAssignedTimeslot = parseFloat(TableRows[i].cells[9].textContent);
				var AssignedCurrent = parseFloat(TableRows[i].cells[10].textContent);
				TableRows[i].cells[13].textContent = 0;
				var Rating = parseFloat(TableRows[i].cells[2].textContent);
				if ( AvailCurrent == 1 && oblig <= 0 && AssignedCurrent == 1 ) {
					burned++;
					if ( Rating <= 50 ) {
						burned_top50++; BurnedTop50List = BurnedTop50List + TableRows[i].cells[1].textContent+" (Avg Rating=" + Rating + ")\n";
					} else {
						BurnedList = BurnedList + TableRows[i].cells[1].textContent+" (Avg Rating=" + Rating + ")\n";
					}
				}
				if ( AvailCurrent == 1 && SaveAssignedTimeslot == 0 && AssignedCurrent == 0 && oblig >= (FutPoss + 1) ) {
					TableRows[i].cells[13].textContent = "1";
					NewRdsLost++ ;
					LostList = LostList + TableRows[i].cells[1].textContent+" (Avg Rating=" + Rating + " with " + oblig + " still owed) \n";
				}
				var dummy = oblig;
				if ( FutPoss < dummy) { dummy = FutPoss; }
				if ( dummy < 0 ) { dummy = 0; }
				TotPref = TotPref + (dummy * Rating);
				PrefNum = PrefNum + dummy ;
			}
			//window.alert("Lost Rounds from" + LostList);
			var time_display = document.getElementById("status_box");
			time_display.textContent = time_display.textContent + "\nLost rounds from: \n" + LostList;
			time_display.textContent = time_display.textContent + "\nTop 50 judges burned: \n" + BurnedTop50List;
			time_display.textContent = time_display.textContent + "\nOther judges burned: \n" + BurnedList;

			var dummy = document.getElementById("RdsLost");
			dummy.textContent = NewRdsLost + "/" + PrefNum;
			var dummy = document.getElementById("PrefLeft");
			var dummy2 = TotPref / PrefNum;
			dummy.textContent = dummy2.toFixed(1);
			var dummy = document.getElementById("BurnedCurrent");
			dummy.textContent = burned;
			var dummy = document.getElementById("BurnedTop50");
			dummy.textContent = burned_top50;
			var dummy = document.getElementById("BodiesLeft");
			dummy.textContent = bodies_left;

			//and now for the chatty
			//Rounds lost, left, and needed
			var future_category_need = document.getElementById("future_category_need").textContent;
			var prelims_left =  document.getElementById("prelims_left").textContent;
			var to_spare = PrefNum - future_category_need;
			var extra_per_rd = (to_spare/prelims_left).toFixed(1);
			var dummy = document.getElementById("ResultRounds");
			var str = "You lost " + NewRdsLost + " and have a total of " + PrefNum +" left , and you need " + future_category_need + " to finish the tourney";
			str = str + " (including all events using this judge category), so you've got " + to_spare + " rounds to spare.";
			str = str + " There are " + prelims_left  + " prelims left after this one, so on average you can lose ";
			str = str + extra_per_rd + " per round.";
			dummy.textContent = str;
			if (extra_per_rd < 0) {
				str = "You are TOTALLY HOSED -- not enough rounds of judging to finish the tourney.";
			} else if (extra_per_rd == 0) {
				str = "Oh God, this is tight.  You have NO ROUNDS TO LOSE.  I'd try again and see if you can save some.";
			} else if (extra_per_rd <= 2) {
				str = "I hope you like a challenge; this is do-able, but it's gonna be tight.";
			} else if (extra_per_rd <= 5) {
				str = "Looks pretty good, but don't get lazy.  You should be all right if you don't lose a bunch of rounds suddently.";
			} else if (extra_per_rd > 5) {
				str = "Herod never had such riches.  You have so many judges you should probably think about improving the pref.";
			}
			if (NewRdsLost > extra_per_rd) {
				str = str + " You DID just make things a little worse than they were before, so be careful.";
			}
			var dummy = document.getElementById("CommentRounds");
			dummy.textContent = str;
			//Avg pref left in the pool
			var SavedPrefLeft = parseFloat(document.getElementById("SavedPrefLeft").textContent);
			var current_pref_left = (TotPref / PrefNum).toFixed(1);
			var pref_change = parseFloat((current_pref_left - SavedPrefLeft).toFixed(1));
			str = "The average pref for judges (weighted by rounds of judging left) before this trial was " + SavedPrefLeft;
			str = str + ", and now it's " + current_pref_left + ", so there was a change of " + pref_change;
			var dummy = document.getElementById("ResultPrefLeft");
			dummy.textContent = str;
			if (pref_change < 0 ) {
				str = "SWEET.  You will have better judiging in the future than you have now.";
			} else if (pref_change <= 1) {
				str = "Well, judging got a little worse, but it's not tragic.";
			} else if (pref_change <= 2) {
				str = "Hmmm...future judge pref got worse and by a decent amount; I'd try fiddling to lower this number.";
			} else if (pref_change > 2) {
				str = "Future judging is quite a bit worse; if the number is over 50, it's time to worry.";
			}
			if (current_pref_left < 50 && pref_change > 0 ) {
				str = str + " You're still under 50 overall, so things are probably OK.";
			}
			if (current_pref_left > 50 ) {
				str = str + " Still, you're over 50 overall, so keeping everything in the top 50% might get dicey.";
			}
			var dummy = document.getElementById("CommentPrefLeft");
			dummy.textContent = str;
			//burned and bodfies
			var burned = parseFloat(document.getElementById("BurnedCurrent").textContent);
			var burned_top50 = parseFloat(document.getElementById("BurnedTop50").textContent);
			var bodies_left = parseFloat(document.getElementById("BodiesLeft").textContent);
			str = "You burned " + burned + " judges, and " + burned_top50 +" of them were in the top 50% of the pool. ";
			str = str + "You have " + bodies_left + " and need " + n_debates + " live bodies per round."
			var dummy = document.getElementById("ResultBurned");
			dummy.textContent = str;
			var body_pct = bodies_left/n_debates;
			str = "nothing special";
			if (body_pct < 0 ) {
				str = "You are SCREWED.  Not enough bodies to fill all the debates; try again and start begging judges.";
			} else if (body_pct == 1) {
				str = "If this were pants, they'd be to tight.  You have NO margin of error and can't afford to burn another single judge.";
			} else if (body_pct <= 1.1) {
				str = "In the ballpark but don't get lazy; keep an eye on this";
			} else if (body_pct > 1.1 && bodies_left >= 5) {
				str = "Seems OK.";
			}
			if (bodies_left >= 10 ) {
				str = str + " I mean, you got at least 10 bodies extra per round, so things are probably fine.";
			}
			var dummy = document.getElementById("CommentBurned");
			dummy.textContent = str;
			if (prelims_left == 0 ) {
				var dummy = document.getElementById("CommentBurned"); dummy.textContent = "n/a -- last round";
				var dummy = document.getElementById("CommentPrefLeft"); dummy.textContent = "n/a -- last round";
				var dummy = document.getElementById("CommentRounds"); dummy.textContent = "n/a -- last round";
				var dummy = document.getElementById("ResultBurned"); dummy.textContent = "n/a -- last round";
				var dummy = document.getElementById("ResultPrefLeft"); dummy.textContent = "n/a -- last round";
				var dummy = document.getElementById("ResultRounds"); dummy.textContent = "n/a -- last round";
			}
		}

		do_stddev = function(strSaved) {

			var n_judges = parseFloat(document.getElementById("n_judges").value);
			var MasterTable = document.getElementById("current_pairing");
			var TableRows = MasterTable.getElementsByTagName("tr");
			var TotDiff = [0,0,0]; var PrefCt = [0,0,0]; var Cohort_num;
			var Plus1SD = [0,0,0];
			var Plus2SD = [0,0,0];
			var SD = [0,0,0];
			var AvgforCohort = [0,0,0];
			AvgforCohort[0] = parseFloat(document.getElementById(strSaved+"AvgAbove").textContent);
			AvgforCohort[1] = parseFloat(document.getElementById(strSaved+"AvgAt").textContent);
			AvgforCohort[2] = parseFloat(document.getElementById(strSaved+"AvgBelow").textContent);
			//first pass; calculate stddev per cohort
			for (var i = 1; i < TableRows.length; i++) {
				var Cohort = document.getElementById(TableRows[i].cells[0].textContent+"Cohort");
				if ( Cohort != null ) {
					if ( Cohort.textContent == "Above" ) { Cohort_num = 0; }
					if ( Cohort.textContent == "At" ) { Cohort_num = 1; }
					if ( Cohort.textContent == "Below" ) { Cohort_num = 2; }
				}

				for (var j = 1; j <= n_judges; j++) {
					var id_to_get = TableRows[i].cells[0].textContent+"Judge"+j+"Mut";
					for (var tm = 1; tm <= 2; tm++) {
						var id_to_get = TableRows[i].cells[0].textContent+"Judge"+j+"Pref"+tm;
						var pref = parseFloat(document.getElementById(id_to_get).textContent);
						if ( pref != null ) {
							TotDiff[Cohort_num] = TotDiff[Cohort_num] + Math.abs(pref-AvgforCohort[Cohort_num]) ;
							PrefCt[Cohort_num] = PrefCt[Cohort_num] + 1;
//							window.alert("Panel/Judge=" + id_to_get + " Pref=" + parseFloat(pref.textContent) + " TotPref=" + TotPref[Cohort_num] + " PrefCt=" + PrefCt[Cohort_num]);
						}
					}
				}
			}
			//update avg pref display
			var dummy = document.getElementById(strSaved+"AvgAbove");
			SD[0] = parseFloat(TotDiff[0]/PrefCt[0]).toFixed(1);
			dummy.textContent = dummy.textContent + " (SD=" + SD[0] + " n=" + PrefCt[0] + ")";
			var dummy = document.getElementById(strSaved+"AvgAt");
			SD[1] = parseFloat(TotDiff[1]/PrefCt[1]).toFixed(1);
			dummy.textContent = dummy.textContent + " (SD=" + SD[1] + " n=" + PrefCt[1] + ")";
			var dummy = document.getElementById(strSaved+"AvgBelow");
			SD[2] = parseFloat(TotDiff[2]/PrefCt[2]).toFixed(1);
			dummy.textContent = dummy.textContent + " (SD=" + SD[2] + " n=" + PrefCt[2] + ")";
			//second pass; count over 1 & 2 SD
			for (var i = 1; i < TableRows.length; i++) {
				var Cohort = document.getElementById(TableRows[i].cells[0].textContent+"Cohort");
				if ( Cohort != null ) {
					if ( Cohort.textContent == "Above" ) { Cohort_num = 0; }
					if ( Cohort.textContent == "At" ) { Cohort_num = 1; }
					if ( Cohort.textContent == "Below" ) { Cohort_num = 2; }
				}

				for (var j = 1; j <= n_judges; j++) {
					var id_to_get = TableRows[i].cells[0].textContent+"Judge"+j+"Mut";
					for (var tm = 1; tm <= 2; tm++) {
						var id_to_get = TableRows[i].cells[0].textContent+"Judge"+j+"Pref"+tm;
						var pref = parseFloat(document.getElementById(id_to_get).textContent);
						if ( pref != null ) {
							if ( pref > ( Number(SD[Cohort_num]) + Number(AvgforCohort[Cohort_num]) )  ) { Plus1SD[Cohort_num]++; }
							if ( pref > ( ( Number(SD[Cohort_num]) * 2 ) + Number(AvgforCohort[Cohort_num]) ) ) { Plus2SD[Cohort_num]++; }
						}
					}
				}
			}
			//update display
			var dummy = document.getElementById(strSaved+"Plus1SDAbove");
			var dummy2 = Number(SD[0]) + Number(AvgforCohort[0]); dummy2 = dummy2.toFixed(1);
			dummy.textContent = Plus1SD[0] + " (" + dummy2 + " or higher)";
			var dummy = document.getElementById(strSaved+"Plus2SDAbove");
			var dummy2 = ( ( Number(SD[0]) * 2 ) + Number(AvgforCohort[0]) ).toFixed(1);
			dummy.textContent = Plus2SD[0] + " (" + dummy2 + " or higher)";

			var dummy = document.getElementById(strSaved+"Plus1SDAt");
			var dummy2 = Number(SD[1]) + Number(AvgforCohort[1]); dummy2 = dummy2.toFixed(1);
			dummy.textContent = Plus1SD[1] + " (" + dummy2 + " or higher)";
			var dummy = document.getElementById(strSaved+"Plus2SDAt");
			var dummy2 = ( ( Number(SD[1]) * 2 ) + Number(AvgforCohort[1]) ).toFixed(1);
			dummy.textContent = Plus2SD[1] + " (" + dummy2 + " or higher)";

			var dummy = document.getElementById(strSaved+"Plus1SDBelow");
			var dummy2 = Number(SD[2]) + Number(AvgforCohort[2]); dummy2 = dummy2.toFixed(1);
			dummy.textContent = Plus1SD[2] + " (" + dummy2 + ") or higher";
			var dummy = document.getElementById(strSaved+"Plus2SDBelow");
			var dummy2 = ( ( Number(SD[2]) * 2 ) + Number(AvgforCohort[2]) ).toFixed(1);
			dummy.textContent = Plus2SD[2] + " (" + dummy2 + ") or higher";

		}

		//updates the diagnostics based on the current set of judge assignments;
		//earlier I had typed the comment "gotta run judge_diagnostics first" but I think I'm insane
		current_diagnostics = function() {

			var n_judges = parseFloat(document.getElementById("n_judges").value);
			var MasterTable = document.getElementById("current_pairing");
			var TableRows = MasterTable.getElementsByTagName("tr");
			var TotPref = [0,0,0]; var PrefCt = [0,0,0]; var Cohort_num;
			var WorstPref = [0,0,0];
			var TotMut = [0,0,0];
			var MutCt = [0,0,0];
			var WorstMut = [0,0,0];
			for (var i = 1; i < TableRows.length; i++) {
				var Cohort = document.getElementById(TableRows[i].cells[0].textContent+"Cohort");
				if ( Cohort != null ) {
					if ( Cohort.textContent == "Above" ) { Cohort_num = 0; }
					if ( Cohort.textContent == "At" ) { Cohort_num = 1; }
					if ( Cohort.textContent == "Below" ) { Cohort_num = 2; }
				}
				for (var j = 1; j <= n_judges; j++) {
					var id_to_get = TableRows[i].cells[0].textContent+"Judge"+j+"Mut";
					var mut = document.getElementById(id_to_get);
					if ( mut != null ) {
						TotMut[Cohort_num] = TotMut[Cohort_num] + parseFloat(mut.textContent);
						MutCt[Cohort_num] = MutCt[Cohort_num] + 1;
						if ( parseFloat(mut.textContent) > WorstMut[Cohort_num] ) { WorstMut[Cohort_num] = parseFloat(mut.textContent); }
					}

					for (var tm = 1; tm <= 2; tm++) {
						var id_to_get = TableRows[i].cells[0].textContent+"Judge"+j+"Pref"+tm;
						var pref = document.getElementById(id_to_get);
						if ( pref != null ) {
							TotPref[Cohort_num] = TotPref[Cohort_num] + parseFloat(pref.textContent) ;
							PrefCt[Cohort_num] = PrefCt[Cohort_num] + 1;
							if ( parseFloat(pref.textContent) > WorstPref[Cohort_num] ) { WorstPref[Cohort_num] = parseFloat(pref.textContent) };
//							window.alert("Panel/Judge=" + id_to_get + " Pref=" + parseFloat(pref.textContent) + " TotPref=" + TotPref[Cohort_num] + " PrefCt=" + PrefCt[Cohort_num]);
						}
					}
				}
			}

			var dum_str;
			for (var i = 0; i <= 2; i++) {
				if ( i == 0 ) { dum_str = "Above"; }
				if ( i == 1 ) { dum_str = "At"; }
				if ( i == 2 ) { dum_str = "Below"; }
				dummy = document.getElementById("Avg"+dum_str);
				dummy.textContent=parseFloat(TotPref[i]/PrefCt[i]).toFixed(1);
				dummy = document.getElementById("Worst"+dum_str);
				dummy.textContent=WorstPref[i].toFixed(1);
				dummy = document.getElementById("AvgMut"+dum_str);
				dummy.textContent=parseFloat(TotMut[i]/MutCt[i]).toFixed(1);
				dummy = document.getElementById("WorstMut"+dum_str);
				dummy.textContent=WorstMut[i].toFixed(1);
				//now update the chatty table
				dummy = document.getElementById("ResultPref"+dum_str);
				dummy.textContent = "n/a";
				if ( PrefCt[i] > 0 ) {
					dummy.textContent = "Average was "+parseFloat(TotPref[i]/PrefCt[i]).toFixed(1)+" and worst was "+WorstPref[i].toFixed(1);
					dummy = document.getElementById("CommentPref"+dum_str);
					if ( parseFloat(TotPref[i]/PrefCt[i]).toFixed(1) <= 10 ) {
						dummy.textContent="Freaking awesome";
					} else if ( parseFloat(TotPref[i]/PrefCt[i]).toFixed(1) <= 20 ) {
						dummy.textContent="Really freaking good";
					} else if ( parseFloat(TotPref[i]/PrefCt[i]).toFixed(1) <= 30 ) {
						dummy.textContent="Many times you can get under 20, but this isn't bad";
					} else if ( parseFloat(TotPref[i]/PrefCt[i]).toFixed(1) <= 40 ) {
						dummy.textContent="Not unacceptable but below average";
					} else if ( parseFloat(TotPref[i]/PrefCt[i]).toFixed(1) <= 50 ) {
						dummy.textContent="The worst you can do and still be OK";
					} else if ( parseFloat(TotPref[i]/PrefCt[i]).toFixed(1) > 50 ) {
						dummy.textContent="Pretty bad";
					}
				}
				dummy = document.getElementById("ResultMut"+dum_str);
				dummy.textContent ="n/a";
				if ( PrefCt[i] > 0 ) {
					dummy.textContent = "Average was "+parseFloat(TotMut[i]/MutCt[i]).toFixed(1)+" and worst was "+WorstMut[i].toFixed(1);
					dummy = document.getElementById("CommentMut"+dum_str);
					if ( parseFloat(TotMut[i]/MutCt[i]).toFixed(1) <= 10 ) {
						dummy.textContent="Really good";
					} else if ( parseFloat(TotMut[i]/MutCt[i]).toFixed(1) <= 20 ) {
						dummy.textContent="Acceptable, but it usually goes better";
					} else if ( parseFloat(TotMut[i]/MutCt[i]).toFixed(1) <= 30 ) {
						dummy.textContent="Eek; above borderline probably needs fixing";
					} else if ( parseFloat(TotMut[i]/MutCt[i]).toFixed(1) > 40 ) {
						dummy.textContent="Just terrible";
					}
				}
			}

			//update judge situation
			judge_diagnostics();

		}

	</script>

		<div class="full nospace">

			<span class="half nospace">
				<h2 class="marless padno">
					<% $round->realname %> ordinal judge placement
				</h2>

				<h5 class="padno">
					The Web version of the CAT/STA approach
				</h5>
			</span>

			<span class="half rightalign nospace right padtopmore">
				<a class="dkblue padmuchmore twofifth" href="/panel/schemat/show.mhtml?round_id=<% $round->id %>">
					Return to <% $round->realname %>
				</a>

				<a class="padmuchmore dkblue twofifth" onclick='show_help()'>Help me, I'm Lost</a>
				<!--  This sends you to Gary's thing, but we're not supporting it
				<a class="padmuchmore dkblue twofifth"  href="/panel/round/debate_judge_assign_sta.mhtml?round_id=<% $round->id %>">
					I really wanted STA
				</a>
				--!>
			</span>

		</div>

		<label id="prelims_left" style='display:none;'><% $prelims_left %></label>

		<form action="debate_judge_assign_sta.mhtml" method="post">
		<input type="hidden" value="<% $round_id %>" name="round_id">
		<input type="hidden" value="<% $is_elim %>" name="is_elim" id="is_elim">
		<input id="n_judges" type="hidden" value="<% $n_judges %>" >

		<span>

		<div class="nospace full martopmore">
			<h4 class="nospace">Weights and Settings</h4>
		</div>
		<label >Instructions: Make sure you like these settings (you probably only need to adjust "Pref weight") and
			then click one of those <br>buttons to the right, probably the one that says "Run Trial."  Click the help button in the top right for details.
			<br>Hover your mouse over any box below for more info.
		</label>

		<table class="narrow" id="weights_settings" >
		<tbody class="smallish">
			<tr class="even" >
				<td  title="This sets how much to prioritze good judging vs. saving judges for future rounds.  Click help for details.">
					Pref weight:<input id="hi_pref_wt" type="number" step="0.01" class="notfirst smaller" min=0 max=1 size=4  name="hi_pref_wt" value="<% .4 %>">
					<br>
					Future pref:<input id="fut_pref_wt" type="number" step="0.01" class="notfirst smaller" min=0 max=1 size=4  name="fur_pref_wt" value="<% .5 %>">
				</td>
				<td title="This sets the breakpoint to determine which debates are at, under, and over the break line.">
					Max losses and still clear:<input id="break_line"  type="number" class="smaller" min=0 max=99 size=4  name="break_line" value="<% $break_line %>"
				</td>
				<td title="This defines the average ordinal percentile that makes a judge hard to place.  Only matters if you use the 'Hard to place' button.">
					Average pref of 'hard to place' judges:<input type="number" class="smaller" min=0 max=99 size=4  id="max_avg_pref" value="<% $max_avg_pref %>">
				</td>
				<td title="Sets the max mutuality on a multi-judge panel.  Click help for details">
					Panel mut %:<input type="number" step="0.05" class="smaller" min=0 max=99 size=4  id="panel_mut_pct" value="<% $panel_mut_pct %>">
				</td>
			</tr>
		</tbody>
		</table>
		<table class="narrow" id="constraints" style="width:800px;">
		<tbody class="smallish yellowrow">
			<tr title="Sets the lowest ordinal percentile and worst mutuality you'd allow for any single judge placement.">
				<th colspan="2">Above the break line (&lt;<% $break_line %> losses)</th>
				<th colspan="2">At the break line (<% $break_line %> losses)</th>
				<th colspan="2">Below the break line (&gt;<% $break_line %> losses)</th>
			</tr>
			<tr class="even" >
				<td>
					Pref:
					<input id="max_pref_above" type="number" class="smaller" min=0 max=99 name="max_pref_above" value="<% $max_pref{'above'} %>">
				</td>
				<td>
					Mut:
					<input id="max_mut_above" type="number" class="smaller" min=0 max=99 name="max_mut_above" value="<% $max_mut{'above'} %>">
				</td>
				<td>
					Pref:
					<input id="max_pref_at" type="number" class="smaller" min=0 max=99 name="max_pref_at" value="<% $max_pref{'at'} %>">
				</td>
				<td>
					Mut:
					<input id="max_mut_at" type="number" class="smaller" min=0 max=99 name="max_mut_at" value="<% $max_mut{'at'} %>">
				</td>
				<td>
					Pref:
					<input id="max_pref_below" type="number" class="smaller" min=0 max=99 name="max_pref_below" value="<% $max_pref{'below'} %>">
				</td>
				<td>
					Mut:
					<input id="max_mut_below" type="number" class="smaller" min=0 max=99 name="max_mut_below" value="<% $max_mut{'below'} %>">
				</td>
			</tr>
			</tbody>
		</table>

		<div class="nospace full martopmore">
			<span >
				<h4 class="nospace">Trial Results -- How'd I diddley-do?</h4>
			</span>
		</div>

		<table class="narrow" id="weights_settings" style="max-width:800px;">
			<caption style="text-align:left">
				Instructions: If you like how you diddley-did, use that "Save Placements" button to the right.
				Otherwise, tweak the weights and settings and give it another rip.
			</caption>
			<tr class="smaller yellowrow" >
				<th class="odd">
					Measure
				</th>
				<th class="odd">
					Value
				</th>
				<th class="odd">
					Comments
				</th>
			</tr>
			<tr class="even">
				<td>
					Preference Above the break line
				</td>
				<td id="ResultPrefAbove">
				</td>
				<td id="CommentPrefAbove">
				</td>
			</tr>
			<tr >
				<td>
					Mutuality Above the break line
				</td>
				<td id="ResultMutAbove">
				</td>
				<td id="CommentMutAbove">
				</td>
			</tr>
			<tr class="even">
				<td>
					Preference At the break line
				</td>
				<td id="ResultPrefAt">
				</td>
				<td id="CommentPrefAt">
				</td>
			</tr>
			<tr>
				<td>
					Mutuality At the break line
				</td>
				<td id="ResultMutAt">
				</td>
				<td id="CommentMutAt">
				</td>
			</tr>
			<tr class="even">
				<td>
					Preference Below the Break line
				</td>
				<td id="ResultPrefBelow">
				</td>
				<td id="CommentPrefBelow">
				</td>
			</tr>
			<tr>
				<td>
					Mutuality Below the break line
				</td>
				<td id="ResultMutBelow">
				</td>
				<td id="CommentMutBelow">
				</td>
			</tr>
			<tr class="even">
				<td>
					Rounds lost/left/needed
				</td>
				<td id="ResultRounds">
				</td>
				<td id="CommentRounds">
				</td>
			</tr>
			<tr>
				<td>
					Average pref left
				</td>
				<td id="ResultPrefLeft">
				</td>
				<td id="CommentPrefLeft">
				</td>
			</tr>
			<tr class="even">
				<td>
					Judges Burned
				</td>
				<td id="ResultBurned">
				</td>
				<td id="CommentBurned">
				</td>
			</tr>
		</table>

		</span>

		<span class="true quarter top even">

			<h4 class="padless marno">
				Functions
			</h4>

			<label for="clear_first">
				<div class="full hover padless marno">
					<span class="threequarter">
						Erase current placements (not saved judges):
					</span>

					<span class="quarter">
						<input id="clear_first" type="checkbox" >
					</span>

				</div>

%			my $style_display= "style='display:none;'"; if ($person->site_admin) { $style_display=""; }

				<div class="full hover padless marno" <% $style_display %> >
					<span class="threequarter">
						Replace judges but keep results
					</span>

					<span class="quarter">
						<input id="just_test" type="checkbox" checked="checked">
					</span>

				</div>

			</label>

			<div class="full nospace centeralign">

				<input id="place_button" class="fullbutton" type="button" value="Run trial" onclick="PlaceJudges()">

				<input id="delete_button" class="fullbutton" type="button" value="Wipe trial result" onclick="DeletePairing(<% $round_id %>)">

				<br />

				<input id="save_button" class="red fullbutton" type="button" value="Save Placements" onclick="SavePairing(<% $round_id %>)">

			</div>

			<h5 class="martopmore">
				Place only judges:
			</h5>

			<div class="full nospace centeralign">
				<input id="judgemax_button" type="button" class="fullbutton smallish" value="With full commitments" onclick="JudgeMaxPlacement(<% $round_id %>, 0)">
				<input id="judgemax_button" type="button" class="fullbutton smallish" value="Hard to place" onclick="JudgeMaxPlacement(<% $round_id %>, 1)">
				<input id="judgemax_button" type="button" class="fullbutton smallish" value="Struck in other events" onclick="JudgeMaxPlacement(<% $round_id %>, 2)">
				<input id="judgemax_button" type="button" class="fullbutton smallish" value="Diverse" onclick="JudgeMaxPlacement(<% $round_id %>, 3)">
			</div>

			<a class="blue full smaller padleft marleft centeralignmartopmore" onclick='describe_judgemax()' >
				Guide to placing restricted judges
			</a>

			<h4 class="martopmore">
				Tight Judging Pools:
			</h4>

			<div class="full nospace centeralign">
				<input id="judgemax_button" type="button" class="fullbutton smallish" value="Reality Check" onclick="PlaceJudges('Reality')">
				<input id="judgemax_button" type="button" class="fullbutton smallish" value="Just Get a Judge in Every Debate" onclick="TightMaxPlacement()">
			</div>

			<a class="blue full smaller padleft marleft centeralignmartopmore" onclick='describe_tightness()' >
				Guide to tight judging pools
			</a>

		</span>


		<div class="nospace full martopmore">
			<span class="third">
				<h4 class="nospace">Diagnostics and details</h4>
			</span>
		</div>

		<div class="evenrow centeralign">
			Messages:
			<textarea id="status_box" cols="100" rows="3"></textarea>
		</div>

		<table >

			<tr class="smaller yellowrow" >

				<th class="odd" width="150">
				</th>
				<th width="150">
					Saved
				</th>
				<th width="150">
					Trial
				</th>
				<th class="odd">
				</th>

			</tr>

			<tr class="centeralign">
				<th class="smallish" >
					Above break line
				</th>
				<td></td>
				<td></td>
			</tr>
			<tr>
				<td> Avg Pref
				</td>
				<td class="even" id="SavedAvgAbove"><% sprintf("%.1f", $avg_pref[1]) %></td>
				<td class="even" id="AvgAbove"></td>
			</tr>
			<tr>
				<td>Worst Pref
				</td>
				<td class="even" id="SavedWorstAbove"><% sprintf("%.1f", $worst_pref[1]) %></td>
				<td class="even" id="WorstAbove"></td>
			</tr>
			<tr>
				<td>Avg Mut
				</td>
				<td class="even" id="SavedAvgMutAbove"><% sprintf("%.1f", $avg_mut[1]) %></td>
				<td class="even" id="AvgMutAbove"></td>
			</tr>
			<tr>
				<td>Worst Mut
				</td>
				<td class="even" id="SavedWorstMutAbove"><% sprintf("%.1f", $worst_mut[1]) %></td>
				<td class="even" id="WorstMutAbove"></td>
			</tr>
			<tr>
				<td>Over Target
				</td>
				<td class="even" id="SavedPanelsOverAbove"></td>
				<td class="even" id="PanelsOverAbove"></td>
			</tr>
			<tr>
				<td>+1 SD
				</td>
				<td class="even" id="SavedPlus1SDAbove"></td>
				<td class="even" id="Plus1SDAbove"></td>
			</tr>
			<tr>
				<td>+2 SD
				</td>
				<td class="even" id="SavedPlus2SDAbove"></td>
				<td class="even" id="Plus2SDAbove"></td>
			</tr>

			<tr class="centeralign">
				<th class="smallish" >
					At break line
				</th>
				<td></td>
				<td></td>

			</tr>
			<tr>
				<td>Avg Pref
				</td>
				<td class="even" id="SavedAvgAt"><% sprintf("%.1f", $avg_pref[2]) %></td>
				<td class="even" id="AvgAt"></td>
			</tr>
			<tr>
				<td>Worst Pref
				</td>
				<td class="even" id="SavedWorstAt"><% sprintf("%.1f", $worst_pref[2]) %></td>
				<td class="even" id="WorstAt"></td>
			</tr>
			<tr>
				<td>Avg Mut
				</td>
				<td class="even" id="SavedAvgMutAt"><% sprintf("%.1f", $avg_mut[2]) %></td>
				<td class="even" id="AvgMutAt"></td>
			</tr>
			<tr>
				<td>Worst Mut
				</td>
				<td class="even" id="SavedWorstMutAt"><% sprintf("%.1f", $worst_mut[2]) %></td>
				<td class="even" id="WorstMutAt"></td>
			</tr>
			<tr>
				<td>Over Target
				</td>
				<td class="even" id="SavedPanelsOverAt"></td>
				<td class="even" id="PanelsOverAt"></td>
			</tr>
			<tr>
				<td>+1 SD
				</td>
				<td class="even" id="SavedPlus1SDAt"></td>
				<td class="even" id="Plus1SDAt"></td>
			</tr>
			<tr>
				<td>+2 SD
				</td>
				<td class="even" id="SavedPlus2SDAt"></td>
				<td class="even" id="Plus2SDAt"></td>
			</tr>

			<tr class="centeralign">
				<th class="smallish" >
					BELOW break line
				</th>
				<td></td>
				<td></td>

			</tr>
			<tr>
				<td>Avg Pref
				</td>
				<td class="even" id="SavedAvgBelow"><% sprintf("%.1f", $avg_pref[3]) %></td>
				<td class="even" id="AvgBelow"></td>
			</tr>
			<tr>
				<td>Worst Pref
				</td>
				<td class="even" id="SavedWorstBelow"><% sprintf("%.1f", $worst_pref[3]) %></td>
				<td class="even" id="WorstBelow"></td>
			</tr>
			<tr>
				<td>Avg Mut
				</td>
				<td class="even" id="SavedAvgMutBelow"><% sprintf("%.1f", $avg_mut[3]) %></td>
				<td class="even" id="AvgMutBelow"></td>
			</tr>
			<tr>
				<td>Worst Mut
				</td>
				<td class="even" id="SavedWorstMutBelow"><% sprintf("%.1f", $worst_mut[3]) %></td>
				<td class="even" id="WorstMutBelow"></td>
			</tr>
			<tr>
				<td>Over Target
				</td>
				<td class="even" id="SavedPanelsOverBelow"></td>
				<td class="even" id="PanelsOverBelow"></td>
			</tr>
			<tr>
				<td>+1 SD
				</td>
				<td class="even" id="SavedPlus1SDBelow"></td>
				<td class="even" id="Plus1SDBelow"></td>
			</tr>
			<tr>
				<td>+2 SD
				</td>
				<td class="even" id="SavedPlus2SDBelow"></td>
				<td class="even" id="Plus2SDBelow"></td>
			</tr>

			<tr class="centeralign">
				<th class="smallish" >
					Commitment Use
				</th>
				<td></td>
				<td></td>
			</tr>
			<tr>
				<td colspan="3" >Rounds of judging needed for future prelims in judge category <% $event->category->abbr %>:
				<label id="future_category_need"><% $needed_judges_future %></label>
				</td>
			</tr>
			<tr>
				<td>Rounds Lost/Left for event
				</td>
				<td class="even" id="SavedRdsLost"><% $lost_rounds_current %>/<% $category_rds_left %></td>
				<td class="even" id="RdsLost"></td>
			</tr>
			<tr>
				<td>Avg Pref Left
				</td>
				<td class="even" id="SavedPrefLeft"><% sprintf("%.1f", $tot_pref/$tot_rds) %></td>
				<td class="even" id="PrefLeft"></td>
			</tr>
			<tr>
				<td>Burned judges
				</td>
				<td class="even" id="SavedBurnedCurrent"><% $assigned_to_last %></td>
				<td class="even" id="BurnedCurrent"></td>
			</tr>
			<tr>
				<td>Top-50% Burned judges
				</td>
				<td class="even" id="SavedBurnedTop50"><% $burned_top50 %></td>
				<td class="even" id="BurnedTop50"></td>
			</tr>
			<tr>
				<td>Total Bodies left for event
				</td>
				<td class="even" id="SavedBodiesLeft"><% $live_bodies_left %></td>
				<td class="even" id="BodiesLeft"></td>
			</tr>


		</table>

		<h4>Current Pairings</h4>

		<& "/funclib/tablesorter.mas", table => "current_pairing" &>

		<table class="narrow" id="current_pairing" >
<!--
				<a onclick='current_diagnostics()' >Run Diagnostics on Pairings Below</a>
				<a onclick='judge_test()' >Test Judge Placement</a>
-->
		<thead>
		<tr class="yellowrow smallish" >
		<th class="centeralign" <% $debug_display %>>panel</th>
		<th class="centeralign" <% $debug_display %>>aff ID</th>
		<th class="centeralign" >Aff</th>
		<th class="centeralign" <% $debug_display %>>neg ID</th>
		<th class="centeralign" >Neg</th>
%		for my $i (1 .. $n_judges) {
 		  <th class="centeralign" <% $debug_display %>>Judge <% $i %> ID</th>
   		  <th>Judge <% $i %> Name</th>
   		  <th class="centeralign" <% $debug_display %>>Judge <% $i %> Pref 1</th>
  		  <th class="centeralign" <% $debug_display %>>Judge <% $i %> Pref 2</th>
  		  <th class="centeralign" <% $debug_display %>>Judge <% $i %> Mut</th>
%		}
		<th class="centeralign" >Avg</th>
		<th class="centeralign" >Balance</th>
		<th class="centeralign" >Break <br /> Line</th>
		</tr>
		</thead>
		<tbody class="smallish">
%		my %live_panels;
%		foreach my $panel (@panels) {

%			my $co;	my $pan_tot; my $pan_ct; my $pan_bal; my $ctr;
%			my @showed_side;
%			my @ballots = Tab::Ballot->search( panel => $panel->id);
%			@ballots = sort {$a->side cmp $b->side} @ballots;
%			my $aff; my $neg;

%			if ( $panel->bye == 0 and scalar(@ballots)>1 ) {
%				$live_panels{$panel->id} = 1;
				<tr id="pairing_panel<% $panel->id %>" >
				<td <% $debug_display %>><% $panel->id %></td>
%					foreach my $ballot (@ballots) {
%						if ( $break_line ==  $entry_losses{$ballot->entry} ) { $co = 2; }
%						if ( $break_line >  $entry_losses{$ballot->entry} and ($co == 0 or $co == 1) ) { $co = 1; }
%						if ( $break_line <  $entry_losses{$ballot->entry} and ($co == 0 or $co == 3) ) { $co = 3; }
%						if ($round->type eq "elim") { $co = 2; }
%						if ( $showed_side[$ballot->side] != 1 ) {
							<td <% $debug_display %>><% $ballot->entry %></td>

							<td title="<% $entry_code{$ballot->entry} %>">
								<span class="threequarters nowrap padless marno">
									<% substr($entry_code{$ballot->entry}, 0, 24) %>
								</span>
								<span class="fifth nospace nowrap padleft rightalign">
									<% $entry_wins{$ballot->entry} %>-<% $entry_losses{$ballot->entry} %></td>
								</span>
							</td>
<%perl>
							$showed_side[$ballot->side] = 1;
							if ( $ballot->side == 1 ) { $aff=$ballot->entry; }
							if ( $ballot->side == 2 ) { $neg=$ballot->entry; }
						}
					}

					foreach my $ballot (@ballots) {
						if ($ballot->side == 1 ) {
							$ctr++;
							$showed_side[$ballot->side] = 1;
</%perl>
							<td <% $debug_display %> id="<% $panel %>Judge<% $ctr %>ID"><% $ballot->judge %></td>

							<td id=<% $panel %>Judge<% $ctr %>Name>
								<% $judge{$ballot->judge}{'name'} %><br>
								<% $pref_record{$ballot->judge}{$panel->id}{"display"} %>
							</td>
%							my ($pref1, $pref2, $mut) = prefdata( $pref_record{$ballot->judge}{$panel->id}{"display"} ) ;
							<td <% $debug_display %> id="<% $panel %>Judge<% $ctr %>Pref1"><% $pref1 %></td>
							<td <% $debug_display %> id="<% $panel %>Judge<% $ctr %>Pref2"><% $pref2 %></td>
							<td <% $debug_display %> id="<% $panel %>Judge<% $ctr %>Mut"><% sprintf("%.1f", $mut) %></td>
%						}
%					}

%					if ($ctr < $n_judges ) {
%						for my $i ($ctr+1 .. $n_judges) {
							<td <% $debug_display %> id="<% $panel %>Judge<% $i %>ID">0</td>
							<td id=<% $panel %>Judge<% $i %>Name>
								Unassigned
							</td>
							<td <% $debug_display %> id="<% $panel %>Judge<% $i %>Pref1">0</td>
							<td <% $debug_display %> id="<% $panel %>Judge<% $i %>Pref2">0</td>
							<td <% $debug_display %> id="<% $panel %>Judge<% $i %>Mut">0</td>
%					    }
%					}

					<td class="centeralign" id="<% $panel %>Avg">
%						printf("%.1f", (($pref_record{$panel->id}{$aff} + $pref_record{$panel->id}{$neg})/($n_judges*2) ) )
%							if $n_judges;
					</td>
					<td class="centeralign" id="<% $panel %>Bal">
%						printf("%.1f", $pref_record{$panel->id}{"diff"});
					</td>
					<td class="centeralign" id="<% $panel %>Cohort"><% $cohort[$co] %></td>
%				}
%			}
		</tbody>
		</table>

		<a onclick='display_toggle("judge_use")' >Show/Hide Judge Data detail table</a><br>
		<a onclick='display_toggle("STAData")' >Show Pref Data detail table</a>

		<table style='display:none;' id="judge_use">
			<caption>
			Judge Use Situation <a onclick='judge_diagnostics()' >Run Diagnostics on Judge Data Below</a>
			</caption>
			<tr>
				<td>0 - ID</td>
				<td>1 - Judge</td>
				<td>2 - Avg Rating</td>
				<td>3 - Obligation</td>
				<td>4 - Available for Current RD</td>
				<td>5 - Saved: Judged so far</td>
				<td>6 - Saved: Oblig Left</td>
				<td>7 - Saved: Future Possible</td>
				<td>8 - Saved: Assigned to this rd</td>
				<td>9 - Saved: Assigned elsewhere in timeslot</td>
				<td>10 - Display: Assigned</td>
				<td>11 - Display: Oblig Left</td>
				<td>12 - Display: Lost</td>
				<td>13 - Display: Lost Current</td>
  				<td>14 - Struck in other events</td>
				<td>14 - Diverse</td>
			</tr>
%		foreach my $judges (@judge_ref) {
%			my $key = $judges->id;
			<tr id="Judge<% $judges->id %>" >
				<td><% $key %></td>
				<td><% $judge{$judges->id}{'name'} %></td>
				<td id="<% $judges->id%>Rating" ><% $judge{$judges->id}{'avg_pref'} %></td>
				<td id="<% $judges->id%>Oblig" ><% ${$judge_hash}{$key}{'oblig'} %></td>
				<td><% ${$judge_hash}{$key}{'avail_current'} %></td>
%				my $judged_already = ${$judge_hash}{$key}{'judged_already'};
%				$judged_already = 0 unless $judged_already;

				<td><% $judged_already %></td>

				<td
					id="<% $judges->id%>ObligLeft"
				><% ${$judge_hash}{$key}{'oblig'} - ${$judge_hash}{$key}{'judged_already'} %></td>

				<td id="<% $judges->id%>FutPoss"><% ${$judge_hash}{$key}{'future_possible'} %></td>

				<td>
%					my $assign_to_rd = ${$judge_hash}{$key}{'in_round'};
%					$assign_to_rd = 0 unless $assign_to_rd;
					<% $assign_to_rd %>
				</td>

				<td>
%					my $in_other_event = ${$judge_hash}{$key}{'in_timeslot'};
%					if ($assign_to_rd == 1) { $in_other_event = 0; }
%					$in_other_event = 0 unless $in_other_event;
					<% $in_other_event %>
				</td>

				<td id="<% $key %>DisplayAssigned">0</td>
				<td id="<% $key %>DisplayObligLeft">0</td>
				<td id="<% $key %>DisplayLost">0</td>
				<td><% ${$judge_hash}{$key}{'lost_current'} %></td>
				<td><% $struck_in_other_events{$judges->id} %></td>
				<td><% $judge{$judges->id}{'diverse'}  %></td>
    			</tr>
%			}

		</table>

%		$page_end = time(); if ($debug_time) {
		Total time before STA Data Table: <% printf("%.2f\n", $page_end - $page_start) %>
%		}

		<table style='display:none;' id="STAData">
			<caption>
				STA Data
			</caption>
			<tr>
				<td>Judge ID</td>
				<td>Judge Name</td>
				<td>Panel ID</td>
				<td>Pref 1</td>
				<td>Pref 2</td>
				<td>MutualPref</td>
				<td>Below Max</td>
				<td>Panel Impact</td>
			</tr>
%		foreach my $judges (@judge_ref) {
%			my $key = $judges->id;
%			foreach my $panel (@panels) {
%				if ( $live_panels{$panel->id} == 1 ) {
					<tr id="STA<% $key %>-<% $panel->id %>">
						<td><% $key %></td>
						<td><% $judge{$judges->id}{'name'} %> </td>
						<td><% $panel->id %></td>

<%perl>
						my $pref1 = $all_pref{$pan_entry{$panel->id}{1}."-".$key};
						my $pref2 = $all_pref{$pan_entry{$panel->id}{2}."-".$key};
						if ( $pref1 == 0 && $pref2 == 0 && $default_mjp == -1 ) { $pref1 = 1; $pref2=1; }
						if ( $pref1 == 0 && $default_mjp == -1 ) { $pref1 = $pref2; }
						if ( $pref1 == 0 && $default_mjp > 0 ) { $pref1 = $default_mjp; }
						if ( $pref2 == 0 && $default_mjp == -1 ) { $pref2 = $pref1; }
						if ( $pref2 == 0 && $default_mjp > 0 ) { $pref2 = $default_mjp; }
</%perl>
						<td><% $pref1 %></td>
						<td><% $pref2 %></td>
						<td>Magic Number</td>
%						my $dummy = $pref1;
%						if ( $pref2 > $pref1 ) { $dummy = $pref2; }
						<td><% $dummy %></td>
%						my $mut = $pref1 - $pref2;
%						$mut = sprintf("%.1f", $mut);
						<td><% $mut %></td>
					</tr>
%				}
%			}
%		}

		</table>

		revised 9/29/16
%		$page_end = time(); if ($debug_time) {
		Total time after tables rendered: <% printf("%.2f\n", $page_end - $page_start) %>
%		}
%		}

	</div>
