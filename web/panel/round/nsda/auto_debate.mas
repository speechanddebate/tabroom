<%args>
	$tourn
	$tourn_settings
	$round
	$person
	$limit_to
</%args>
<%init> 

	use List::Util 'shuffle';

	my $event = $round->event;
	my %event_settings = $event->all_settings;

	logMe("Round paired by ".$person->email.": ".$person->first." ".$person->last);

	my $previous_round = Tab::Round->search( 
		event => $event->id, 
		name => ($round->name - 1)
	)->first;

	my @results = $m->comp(
		 "/tabbing/results/order_entries.mas",
		 round => $previous_round,
	) if $previous_round; 

	my $ref = pop @results if @results;

	my %entries = %{$ref} if $ref;

	my $no_brackets;

	if ($tourn_settings->{"nsda_nats"} && $previous_round) { 
		$no_brackets++ if $previous_round->type eq "prelim";
	}

	# Get the final debate tiebreaker set
	my $final_tiebreak_set = Tab::TiebreakSet->search(
		tourn => $tourn->id,
		name => "Debate Final"
	)->first;

	# Get the number of qualifiers for the little dance at the end

	my ($total_quals, $alternates, $total_entries) = 
		$m->comp("/funclib/nsda_qualifier_count.mas", event => $event);

	$total_quals = 2 if $tourn_settings->{"nsda_nats"};

	# Acquire the relevant opponent data

	my $dbh = Tab::DBI->db_Main();

	my %scores = (
		bracket  => "1000000000000000",
		school   => "1000000000000",
		repeat   => "1000000000",
		state    => "1000000",
		side     => "1000",
		district => "10"
	);

	$scores{"state"} = 1000000000000 if $tourn_settings->{"nsda_nats"};

	undef $scores{"state"} 
		if $round->name >= $event_settings{"state_constraint_threshold"}
		&& (defined $event_settings{"state_constraint_threshold"});

	$scores{"side"} = 0 
		if $event_settings{"no_side_constraints"};

	$entries{"scores"} = \%scores;

	my %entry_losses = $m->comp(
		"/funclib/entry_losses.mas", 
		event => $event,
		round => $previous_round
	);

	my @outs; 

	my %round_schools =
		map {$_->id => $_} 
		$m->comp( "/funclib/round_schools.mas", round => $previous_round)
		if $tourn_settings->{"nsda_nats"} && $previous_round;

	KEY:
	foreach my $key (
		sort {$a <=> $b} keys %{$entries{"by_place"}}
	) {

		ENTRY:
		foreach my $entry_id (@{${$entries{"by_place"}}{$key}}) {

			my $school_id = $entries{"school_id"}{$entry_id};
				
			if (scalar (keys %{$entries{"unpaired"}}) >= $limit_to ) { 

				push @outs, $entry_id;
				next ENTRY;
			}

			$entries{"unpaired"}{$entry_id}++;

			$entries{"school_size"}{$school_id}++;
			
			my $losses = $entries{"tiebreak"}{1}{$entry_id};

			$losses = 0 if $no_brackets;

			push @{$entries{"brackets"}{$losses}}, $entry_id;

			$entries{$entry_id}{"losses"} = $losses;
		
			if ($tourn_settings->{"nsda_nats"} && $school_id) { 
			
				$entries{"district"}{$entry_id} = 
					$round_schools{$school_id}->districtid;

				$entries{"state"}{$entry_id} = 
					$round_schools{$school_id}->regionid;
			}
		}
	}

    my $school_debates_self++ 
		if $event_settings{"school_debates_self"};

	my $ballot_sth = $dbh->prepare('
		select distinct 
			entry.id, 
			opponent.id, opponent.school,
			round.name,
			ballot.bye, panel.bye, ballot.side

		from (entry, ballot, panel, round)

		left join ballot opp_ballot on 
			opp_ballot.panel = panel.id
			and opp_ballot.entry != entry.id

		left join entry opponent on 
			opponent.id = opp_ballot.entry
			and opponent.id != entry.id

		where entry.event = ?
		and entry.active = 1
		and entry.id = ballot.entry
		and ballot.panel = panel.id
		and panel.round = round.id
		and round.name < ? 
	');

	$ballot_sth->execute($event->id, $round->name);

	while( 
		my (
			$entry_id, $opp_id, $opp_school, 
			$round_name, 
			$ballot_bye, $panel_bye, 
			$ballot_side
		)
		= $ballot_sth->fetchrow_array() 
	) {

		$entries{$entry_id}{"byes"}++ if $panel_bye;
		next if ($panel_bye);

		$entries{$entry_id}{"hits"}{$opp_id}++;
		$entries{$entry_id}{"hit_school"}{$opp_school}++;
		$entries{$entry_id}{"side_count"}{$ballot_side}++;

		$entries{$entry_id}{$round_name}{"opp"} = $opp_id;
		$entries{$entry_id}{$round_name}{"side"} = $ballot_side;
		push @{$entries{$entry_id}{"opponents"}}, $opp_id;
	}

	our $round_log;
	our $step_counter;

	# PAIR THE DEBATES

	my %panels;

	my $selected_bye;

	# CHECK FOR CONDITIONS INDICATING DONE-NESS
	my $num_entries = scalar (keys %{$entries{"unpaired"}});

	my $bye_to_undefeated;
	my $draw_two_byes;

	my $done_pairing;

	if ($total_quals < 3 && $num_entries == 3) { 
		$bye_to_undefeated++;
	}

	if (
		($num_entries == 4 && $total_quals == 3) 
		|| ($num_entries == 5 && $total_quals == 4) 
	) { 

		if ($previous_round->type eq "elim") { 

			# Triggers the below rule about 2 entries bying to nationals
			$num_entries = 2; 

			my %entry_losses = $m->comp(
				"/funclib/entry_losses.mas", 
				round => $previous_round,
				event => $event
			);

			KEY:
			foreach my $key (sort {$a <=> $b} keys %{$entries{"by_place"}}) {

				ENTRY:
				foreach my $entry_id (@{${$entries{"by_place"}}{$key}}) {

					if ($entries{"tiebreak"}{1}{$entry_id} != 1) { 

						if ($entry_losses{$entry_id} == 0) { 

							# The undefeated has lost.  Per rule 3/b/1 we are done!
							$previous_round->tiebreak_set($final_tiebreak_set->id);
							$previous_round->type("final");
							$previous_round->update;

							my $msg = "As the undefeated lost their debate, we have 3 qualifiers";
							$m->redirect("/tabbing/results/nsda_qualifiers.mhtml?event_id=".$event->id."&msg=$msg");


						} else { 
							push @outs, $entry_id;
						}

					} 
				
				}

			}

		} else { 

			my $elim_tiebreak_set = Tab::TiebreakSet->search(
				tourn => $tourn->id,
				name => "Debate Elim"
			)->first;

			$round->tiebreak_set($elim_tiebreak_set->id);
			$round->type("elim");
			$round->update();
			$bye_to_undefeated++;
		}

	}

	if (
		($num_entries == 2 && $total_quals == 3)
		|| ($num_entries == 3 && $total_quals == 4)
	) { 

		# Runoff among the losers of the previous round; everyone else byes to
		# nationals

		$round->tiebreak_set($final_tiebreak_set->id);
		$round->type("final");
		$round->update();

		foreach my $bye_id (keys %{$entries{"unpaired"}} ) {
			$panels{$bye_id}{"opponent"} = "BYE";
		}

		@outs = shuffle(@outs);

		my $one = shift @outs if @outs;
		my $two = shift @outs if @outs;

		unless ($event_settings{"no_side_constraints"}) { 

			my $one_diff = $entries{$one}{"side_count"}{1} - $entries{$one}{"side_count"}{2};
			my $two_diff = $entries{$two}{"side_count"}{1} - $entries{$two}{"side_count"}{2};

			if ($two_diff < $one_diff) { 
				my $stop = $two;
				$two = $one;
				$one = $stop;
			}

		}

		$panels{$one}{"opponent"} = $two;
		$panels{$one}{"side"} = 1;
		$panels{$one}{"bracket"} = 1;

		$panels{$two}{"opponent"} = $one;
		$panels{$two}{"side"} = 2;
		$panels{$two}{"bracket"} = 1;

		$done_pairing++;

	}

	if (
		($total_quals == 3 && $num_entries == 5)
		|| ($total_quals == 4 && $num_entries == 7)
		|| ($total_quals == 4 && $num_entries == 6)
	) { 

		$bye_to_undefeated++;
		$draw_two_byes++ if $num_entries == 6;


		$round->tiebreak_set($final_tiebreak_set->id);
		$round->type("final");
		$round->update();

	}

	# STEP ONE: DRAW THE BYE

	unless ($done_pairing) { 

		if ($num_entries % 2 || $draw_two_byes) {

			my @selected_byes; 

			if ($bye_to_undefeated) { 

				my $byes = 1;
				$byes++ if $draw_two_byes;

				logMe("Drawing $byes bye; $num_entries triggers late round rules: bye first to undefeateds");

				my @bye_eligible;
				my $log_message;

				# First, undefeated entries that have not drawn a bye

				foreach my $entry_id (@{$entries{"brackets"}{0}}) { 
					next if $entries{$entry_id}{"byes"} > 0;
					push @bye_eligible, $entry_id;
				}

				# Next, all undefeateds if that wasn't enough 

				if ( (scalar @bye_eligible) < $byes) { 

					# Undefeateds without byes automatically get byes if they
					# exist. 
					$log_message = "Drawing from undefeateds";

					push @selected_byes, @bye_eligible if @bye_eligible;

					foreach my $entry_id (@{$entries{"brackets"}{0}}) { 
						push @bye_eligible, $entry_id;
					}

				} else { 

					$log_message = "Drawing from undefeateds without a bye";

				}

				# If there are insufficient undefeateds, draw from everyone not
				# debating a bye.

				if ( (scalar @bye_eligible) < $byes ) { 

					$log_message = "There are no undefeateds; drawing among one-loss entries without a bye";

					# Undefeateds automatically get byes if they exist. 
					push @selected_byes, @bye_eligible if @bye_eligible;

					foreach my $entry_id (@{$entries{"brackets"}{1}}) { 
						next if $entries{$entry_id}{"byes"} > 0;
						push @bye_eligible, $entry_id;
					}
				}

				# If there are still insufficient byes, everyone is eligible

				if ( (scalar @bye_eligible) < $byes) { 

					$log_message = "All one-loss teams have drawn a bye; drawing among them all";

					# Those without byes automatically get byes if they exist. 
					push @selected_byes, @bye_eligible if @bye_eligible;

					push @bye_eligible, @{$entries{"brackets"}{1}};

				}

				logMe($log_message) if $log_message;

				# Pick as many byes as you need from the leftovers. 

				@bye_eligible = shuffle(@bye_eligible);

				my %already = map {$_ => 1} @selected_byes;

				while ( 
					   ( (scalar @selected_byes) < $byes)
					&& ( (scalar @bye_eligible) > 0 )
				) { 

					my $candidate = shift @bye_eligible;
					next if $already{$candidate};
					push @selected_byes, $candidate;
				}

			} else { 

				logMe("Drawing a bye; $num_entries is odd:");

				my @bye_eligible;

				# First, one-loss entries who lost to an undefeated and have not
				# drawn a bye.

				ENTRY:
				foreach my $entry_id (@{$entries{"brackets"}{1}}) { 


					next if $entries{$entry_id}{"byes"} > 0;

					my $undefeated_loss;

					foreach my $opponent (@{$entries{$entry_id}{"opponents"}}) { 

						$undefeated_loss++ unless $entry_losses{$opponent} > 0;
						last if $undefeated_loss;
					}

					next unless $undefeated_loss;
					push @bye_eligible, $entry_id;
					
				}

				unless (@bye_eligible) { 

					my $message = " No entries without a bye have lost to an undefeated entry. ";
					$message .= "Drawing from all entries without a bye";

					logMe($message);

					ENTRY:
					foreach my $entry_id (@{$entries{"brackets"}{1}}) { 

						next if $entries{$entry_id}{"byes"};
						push @bye_eligible, $entry_id;
					
					}

					unless (@bye_eligible) { 
						foreach my $entry_id (@{$entries{"brackets"}{0}}) { 

							next if $entries{$entry_id}{"byes"};
							push @bye_eligible, $entry_id;
						
						}
					}
				}

				my $eligibles;

				foreach my $entry_id (@bye_eligible) {
					$eligibles .= ", " if $eligibles;
					$eligibles .= $entries{"code"}{$entry_id};
				}

				logMe("Entries eligible for byes: $eligibles");

				@bye_eligible = shuffle(@bye_eligible);
				push @selected_byes, shift @bye_eligible;

			}

			foreach my $selected_bye (@selected_byes) { 

				logMe("Selected ".$entries{"code"}{$selected_bye}." as a BYE");

				$panels{$selected_bye}{"opponent"} = "BYE"; 
				$panels{$selected_bye}{"bracket"} = "1";
			}

			# Remove bye from the brackets;

			delete($entries{"unpaired"}{$selected_bye});

			my $index;  

			my $bye_bracket = $entries{$selected_bye}{"losses"};

			$index++ until (
				(${$entries{"brackets"}{$bye_bracket}}[$index] == $selected_bye)
				|| ($index > scalar @{$entries{"brackets"}{$bye_bracket}})
			);

			splice(@{$entries{"brackets"}{$bye_bracket}}, $index, 1); 

			foreach my $bracket (0 .. 1) { 

				my $bracket_string;

				foreach my $id (@{$entries{"brackets"}{$bracket}}) { 
					$bracket_string .= ", " if $bracket_string;
					$bracket_string .= $entries{"code"}{$id};
				}

				$bracket_string = " $bracket loss bracket is now: ".$bracket_string;
				logMe($bracket_string);
			}

		} else { 

			logMe("No bye need be drawn; $num_entries entries");

		}

		# STEP TWO: PAIR THE BRACKETS!

		# Score every entry against every opponent:

		foreach my $bracket (0 .. 1) { 

			foreach my $entry (@{$entries{"brackets"}{$bracket}}) {

				my $notfirst;

				foreach my $opponent (keys %{$entries{"unpaired"}}) { 

					next if $opponent == $entry;

					# Me on the aff
					unless ($entries{"scores"}{$entry}{$opponent})  { 
						$entries{"scores"}{$entry}{$opponent} 
							= scoreDebate($entry, $opponent, \%entries);
					}

					# Me on the neg
					unless ($entries{"scores"}{$opponent}{$entry})  { 
						$entries{"scores"}{$opponent}{$entry} 
							= scoreDebate($opponent, $entry, \%entries);
					}
					
				}

			} 

		} 

		foreach my $bracket (0 .. 1) { 

			logMe(" Pairing $bracket loss bracket into debates ");

			# Assign initial opponents

			foreach my $entry (shuffle (@{$entries{"brackets"}{$bracket}}) ) { 

				next if $panels{$entry}{"opponent"};

				my $chosen;
				my $entry_side;

				# First, find the best possible matchup left on the aff. 

				my @opponents = 
					sort { 
						$entries{"scores"}{$entry}{$a} 
							<=> 
						$entries{"scores"}{$entry}{$b} 
					} keys (%{$entries{"unpaired"}});

				my $aff_opponent;

				foreach my $opp (@opponents) { 
					next if $opp == $entry;
					next if $panels{$opp}{"opponent"};
					$aff_opponent = $opp;
					last;
				}

				if ($event_settings{"no_side_constraints"}) { 

					$chosen = $aff_opponent;
					$entry_side = 1;

				} else { 

					# Now try the other side

					my @opponents = 
						sort { 
							$entries{"scores"}{$a}{$entry} 
								<=> 
							$entries{"scores"}{$b}{$entry}
						} keys (%{$entries{"unpaired"}});

					my $neg_opponent;

					foreach my $opp (@opponents) { 
						next if $opp == $entry;
						next if $panels{$opp}{"opponent"};
						$neg_opponent = $opp;
						last;
					}

					$chosen = $aff_opponent unless $neg_opponent;
					$chosen = $neg_opponent unless $aff_opponent;

					unless ($chosen) { 

						$chosen = $aff_opponent;

						if ($entries{"scores"}{$entry}{$aff_opponent} 
							< $entries{"scores"}{$neg_opponent}{$entry}
						) { 

							$chosen = $aff_opponent;
							$entry_side = 1;

						} elsif ($entries{"scores"}{$entry}{$aff_opponent} 
							> $entries{"scores"}{$neg_opponent}{$entry}
						) { 

							$chosen = $neg_opponent;
							$entry_side = 2;

						} else { 

							# Flip the proverbial coin, all else being equal

							if (int(rand(100)) > 50) { 

								$chosen = $aff_opponent;
								$entry_side = 1;

							} else { 

								$chosen = $neg_opponent;
								$entry_side = 2;

							}
						}
					}
				}

				unless ($chosen) { 

					logMe("Something has gone wrong: no opponent found for ".$entries{"code"}{$entry});

				} else { 

					$panels{$entry}{"side"} = $entry_side;
					$panels{$entry}{"opponent"} = $chosen;
					$panels{$entry}{"bracket"} = $bracket;

					my $chosen_side = $entry_side - 1;
					$chosen_side = 2 if $chosen_side < 1;

					$panels{$chosen}{"side"} = $chosen_side;
					$panels{$chosen}{"opponent"} = $entry;
					$panels{$chosen}{"bracket"} = $bracket;

				}

			}

			foreach my $entry (shuffle (@{$entries{"brackets"}{$bracket}}) ) { 

				my $opp = $panels{$entry}{"opponent"};
				next if $entries{$opp}{"losses"} < $bracket;

				my $entry_side = $panels{$entry}{"side"};

				my $score = $entries{"scores"}{$entry}{$opp} if $entry_side == 1;
				$score = $entries{"scores"}{$opp}{$entry} if $entry_side == 2;

				logMe($entries{"code"}{$entry}." debates ".$entries{"code"}{$opp}.
					" on ".$entry_side." with score $score");

			}

			logMe("Trying double shuffles to see if any improvements can be made");

			# Do swapping to ensure the best overall scoring of pairings 

			foreach my $pass ( 1 .. 20) { 
			
				my $swap_counter; 

				foreach my $entry (shuffle (@{$entries{"brackets"}{$bracket}}) ) { 

					my $entry_side = $panels{$entry}{"side"};
					my $entry_opponent = $panels{$entry}{"opponent"};

					# You may not make a switch that affects a better bracket
					next if $entries{$entry_opponent}{"losses"} < $bracket;

					# This shouldn't happen but what the hell, let's check. 
					next if $entry_opponent eq "BYE";

					my $entry_opponent_side = $panels{$entry_opponent}{"side"};

					my $entry_baseline = $entries{"scores"}{$entry}{$entry_opponent} 
						if $entry_side == 1;

					$entry_baseline = $entries{"scores"}{$entry_opponent}{$entry} 
						if $entry_side == 2;

					# Do this because the 0 loss bracket can pull up different debaters
					# to solve conflicts; but the 1 loss bracket cannot solve conflicts
					# from the 0 loss bracket. 

					my $swap_candidate; 
					my $current_diff;

					my $entry_bracket = $entries{$entry}{"losses"};

					foreach my $other (shuffle (@{$entries{"brackets"}{$entry_bracket}}) ) { 

						next if $other == $entry;
						next if $other == $entry_opponent;

						my $other_opponent = $panels{$other}{"opponent"};
						next if $other_opponent eq "BYE";
						next if $entries{$other_opponent}{"losses"} < $bracket;

						# This is the point of comparison for any swapping

						# How does the candidate score if they go into my spot?

						my $other_swap;

						$other_swap = $entries{"scores"}{$other}{$entry_opponent} 
							if $entry_side == 1;

						$other_swap = $entries{"scores"}{$entry_opponent}{$other} 
							if $entry_side == 2;

						my $entry_swap;
						my $other_baseline;

						# If the swapee already has an opponent, test the converse too

						if ($other_opponent) { 
						
							my $other_side = $panels{$other}{"side"};

							$other_baseline = $entries{"scores"}{$other}{$other_opponent} 
								if $other_side == 1;

							$other_baseline = $entries{"scores"}{$other_opponent}{$other} 
								if $other_side == 2;

							$entry_swap = $entries{"scores"}{$entry}{$other_opponent} 
								if $entry_side == 1;

							$entry_swap = $entries{"scores"}{$other_opponent}{$entry} 
								if $entry_side == 2;

						} 

						my $swap_total = $entry_swap + $other_swap;
						my $baseline_total = $entry_baseline + $other_baseline;

						my $swap_diff = $baseline_total - $swap_total;

						# Only track swaps that improve scores because
						# there's no reason to keep going if we're only doing
						# zero-score swaps. 

						if ($swap_diff > $current_diff) { 
							$swap_counter++;
						}

						# If the swapped scores are equal better than the current
						# baseline, nominate the entry for a swap. 

						# The swapping if the scores are equal is order to set up
						# some random rematching for future swap attempts 

						if ($swap_diff >= $current_diff) { 
						
							$swap_candidate = $other; 
							$current_diff = $swap_diff;
						}

					}

					# An entry was found which improves the overall score, so swap
					# them. 

					if ($swap_candidate) { 
					
						my $swap_opponent = $panels{$swap_candidate}{"opponent"};
						my $swap_side = $panels{$swap_candidate}{"side"};
						my $swap_bracket = $panels{$swap_candidate}{"bracket"};
						my $entry_bracket = $panels{$entry}{"bracket"};

						if ($swap_opponent) { 

							$panels{$entry}{"opponent"} = $swap_opponent;
							$panels{$entry}{"bracket"} = $swap_bracket;
							$panels{$entry}{"side"} = $swap_side;
							$panels{$swap_opponent}{"opponent"}  = $entry;

						} else { 

							undef $panels{$entry}{"opponent"};
							undef $panels{$entry}{"bracket"};
							undef $panels{$entry}{"side"};
						}

						if ($entry_opponent) { 

							$panels{$swap_candidate}{"opponent"} = $entry_opponent;
							$panels{$swap_candidate}{"bracket"} = $entry_bracket;
							$panels{$swap_candidate}{"side"} = $entry_side;
							$panels{$entry_opponent}{"opponent"}  = $swap_candidate;

						} else { 

							undef $panels{$swap_candidate}{"opponent"};
							undef $panels{$swap_candidate}{"bracket"};
							undef $panels{$swap_candidate}{"side"};

						}

					}
				}

				last unless $swap_counter > 0;

			}
		}

	}
	
	# Write out the resulting debates

	my %done; 

	# Oh the irony!
	my $letter = 1; 

	my $standard_side;

	foreach my $entry (
		sort {$panels{$a}{"bracket"} <=> $panels{$b}{"bracket"} } 
		keys %panels
	) { 

		next unless $entry;

		next if $done{$entry}++;

	 	next if (
			($panels{$entry}{"opponent"} ne "BYE")
			&& $done{$panels{$entry}{"opponent"}}++
		);

		my $side = $panels{$entry}{"side"};
		my $opp  = $panels{$entry}{"opponent"};

		if ($side == 1) { 

			my $score = $entries{"scores"}{$entry}{$opp};

			logMe($entries{"code"}{$opp}." aff vs ".$entries{"code"}{$entry}.
				" on neg scores $score");

		} else { 

			my $score = $entries{"scores"}{$opp}{$entry};

			logMe($entries{"code"}{$entry}." aff vs ".$entries{"code"}{$opp}.
				" on neg scores $score");

		}

		my $bye = 0;
		$bye = 1 if $opp eq "BYE";
		$side = 1 if $opp eq "BYE";

		$side = $standard_side++ unless $side;

		my $panel = Tab::Panel->create({
			letter  => $letter,
			round   => $round->id,
			flight  => 1,
			bye     => $bye,
			bracket => $panels{$entry}{"bracket"}
		});

		$letter++;

		Tab::Ballot->create({
			panel        => $panel,
			entry        => $entry,
			side         => $side,
			judge        => 0,
			audit        => 0,
			speakerorder => 0
		});

		unless ($bye) { 

			$side--;
			$side = 2 if $side < 1;

			Tab::Ballot->create({
				panel        => $panel,
				entry        => $opp,
				side         => $side,
				judge        => 0,
				audit        => 0,
				speakerorder => 0
			});

		}

	}


	$round->setting("nsda_pairing_log", 0);
	$round->setting("nsda_pairing_log", "text", $round_log);

	undef $round_log;
	undef $step_counter;

	return;

	sub scoreDebate { 

		my ($aff, $neg, $entries_ref) = @_;

		my $score;

		# Check for wrong bracket.  Pullups are forbidden unless strictly
		# necessary.

		if ($entries_ref->{$aff}{"losses"} != $entries_ref->{$neg}{"losses"}) { 
			$score += $entries_ref->{"scores"}{"bracket"};
		}

		# Check and penalize school hits

		if (
			$entries_ref->{"school_id"}{$aff} 
			== $entries_ref->{"school_id"}{$neg}
		) { 
			$score += $entries_ref->{"scores"}{"school"};
		}

		if (
			$entries_ref->{"district"}{$aff} 
			== $entries_ref->{"district"}{$neg}
		) { 
			$score += $entries_ref->{"scores"}{"district"};
		}

		if (
			$entries_ref->{"state"}{$aff} == $entries_ref->{"state"}{$neg}
		) { 
			$score += $entries_ref->{"scores"}{"state"};
		}

		$score +=  
			$entries_ref->{"scores"}{"repeat"} 
			* $entries_ref->{$aff}{"hits"}{$neg};

		my $aff_side_diff = 
			$entries_ref->{$aff}{"side_count"}{1}
			- $entries_ref->{$aff}{"side_count"}{2};

		my $neg_side_diff 
			= $entries_ref->{$neg}{"side_count"}{2} 
			- $entries_ref->{$neg}{"side_count"}{1};

		if ($aff_side_diff > 0) { 
			$score += $entries_ref->{"scores"}{"side"} * $aff_side_diff;
		}

		if ($neg_side_diff > 0) { 
			$score += $entries_ref->{"scores"}{"side"} * $neg_side_diff;
		}

		return $score;

	}

	sub logMe {

		my $string = shift;

		$step_counter++;

		$round_log .= '<div class="full lightrow marleftmuchmore">';

		$round_log .= '<span class="quarter strong">';
		$round_log .= "Step ".$step_counter.". ";
		$round_log .= '</span> ';
		$round_log .= '<span class="threequarters">';
		$round_log .= $string;
		$round_log .= '</span> ';
		$round_log .= "</div>\n";

		return;
	}

</%init>
