<%args>
	$tourn
	$tourn_settings
	$person
	$round_id    => undef
	$round       => undef
	$min_bracket => undef
	$max_bracket => undef
</%args>
<%init>

	use List::Util 'shuffle';

	my $dbh = Tab::DBI->db_Main();
	my $debug;

	unless ($round) {
		$round = Tab::Round->retrieve($round_id);
	}

	unless ($round) {
		$m->comp("/funclib/abort.mas",
			message => "No round found for ID $round_id"
		);
	}

	my $event      = $round->event;
	my $category   = $event->category;
	my $event_type = $event->type;
	my $round_type = $round->type;

	my %event_settings    = $event->all_settings;
	my %category_settings = $category->all_settings;

    my $description = "Re-assigned the judges for round ".$round->realname." of ".$event->abbr;

	if ($round->setting('timeslot_merge')) {
		$description = "Re-assigned the judges for ".$category->abbr." merged rounds in ".$round->timeslot->name;
	}

	if ($min_bracket) {
		$description .= " in debates with more than $min_bracket wins";
	}

	if ($max_bracket) {
		$description .= " in debates with fewer than $max_bracket wins";
	}

	$description .= " using debate_judge_assign.mhtml";

	$m->comp("/funclib/log.mas",
        type        => 'tabbing',
        event       => $event->id,
        tourn       => $tourn->id,
        person      => $person,
        description => $description
    );

    $m->comp(
		"/funclib/round_clear_judges.mas",
		round       => $round,
		person      => $person,
		nobye       => 1,
		min_bracket => $min_bracket,
		max_bracket => $max_bracket
	);

	my @schools = $m->comp(
		"/funclib/event_schools.mas",
		event => $event
	);

	my $prelim_count;

	foreach my $round ($event->rounds) {
		next if $round_type eq "elim";
		next if $round_type eq "final";
		next if $round_type eq "runoff";
		$prelim_count++;
	}

	my $this_round = $round->id;

	my $tz = $tourn->tz;
	$tz = "UTC" unless $tz;

	my $round_start = eval {
		return $round->timeslot->start->set_time_zone($tz);
	};

	unless ($round_start) {

		my $message = "This round has no timeslot assigned. Assigning judging is ";
		$message .= " impossible without a timeslot.  Please correct this to continue.";

		if ($ARGS{"return"}) {
			return $message;
		} else {
			$m->comp("/funclib/abort.mas",
				message => $message
			);
		}
	}

	my $round_end = $round->timeslot->end->set_time_zone($tz);

	my @jpool = $round->jpools;
	my $flights = $round->flighted;
	$flights = 1 unless $flights;

	unless (
		$event_settings{'online_mode'} eq "nsda_campus"
		|| $event_settings{'online_mode'} eq "nsda_campus_observers"
	) {
		$flights = 1 if $event_settings{"flight_rooms_only"};
	}

	my %entry_seed_position = ();
	my $best_judges_highest_seed = $event_settings{"best_judges_highest_seed"};
	my $invert_ratings = $event_settings{"invert_ratings"};
	my $logfirst;

	if ($best_judges_highest_seed) {

		my (
			$entries_ref,
			$tbs_ref,
			$desc_ref,
			$forfeit_ref,
			$meh,
			$panrank_ref,
			$panletter_ref,
			$long_desc_ref
		)
		= $m->comp(
			"/tabbing/results/order_entries.mas",
			round => $round
		);

		foreach my $key (sort {$a <=> $b} keys %{$entries_ref}) {
			foreach my $entry_id (@{${$entries_ref}{$key}}) {
				$entry_seed_position{$entry_id} = $key;
			}
		}
	}

	my $num_judges = $round->setting("num_judges");
	$num_judges = 1 unless $num_judges;

    my $dio_region = $event->setting("diocese_regions");

	my $prefs = $category_settings{"prefs"};
	undef $prefs if $event_settings{"no_prefs"};
	undef $prefs if $prefs eq "none";

	my $tab_ratings = $category_settings{"tab_ratings"};
	my $coach_ratings = $category_settings{"coach_ratings"};

	my $event_ballots_sth = $dbh->prepare("
		select distinct
			ballot.id, ballot.judge, ballot.bye,
			round.id, round.type,
			entry.id, entry.code, entry.school, region.id, area.value area,
			entry.event,
			seed.value,
			online_hybrid.value,
			ballot.side,
			panel.bracket, panel.id, panel.bye,
			winner.value
		from (ballot, panel, round, entry, event, school)
		left join entry_setting seed on seed.entry = entry.id and seed.tag = 'pairing_seed'
		left join entry_setting online_hybrid on online_hybrid.entry = entry.id and online_hybrid.tag = 'pairing_online_hybrid'
		left join score winner on winner.ballot = ballot.id and winner.tag = 'ballot'
		left join region on school.region = region.id
		left join region_setting area on area.region = region.id and area.tag = 'area'
		left join chapter on school.chapter = chapter.id

		where event.category = ?
		and round.event = event.id
		and round.id = panel.round
		and panel.id = ballot.panel
		and ballot.entry = entry.id
		and entry.school = school.id
	");

	$event_ballots_sth->execute($category->id);

	my %entries;
	my %judges;

	my %school_entries;
	my %region_entries;
	my %dioregion_entries;

	my %panels;
	my %ballots;

	my %judge_baseline;
	my $max_actual;

	while (
		my (
			$ballot, $judge, $bbye,
			$round_id, $type,
			$entry, $code, $entry_school, $entry_region, $entry_area,
			$event_id,
			$entry_seed,
			$online_hybrid,
			$side,
			$bracket, $panel, $pbye,
			$winner
		) = $event_ballots_sth->fetchrow_array()
	) {

		if ($round_id == $this_round) {

			if (
				(defined($min_bracket) && $bracket <= $min_bracket)
				|| (defined($max_bracket) && $bracket > $max_bracket)
			) {
				$judge_baseline{$judge}++ if $judge;
				next;
			}

			if ($bracket > $max_actual) {
				$max_actual = $bracket;
			}

			$entries{$entry}{"seed"} = $entry_seed;

			if ($event_settings{'online_hybrid'}) {
				$entries{$entry}{"online_hybrid"} = $online_hybrid;

				if ($online_hybrid) {
					$panels{"online"}{$panel} = 1;
				}
			}

			$entries{$entry}{"side"}     = $side;
			$entries{$entry}{"code"}     = $code;
			$entries{$entry}{"event_id"} = $event_id;
			$entries{$entry}{"school"}   = $entry_school;
			$entries{$entry}{"region"}   = $entry_region;
			$entries{$entry}{"area"}     = $entry_area;

			if ($tourn_settings->{"ncfl"} && $entry_region && $dio_region->{$entry_region}) {
				$entries{$entry}{"dioregion"} = $dio_region->{$entry_region};
				push @{$dioregion_entries{$dio_region->{$entry_region}}}, $entry;
			}

			push @{$school_entries{$entry_school}}, $entry;

			push @{$region_entries{$entry_region}}, $entry
					if $entry_region;

			push @{$panels{"all"}}, $panel;
			$panels{"bye"}{$panel} = $pbye;

			if (
				($entry_seed && $entry_seed < $panels{"seed"}{$panel})
				|| (not defined $panels{"seed"}{$panel})
			) {
				$panels{"seed"}{$panel} = $entry_seed;
			}

			$panels{"bracket"}{$panel} = $bracket;

			if ($best_judges_highest_seed) {

				if ($round->name == 1) {

					if (
						($entry_seed < $panels{"bracketrank"}{$panel})
						|| (not defined $panels{"bracketrank"}{$panel})
					) {
						$panels{"bracketrank"}{$panel} = $entry_seed
					}

				} else {

					if (
						($entry_seed_position{$entry} < $panels{"bracketrank"}{$panel})
						|| (not defined $panels{"bracketrank"}{$panel})
					) {
						$panels{"bracketrank"}{$panel} = $entry_seed_position{$entry}
					}
				}
			}

			push @{$panels{"entries"}{$panel}}, $entry;

		} else {

			push @{$judges{"rounds"}{$judge}}, $round_id if $round_id;
			push @{$judges{"ballots"}{$judge}}, $ballot;
			push @{$entries{$entry}{"ballots"}}, $ballot;

			$ballots{$ballot}{"type"}   = $type;
			$ballots{$ballot}{"side"}   = $side;
			$ballots{$ballot}{"entry"}  = $entry;
			$ballots{$ballot}{"winner"} = $winner;
		}
	}

	my $judge_sth;

	if (@jpool) {

		$judge_sth = $dbh->prepare("
			select distinct judge.id, concat_ws(' ',judge.last, judge.first) as name,
				judge.school, region.id,
				area.value area,
				tab_rating.value tab_rating,
				online_hybrid.value online_hybrid,
				rating_tier.name rating_tier,
				diverse.value diverse,
				judge.obligation, judge.hired

			from (judge, jpool_judge, jpool_round, round)

			left join judge_setting as tab_rating on
				tab_rating.judge = judge.id
				and tab_rating.tag = 'tab_rating'

			left join judge_setting as online_hybrid on
				online_hybrid.judge = judge.id
				and online_hybrid.tag = 'online_hybrid'

			left join judge_setting as diverse on
				diverse.judge = judge.id and diverse.tag = 'diverse'

			left join rating coach_rating on
				coach_rating.judge = judge.id and coach_rating.type = 'coach'

			left join rating_tier on
				coach_rating.rating_tier = rating_tier.id

			left join school on judge.school = school.id
			left join chapter on school.chapter = chapter.id
			left join region on school.region = region.id
			left join region_setting area on area.region = region.id and area.tag = 'area'

			where judge.active = 1
			and judge.id = jpool_judge.judge
			and jpool_round.jpool = jpool_judge.jpool
			and jpool_round.round = round.id
			and round.id = ?

			and not exists (
				select js.id
				from judge_setting js
				where js.judge = judge.id
				and js.tag = 'sub_only'
			)

			and not exists (
				select jpj.id
				from jpool_judge jpj, jpool_setting jps
				where jps.value = round.timeslot
				and jps.tag = 'standby_timeslot'
				and jps.jpool = jpj.jpool
				and jpj.judge = judge.id
			)

			group by judge.id
		");

	} else {

		$judge_sth = $dbh->prepare("
			select distinct judge.id, concat_ws(' ',judge.last, judge.first) as name,
				judge.school, region.id,
				area.value area,
				tab_rating.value tab_rating,
				online_hybrid.value online_hybrid,
				rating_tier.name rating_tier,
				diverse.value diverse,
				judge.obligation, judge.hired

			from (judge, event, round)

			left join judge_setting as tab_rating
				on tab_rating.judge = judge.id
				and tab_rating.tag = 'tab_rating'

			left join judge_setting as online_hybrid on
				online_hybrid.judge = judge.id
				and online_hybrid.tag = 'online_hybrid'

			left join judge_setting as diverse
				on diverse.judge = judge.id
				and diverse.tag = 'diverse'

			left join rating coach_rating
				on coach_rating.judge = judge.id
				and coach_rating.type = 'coach'

			left join rating_tier on coach_rating.rating_tier = rating_tier.id

			left join school on judge.school = school.id
			left join region on school.region = region.id
			left join region_setting area on area.region = region.id and area.tag = 'area'
			left join chapter on school.chapter = chapter.id

			where judge.active = 1
			and judge.category = event.category
			and event.id = round.event
			and round.id = ?

			and not exists (
				select js.id
				from judge_setting js
				where js.judge = judge.id
				and js.tag = 'sub_only'
			)

			and not exists (
				select jpj.id
				from jpool_judge jpj, jpool_setting jps
				where jps.value = round.timeslot
				and jps.tag = 'standby_timeslot'
				and jps.jpool = jpj.jpool
				and jpj.judge = judge.id
			)
			group by judge.id
		");

	}

	$judge_sth->execute($round->id);
	my %school_judges;
	my %region_judges;

	my $use_areas;

	while (
		my (
			$id, $last,
			$school, $region,
			$area,
			$tab_rating,
			$online_hybrid,
			$coach_rating,
			$diverse,
			$obligation,
			$hired,
		) = $judge_sth->fetchrow_array()
	) {

		next unless $id;
		push @{$judges{"all"}}, $id;

		$judges{"name"}{$id}   = $last;
		$judges{"school"}{$id} = $school;
		$judges{"region"}{$id} = $region;
		$judges{"area"}{$id}   = $area;

		if ($area) {
			$use_areas++;
		}

		if ($tourn_settings->{"ncfl"} && $region) {
			$judges{"dioregion"}{$id} = $dio_region->{$region} || 99;
		}

		unless ($category_settings{"elim_only_ratings"} && $round_type eq "prelim") {
			$judges{"rating"}{$id} = $coach_rating if $coach_ratings;
			$judges{"rating"}{$id} = $tab_rating if $tab_ratings;
		}

		if ($event_settings{'online_hybrid'}) {
			$judges{"online"}{$id} = $online_hybrid;
		}

		$judges{"diverse"}{$id} = $diverse;
		$judges{"obligation"}{$id} = $obligation + $hired;
		push @{$school_judges{$school}}, $id;

		unless ($event_settings{"allow_judge_own"}) {

			push @{$judges{"conflicts"}{$id}}, @{$school_entries{$school}} if $school_entries{$school} ;

			if (
				$event_settings{"region_constrain"}
				|| $event_settings{"region_judge_forbid"}
				|| $tourn_settings->{"ncfl"}
			) {
				push @{$judges{"conflicts"}{$id}}, @{$region_entries{$region}}
					if $region_entries{$region};
			}
		}

		if ($tourn_settings->{"ncfl"}
			&& $region
			&& $dioregion_entries{$dio_region->{$region}}
			&& $event_settings{"conflict_dioregion_judges"}
		) {
			push @{$judges{"conflicts"}{$id}}, @{$dioregion_entries{$dio_region->{$region}}};
		}
	}

	unless ($judges{"all"} && @{$judges{"all"}}) {

		# does the next line replace this? JB
		# No, because the next is only triggered if there are pools - CLP

		my $err = "No judges were available.";
		$err = "No judges were found.  Did you put judges into the judge pools?" if @jpool;
		return $err if $ARGS{"return"};

		$m->redirect("/panel/schemat/show.mhtml?round_id=".$round->id."&disp=1&err=$err");
	}

	my $strikes_sth = $dbh->prepare("
		select distinct strike.id, strike.judge, strike.type, strike.event, strike.entry,
			strike.school, strike.region, strike.dioregion, strike.start, strike.end
		from strike
		where strike.tourn = ?
	");

	$strikes_sth->execute($tourn->id);

	while (
		my ($id, $judge, $type,
			$strike_event, $entry, $school, $region, $dioregion, $start, $end
		) = $strikes_sth->fetchrow_array()
	) {

		if ($type eq "conflict" || $type eq "entry") {

			if ($school) {
				push @{$judges{"conflicts"}{$judge}}, @{$school_entries{$school}} if $school_entries{$school};
			} else {
				push @{$judges{"conflicts"}{$judge}}, $entry;
			}
		}

		if ($type eq "elim" || $type eq "event") {

			next if ($round_type eq "elim"
					|| $round_type eq "final"
					|| $round_type eq "runoff")
				&& $type eq "elim";
			$judges{'no_event'}{$judge}{$strike_event}++;
		}

		if ($type eq "hybrid") {
			foreach my $school_judge (@{$school_judges{$school}}) {
				push @{$judges{"conflicts"}{$school_judge}}, $entry;
			}
		}

		if ($type eq "region" && $region_entries{$region}) {
			push @{$judges{"conflicts"}{$judge}}, @{$region_entries{$region}};
		}

		if ($tourn_settings->{"ncfl"}
			&& $type eq "dioregion"
			&& $dioregion_entries{$dioregion}
		) {
			push @{$judges{"conflicts"}{$judge}}, @{$dioregion_entries{$dioregion}};
		}

		if ($type eq "school" && $school_entries{$school}) {
			push @{$judges{"conflicts"}{$judge}}, @{$school_entries{$school}};
		}

		if ($type eq "time" || $type eq "departure") {

			my $start_dt;
			my $end_dt;

			eval {
				$start_dt = DateTime::Format::MySQL->parse_datetime($start);
				$end_dt = DateTime::Format::MySQL->parse_datetime($end);
			};

			if ($start_dt && $end_dt) {

				$start_dt->set_time_zone("UTC");
				$end_dt->set_time_zone("UTC");

				$start_dt->set_time_zone($tz);
				$end_dt->set_time_zone($tz);

				if ($round_start <= $end_dt
					&& $round_end >= $start_dt
				) {
					$judges{"out"}{$judge}++;
				}
			}
		}
	}

	my $rounds_missed_sth = $dbh->prepare("
		select distinct judge.id, count(round.id)
		from judge, round, timeslot, strike, event
		where judge.id = strike.judge
		and judge.category = event.category
		and event.id = ?
		and round.event = event.id
		and (strike.type = 'time' or strike.type = 'departure')
		and strike.start < timeslot.end
		and strike.end > timeslot.start
		and timeslot.id = round.timeslot
		group by judge.id
	");

	$rounds_missed_sth->execute($event->id);

	while (
		my ($judge, $rounds_struck)
		= $rounds_missed_sth->fetchrow_array()
	) {
		$judges{"roundstruck"}{$judge} = $rounds_struck;
	}

	if (@jpool) {

		my $busy_sth = $dbh->prepare("
			select distinct judge.id
			from ballot, panel, round, timeslot, timeslot mytime, round myround,
				judge, jpool_judge, jpool_round
			where myround.id = ?
				and myround.timeslot = mytime.id
				and mytime.start < timeslot.end
				and mytime.end > timeslot.start
				and timeslot.id = round.timeslot
				and round.id = panel.round
				and panel.id = ballot.panel
				and ballot.judge = judge.id
				and judge.id = jpool_judge.judge
				and jpool_judge.jpool = jpool_round.jpool
				and jpool_round.round = myround.id
		");

		$busy_sth->execute($round->id);

		while (my ($judge) = $busy_sth->fetchrow_array() ) {
			$judges{"out"}{$judge}++;
		}

		$busy_sth = $dbh->prepare("
			select distinct judge.id
			from ballot, panel, round, timeslot, timeslot mytime, round myround,
				judge, judge jjudge, jpool_judge, jpool_round
			where myround.id = ?

				and myround.timeslot = mytime.id

				and mytime.start < timeslot.end
				and mytime.end > timeslot.start

				and timeslot.id = round.timeslot
				and round.id = panel.round
				and panel.id = ballot.panel
				and ballot.judge = judge.id
				and judge.person = jjudge.person
				and judge.person > 0
				and jjudge.person = jpool_judge.judge
				and jpool_judge.jpool = jpool_round.jpool
				and jpool_round.round = myround.id

				and not exists (
					select esa.id
					from event_setting esa
					where esa.tag = 'online_mode'
					and esa.event = round.event
					and esa.value = 'async'
				)

				and not exists (
					select esa.id
					from event_setting esa
					where esa.tag = 'online_mode'
					and esa.event = myround.event
					and esa.value = 'async'
				)
		");

		$busy_sth->execute($round->id);

		while (my ($judge) = $busy_sth->fetchrow_array() ) {
			$judges{"out"}{$judge}++;
		}

		$busy_sth->finish();

	} else {

		my $busy_sth = $dbh->prepare("
			select distinct judge.id
				from ballot, panel, round, timeslot, timeslot mytime, round myround, judge
			where myround.id = ?
				and myround.timeslot = mytime.id
				and mytime.start < timeslot.end
				and mytime.end > timeslot.start
				and timeslot.id = round.timeslot
				and round.id = panel.round
				and panel.id = ballot.panel
				and ballot.judge = judge.id
				and judge.category = ?

				and not exists (
					select esa.id
					from event_setting esa
					where esa.tag = 'online_mode'
					and esa.event = round.event
					and esa.value = 'async'
				)

				and not exists (
					select esa.id
					from event_setting esa
					where esa.tag = 'online_mode'
					and esa.event = myround.event
					and esa.value = 'async'
				)
		");

		$busy_sth->execute($round->id, $category->id);

		while (my ($judge) = $busy_sth->fetchrow_array() ) {
			$judges{"out"}{$judge}++;
		}

		$busy_sth = $dbh->prepare("
			select distinct judge.id
				from ballot, panel, round, timeslot, timeslot mytime, round myround, judge, judge pjudge
			where myround.id = ?
				and mytime.start < timeslot.end
				and mytime.end > timeslot.start
				and myround.timeslot = mytime.id
				and timeslot.id      = round.timeslot
				and round.id         = panel.round
				and panel.id         = ballot.panel
				and ballot.judge     = pjudge.id
				and (pjudge.person   != 0 and pjudge.person is not NULL)
				and pjudge.person    = judge.person
				and judge.category   = ?

				and not exists (
					select esa.id
					from event_setting esa
					where esa.tag = 'online_mode'
					and esa.event = round.event
					and esa.value = 'async'
				)

				and not exists (
					select esa.id
					from event_setting esa
					where esa.tag = 'online_mode'
					and esa.event = myround.event
					and esa.value = 'async'
				)

		");

		$busy_sth->execute($round->id, $category->id);

		while (my ($judge) = $busy_sth->fetchrow_array() ) {
			$judges{"out"}{$judge}++;
		}
	}

	my %tier_value;
	my %tier_strike;

	my $tiers;

	if ($prefs && $prefs ne "ordinals") {

		$tiers++;

		foreach my $tier (
			sort {$a->name cmp $b->name}
			$category->rating_tiers(type => "mpj")
		) {
			$tier_value{$tier->id} = $tier->name;
			$tier_strike{$tier->id}++
				if $tier->strike || $tier->conflict;
		}
	}

	my $ratings_sth = $dbh->prepare("
		select distinct rating.id, rating.judge, rating.entry, rating.rating_tier, rating.percentile
			from rating, ballot, panel
		where panel.round = ?
			and ballot.panel = panel.id
			and panel.bye = 0
			and ballot.bye = 0
			and ballot.entry = rating.entry
			and (ballot.side = rating.side OR rating.side = 0 OR rating.side IS NULL)
			and not exists (
				select school_setting.id
				from school_setting, entry
				where rating.entry = entry.id
				and school_setting.school = entry.school
				and school_setting.tag = 'noprefs'
				and school_setting.value = 1
			)
		group by rating.id
	");

	$ratings_sth->execute($round->id);

	my %mjp;

	while (
		my ($id, $judge, $entry, $tier, $percentile)
		= $ratings_sth->fetchrow_array()
	) {

		next unless ($tier || $percentile);

		$mjp{$judge}{$entry} = $tier_value{$tier}
			if $tier > 0;

		$mjp{$judge}{$entry} = $percentile
			if $percentile > 0;

		push @{$judges{"conflicts"}{$judge}}, $entry
			if $tier && $tier_strike{$tier};
	}

	my %panel_seen = ();

	#Deduplicate
	@{$panels{"all"}} = grep { ! $panel_seen{$_} ++ } @{$panels{"all"}};
	@{$panels{"all"}} = sort {$panels{"bracket"}{$b} <=> $panels{"bracket"}{$a}} @{$panels{"all"}};

	$judges{"use"} = $m->comp("/funclib/judge_use.mas", round_id => $round->id);

	my $round_burn_avoid = $category_settings{"round_burn_avoid"};
	my $mutuality        = $category_settings{"mutuality"};
	my $preference       = $category_settings{"preference"};
	my $default_mjp      = $category_settings{"default_mjp"};
	my $diversity        = $category_settings{"diverse_judge_weight"};
	my $suckage          = $category_settings{"sucktastic_judge_weight"};
	my $prefer_hireds    = $category_settings{"mjp_prefer_hireds"};
	my $meatspace        = $category_settings{"mjp_meatspace"};

	$diversity        = 1 if not defined $diversity;
	$suckage          = 3 if not defined $suckage;
	$mutuality        = 40 if not defined $mutuality;
	$preference       = 15 if not defined $preference;
	$preference       = 100 if $invert_ratings;
	$default_mjp      = 2 if not defined $default_mjp;

	$round_burn_avoid = 3 if not defined $round_burn_avoid;
	$round_burn_avoid -= 3 if $min_bracket;

	$prefer_hireds    = 10 if not defined $prefer_hireds;
	$meatspace        = 2 if not defined $meatspace;


	$mutuality        = 0 if $mutuality < 0;
	$diversity        = 0 if $diversity < 0;
	$suckage          = 0 if $suckage < 0;
	$preference       = 0 if $preference < 0;
	$default_mjp      = 0 if $default_mjp < 0;
	$meatspace        = 0 if $meatspace < 0;
	$round_burn_avoid = 0 if $round_burn_avoid < 0;
	$prefer_hireds    = 0 if $prefer_hireds < 0;
	$preference       = 15 if $tab_ratings && $preference < 1;

	unless (defined $prefs) {
		$mutuality   = 0;
		$default_mjp = 0;
	}

	$round_burn_avoid = 0 unless $category_settings{"rounds_per"};

	if (not defined $round_burn_avoid) {
		if ($prefs eq "none" || (not defined $prefs)) {
			$round_burn_avoid = 5;
		} elsif ($round_type eq "elim" || $round_type eq "final") {
			$round_burn_avoid = 0;
		}
	}

	my %use_priority;

	my %judge_prefs = $m->comp(
		"/funclib/judges_by_pref.mas",
		category => $category
	);

	foreach my $judge (@{$judges{"all"}}) {

		my %seen = ();

		@{$judges{"rounds"}{$judge}} =
			grep { ! $seen{$_}++ }
			@{$judges{"rounds"}{$judge}};

		my $num_rounds = scalar @{$judges{"rounds"}{$judge}};

		$judges{"score"}{$judge} +=
			scalar @{$judges{"conflicts"}{$judge}}
			if $judges{"conflicts"}{$judge};

		if ( $category_settings{"rounds_per"} && (
				($round_type ne "elim"
					&& $round_type ne "final"
					&& $round_type ne "runoff"
				)
				|| ($tourn_settings->{"nsda_nats"} && (not defined $event_settings{"not_nats"}))
			)
		) {

			$judges{"out"}{$judge}++ if $num_rounds >= $judges{"obligation"}{$judge};

			my $remaining_prelims = $prelim_count + 1 - $round->name;
			my $round_diff = $remaining_prelims * $judges{"use"}{$judge}{"percentage"} / 100;

			# Use people with more obligation
			if ($round_diff > 0) {
				$judges{"score"}{$judge} -= $round_diff ** $round_burn_avoid;
				$use_priority{$judge} -= $round_diff ** $round_burn_avoid;
			}

			#All else equal use the newbies;
			$use_priority{$judge} += $judges{"use"}{$judge}{"judged_already"};

			if ($tourn_settings->{"nsda_nats"} ) {
				$use_priority{$judge} += ($judges{"use"}{$judge}{"judged_already"} * 10000 );
				$use_priority{$judge} += ($judges{"use"}{$judge}{"judged_secondary"} * 100 );
			}

			$use_priority{$judge."-dontcare"} += 1000000000 * ($round_diff ** $round_burn_avoid ** 2)
				if $round_diff > 0 && $prefs eq "ordinals";

			$judges{"roundcount"}{$judge} = $num_rounds;

		} else {

			if ($round_type ne "elim" && $round_type ne "final" && $round_type ne "runoff") {
				my $round_factor = $num_rounds;
				$round_factor -= $judges{"roundstruck"}{$judge};
				$round_factor = $round_factor * $round_burn_avoid;

				$judges{"score"}{$judge} += $round_factor * 1;
				$use_priority{$judge} += $round_factor * .1;
				$judges{"roundcount"}{$judge} = $num_rounds;
			}

			if (
				$tourn_settings->{"ncfl"}
				&& (
					$round_type eq "elim"
					|| $round_type eq "final"
					|| $round_type eq "runoff"
				)
			) {
				$judges{"score"}{$judge} += 50000 if $judges{"rating"}{$judge} eq "A";
				$judges{"score"}{$judge} += 2500 if $judges{"rating"}{$judge} eq "B";
				$use_priority{$judge} -= 50000 if $judges{"rating"}{$judge} eq "A";
				$use_priority{$judge} -= 2500 if $judges{"rating"}{$judge} eq "B";
			}

			if ($tourn_settings->{ncfl}) {
				if ($dioregion_entries{$dio_region->{$judges{"region"}{$judge}}} < 1) {
					$use_priority{$judge} -= $prefer_hireds;
				}
			}

			if ($tourn_settings->{"nsda_nats"} ) {
				$use_priority{$judge} += $judges{"use"}{$judge}{"judged_already"} * 1000000;
				$use_priority{$judge} += $judges{"use"}{$judge}{"judged_secondary"} * 100000;
			}
		}

		$use_priority{$judge} -= $prefer_hireds if $judges{"school"}{$judge} < 1;
		$use_priority{$judge} -= $judges{"diverse"}{$judge} * $diversity if $diversity;

		$use_priority{$judge} -=
			($judge_prefs{$judge}{"avg"} - ($judge_prefs{$judge}{"stdv"}/3)) * $suckage
			if $suckage;

		next if $judges{"out"}{$judge};

		if ($judges{"ballots"}{$judge}) {

			BALLOT:

			foreach my $ballot (
				sort { $entries{$ballots{$a}{"entry"}}{"code"}
				cmp $entries{$ballots{$b}{"entry"}}{"code"}} @{$judges{"ballots"}{$judge}}
			) {

				my $entry = $ballots{$ballot}{"entry"};

				if ($event_settings{"allow_repeat_elims"} &&
						($round_type eq "elim"
						|| $round_type eq "final"
						|| $round_type eq "runoff"
						|| $ballots{$ballot}{"type"} eq "elim"
						|| $ballots{$ballot}{"type"} eq "final"
						|| $ballots{$ballot}{"type"} eq "runoff"
						)
					) {

					if ($event_settings{"disallow_repeat_drop"}) {
						next BALLOT if $ballots{$ballot}{"winner"};
					} else {
						next BALLOT;
					}
				}

				push @{$judges{"avoid"}{$judge}}, $entry;

				next if $event_settings{"allow_repeat_judging"};

				next if $event_settings{"allow_repeat_prelim_side"}
					&& $ballots{$ballot}{"side"} != $entries{$entry}{"side"};

				push @{$judges{"conflicts"}{$judge}}, $entry;
			}

		}

		foreach my $clash (@{$judges{"conflicts"}{$judge}}) {
			$judges{"entry_strike"}{$judge}{$clash}++;
		}

	}

	my %default_settings = $m->comp(
		"/funclib/default_rating_settings.mas",
		type => $event->type
	);

	my $bracket_order = $round->setting("tab_rating_priority");
	$bracket_order = $default_settings{$round->name} unless $bracket_order;
	$bracket_order =~ s/\s*//g;

	my @orders = split(/\,/, $bracket_order)
		unless $round_type eq "elim"
		|| $round_type eq "final"
		|| $round_type eq "runoff";

	unless ($tab_ratings || $coach_ratings || $prefs) {
		undef @orders;
	}

	my %bracket_score;
	my $order_multiplier;

	my $last_order = 0;
	my $shuffle_post;

	undef @orders
		if $round_type eq "prelim"
		&& (not defined $tourn_settings->{"wsdc"});

	unless (@orders) {
		foreach (1 .. $num_judges) {
			$shuffle_post++;
			foreach my $order (0 .. $max_actual) {
				push @orders, $order;
			}
		}
	}

	my $multiplier = scalar @orders + 1;
	my %order_count = ();

	foreach my $order (@orders) {
		$order_count{$order}++;
	}

	my @new_orders;

	foreach my $order (@orders) {

		my $lack = $num_judges - $order_count{$order};

		while ($lack > 0) {
			push @new_orders, $order;
			$lack--;
		}
	}

	push @orders, @new_orders;

	my $loss_threshold = $event_settings{"break_point"};
	undef $loss_threshold unless $event_settings{"nobreak_noprefs"};

	my $max_pref = $event_settings{"max_pref"}
		if $event_settings{"max_pref"};

	my $max_nobreak_pref = $event_settings{"max_nobreak_pref"}
		if $event_settings{"max_nobreak_pref"};

	my $bracket_dont_cannot_clear = $round->name - $loss_threshold - 1
		if $loss_threshold > 0;

	my $max_panel_bracket_rank;

	foreach my $panel (keys %{$panels{"bracketrank"}} ) {

		$max_panel_bracket_rank = $panels{"bracketrank"}{$panel}
			if $max_panel_bracket_rank < $panels{"bracketrank"}{$panel};
	}

	$max_panel_bracket_rank++;

	foreach my $order (reverse @orders) {

		foreach my $panel (@{$panels{"all"}}) {

			next unless $panels{"bracket"}{$panel} == $order;

			if ($best_judges_highest_seed) {

				my $mult = $order;

				$mult = 3 if $round->name == 1 && $order == 0;

				$bracket_score{$panel} = ($max_panel_bracket_rank - $panels{"bracketrank"}{$panel}) ** $mult;

			} else {
				$bracket_score{$panel} = $order * 2;
			}
		}
		$last_order = $order;
	}

	my $seed_order = $round->setting("tab_seed_priority");

	$seed_order =~ s/\s*//g;

	my @seed_orders = split(/\,/, $seed_order)
		if $round_type eq "prelim";

	my %seed_score;

	undef $order_multiplier;

	foreach my $order (reverse @seed_orders) {

		$order_multiplier++;
		$order_multiplier++;

		foreach my $panel (@{$panels{"all"}}) {
			$panels{"seed"}{$panel} = 0 unless $panels{"seed"}{$panel};
			next unless $panels{"seed"}{$panel} == $order;
			$seed_score{$panel} = $order_multiplier;
		}

		$last_order = $order;
	}

	$last_order++;
	foreach my $panel (@{$panels{"all"}}) {
		next if $seed_score{$panel};
		$seed_score{$panel} = $last_order;
	}

	my %fix_flight;

	my @flight_settings =
		$m->comp(
			"/funclib/event_entry_settings.mas",
			event => $event,
			tag   => "preferred_flight"
		);

	my %preferred_flight =
		map {$_->entry->id => $_->value}
		@flight_settings;

	my %judge_panel_score;

	@{$panels{"all"}} = shuffle @{$panels{"all"}} if $shuffle_post;

	if ($best_judges_highest_seed) {
		@{$panels{"all"}} = sort {
			$panels{"bracketrank"}{$a} <=> $panels{"bracketrank"}{$b}
		} @{$panels{"all"}};
	}

	# Create judge panel scores

	PANEL:
	foreach my $panel (@{$panels{"all"}}) {

		next if $panels{"bye"}{$panel};

		my $dont_care++ if $bracket_dont_cannot_clear
			&& $panels{"bracket"}{$panel} <= $bracket_dont_cannot_clear;

		undef $dont_care if $round->name == 1;

		JUDGE:
		foreach my $judge (@{$judges{"all"}}) {

			my $score = 0;
			next JUDGE if $judges{"out"}{$judge};

			my $diff;
			my $mjp_first;

			if ($event_settings{'online_hybrid'}) {
				if ($panels{"online"}{$panel} != $judges{"online"}{$judge}) {
					$score += $meatspace;
				}
			}

			foreach my $entry (@{$panels{"entries"}{$panel}}) {

				if ($flights > 1 ) {
					$fix_flight{$panel} = $preferred_flight{$entry};
				}

				# Score each judge against this entry for various reasons.  The
				# below penalizes judge strikes a lot.

				$score += 50000 if $judges{"avoid"}{$entry};
				$score += 100000000 if $judges{"entry_strike"}{$judge}{$entry};

				if ($entries{$entry}{"event_id"}) {
					if ($judges{'no_event'}{$judge}{$entries{$entry}{"event_id"}}) {
						$score += 100000000;
					}
				}

				# Light regional constraints
				if ($event_settings{"region_avoid"}) {
					if (
						$entries{$entry}{"region"}
						&& $entries{$entry}{"region"} == $judges{"region"}{$judge}
					) {
						$score += 100;
					}

					if (
						$entries{$entry}{"area"}
						&& $entries{$entry}{"area"} == $judges{"area"}{$judge}
					) {
						$score += 10;
					}
				}

				# Heavy regional constraints
				if ($event_settings{"region_constrain"}) {
					if (
						$entries{$entry}{"region"}
						&& $entries{$entry}{"region"} == $judges{"region"}{$judge}
					) {
						$score += 5000000;
					}

					if (
						$entries{$entry}{"area"}
						&& $entries{$entry}{"area"} == $judges{"area"}{$judge}
					) {
						$score += 100;
					}
				}

				# NCFL means regional constraints are the same weight as schools
				if ($tourn_settings->{"ncfl"}) {
					if (
						$entries{$entry}{"dioregion"}
						&& $entries{$entry}{"dioregion"} == $judges{"dioregion"}{$judge}
					) {
						$score += 5000000;
					}
				}

				# Scores judges bsaed on MJP weights
				if ($prefs && $prefs ne "none") {

					$score += 500000 if $judges{"avoid"}{$entry} && $prefs eq "ordinals";

					my $mjp_rating = $mjp{$judge}{$entry};
					$mjp_rating = $default_mjp unless $mjp_rating;

					# Ignore prefs if entry is not eligible to clear
					if ($dont_care && $max_nobreak_pref) {
						$score += 500000 if $mjp_rating > $max_nobreak_pref;
					} elsif ($max_pref) {
						$score += 500000 if $mjp_rating > $max_pref;
					}

					if ($mjp_first) {
						$diff = abs($mjp_first - $mjp_rating)
							if $mjp_first && $mjp_rating;
					} else {
						$mjp_first = $mjp_rating
							unless $mjp_first;
					}

					if ($dont_care) {
						$score += $mjp_rating * .1;
					} else {
						$score += $mjp_rating * $preference;
						$score += $default_mjp * $preference
							unless $mjp_rating;
					}

					$judges{"panel_rating"}{$judge}{$panel} .= " - "
						if $judges{"panel_rating"}{$judge}{$panel};

					$judges{"panel_rating"}{$judge}{$panel} .= $mjp_rating;

					$judges{"panel_rating"}{$judge}{$panel} .= "1"
						if not defined $mjp_rating &! $dont_care;
				}
			}

			# Caring quota maximizes the prefs in the clearing eligible
			# brackets over the down and outs.

			my $caring_quota = 1;
			$caring_quota = .01 if $dont_care;

			if ($prefs && $prefs ne "none") {
				$score += $diff * $mutuality * $caring_quota;
			}

			$score += $judges{"roundcount"}{$judge} * .1;
			$score += $use_priority{$judge};
			$score += $use_priority{$judge."-dontcare"} if $dont_care;

			if ($tab_ratings) {
				if ($invert_ratings) {
					$use_priority{$judge} -= $judges{"rating"}{$judge} * $preference;
				} else {
					$use_priority{$judge} += $judges{"rating"}{$judge} * $preference;
				}
			}

			if ($tab_ratings &! $dont_care) {
				$score += $judges{"rating"}{$judge} * $preference
					if $judges{"rating"}{$judge} eq int($judges{"rating"}{$judge});
			}

			$score += $score * $bracket_score{$panel}
				if $bracket_score{$panel}
				&& $round_type ne "elim"
				&! $dont_care;

			$score += $score * $seed_score{$panel}
				if $seed_score{$panel}
				&& $round_type eq "prelim"
				&! $dont_care;

			$score -= $judges{'rating'}{$judge} * $preference if $tab_ratings;
			$judge_panel_score{$judge}{$panel} = $score;
		}
	}

	my $linked;
	my $panel_done;
	my $current_total;

	my $ticknumber = 30;

	unless ($prefs || $prefs eq "none") {
		$ticknumber = 3;
	}

	foreach my $tick (1 .. $ticknumber) {

		# On each iteration the system creates a bunch of panels and judges,
		# then does a few swaps to see if it can improve on the placements.

		my %test_judges;
		my %test_flight;
		my %test_panels;
		my %panel_link;
		my %am_other;
		delete $judges{'flight'};

		if ($num_judges > 1 && $flights > 1) {

			$linked++;

			if ($tourn_settings->{"ncfl"} || $use_areas) {

				my %matches_with = ();

				# This takes care of the diocese region thing that baffles me
				# and is best not confronted directly.

				foreach my $panel (shuffle @{$panels{"all"}}) {

					@{$matches_with{$panel}} = ();

					MATCH:
					foreach my $potential_match (shuffle @{$panels{"all"}}) {

						next if $panel == $potential_match;
						next if $panels{"bye"}{$panel};

						foreach my $first (@{$panels{"entries"}{$potential_match}}) {
							foreach my $second (@{$panels{"entries"}{$panel}}) {
								if (
									$entries{$first}{"dioregion"} == $entries{$second}{"dioregion"}
									|| $entries{$first}{"area"} == $entries{$second}{"area"}
								) {
									next MATCH;
								}
							}
						}

						push @{$matches_with{$panel}}, $potential_match;
					}
				}

				@{$panels{"all"}} = sort {
					scalar @{$matches_with{$a}} <=> scalar @{$matches_with{$b}}
				} @{$panels{"all"}};

				my %taken = ();

				PANEL:
				foreach my $panel (@{$panels{"all"}}) {

					next if $panels{"bye"}{$panel};
					next if $taken{$panel}++;

					my $current_flight = 1;
					$test_flight{$panel} = $current_flight;

					MATCH:
					foreach my $match (shuffle @{$matches_with{$panel}}) {

						next if $taken{$match}++;

						push @{$panel_link{$panel}}, $match;

						$am_other{$match}++;
						$current_flight++;
						$test_flight{$match} = $current_flight;

						if ($current_flight >= $flights) {
							next PANEL;
						}
					}

					unless (
						$panel_link{$panel}
						&& (scalar @{$panel_link{$panel}} == ($flights - 1))
					) {

						MATCH:
						foreach my $match (shuffle @{$panels{"all"}}) {

							next if $taken{$match}++;

							push @{$panel_link{$panel}}, $match;
							$am_other{$match}++;

							$current_flight++;
							$test_flight{$match} = $current_flight;

							if ($current_flight >= $flights) {
								next PANEL;
							}
						}
					}
				}

			} else {

				my $last_panel;
				my $current_flight = 1;

				# Randomize the panels unless you are APDA and crazy and
				# putting only the best judges at the very top of things.

				unless ($best_judges_highest_seed) {
					@{$panels{"all"}} = shuffle @{$panels{"all"}};
				}

				foreach my $panel (@{$panels{"all"}}) {

					next if $panels{"bye"}{$panel};

					# This will hook panels together in an attempt to keep the panels
					# the same between two different rooms

					$test_flight{$panel} = $current_flight;
					push @{$panel_link{$panel}}, $last_panel;

					$am_other{$last_panel}++;
					$current_flight++;

					if ($current_flight > $flights) {
						$current_flight = 1;
						undef $last_panel;
					} else {
						$last_panel = $panel;
					}
				}
			}

			@{$panels{"all"}} =
				sort {$test_flight{$b} <=> $test_flight{$a}}
				@{$panels{"all"}};

		} elsif ($prefs || $prefs eq "none") {

		} elsif ($flights > 1 && ($round_type eq "highlow" || $round_type eq "highhigh")) {

			# For powermatched rounds take the first half and stick them into
			# F1 to start with and the other half goes into F2 to try and make
			# that happen.

			my $portion = POSIX::ceil(scalar @{$panels{"all"}} / $flights);;

			@{$panels{"all"}} =
				sort {$panels{"bracket"}{$b} <=> $panels{"bracket"}{$a}}
				@{$panels{"all"}};

			my $counter;
			my $flight = 1;

			foreach my $panel (@{$panels{"all"}}) {
				if ($counter++ >= $portion) {
					$flight++;
					undef $counter;
				}
				next if $panels{"bye"}{$panel};
				$fix_flight{$panel}  = $flight;
				$test_flight{$panel} = $flight;
			}
		}

		my %judge_used = %judge_baseline;
		my $attempt_total;
		my $order_count;
		my %already;

		foreach my $order (@orders) {

			$order_count++;
			@{$panels{"all"}} = reverse @{$panels{"all"}} unless $order % 2;
			my %used;

			undef %am_other;

			PANEL:
			foreach my $panel (@{$panels{"all"}}) {

				next if $panels{"bye"}{$panel};
				next if $used{$panel};
				next if ($test_judges{$panel} && scalar (@{$test_judges{$panel}}) >= $num_judges);

				if ($tab_ratings || $coach_ratings || $prefs) {
					next if $round_type ne "final"
						&& $round_type ne "elim"
						&& $round_type ne "runoff"
						&& defined $panels{"bracket"}{$panel}
						&& defined $order
						&& $order != $panels{"bracket"}{$panel}
						&& (not defined $tourn_settings->{"nsda_district"});
				}

				my @others = @{$panel_link{$panel}} if $panel_link{$panel};

				@{$judges{"all"}} =
					sort {$judges{"score"}{$b} <=> $judges{"score"}{$a}}
					@{$judges{"all"}};

				@{$judges{"all"}} =
					sort {$judge_panel_score{$a}{$panel} <=> $judge_panel_score{$b}{$panel}}
					@{$judges{"all"}};

				JUDGE:
				foreach my $judge (@{$judges{"all"}}) {

					next JUDGE if $judges{"out"}{$judge};
					next JUDGE if $judge_used{$judge} >= $flights;
					next JUDGE if $judge_used{$judge} == $judges{"use"}{$judge}{"left"}
						&& $category_settings{"sections_per"};

					next JUDGE if $judge_used{$judge} && $linked;
					next JUDGE if $judges{'flight'}{$judge}{$fix_flight{$panel}} && $fix_flight{$panel};

					foreach my $entry (@{$panels{"entries"}{$panel}}) {

						next JUDGE if $judges{"entry_strike"}{$judge}{$entry};

						if ($entries{$entry}{"event_id"}) {
							if ($judges{'no_event'}{$judge}{$entries{$entry}{"event_id"}}) {
								next JUDGE;
							}
						}
					}

					unless ($category_settings{"allow_school_panels"}) {
						if (
							$judges{"school"}{$judge}
							&& $already{$panel}{"school"}{$judges{"school"}{$judge}}
						) {
							next JUDGE;
						}
					}


					if ($tourn_settings->{"nsda_nats"}) {
						unless ($category_settings{"allow_region_panels"}) {
							if (
								$judges{"region"}{$judge}
								&& $already{$panel}{"region"}{$judges{"region"}{$judge}}
							) {
								next JUDGE;
							}
						}
					} elsif ($tourn_settings->{"ncfl"}) {

						unless ($category_settings{"allow_school_panels"}) {
							if ($judges{"region"}{$judge}
								&& $already{$panel}{"region"}{$judges{"region"}{$judge}}
							) {
								next JUDGE;
							}
						}

						unless ($category_settings{"allow_region_panels"}) {
							if ($judges{"dioregion"}{$judge}
								&& $already{$panel}{"dioregion"}{$judges{"dioregion"}{$judge}}
							) {
								next JUDGE;
							}
						}
					} elsif ($tourn_settings->{"regions"}) {

						unless ($category_settings{"allow_school_panels"}) {
							if ($judges{"region"}{$judge}
								&& $already{$panel}{"region"}{$judges{"region"}{$judge}}
							) {
								next JUDGE;
							}
						}

						unless ($category_settings{"allow_region_panels"}) {
							if ($judges{"area"}{$judge}
								&& $already{$panel}{"area"}{$judges{"area"}{$judge}}
							) {
								next JUDGE;
							}
						}
					}

					push @{$test_judges{$panel}}, $judge;
					push @{$test_panels{$judge}}, $panel;

					$judge_used{$judge}++;

					if ($fix_flight{$panel}) {
						$judges{'flight'}{$judge}{$fix_flight{$panel}} = 1;
						$test_flight{$panel} = $fix_flight{$panel};
					} else {
						$test_flight{$panel} = $judge_used{$judge};
					}

					if ($fix_flight{$panel}) {
						$judges{'flight'}{$judge}{$fix_flight{$panel}}++;
					}

					if ($judges{"school"}{$judge}) {
						$already{$panel}{"school"}{$judges{"school"}{$judge}}++;
					}

					if ($judges{"area"}{$judge}) {
						$already{$panel}{"area"}{$judges{"area"}{$judge}}++;
					}

					if ($judges{"region"}{$judge}) {
						$already{$panel}{"region"}{$judges{"region"}{$judge}}++;
					}

					if ($judges{"dioregion"}{$judge}) {
						$already{$panel}{"dioregion"}{$judges{"dioregion"}{$judge}}++;
					}

					$used{$panel}++;
					$attempt_total += $judge_panel_score{$judge}{$panel};

					if ($test_judges{$panel} && (scalar @{$test_judges{$panel}}) == $num_judges) {
						last JUDGE;
					}

				}

				my $other_flight;

				# Find a friend that works with this panel if it can be done

				if ($num_judges > 1 && $flights > 1) {

					OTHER:
					foreach my $other (@{$panels{"all"}}) {

						next if $other == $panel;
						next if $panels{"bye"}{$other};
						next if $used{$other};
						next if ($test_judges{$other} && scalar (@{$test_judges{$other}}) >= $num_judges);

						my $nein;

						foreach my $judge (@{$test_judges{$panel}}) {

							foreach my $entry (@{$panels{"entries"}{$other}}) {

								$nein++ if $judges{"entry_strike"}{$judge}{$entry};

								if ($entries{$entry}{"event_id"}) {
									if ($judges{'no_event'}{$judge}{$entries{$entry}{"event_id"}}) {
										$nein++;
									}
								}
							}
						}

						unless ($nein) {
							$other_flight = $other;
							foreach my $judge (@{$test_judges{$panel}}) {
								push @{$test_panels{$judge}}, $other;
								push @{$test_judges{$other}}, $judge;
							}
							last OTHER;
							$used{$other}++;
						}
					}
				}

				next PANEL;
			}
		}

		foreach my $panel (@{$panels{"all"}}) {
			if ($test_judges{$panel}) {
				my $judgecount = scalar @{$test_judges{$panel}};
				if ($judgecount < $num_judges) {
					$attempt_total += 1000000000000;
				}
			}
		}

		unless ($prefs eq "none" || not defined $prefs) {

			foreach my $tock (1 .. 5) {

				next if $linked;

				PANEL:
				foreach my $first (@{$panels{"all"}}) {

					next if $panels{"bye"}{$first};
					my %entry_id;

					foreach (@{$panels{"entries"}{$first}}) {
						$entry_id{$_}++;
					}

					foreach my $first_judge (@{$test_judges{$first}}) {

						my $current_diff;
						my $swap_with;
						my $swap_panel;

						JUDGE:
						foreach my $second_judge (@{$judges{"all"}}) {

							next if $second_judge == $first_judge;
							next if $judges{"out"}{$second_judge};

							foreach my $entry (@{$panels{"entries"}{$first}}) {

								next JUDGE if $judges{"entry_strike"}{$second_judge}{$entry};

								if ($entries{$entry}{"event_id"}) {
									if ($judges{'no_event'}{$second_judge}{$entries{$entry}{"event_id"}}) {
										next JUDGE;
									}
								}
							}

							foreach my $judge (@{$test_judges{$first}}) {

								unless ($category_settings{"allow_school_panels"}) {
									next JUDGE
										if $judges{"school"}{$second_judge}
										== $judges{"school"}{$judge};
								}

								if ($tourn_settings->{"ncfl"}) {

									unless ($category_settings{"allow_school_panels"}) {
										if ($judges{"region"}{$second_judge} == $judges{"region"}{$judge}) {
											next JUDGE;
										}
									}

									unless ($category_settings{"allow_region_panels"}) {
										if ($judges{"dioregion"}{$second_judge} == $judges{"dioregion"}{$judge}) {
											next JUDGE;
										}
									}
								}
							}

							SECTION:
							foreach my $second (@{$test_panels{$second_judge}}) {

								if ($fix_flight{$first}
									&& $fix_flight{$second}
									&& $fix_flight{$first} != $fix_flight{$second}
								) {

									# Cannot swap section $first for section
									# $second because they're in different fixed
									# flights

									next SECTION;
								}

								foreach my $judge (@{$test_judges{$second}}) {

									unless ($category_settings{"allow_school_panels"}) {
										next JUDGE
											if $judges{"school"}{$first_judge}
											== $judges{"school"}{$judge};
									}

									if ($tourn_settings->{"ncfl"}) {

										unless ($category_settings{"allow_school_panels"}) {
											if ($judges{"region"}{$first_judge} == $judges{"region"}{$judge}) {
												next JUDGE;
											}
										}

										unless ($category_settings{"allow_region_panels"}) {
											if ($judges{"dioregion"}{$first_judge} == $judges{"dioregion"}{$judge}) {
												next JUDGE;
											}
										}
									}
								}
							}

							if ( $test_panels{$second_judge}
								&& (
									(scalar @{$test_panels{$second_judge}} >= $flights)
									|| ((scalar @{$test_panels{$second_judge}} >= $judges{"use"}{$second_judge}{"left"})
										&& $category_settings{"sections_per"})
								)
							) {

								foreach my $second (@{$test_panels{$second_judge}}) {

									next if $fix_flight{$first}
										&& $fix_flight{$second}
										&& $fix_flight{$first} != $fix_flight{$second};

									my $baseline_score = $judge_panel_score{$first_judge}{$first};
									my $second_score += $judge_panel_score{$second_judge}{$first};

									foreach my $entry (@{$panels{"entries"}{$second}}) {
										next JUDGE if $judges{"entry_strike"}{$first_judge}{$entry};
										if ($entries{$entry}{"event_id"}) {
											if ($judges{'no_event'}{$first_judge}{$entries{$entry}{"event_id"}}) {
												next JUDGE;
											}
										}
									}

									$second_score += $judge_panel_score{$first_judge}{$second};
									$baseline_score += $judge_panel_score{$second_judge}{$second};

									if ( ($baseline_score - $second_score) > $current_diff ) {
										$current_diff = $baseline_score - $second_score;
										$swap_with = $second_judge;
										$swap_panel = $second;
									}
								}

							} elsif ($judges{'flight'}{$second_judge}{$fix_flight{$first}}) {

								foreach my $second (@{$test_panels{$second_judge}}) {

									next if $fix_flight{$first}
										&& $fix_flight{$second}
										&& ($fix_flight{$first} != $fix_flight{$second});

									my $baseline_score = $judge_panel_score{$first_judge}{$first};
									my $second_score += $judge_panel_score{$second_judge}{$first};

									foreach my $entry (@{$panels{"entries"}{$second}}) {
										next JUDGE if $judges{"entry_strike"}{$first_judge}{$entry};
										if ($entries{$entry}{"event_id"}) {
											if ($judges{'no_event'}{$first_judge}{$entries{$entry}{"event_id"}}) {
												next JUDGE;
											}
										}
									}

									$second_score += $judge_panel_score{$first_judge}{$second};
									$baseline_score += $judge_panel_score{$second_judge}{$second};

									if ( ($baseline_score - $second_score) > $current_diff ) {
										$current_diff = $baseline_score - $second_score;
										$swap_with = $second_judge;
										$swap_panel = $second;
									}
								}

							} else {

								my $baseline_score = $judge_panel_score{$first_judge}{$first};
								my $second_score += $judge_panel_score{$second_judge}{$first};

								if ( ($baseline_score - $second_score) > $current_diff ) {
									$current_diff = $baseline_score - $second_score;
									$swap_with = $second_judge;
									undef $swap_panel;
								}
							}
						}

						if ($swap_with) {

							my @new_first;
							$attempt_total -= $current_diff;

							# Take Judge 1 $first_judge out of their current panel $first
							foreach my $judge (@{$test_judges{$first}}) {
								push @new_first, $judge unless $judge == $first_judge;
							}

							# Put judge 2, the $swap_with, into panel $first
							push @new_first, $swap_with;
							@{$test_judges{$first}} = @new_first;
							my @new_first_panels;

							# Take Panel $first out of the $first_judges's panels
							foreach my $panel (@{$test_panels{$first_judge}}) {
								next if $panel == $first;
								push @new_first_panels, $panel;
							}

							# If Judge 1 is taking Judge 2's place elsewhere, that is $swap_with and in J1 goes

							if ($swap_panel) {

								push @new_first_panels, $swap_panel;
								my @new_second;

								# Take J2 out of the swap with destination please
								foreach my $judge (@{$test_judges{$swap_panel}}) {
									push @new_second, $judge unless $judge == $swap_with;
								}

								push @new_second, $first_judge;
								@{$test_judges{$swap_panel}} = @new_second;
							}

							@{$test_panels{$first_judge}} = @new_first_panels;

							my @new_second_panels;

							foreach my $panel (@{$test_panels{$swap_with}}) {
								next if $panel == $swap_panel;
								push @new_second_panels, $panel;
							}

							push @new_second_panels, $first;
							@{$test_panels{$swap_with}} = @new_second_panels;

							if ($fix_flight{$swap_panel}) {
								undef $judges{'flight'}{$swap_with}{$fix_flight{$swap_panel}};
								$judges{'flight'}{$first_judge}{$fix_flight{$swap_panel}}++;
							}

							if ($fix_flight{$first}) {
								undef $judges{'flight'}{$first_judge}{$fix_flight{$first}};
								$judges{'flight'}{$swap_with}{$fix_flight{$first}}++;
							}
						}
					}
				}
			}
		}

		if ($current_total > $attempt_total || not defined $current_total ) {
			$current_total = $attempt_total;
			$panels{"judges"} = \%test_judges;
			$panels{"flight"} = \%test_flight;
			$judges{"panels"} = \%test_panels;
		}
	}

	foreach my $judge (@{$judges{"all"}}) {

		my $flight;

		next unless $judges{"panels"}{$judge};

		@{$judges{"panels"}{$judge}} =
			sort {$panels{"bracket"}{$b} <=> $panels{"bracket"}{$a}}
			@{$judges{"panels"}{$judge}};

		@{$judges{"panels"}{$judge}} =
			sort {$fix_flight{$a} <=> $fix_flight{$b}}
			@{$judges{"panels"}{$judge}};

		foreach my $panel (@{$judges{"panels"}{$judge}}) {
			$flight++;
			$panels{"flight"}{$panel} = $flight;
		}
	}

	foreach my $panel_id (@{$panels{"all"}}) {

		my $panel = Tab::Panel->retrieve($panel_id);

		if ($panel > 0) {
			$panel->flight($panels{"flight"}{$panel});
			$panel->flight(1) unless $panels{"flight"}{$panel};
			$panel->update();
			next if $panel->bye();

			foreach my $judge (@{$panels{"judges"}{$panel->id}}) {

				$m->comp("/funclib/panel_judgeadd.mas",
					panel    => $panel,
					judge_id => $judge
				);
			}
		}
	}

	my $msg = "Judges added";

	if ($ARGS{"return"}) {

		return $msg;

	} elsif (not defined $debug) {

		$m->comp("/funclib/panel_letters.mas", round => $round);

		if (
			$event_settings{"online_mode"}
			&& ($event_settings{"online_mode"} eq "public_jitsi"
				|| $event_settings{"online_mode"} eq "public_jitsi_observers"
				|| $event_settings{"online_mode"} eq "nsda_campus"
				|| $event_settings{"online_mode"} eq "nsda_campus_observers"
			) && (not defined $round->setting("use_normal_rooms"))
			&& (not defined $event_settings{"online_hybrid"})
		) {

			my $msg = "Sections assigned and renumbered by flight";
			$m->redirect("/panel/schemat/show.mhtml?round_id=".$round->id."&msg=$msg");

		} elsif ($flights == 1 || $linked) {

			$m->redirect("/panel/round/rooms.mhtml?round_id=".$round->id);
		} else {
			$m->redirect("/panel/schemat/show.mhtml?round_id=".$round->id."&disp=1&msg=$msg");
		}
	}

</%init>

	<div class="main">

		<h2> Wheee!!  <% $round->realname %></h2>

		<h4>Paneling total score is <% $current_total %></h4>

%		foreach my $panel (@{$panels{"all"}}) {

			<div class="row full">

				<span class="twentieth">
					<% $panels{"bracket"}{$panel} %> - <% $bracket_score{$panels{"bracket"}{$panel}} %>
					<% $panels{"bracketrank"}{$panel} %>
					<% $bracket_score{$panel} %>
				</span>

				<span class="twentieth">
					<% $panels{"flight"}{$panel} %>
				</span>

%				my $notfirst;

%				foreach my $entry (@{$panels{"entries"}{$panel}}) {
					<span class="fifth">
						<% $notfirst++ ? "vs " : "" %>
						<% $entries{$entry}{"seed"} %>
						<% $entries{$entry}{"code"} %>
					</span>
%				}

				<span class="half marno">
%					foreach my $judge (@{$panels{"judges"}{$panel}}) {
						<div class="full padless">
							Rating <% $judges{"rating"}{$judge} > 0 ? $judges{"rating"}{$judge} : "" %> :
							Prefs <% $prefs && $prefs ne "none" ? $judges{"panel_rating"}{$judge}{$panel} : "" %> -
							PScore <% $judge_panel_score{$judge}{$panel} %>
							Use <% $use_priority{$judge} %>
							<% $judges{"name"}{$judge} %>
						</div>
%					}
				</span>

			</div>
%		}

	</div>
