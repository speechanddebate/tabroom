<%args>
	$tourn
	$tourn_settings
	$person
	$round_id
	$min_bracket => undef
	$max_bracket => undef
</%args>
<%init>

	my $debug;

	use List::Util 'shuffle';

	my $round = Tab::Round->retrieve($round_id);

	my $event = $round->event;

    my $description = $person->first." ".$person->last." (".$person->email.") 
		has re-assigned the judges for round ".$round->realname." of ".$event->abbr;

	if ($min_bracket) { 
		$description .= " in debates with more than $min_bracket wins";
	}

	if ($max_bracket) { 
		$description .= " in debates with fewer than $max_bracket wins";
	}

    Tab::ChangeLog->create({ 
        type        => 'tabbing',
        event       => $event->id,
        tourn       => $tourn->id,
        person      => $person->id,
        description => $description
    }); 

    $m->comp(
		"/funclib/round_clear_judges.mas", 
		round       => $round,
		nobye       => 1,
		min_bracket => $min_bracket,
		max_bracket => $max_bracket
	);

	my @schools = $m->comp(
		"/funclib/event_schools.mas", 
		event => $event 
	);

	my $prelim_count;

	foreach my $round ($event->rounds) { 
		next if $round->type eq "elim";
		next if $round->type eq "final";
		next if $round->type eq "runoff";
		$prelim_count++;
	}

	my $event_type = $event->type;
	my $category = $event->category;

	my %category_settings = $category->all_settings;
	my %event_settings = $event->all_settings;

	my $this_round = $round->id;
	my $round_type = $round->type;

	my $tz = $tourn->tz;
	$tz = "UTC" unless $tz;

	my $round_start = $round->timeslot->start->set_time_zone($tz);
	my $round_end = $round->timeslot->end->set_time_zone($tz);

	my @jpool = $round->jpools;
	my $flights = $round->flighted;
	$flights = 1 unless $flights;
	$flights = 1 if $event_settings{"flight_rooms_only"};

	my %entry_seed_position = ();

	my $best_judges_highest_seed = 
		$event_settings{"best_judges_highest_seed"};

	my $logfirst;

	if ($best_judges_highest_seed) { 

		my (
			$entries_ref,
			$tbs_ref,
			$desc_ref,
			$forfeit_ref,
			$meh,
			$panrank_ref,
			$panletter_ref,
			$long_desc_ref
		) 
		= $m->comp(
			"/tabbing/results/order_entries.mas", 
			round => $round
		);

		foreach my $key (sort {$a <=> $b} keys %{$entries_ref}) {
			foreach my $entry_id (@{${$entries_ref}{$key}}) {
				$entry_seed_position{$entry_id} = $key;
			}

		}
	}

	my $num_judges = $round->setting("num_judges");
	$num_judges = 1 unless $num_judges;

    my %dio_region;

    if ($tourn_settings->{"ncfl"}) { 
        foreach my $diocese (
			$m->comp("/funclib/tourn_regions.mas", tourn => $tourn)
		) { 
            $dio_region{$diocese->id} = $diocese->setting('region-'.$event->id);
        }
    }   

	my $prefs = $category_settings{"prefs"};

	if ($prefs eq "ndt") { 
		if ($round->type eq "elim" 
			|| $round->type eq "final" 
			|| $round->type eq "runoff"
		) { 
			$prefs = "caps";
		} else { 
			$prefs = "ordinals";
		}
	}

	undef $prefs if $event_settings{"no_prefs"};
	undef $prefs if $prefs eq "none";

	my $tab_ratings = $category_settings{"tab_ratings"};
	my $coach_ratings = $category_settings{"coach_ratings"};

	my $dbh = Tab::DBI->db_Main();

	my $event_ballots_sth = $dbh->prepare("
		select distinct 
			ballot.id, ballot.judge, ballot.bye,
			round.id, round.type, 
			entry.id, entry.code, entry.school, region.id,
			seed.value, ballot.side, 
			panel.bracket, panel.id, panel.bye, 
			winner.value
		from (ballot, panel, round, entry, event, school)
		left join entry_setting seed on seed.entry = entry.id and seed.tag = 'pairing_seed'
		left join score winner on winner.ballot = ballot.id and winner.tag = 'ballot'
		left join region on school.region = region.id
		left join chapter on school.chapter = chapter.id

		where event.category = ?
		and round.event = event.id
		and round.id = panel.round
		and panel.id = ballot.panel
		and ballot.entry = entry.id
		and entry.school = school.id
	");

	$event_ballots_sth->execute($category->id);

	my %entries;
	my %judges;

	my %school_entries;
	my %region_entries;
	my %dioregion_entries;

	my %panels;

	my %ballot_type;
	my %ballot_side;
	my %ballot_entry;
	my %ballot_judge;
	my %ballot_winner;

	while (my (
		$ballot, $judge, $bbye,
		$round_id, $type,
		$entry, $code, $entry_school, $entry_region,
		$entry_seed, $side,
		$bracket, $panel, $pbye,
		$winner
	) = $event_ballots_sth->fetchrow_array() ) {

		if ($round_id == $this_round) { 

			next if defined($min_bracket) && $bracket <= $min_bracket;
			next if defined($max_bracket) && $bracket > $max_bracket;

			$entries{$entry}{"seed"} = $entry_seed;
			$entries{$entry}{"side"} = $side;
			$entries{$entry}{"code"} = $code;

			$entries{$entry}{"school"} = $entry_school;
			$entries{$entry}{"region"} = $entry_region;

			if ($tourn_settings->{"ncfl"}) { 
				$entries{$entry}{"dioregion"} 
					= $dio_region{$entry_region}
					if $entry_region;
			}

			push @{$school_entries{$entry_school}}, $entry;

			push @{$region_entries{$entry_region}}, $entry 
					if $entry_region;

			if ($tourn_settings->{"ncfl"}) { 
				push @{$dioregion_entries{$dio_region{$entry_region}}}, $entry 
					if $entry_region 
					&& $dio_region{$entry_region};
			}

			push @{$panels{"all"}}, $panel;

			$panels{"bye"}{$panel} = $pbye;

			$panels{"seed"}{$panel} = $entry_seed 
				unless $panels{"seed"}{$panel};

			$panels{"seed"}{$panel} = $entry_seed 
				if $entry_seed 
				&& $entry_seed < $panels{"seed"}{$panel};

			$panels{"bracket"}{$panel} = $bracket;

			if ($best_judges_highest_seed) { 

				if ($round->name == 1) { 

					$panels{"bracketrank"}{$panel} = $entry_seed
						unless $panels{"bracketrank"}{$panel};

					$panels{"bracketrank"}{$panel} = $entry_seed
						if $entry_seed < $panels{"bracketrank"}{$panel};

				} else { 

					$panels{"bracketrank"}{$panel} = $entry_seed_position{$entry} 
						unless $panels{"bracketrank"}{$panel};

					$panels{"bracketrank"}{$panel} = $entry_seed_position{$entry} 
						if $entry_seed_position{$entry} < $panels{"bracketrank"}{$panel};

				}
			}

			push @{$panels{"entries"}{$panel}}, $entry;

		} else { 

			push @{$judges{"rounds"}{$judge}}, $round_id if $round_id;
			push @{$judges{"ballots"}{$judge}}, $ballot;
			push @{$entries{$entry}{"ballots"}}, $ballot;

			$ballot_type{$ballot} = $type;
			$ballot_side{$ballot} = $side;
			$ballot_entry{$ballot} = $entry;
			$ballot_winner{$ballot} = $winner;
			$ballot_judge{$ballot} = $judge;

		}

	}

	my $judge_sth;

	if (@jpool) { 

		$judge_sth = $dbh->prepare("
			select distinct judge.id, concat_ws(' ',judge.last, judge.first) as name, 
				judge.school, region.id,
				tab_rating.value, 
				rating_tier.name, 
				diverse.value, 
				judge.obligation, judge.hired

			from (judge, jpool_judge, jpool_round)

			left join judge_setting as tab_rating on 
				tab_rating.judge = judge.id 
				and tab_rating.tag = 'tab_rating'

			left join judge_setting as diverse on 
				diverse.judge = judge.id and diverse.tag = 'diverse'

			left join rating coach_rating on 
				coach_rating.judge = judge.id and coach_rating.type = 'coach'

			left join rating_tier on 
				coach_rating.rating_tier = rating_tier.id

			left join school on judge.school = school.id 
			left join chapter on school.chapter = chapter.id
			left join region on school.region = region.id

			where judge.active = 1
			and judge.id = jpool_judge.judge
			and jpool_round.jpool = jpool_judge.jpool
			and jpool_round.round = ?
			group by judge.id
		");

	} else { 

		$judge_sth = $dbh->prepare("
			select distinct judge.id, concat_ws(' ',judge.last, judge.first) as name, 
				judge.school, region.id,
				tab_rating.value, 
				rating_tier.name, 
				diverse.value, 
				judge.obligation, judge.hired

			from (judge, event, round)

			left join judge_setting as tab_rating 
				on tab_rating.judge = judge.id 
				and tab_rating.tag = 'tab_rating'

			left join judge_setting as diverse 
				on diverse.judge = judge.id 
				and diverse.tag = 'diverse'

			left join rating coach_rating 
				on coach_rating.judge = judge.id 
				and coach_rating.type = 'coach'

			left join rating_tier on coach_rating.rating_tier = rating_tier.id

			left join school on judge.school = school.id
			left join region on school.region = region.id
			left join chapter on school.chapter = chapter.id

			where judge.active = 1
			and judge.category = event.category 
			and event.id = round.event
			and round.id = ?
			group by judge.id
		");

	}

	$judge_sth->execute($round->id);

	my %school_judges;
	my %region_judges;

	while (
		my ($id, $last, 
			$school, $region,
			$tab_rating,
			$coach_rating,
			$diverse,
			$obligation,
			$hired,
		) = $judge_sth->fetchrow_array()
	) {

		next unless $id;

		push @{$judges{"all"}}, $id;

		$judges{"name"}{$id} = $last;
		$judges{"school"}{$id} = $school;

		$judges{"region"}{$id} = $region;

		if ($tourn_settings->{"ncfl"}) { 
			$judges{"dioregion"}{$id} = $dio_region{$region} 
				if $region;
		}	

		$judges{"rating"}{$id} = $tab_rating 
			if $tab_ratings;

		$judges{"rating"}{$id} = $coach_rating 
			if $coach_ratings;

		$judges{"diverse"}{$id} = $diverse;

		$judges{"obligation"}{$id} = $obligation + $hired; 

		push @{$school_judges{$school}}, $id;
			
		unless ($event_settings{"allow_judge_own"}) { 

			push @{$judges{"conflicts"}{$id}}, @{$school_entries{$school}}
				if $school_entries{$school} ;

			if ( 
				$event_settings{"region_constrain"} 
				|| $tourn_settings->{"ncfl"}
			) { 

				push @{$judges{"conflicts"}{$id}}, @{$region_entries{$region}}
					if $region_entries{$region};
			}

		}

		if ($tourn_settings->{"ncfl"} 
			&& $category_settings{"conflict_region_judges"}
		) { 
			push @{$judges{"conflicts"}{$id}}, @{$dioregion_entries{$dio_region{$region}}}
				if $region
				&& $dioregion_entries{$dio_region{$region}}
		}

	}

	unless ($judges{"all"} && @{$judges{"all"}}) { 

		# does the next line replace this? JB 
		# No, because the next is only triggered if there are pools - CLP

		my $err = "No judges were available."; 

		$err = "No judges were found.  Did you put judges into the judge pools?" 
			if @jpool;

		$m->redirect("/panel/schemat/show.mhtml?round_id=".$round->id."&disp=1&err=$err");

	}

	my $strikes_sth = $dbh->prepare("
		select distinct strike.id, strike.judge, strike.type, strike.event, strike.entry, 
			strike.school, strike.region, strike.dioregion, strike.start, strike.end
		from strike
		where strike.tourn = ?
	");

	$strikes_sth->execute($tourn->id);

	while (
		my ($id, $judge, $type, 
			$strike_event, $entry, $school, $region, $dioregion, $start, $end
		) = $strikes_sth->fetchrow_array() 
	) {

		if ($type eq "conflict" || $type eq "entry") { 

			if ($school) {	 

				push @{$judges{"conflicts"}{$judge}}, @{$school_entries{$school}} 
					if $school_entries{$school};

			} else {  
				push @{$judges{"conflicts"}{$judge}}, $entry;
			}
		} 

		if ($type eq "elim" || $type eq "event") { 

			next if ($round_type eq "elim" 	
					|| $round_type eq "final"
					|| $round_type eq "runoff") 
				&& $type eq "elim";

			next unless $strike_event == $event->id;
			$judges{"out"}{$judge}++;
		}

		if ($type eq "hybrid") { 
			foreach my $school_judge (@{$school_judges{$school}}) { 
				push @{$judges{"conflicts"}{$school_judge}}, $entry;
			}
		}

		if ($type eq "region") { 
			push @{$judges{"conflicts"}{$judge}}, @{$region_entries{$region}}
				if $region_entries{$region};
		}

		if ($tourn_settings->{"ncfl"}) { 
			if ($type eq "dioregion") { 
				push @{$judges{"conflicts"}{$judge}}, @{$dioregion_entries{$dioregion}} 
					if $dioregion_entries{$dioregion};
			}
		}

		if ($type eq "school") { 
			push @{$judges{"conflicts"}{$judge}}, @{$school_entries{$school}} 
				if $school_entries{$school};
		}

		if ($type eq "time") { 

			my $start_dt;
			my $end_dt; 

			eval { 
				$start_dt = DateTime::Format::MySQL->parse_datetime($start);
				$end_dt = DateTime::Format::MySQL->parse_datetime($end);
			};

			if ($start_dt && $end_dt) { 

				$start_dt->set_time_zone("UTC");
				$end_dt->set_time_zone("UTC");

				$start_dt->set_time_zone($tz);
				$end_dt->set_time_zone($tz);

				$judges{"out"}{$judge}++  
					if ($round_start <= $end_dt 
						&& $round_end >= $start_dt);

			}
		}
	}

	my $rounds_missed_sth = $dbh->prepare("
		select distinct judge.id, count(round.id)
		from judge, round, timeslot, strike, event
		where judge.id = strike.judge
		and judge.category = event.category
		and event.id = ? 
		and round.event = event.id
		and strike.type = 'time'
		and strike.start < timeslot.end
		and strike.end > timeslot.start
		and timeslot.id = round.timeslot
		group by judge.id
	");

	$rounds_missed_sth->execute($event->id);

	while (
		my ($judge, $rounds_struck) 
		= $rounds_missed_sth->fetchrow_array() 
	) {
		$judges{"roundstruck"}{$judge} = $rounds_struck;
	}

	if (@jpool) { 

		my $busy_sth = $dbh->prepare("
			select distinct judge.id
			from ballot, panel, round, timeslot, timeslot mytime, round myround, 
				judge, jpool_judge, jpool_round
			where myround.id = ? 
			and myround.timeslot = mytime.id
			and mytime.start < timeslot.end
			and mytime.end > timeslot.start
			and timeslot.id = round.timeslot
			and round.id = panel.round
			and panel.id = ballot.panel
			and ballot.judge = judge.id
			and judge.id = jpool_judge.judge
			and jpool_judge.jpool = jpool_round.jpool 
			and jpool_round.round = myround.id
		");

		$busy_sth->execute($round->id);

		while (my ($judge) = $busy_sth->fetchrow_array() ) {

			$judges{"out"}{$judge}++;
		}

	} else { 

		my $busy_sth = $dbh->prepare("
			select distinct judge.id
			from ballot, panel, round, timeslot, timeslot mytime, round myround, judge
			where myround.id = ?
			and myround.timeslot = mytime.id
			and mytime.start < timeslot.end
			and mytime.end > timeslot.start
			and timeslot.id = round.timeslot
			and round.id = panel.round
			and panel.id = ballot.panel
			and ballot.judge = judge.id
			and judge.category = ?
		");

		$busy_sth->execute($round->id, $category->id);

		while (my ($judge) = $busy_sth->fetchrow_array() ) {

			$judges{"out"}{$judge}++;
		}

	}

	my %tier_value;
	my %tier_strike;

	my $tiers;

	if ($prefs && $prefs ne "ordinals") { 

		$tiers++;

		foreach my $tier (
			sort {$a->name cmp $b->name} 
			$category->rating_tiers(type => "mpj")
		) {
			$tier_value{$tier->id} = $tier->name;
			$tier_strike{$tier->id}++ 
				if $tier->strike || $tier->conflict;
		}
	}

	my $ratings_sth = $dbh->prepare("
		select distinct rating.id, rating.judge, rating.entry, rating.rating_tier, rating.percentile
		from rating, ballot, panel
		where panel.round = ?
		and ballot.panel = panel.id
		and panel.bye = 0
		and ballot.bye = 0
		and ballot.entry = rating.entry
		and not exists ( 
			select school_setting.id
			from school_setting, entry
			where rating.entry = entry.id
			and school_setting.school = entry.school
			and school_setting.tag = 'noprefs'
			and school_setting.value = 1
		)
		group by rating.id
	");

	$ratings_sth->execute($round->id);

	my %mjp;

	while (
		my ($id, $judge, $entry, $tier, $percentile) 
		= $ratings_sth->fetchrow_array() 
	) {

		next unless ($tier || $percentile);

		$mjp{$judge}{$entry} = $tier_value{$tier} 
			if $tier > 0;

		$mjp{$judge}{$entry} = $percentile 
			if $percentile > 0;

		push @{$judges{"conflicts"}{$judge}}, $entry 
			if $tier && $tier_strike{$tier};
	}

	my %panel_seen = (); 

	#Deduplicate
	@{$panels{"all"}} = 
		grep { ! $panel_seen{$_} ++ } 
		@{$panels{"all"}};

	@{$panels{"all"}} = 
		sort {$panels{"bracket"}{$b} <=> $panels{"bracket"}{$a}} 
		@{$panels{"all"}};

	$judges{"use"} = $m->comp(
		"/funclib/judge_use.mas", 
		round_id => $round->id
	);    

	my $round_burn_avoid = $category_settings{"round_burn_avoid"};
	my $mutuality = $category_settings{"mutuality"};
	my $preference = $category_settings{"preference"};
	my $default_mjp = $category_settings{"default_mjp"};
	my $diversity = $category_settings{"diverse_judge_weight"};
	my $suckage = $category_settings{"sucktastic_judge_weight"};
	my $prefer_hireds = $category_settings{"mjp_prefer_hireds"};

	$diversity = 1 if not defined $diversity;
	$suckage = 3 if not defined $suckage;
	$mutuality = 40 if not defined $mutuality;
	$preference = 15 if not defined $preference;
	$preference = 100 if $best_judges_highest_seed;
	$default_mjp = 2 if not defined $default_mjp;
	$round_burn_avoid =  5 if not defined $round_burn_avoid;
	$prefer_hireds = 10 if not defined $prefer_hireds;

	$round_burn_avoid -= 3 if $min_bracket;

	$mutuality        = 0 if $mutuality < 0;
	$diversity        = 0 if $diversity < 0;
	$suckage          = 0 if $suckage < 0;
	$preference       = 0 if $preference < 0;
	$default_mjp      = 0 if $default_mjp < 0;
	$round_burn_avoid = 0 if $round_burn_avoid < 0;
	$prefer_hireds    = 0 if $prefer_hireds < 0;

	$preference = 15 if $tab_ratings && $preference < 1;

	unless ($prefs) { 
		$mutuality   = 0;
		$suckage     = 0;
		$default_mjp = 0;
	}

	$round_burn_avoid = 0 unless $category_settings{"rounds_per"};

	my %use_priority;

	my %judge_prefs = $m->comp(
		"/funclib/judges_by_pref.mas", 
		category => $category
	);

	foreach my $judge (@{$judges{"all"}}) {

		my %seen = (); 

		@{$judges{"rounds"}{$judge}} = 
			grep { ! $seen{$_}++ } 
			@{$judges{"rounds"}{$judge}};

		my $num_rounds = scalar @{$judges{"rounds"}{$judge}};

		$judges{"score"}{$judge} += 
			scalar @{$judges{"conflicts"}{$judge}} 
			if $judges{"conflicts"}{$judge};

		if ( $category_settings{"rounds_per"} && (
				($round_type ne "elim" 
					&& $round_type ne "final" 
					&& $round_type ne "runoff"
				)
				|| ($tourn_settings->{"nsda_nats"} 
					&& (not defined $event_settings{"not_nats"})
				)
			)
		) { 

			$judges{"out"}{$judge}++ 
				if $num_rounds >= $judges{"obligation"}{$judge};
	
			my $remaining_prelims = $prelim_count + 1 - $round->name;

			my $rounds_left = $judges{"use"}{$judge}{"percentage"} * .01 * $judges{"use"}{$judge}{'left'};

			my $rounds_judged = $judges{"use"}{$judge}{"judged_already"};

			my $round_diff = $remaining_prelims - $rounds_left;

			if ($round_diff > 0) { 
				$judges{"score"}{$judge} += $round_diff ** $round_burn_avoid;
				$use_priority{$judge} += $round_diff ** $round_burn_avoid;
			}

			$use_priority{$judge} += $rounds_judged; #All else equal use the newbies;

			$use_priority{$judge."-dontcare"} += 1000000000 * ($round_diff ** $round_burn_avoid ** 2) 
				if $round_diff > 0 && $prefs eq "ordinals";

			$judges{"roundcount"}{$judge} = $num_rounds;

		} else {

			my $round_factor = $num_rounds;
			$round_factor -= $judges{"roundstruck"}{$judge};

			$round_factor = $round_factor * $round_burn_avoid;

			$judges{"score"}{$judge} += $round_factor * .1;
			$use_priority{$judge} += $round_factor * .1;
			$judges{"roundcount"}{$judge} = $num_rounds;
	
			if (
				$tourn_settings->{"ncfl"} 
				&& (
					$round_type eq "elim" 
					|| $round_type eq "final"
					|| $round_type eq "runoff"
				)
			) { 
				$judges{"score"}{$judge} += 50000 
					if $judges{"rating"}{$judge} eq "A";

				$judges{"score"}{$judge} += 2500 
					if $judges{"rating"}{$judge} eq "B";

				$use_priority{$judge} -= 50000 
					if $judges{"rating"}{$judge} eq "A";

				$use_priority{$judge} -= 2500 
					if $judges{"rating"}{$judge} eq "B";
			}

		}

		$use_priority{$judge} -= $prefer_hireds 
			if $judges{"school"}{$judge} < 1;

		$use_priority{$judge} -= $judges{"diverse"}{$judge} * $diversity 
			if $diversity;

		$use_priority{$judge} -= 
			($judge_prefs{$judge}{"avg"} - ($judge_prefs{$judge}{"stdv"}/3)) * $suckage 
			if $suckage;

		next if $judges{"out"}{$judge};

		if ($judges{"ballots"}{$judge}) { 

			BALLOT:

			foreach my $ballot ( 
				sort { $entries{$ballot_entry{$a}}{"code"} 
				cmp $entries{$ballot_entry{$b}}{"code"}} @{$judges{"ballots"}{$judge}}
			) { 

				my $entry = $ballot_entry{$ballot};

				if ($event_settings{"allow_repeat_elims"} && 
						($round_type eq "elim" 
						|| $round_type eq "final" 
						|| $round_type eq "runoff" 
						|| $ballot_type{$ballot} eq "elim" 
						|| $ballot_type{$ballot} eq "final"
						|| $ballot_type{$ballot} eq "runoff"
						)
					) { 

					if ($event_settings{"disallow_repeat_drop"}) { 
						next BALLOT if $ballot_winner{$ballot};
					} else { 
						next BALLOT;
					}
				}

				push @{$judges{"avoid"}{$judge}}, $entry;

				next if $event_settings{"allow_repeat_judging"};

				next if $event_settings{"allow_repeat_prelim_side"} 
					&& $ballot_side{$ballot} != $entries{$entry}{"side"};

				push @{$judges{"conflicts"}{$judge}}, $entry;
			}

		}

		foreach my $clash (@{$judges{"conflicts"}{$judge}}) { 
			$judges{"entry_strike"}{$judge}{$clash}++;
		}

	}

	my %default_settings = $m->comp(
		"/funclib/default_rating_settings.mas", 
		type => $event->type
	);

	my $bracket_order = $round->setting("tab_rating_priority");
	$bracket_order = $default_settings{$round->name} unless $bracket_order;
	$bracket_order =~ s/\s*//g;

	my @orders = split(/\,/, $bracket_order) 
		unless $round_type eq "elim" 
		|| $round_type eq "final"
		|| $round_type eq "runoff";

	my %bracket_score;
	my $order_multiplier;

	my $last_order = 0;
	my $shuffle_post;

	undef @orders 
		if $round->type eq "prelim" 
		&& (not defined $tourn_settings->{"wsdc"});

	unless (@orders) { 
		foreach (1 .. $num_judges) { 
			push @orders, 0;
			$shuffle_post++;
		}
	} 

	my $multiplier = scalar @orders + 1; 

	my %order_count = ();

	foreach my $order (@orders) { 
		$order_count{$order}++;
	}

	my @new_orders;

	foreach my $order (@orders) { 

		my $lack = $num_judges - $order_count{$order};

		while ($lack > 0) { 
			push @new_orders, $order;
			$lack--;
		}
	}

	push @orders, @new_orders;

	my $loss_threshold = $event_settings{"break_point"};
	undef $loss_threshold unless $event_settings{"nobreak_noprefs"};

	my $max_pref = $event_settings{"max_pref"} 
		if $event_settings{"max_pref"}; 

	my $max_nobreak_pref = $event_settings{"max_nobreak_pref"} 
		if $event_settings{"max_nobreak_pref"}; 

	my $bracket_dont_give_a_shit = $round->name - $loss_threshold - 1 
		if $loss_threshold > 0;

	my $max_panel_bracket_rank;

	foreach my $panel (keys %{$panels{"bracketrank"}} ) { 

		$max_panel_bracket_rank = $panels{"bracketrank"}{$panel} 
			if $max_panel_bracket_rank < $panels{"bracketrank"}{$panel};
	}

	$max_panel_bracket_rank++;

	foreach my $order (reverse @orders) { 

		foreach my $panel (@{$panels{"all"}}) { 

			next unless $panels{"bracket"}{$panel} == $order;

			if ($best_judges_highest_seed) { 

				my $mult = $order;

				$mult = 3 if $round->name == 1 && $order == 0;

				$bracket_score{$panel} = 
					($max_panel_bracket_rank - $panels{"bracketrank"}{$panel}) ** $mult;

			} else { 
				$bracket_score{$panel} = $order * 2;
			}
		}
		$last_order = $order;
	}

	my $seed_order = $round->setting("tab_seed_priority");

	$seed_order =~ s/\s*//g;

	my @seed_orders = split(/\,/, $seed_order) 
		if $round_type eq "prelim";

	my %seed_score;

	undef $order_multiplier;

	foreach my $order (reverse @seed_orders) { 

		$order_multiplier++;
		$order_multiplier++;

		foreach my $panel (@{$panels{"all"}}) { 
			$panels{"seed"}{$panel} = 0 unless $panels{"seed"}{$panel};
			next unless $panels{"seed"}{$panel} == $order;
			$seed_score{$panel} = $order_multiplier;
		}

		$last_order = $order; 

	}

	$last_order++;
	foreach my $panel (@{$panels{"all"}}) { 
		next if $seed_score{$panel};
		$seed_score{$panel} = $last_order;
	}

	my %fix_flight;

	my @flight_settings = 
		$m->comp(
			"/funclib/event_entry_settings.mas", 
			event => $event,
			tag   => "preferred_flight"
		);

	my %preferred_flight = 
		map {$_->entry->id => $_->value} 
		@flight_settings;

	my %judge_panel_score;

	@{$panels{"all"}} = shuffle @{$panels{"all"}} if $shuffle_post;
	
	if ($best_judges_highest_seed) { 

		@{$panels{"all"}} = sort {
			$panels{"bracketrank"}{$a} <=> $panels{"bracketrank"}{$b}
		} @{$panels{"all"}};

	}

	PANEL:
	foreach my $panel (@{$panels{"all"}}) { 

		next if $panels{"bye"}{$panel};

		my $dont_care++ if $bracket_dont_give_a_shit 
			&& $panels{"bracket"}{$panel} <= $bracket_dont_give_a_shit;

		undef $dont_care if $round->name == 1;

		JUDGE:
		foreach my $judge (@{$judges{"all"}}) { 

			my $score = 0;
			next JUDGE if $judges{"out"}{$judge};

			my $diff;
			my $mjp_first;

			foreach my $entry (@{$panels{"entries"}{$panel}}) { 
	
				if ($flights > 1 ) { 
					$fix_flight{$panel} = $preferred_flight{$entry};
					$fix_flight{$panel} = ($flights + 1) / 2 
						unless $preferred_flight{$entry};
				}

				$score += 50000 if $judges{"avoid"}{$entry};
				$score += 500000 if $judges{"avoid"}{$entry} && $prefs eq "ordinals";
				$score += 100000000 if $judges{"entry_strike"}{$judge}{$entry};

				my $mjp_rating = $mjp{$judge}{$entry};
				$mjp_rating = $default_mjp unless $mjp_rating;
				
				if ($dont_care && $max_nobreak_pref) { 
					$score += 500000 if $mjp_rating > $max_nobreak_pref;
				} elsif ($max_pref) { 
					$score += 500000 if $mjp_rating > $max_pref;
				}

				if ($event_settings{"region_avoid"}) { 
					$score += 100 if $entries{$entry}{"region"} == $judges{"region"}{$judge};
				}

				if ($event_settings{"region_constrain"}) { 
					if ($entries{$entry}{"region"} == $judges{"region"}{$judge}) { 
						$score += 5000000;
					}
				}

				if ($tourn_settings->{"ncfl"}) { 
					$score += 5000000 if $entries{$entry}{"dioregion"} 
						== $judges{"dioregion"}{$judge};
				}

				if ($prefs && $prefs ne "none") { 

					if ($mjp_first) { 

						$diff = abs($mjp_first - $mjp_rating) 
							if $mjp_first && $mjp_rating;

					} else { 

						$mjp_first = $mjp_rating 
							unless $mjp_first;
					}

					if ($dont_care) {

						$score += $mjp_rating * .1;

					} else { 

						$score += $mjp_rating * $preference;

						$score += $default_mjp * $preference 
							unless $mjp_rating;
					}

					$judges{"panel_rating"}{$judge}{$panel} .= " - " 
						if $judges{"panel_rating"}{$judge}{$panel};

					$judges{"panel_rating"}{$judge}{$panel} .= $mjp_rating;

					$judges{"panel_rating"}{$judge}{$panel} .= "1" 
						if not defined $mjp_rating &! $dont_care;

				}

			}

			my $caring_quota = 1;
			$caring_quota = .01 if $dont_care;

			$score += $diff * $mutuality * $caring_quota 
				if $prefs 
				&& $prefs ne "none";

			$score += $judges{"roundcount"}{$judge} * .1;

			$score += $use_priority{$judge};

			$score += $use_priority{$judge."-dontcare"} 
				if $dont_care;

			if ($tab_ratings &! $dont_care) { 
				$score += $judges{"rating"}{$judge} * $preference
					if $judges{"rating"}{$judge} eq int($judges{"rating"}{$judge});
			} 

			$score += $score * $bracket_score{$panel} 
				if $bracket_score{$panel} 
				&& $round_type ne "elim" 
				&! $dont_care;

			$score += $score * $seed_score{$panel} 
				if $seed_score{$panel} 
				&& $round_type eq "prelim" 
				&! $dont_care;

			$score += $judges{'rating'}{$judge} if $tab_ratings;

			$judge_panel_score{$judge}{$panel} = $score;

		}
	}

	my $panel_done;

	my $current_total;
	my $linked;

	foreach my $tick (1 .. 10) { 

		my %test_judges;
		my %test_flight;
		my %test_panels;
		my %panel_link;
		my %am_other;

		if ($num_judges > 1 && $flights > 1) { 

			$linked++;

			if ($tourn_settings->{"ncfl"}) { 

				my %matches_with = ();
			
				foreach my $panel (shuffle @{$panels{"all"}}) {
			
					@{$matches_with{$panel}} = ();

					MATCH:
					foreach my $potential_match (shuffle @{$panels{"all"}}) {

						next if $panel == $potential_match;
						next if $panels{"bye"}{$panel};

						foreach my $first (@{$panels{"entries"}{$potential_match}}) { 

							foreach my $second (@{$panels{"entries"}{$panel}}) { 
								next MATCH 
									if $entries{$first}{"dioregion"} 
									== $entries{$second}{"dioregion"};
							}
						}

						push @{$matches_with{$panel}}, $potential_match;
					}
				}

				@{$panels{"all"}} = 
					sort { scalar @{$matches_with{$a}} <=> scalar @{$matches_with{$b}} } 
					@{$panels{"all"}};

				my %taken = ();

				PANEL:
				foreach my $panel (@{$panels{"all"}}) { 

					next if $panels{"bye"}{$panel};
					next if $taken{$panel}++;

					my $current_flight = 1;

					$test_flight{$panel} = $current_flight;

					MATCH:
					foreach my $match (shuffle @{$matches_with{$panel}}) { 

						next if $taken{$match}++;

						push @{$panel_link{$panel}}, $match;
						$am_other{$match}++;

						$current_flight++;
						$test_flight{$match} = $current_flight;

						if ($current_flight >= $flights) {
							next PANEL;
						}
					}

					unless (
						$panel_link{$panel} 
						&& (scalar @{$panel_link{$panel}} == ($flights - 1))
					) { 

						MATCH:
						foreach my $match (shuffle @{$panels{"all"}}) { 
						
							next if $taken{$match}++;

							push @{$panel_link{$panel}}, $match;
							$am_other{$match}++;

							$current_flight++;
							$test_flight{$match} = $current_flight;

							if ($current_flight >= $flights) {
								next PANEL;
							}
						}
					}
				}

			} else { 
			
				my $current_flight = 1;
				my $last_panel;

				@{$panels{"all"}} = shuffle @{$panels{"all"}}
					unless $best_judges_highest_seed;
				
				foreach my $panel (@{$panels{"all"}}) {

					next if $panels{"bye"}{$panel};

					$test_flight{$panel} = $current_flight;
					push @{$panel_link{$panel}}, $last_panel;

					$am_other{$last_panel}++;
					$current_flight++;

					if ($current_flight > $flights) {
						$current_flight = 1;
						undef $last_panel;
					} else {
						$last_panel = $panel;
					}
				}

			}

			@{$panels{"all"}} = 
				sort {$test_flight{$b} <=> $test_flight{$a}} 
				@{$panels{"all"}};
		}

		my %judge_used;
		my $attempt_total;
		my $order_count;

		my %already;

		foreach my $order (@orders) { 

			$order_count++;
			@{$panels{"all"}} = reverse @{$panels{"all"}} unless $_ % 2;

			my %used;

			PANEL:
			foreach my $panel (@{$panels{"all"}}) { 

				next if $panels{"bye"}{$panel};
				next if $am_other{$panel};
				next if $used{$panel};

				next if $round_type ne "final" 
					&& $round_type ne "elim" 
					&& $round_type ne "runoff" 
					&& defined $panels{"bracket"}{$panel} 
					&& $order != $panels{"bracket"}{$panel};

				my @others = @{$panel_link{$panel}} if $panel_link{$panel};

				@{$judges{"all"}} = 
					sort {$judges{"score"}{$b} <=> $judges{"score"}{$a}} 
					@{$judges{"all"}};

				@{$judges{"all"}} = 
					sort {$judge_panel_score{$b}{$panel} <=> $judge_panel_score{$a}{$panel}} 
					@{$judges{"all"}};

				JUDGE:
				foreach my $judge (@{$judges{"all"}}) { 

					next JUDGE if $judges{"out"}{$judge};
					next JUDGE if $judge_used{$judge} >= $flights;
					next JUDGE if $judge_used{$judge} && $linked;

					foreach my $entry (@{$panels{"entries"}{$panel}}) { 
						next JUDGE if $judges{"entry_strike"}{$judge}{$entry};
					}

					unless ($category_settings{"allow_school_panels"}) { 
						next JUDGE 
							if $already{$panel}{"school"}{$judges{"school"}{$judge}} 
							&& $judges{"school"}{$judge};
					}

					if ($tourn_settings->{"nsda_nats"}) { 
						unless ($category_settings{"allow_region_panels"}) { 
							next JUDGE 
								if $already{$panel}{"region"}{$judges{"region"}{$judge}} 
								&& $judges{"region"}{$judge};
						}
					}

					if ($tourn_settings->{"ncfl"}) { 

						unless ($category_settings{"allow_school_panels"}) { 
							next JUDGE 
								if $already{$panel}{"region"}{$judges{"region"}{$judge}} 
								&& $judges{"region"}{$judge};
						}

						unless ($category_settings{"allow_region_panels"}) { 
							next JUDGE 
								if $already{$panel}{"dioregion"}{$judges{"dioregion"}{$judge}} 
								&& $judges{"dioregion"}{$judge};
						}
					}

					foreach my $other (@others) { 

						foreach my $entry (@{$panels{"entries"}{$other}}) { 
							next JUDGE if $judges{"entry_strike"}{$judge}{$entry};
						}

						push @{$test_judges{$other}}, $judge;
						push @{$test_panels{$judge}}, $other;

						$judge_used{$judge}++;
						$attempt_total += $judge_panel_score{$judge}{$other};
						$used{$other}++;
					}

					push @{$test_judges{$panel}}, $judge;
					push @{$test_panels{$judge}}, $panel;

					$judge_used{$judge}++;

					$already{$panel}{"school"}{$judges{"school"}{$judge}}++;

					$already{$panel}{"region"}{$judges{"region"}{$judge}}++ 
						if $judges{"region"}{$judge};

					$already{$panel}{"region"}{$judges{"region"}{$judge}}++ 
						if $judges{"region"}{$judge};

					$already{$panel}{"dioregion"}{$judges{"dioregion"}{$judge}}++
						if $judges{"dioregion"}{$judge};

					$used{$panel}++; 

					$test_flight{$panel} = $judge_used{$judge} unless $test_flight{$panel};
					$attempt_total += $judge_panel_score{$judge}{$panel};

					next PANEL;
				}
			}
		}

		foreach my $panel (@{$panels{"all"}}) { 
			if ($test_judges{$panel}) { 
				my $judged = scalar @{$test_judges{$panel}};
				if ($judged < $num_judges) { 
					$attempt_total += 1000000000000;
				}
			}
		}

		foreach my $tock (1 .. 10) { 

			next if $linked;

			PANEL:
			foreach my $first (@{$panels{"all"}}) { 
		
				next if $panels{"bye"}{$first};

				my %entry_id;

				foreach (@{$panels{"entries"}{$first}}) {   
					$entry_id{$_}++;
				}

				foreach my $first_judge (@{$test_judges{$first}}) { 

					my $current_diff;
					my $swap_with;
					my $swap_panel;

					JUDGE:
					foreach my $second_judge (@{$judges{"all"}}) { 

						next if $second_judge == $first_judge;
						next if $judges{"out"}{$second_judge};

						foreach my $entry (@{$panels{"entries"}{$first}}) {   
							next JUDGE if $judges{"entry_strike"}{$second_judge}{$entry};
						}

						foreach my $judge (@{$test_judges{$first}}) {   

							unless ($category_settings{"allow_school_panels"}) { 
								next JUDGE 
									if $judges{"school"}{$second_judge} 
									== $judges{"school"}{$judge};
							}

							if ($tourn_settings->{"ncfl"}) { 

								unless ($category_settings{"allow_school_panels"}) { 
									next JUDGE 
										if $judges{"region"}{$second_judge} 
										== $judges{"region"}{$judge};
								}
						
								unless ($category_settings{"allow_region_panels"}) { 
									if ($judges{"dioregion"}{$second_judge} == $judges{"dioregion"}{$judge}) { 
										next JUDGE;
									}
								}
							}
						}

						foreach my $second (@{$test_panels{$second_judge}}) { 

							foreach my $judge (@{$test_judges{$second}}) {   

								unless ($category_settings{"allow_school_panels"}) { 
									next JUDGE 
										if $judges{"school"}{$first_judge} 
										== $judges{"school"}{$judge};
								}

								if ($tourn_settings->{"ncfl"}) { 

									unless ($category_settings{"allow_school_panels"}) { 
										next JUDGE 
											if $judges{"region"}{$first_judge} 
											== $judges{"region"}{$judge};
									}
							
									unless ($category_settings{"allow_region_panels"}) { 
										if ($judges{"dioregion"}{$first_judge} == $judges{"dioregion"}{$judge}) { 
											next JUDGE;
										}
									}
								}
							}
						}

						if (
							$test_panels{$second_judge} 
							&& scalar @{$test_panels{$second_judge}} >= $flights
						) { 

							foreach my $second (@{$test_panels{$second_judge}}) { 
						
								my $baseline_score = $judge_panel_score{$first_judge}{$first};
								my $second_score += $judge_panel_score{$second_judge}{$first};

								foreach my $entry (@{$panels{"entries"}{$second}}) {   
									next JUDGE if $judges{"entry_strike"}{$first_judge}{$entry};
								}

								$second_score += $judge_panel_score{$first_judge}{$second};
								$baseline_score += $judge_panel_score{$second_judge}{$second};

								if ( ($baseline_score - $second_score) > $current_diff ) { 
									$current_diff = $baseline_score - $second_score;
									$swap_with = $second_judge;
									$swap_panel = $second;
								}
							}

						} else { 

							my $baseline_score = $judge_panel_score{$first_judge}{$first};
							my $second_score += $judge_panel_score{$second_judge}{$first};


							if ( ($baseline_score - $second_score) > $current_diff ) { 
								$current_diff = $baseline_score - $second_score;
								$swap_with = $second_judge;
								undef $swap_panel;
							}
						}
					}

					if ($swap_with) { 

						$attempt_total -= $current_diff;
						
						my @new_first;

						foreach my $judge (@{$test_judges{$first}}) { 
							push @new_first, $judge unless $judge == $first_judge;
						}

						push @new_first, $swap_with;
						@{$test_judges{$first}} = @new_first;

						my @new_first_panels;

						foreach my $panel (@{$test_panels{$first_judge}}) { 
							next if $panel == $first;
							push @new_first_panels, $panel;
						}

						if ($swap_panel) { 
							push @new_first_panels, $swap_panel;

							my @new_second;

							foreach my $judge (@{$test_judges{$swap_panel}}) { 
								push @new_second, $judge unless $judge == $swap_with;
							}
							push @new_second, $first_judge;
							@{$test_judges{$swap_panel}} = @new_second;
						}

						@{$test_panels{$first_judge}} = @new_first_panels;

						my @new_second_panels;

						foreach my $panel (@{$test_panels{$swap_with}}) { 
							next if $panel == $swap_panel;
							push @new_second_panels, $panel;
						}

						push @new_second_panels, $first;
						@{$test_panels{$swap_with}} = @new_second_panels;

					}
				}
			}
		}

		if ($current_total > $attempt_total || not defined $current_total ) { 
			$current_total = $attempt_total;
			$panels{"judges"} = \%test_judges;
			$panels{"flight"} = \%test_flight;
			$judges{"panels"} = \%test_panels;
		}

	}

	foreach my $judge (@{$judges{"all"}}) { 

		my $flight;

		next unless $judges{"panels"}{$judge};

		@{$judges{"panels"}{$judge}} = 
			sort {$fix_flight{$a} <=> $fix_flight{$b}} 
			@{$judges{"panels"}{$judge}};

		foreach my $panel (@{$judges{"panels"}{$judge}}) { 
			$flight++;
			$panels{"flight"}{$panel} = $flight;
		}
	}

	foreach my $panel ($round->panels) { 

		$panel->flight($panels{"flight"}{$panel->id});
		$panel->flight(1) unless $panels{"flight"}{$panel->id};
		$panel->update;

		next if $panel->bye;

		foreach my $judge (@{$panels{"judges"}{$panel->id}}) { 

			$m->comp(
				"/funclib/panel_judgeadd.mas", 
				panel    => $panel,
				judge_id => $judge
			);

		}
		
	}

	my $msg = "Judges added";

	unless ($debug) {

		$m->redirect("/panel/round/rooms.mhtml?round_id=".$round->id) 
			if $flights == 1 || $linked;

		$m->redirect("/panel/schemat/show.mhtml?round_id=".$round->id."&disp=1&msg=$msg");
	}

</%init>

	<div class="main">

	<h2> Wheee!!  <% $round->realname %></h2>

	<h4>Paneling total score is <% $current_total %></h4>

%		foreach my $panel (@{$panels{"all"}}) { 
	
			<div class="row full">
				
				<span class="twentieth">
					<% $panels{"bracket"}{$panel} %> - <% $bracket_score{$panels{"bracket"}{$panel}} %>
					<% $panels{"bracketrank"}{$panel} %>
					<% $bracket_score{$panel} %>
				</span>

				<span class="twentieth">
					<% $panels{"flight"}{$panel} %>
				</span>

%				my $notfirst;

%				foreach my $entry (@{$panels{"entries"}{$panel}}) { 
					<span class="fifth">
						<% $notfirst++ ? "vs " : "" %>
						<% $entries{$entry}{"seed"} %>
						<% $entries{$entry}{"code"} %>
					</span>
%				}

				<span class="half marno">

%				foreach my $judge (@{$panels{"judges"}{$panel}}) { 
					<div class="full padless">
						<% $judges{"rating"}{$judge} > 0 ? $judges{"rating"}{$judge} : "" %> :
						<% $prefs && $prefs ne "none" ? $judges{"panel_rating"}{$judge}{$panel} : "" %> - 
						<% $judge_panel_score{$judge}{$panel} %> -
						<% $judges{"name"}{$judge} %>
					</div>
%				}

				</span>

			</div>

%		}

	</div>
