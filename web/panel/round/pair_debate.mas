<%args>
	$round
	$person
</%args>
<%perl>

	my $event = $round->event;
	my %event_settings = $event->all_settings();
	my $pullup_minimize = $event_settings{"pullup_minimize"};

	if ($pullup_minimize eq "nobody_today_still_does_not_work") {
		$m->comp("pair_powered.mas",
			round  => $round,
			person => $person
		);
		return;
	}

	# if $Tab::url_prefix eq "https://www.tabroom.com";
	our $debugme = 1;
	undef $debugme;

	my $now = DateTime->now(time_zone => "UTC");

	our $error_log = "Pairing ".$round->realname." of ".$event->tourn->name;
	$error_log .= " at ".Tab::nicedt($now)." UTC\n\n";
	$error_log .= " Round ID is ".$round->id."\n\n";

	use POSIX;

	my $pullup_method = $event_settings{"pullup_method"};
	my $pullup_repeat = $event_settings{"pullup_repeat"};
	my $bracket_by_ballots = $event_settings{"bracket_by_ballots"};
	$pullup_repeat = 1 if $bracket_by_ballots;

	my $powermatch_method = $event_settings{"powermatch"};

	my $aff_string = $event_settings{"aff_label"};
	my $neg_string = $event_settings{"neg_label"};
	$aff_string = "Aff" unless $aff_string;
	$neg_string = "Neg" unless $neg_string;

	unless ($pullup_method) {
		$pullup_method="sop";
		$error_log .= "No pullup method set for this event; assuming SOP pullup method (opposition seeds).\n\n";
	}

	unless ($powermatch_method) {
		$powermatch_method="sop";
		$error_log .= "No powermatch method set for this event; assuming SOP pullup method (seed + opposition seeds).\n\n";
	}

	if ($round->type eq "highhigh") {
		$powermatch_method = "highhigh";
	}

	$error_log .= "Pairing using ".$powermatch_method." method for power-matching and ".$pullup_method." for pullups \n";

	#erase any current round
	erase_current_round($round);

	my $side_locked;
	my $side_lock_against;

	my $sidelock_against = $round->setting("sidelock_against");

	if ($sidelock_against) {

		if ($sidelock_against ne "NONE"
			&& $sidelock_against ne "RANDOM"
		) {
			$side_locked++;
			$side_lock_against = $sidelock_against;
		}

	} else {
		$side_locked++ unless ($round->name % 2);
		undef $side_locked if $event_settings{"no_side_constraints"};
	}

	my ($entry_by_id_hash_ref, $precluded_hash_ref)
		= $m->comp("/funclib/make_pairing_hash.mas",
			round_id => $round->id
		);

	my %entry_by_id = %{$entry_by_id_hash_ref};
	my %precluded = %{$precluded_hash_ref};

	my %autobye;

	if ($event_settings{"autobye_nojudge"}) {

		my $dbh = Tab::DBI->db_Main();

		my $bye_sth = $dbh->prepare('
			select entry.id, round.id
			from entry, round, panel, ballot
			where entry.id = ballot.entry
				and ballot.panel = panel.id
				and panel.round = round.id
				and (ballot.bye = 1 or panel.bye = 1)
				and entry.event = ?
		');

		$bye_sth->execute($event->id);

		my %entry_info;

		while (
			my (
				$entry_id, $round_id
			) = $bye_sth->fetchrow_array()
		) {
			$entry_info{$entry_id}{"bye_count"}++;
		}

		my $available_judges = $m->comp(
			"/funclib/round_available_judges.mas",
			round => $round
		);

		my $num_flights = $round->flighted;
		$num_flights = 1 unless $num_flights;

		my $num_judges = $round->setting('num_judges');
		$num_judges = 1 unless $num_judges;

		$available_judges = $available_judges * $num_flights;

		# Sort entries so those with fewer byes go to the front
		my @entries = shuffle (keys %entry_by_id);
		my $num_debates = POSIX::floor( (scalar @entries) / (2 * $num_judges));

		@entries = sort {
			$entry_info{$a}{"bye_count"} <=> $entry_info{$b}{"bye_count"}
			|| $entry_by_id{$b}{'bracket'} <=> $entry_by_id{$a}{"bracket"}
		} @entries;

		while ($num_debates > $available_judges) {
			my $excluded = shift @entries;
			$autobye{$excluded}++;
			delete $entry_by_id{$excluded};
			$num_debates = POSIX::floor( (scalar @entries) / 2);
		}

		foreach my $bye (keys %autobye) {

			my $panel = Tab::Panel->create({
				round   => $round->id,
				bye     => 1,
				letter  => $num_debates++,
				flight  => 1,
				bracket => 0
			});

			Tab::Ballot->create({
				panel  => $panel->id,
				entry  => $bye,
				side   => 1
			});

		}
	}

	my $entry_count = keys %entry_by_id;

	unless ($entry_count > 0) {
		$m->print("<p>You have no entries in this division so it's going to be hard for me to pair a debate.  Try again</p></div>");
		$m->comp("pair_powered.mas",
			round  => $round,
			person => $person
		);
	}

	my %entry_ballots;

	# FIGURE OUT IF YOU NEED TO EVEN SIDES UP WITH TEAMS THAT HAD BYES IN THE PAST

	if ($side_locked) {

		if ($side_lock_against) {

			Tab::Ballot->set_sql( "round_side_lock" => "
				select distinct ballot.*, ballot.entry as entryid
				from ballot, panel
				where panel.round = ?
				and ballot.panel = panel.id
				order by ballot.entry
			");

			foreach my $ballot (Tab::Ballot->search_round_side_lock($side_lock_against)) {
				push @{$entry_ballots{$ballot->entryid}}, $ballot;
			}

		} else {

			Tab::Ballot->set_sql( "tourn_side_lock" => "
				select distinct ballot.*, ballot.entry as entryid
				from ballot, panel, round
				where round.name < ?
					and round.event = ?
					and panel.round = round.id
					and ballot.panel = panel.id
					and ballot.entry > 0
				order by ballot.entry
			");

			foreach my $ballot (Tab::Ballot->search_tourn_side_lock($round->name, $event->id)) {
				push @{$entry_ballots{$ballot->entryid}}, $ballot;
			}
		}

		my $aff;
		my $neg;
		my $sides_even;
		my $ctr;
		my $fixmarker;

		while ($sides_even == 0 and $ctr < 20 ) {

			undef $aff;
			undef $neg;
			undef $sides_even;
			$ctr++;

			if ($ctr >= 20 ) {
				last;
				$error_log .= "bailed at 20 tries\n\n" ;
			}

			foreach my $entry_id (keys %entry_by_id ) {
				$aff++ if $entry_by_id{$entry_id}{'sidedue'} == 1;
				$neg++ if $entry_by_id{$entry_id}{'sidedue'} == 2;
			}

			#exit if things are even, or off by one (non-sidelocked round with a bye)

			if (abs($aff-$neg) <= 1 ) {
				undef $sides_even;
				last;
			}

			#find a team on the wrong side and switch if they've had a bye
			my $side_needed = 1;
			undef $fixmarker;
			$side_needed = 2 if ($aff > $neg);

			foreach my $entry_id (keys %entry_by_id ) {

				if ($fixmarker) { last; }
				if ($entry_by_id{$entry_id}{'sidedue'} != $side_needed) {

					foreach my $ballot (@{$entry_ballots{$entry_id}}) {
						if ( $ballot->bye == 1 or $ballot->panel->bye == 1) {
							$entry_by_id{$entry_id}{'sidedue'} = $side_needed;
							$error_log .= "Switching side due for ".$entry_id." because ";
							$error_log .= "sides need to be evened and they had a bye\n\n" ;
							$fixmarker = 1;
							last;
						}
					}
				}
			}
		}

		$error_log .= "$aff teams due aff and $neg teams due neg\n\n" ;

	}

	# BYE PROCESSING

	# Figure out if you need a bye, and add it if you do; once it's in there it
	# should just get treated like another team that's always last in the
	# bracket and is only precluded from teams it's hit before

	my $top_ofer_seed = 999;

	if ($round->type eq "highlow") {
		foreach my $key (keys %entry_by_id ) {
			$top_ofer_seed = $entry_by_id{$key}{'seed'}
				if $entry_by_id{$key}{'seed'} < $top_ofer_seed;
		}
	}

	if ($entry_count % 2) {

		$entry_by_id{-1}{'code'}        = "Bye";
		$entry_by_id{-1}{'wins'}        = 0;
		$entry_by_id{-1}{'bracket'}     = 0;
		$entry_by_id{-1}{'seed'}        = $entry_count + 1;
		$entry_by_id{-1}{'seed_nowins'} = $entry_count + 1;

		# These two prevent the bye from being pulled up unless all else is bad
		# bad bad.

		$entry_by_id{-1}{'oppseed'} = 1;
		$entry_by_id{-1}{'opp_wins'} = $entry_count + 1;

		if ($round->type eq "highlow") {
			$entry_by_id{-1}{'seed'} = $top_ofer_seed-1;
			$entry_by_id{-1}{'seed_nowins'} = $top_ofer_seed-1;
		}

		$entry_by_id{-1}{'SOP'} = $entry_count*2;

		if ($side_locked) {

			my $aff;
			my $neg;

			foreach my $key (keys %entry_by_id ) {
				if ($entry_by_id{$key}{'sidedue'} == 1) {
					$aff++;
				}
				if ($entry_by_id{$key}{'sidedue'} == 2) {
					$neg++;
				}
			}

			$entry_by_id{-1}{'sidedue'} = 2;
			$entry_by_id{-1}{'sidedue'} = 1 if $aff < $neg;
			$entry_by_id{-1}{'side'} = $entry_by_id{-1}{'sidedue'};
			$error_log .= " Adding a bye on side $entry_by_id{-1}{'sidedue'}" ;
			$error_log .= " Now there now are this many teams including the bye:".(keys %entry_by_id)."<br>";
		}
	}

	# FIGURE OUT WHETHER NORMAL POWER MATCH IS POSSIBLE

	# Count number of possible opponents for each team, and whether one school
	# dominates the bracket

	my $min_possible_opponents = 999;
	my $school_ct = 0;
	my $hi_school;
	my %bracket;
	my %school_entries;

	foreach my $key ( keys %entry_by_id ) {
		$school_entries{ $entry_by_id{$key}{'school'} } ++;
		$bracket{$key}{'side'} = 0;
	}

	count_possible_opponents(\%entry_by_id, \%precluded, \$side_locked, \$min_possible_opponents, \%bracket);

	#figure n teams from 1 school in bracket
	foreach my $key (keys %school_entries) {
		if ( $school_entries{$key} > $school_ct ) {
			$school_ct = $school_entries{$key};
			$hi_school=$key;
		}
	}

	$error_log .= "Fewest opponents for any team is ".$min_possible_opponents."\n\n";
	$error_log .= "Largest school entry is $school_ct and total entries for event are $entry_count\n\n" ;

	#if it's zero bail to disaster mode
	if ($min_possible_opponents == 0) {
		$m->print(" This can't be paired by normal means; one team has no possible opponents.");
		$m->print(" Try pairing by hand; use the back button on your browser.\n\n");
		$m->comp("pair_powered.mas",
			round  => $round,
			person => $person
		);
	}

	#	do a highhigh if not enough degrees of freedom for a power match
	#	if ($min_possible_opponents <= 3 or (($school_ct/$entry_count) > .4) ) {
	#		$powermatch_method = "highhigh";
	#		$error_log .= "\nToo few degrees of freedom -- doing a high-high\n\n" ;
	#	}

	# PAIR IT

	#Figure out how many brackets to pair
	my $hibracket = -1;

	foreach my $key ( keys %entry_by_id ) {
		$hibracket = $entry_by_id{$key}{'wins'} if ($entry_by_id{$key}{'wins'} > $hibracket) ;
	}

	# Loop through the brackets, set them, then pair them creates a global hash
	# called %bracket that can be used by both functions

	my $x = $hibracket;
	$x = 0 if $powermatch_method eq "highhigh";

	# this will (1) pair the bracket if it can, honoring constraints in the
	# bracket.  Exits on success.

	# (2) If it can't pair the bracket, will click into "just make it work"
	# mode, which will honor the bracket and produce a pairing with the right
	# teams in the right bracket but with skewing in the bracket, which should
	# be necessary since the clean pairing attempt failed

	# (3) pull up a different team if even that doesn't work, and try it all
	# again

	# (4) if it still can't pair, the setbracket function will automatically
	# collapse it with the next lower bracket

	# (5) if its the bottom bracket, it will collapse the teams into the next
	# higher bracket and re-pair that

	my $n_tries=0;
	my $collapse_up = 0;

	while ($x > -1) {

		$error_log .= "<br>Now setting $x-win bracket...<br>";
		$error_log .= " About to power-match; teams remaining: ".(keys %entry_by_id)."<br>";

		%bracket = setbracket($round->type, $side_locked, $x, $pullup_method, $pullup_repeat, $pullup_minimize, \%entry_by_id, \%bracket, \%precluded);

		# If there's an odd number of teams in the bracket it must be the last
		# one, so process the bye here

		my $dummy = keys %bracket;
		my $bye_school=0;

		$error_log .= "\nI have $dummy teams in this bracket:<br>";

		foreach my $key (sort keys %bracket) {
			$error_log .=  "\t".$key." ".$entry_by_id{$key}{'code'}." with ";
			$error_log .= $entry_by_id{$key}{'wins'}." wins, due ".$entry_by_id{$key}{'sidedue'};
			$error_log .= " seed:".$entry_by_id{$key}{'seed'}."<br>";
		}

		if ( $entry_count && ($school_ct/$entry_count) > .4  ) {
			$bye_school=$hi_school;
		}

		#make the pullup list
		my @pullup_array = make_pullup_array($x, \%entry_by_id, \%bracket) ;

		# pair the bracket, and exit if it works.  if it doesn't, pull up other
		# teams until there's one that works

		my $i            = 0;
		my $pullup_tries = 0;
		my $last_try     = 0;

		do {
			#infinite loop preventer
			$n_tries++;
			if ($n_tries > (keys %entry_by_id) ) { last };

			#set SOP and seed for sorting
			foreach my $key ( keys %bracket ) {
				$bracket{$key}{'SOP'}         = $entry_by_id{$key}{'SOP'};
				$bracket{$key}{'seed'}        = $entry_by_id{$key}{'seed'};
				$bracket{$key}{'seed_nowins'} = $entry_by_id{$key}{'seed_nowins'};
			}

			#initialize opponent to zero
			foreach my $key ( keys %bracket ) {
				$entry_by_id{$key}{'opponent'}=0;
			}

			#do the actual pairing
			my $outcome = pairbracket($side_locked, $powermatch_method, $pullup_minimize, $round->name, \%entry_by_id, \%bracket, \%precluded);

			# if it fails try the "just pair it" bracket option

			if ($outcome eq "Fail") {
				my $try_ctr = 0;
				do {
					$try_ctr++;
					$outcome = justmakeitwork(\%bracket, \%entry_by_id, $side_locked, \%precluded);
					$error_log .= "justmakeitwork returned $outcome on iteration $try_ctr\n\n";
				} until ( $outcome ne "Fail" || $try_ctr > 20 );
				if ($outcome ne "Fail") { $i = scalar(@pullup_array) + 99 ; }
			} else {
				$i = scalar(@pullup_array) + 99 ;
			}

			# if you get this far you can't pair the bracket, so pull up a
			# different team; this will loop back to the top and try pairing
			# again

			if ($outcome eq "Fail") {

				#set an opponent so it doesn't try to pull them up
				foreach my $key ( keys %bracket) {
					$entry_by_id{$key}{'opponent'}=-999;
				}

				#pull up a different team
				if ( scalar(@pullup_array) > 0 ) {

					my $team_trying_to_replace = $pullup_array[$i];

					unless($last_try) { $last_try = $team_trying_to_replace; }

					delete $bracket{$last_try}; $entry_by_id{$last_try}{'opponent'} = 0 ;

					$error_log .= "\n\ni is $i and scalar is ".scalar(@pullup_array)." \n\nNow  trying to pull up a different team; protecting $entry_by_id{$last_try}{'code'}\n\n";

					#id team to pull up and add to the bracket

					$last_try = pullup(
						$entry_by_id{$team_trying_to_replace}{'sidedue'},
						$pullup_method,
						$pullup_repeat,
						$last_try,
						\%entry_by_id,
						\%bracket,
						\%precluded
					);

					$bracket{$last_try}{'side'} = $entry_by_id{$last_try}{'sidedue'};
					$error_log .= "Now pulling up $entry_by_id{$last_try}{'code'}\n\n";

#					foreach my $key ( keys %bracket ) {
#						print "\n\n".$entry_by_id{$key}{'code'}." wins=".$entry_by_id{$key}{'wins'}." seed=".$entry_by_id{$key}{'seed_nowins'}." side=".$entry_by_id{$key}{'sidedue'};
#					}

					$pullup_tries++;

					if ( $last_try == 0 ) {
						$error_log .= "No other pullup works, so restoring $entry_by_id{$team_trying_to_replace}{'code'}";
						#there's nobody to pull up, so max out tries to escape the loop
						$pullup_tries = (keys %entry_by_id);
						#and restore to the bracket the team you were trying to replace
						$bracket{$team_trying_to_replace}{'side'} = $entry_by_id{$team_trying_to_replace}{'sidedue'};
					}
				}
			}

			if ( $pullup_tries > ((keys %entry_by_id)/2) ) {
				$i++;
				$pullup_tries = 0;
				$last_try = 0;
			}


		} until ($i >= scalar(@pullup_array) );

		#clean out the detritius
		for my $key ( keys %entry_by_id ) {
			if ( $key <=0 && $key != -1 ) { delete($entry_by_id{$key}); }
		}

		if ( unpaired(\%entry_by_id, \%bracket) > 0 && $x > 0 ) {
			$error_log .= "Couldn't pair the bracket; collapsing it with the next bracket down; current bracket is $x \n\n";
		}

		if ( unpaired(\%entry_by_id, \%bracket) > 0 && $x == 0 && $collapse_up < $hibracket ) {

			$error_log .= "Couldn't pair the last bracket; collapsing it with the next bracket up\n\n";

			$x++; #note it will subtract one below, so this will keep it at zero

			$collapse_up++; #counting how many brackets its rolled back to

			#unpair the next bracket up

			foreach my $key ( keys %entry_by_id ) {
				if ($entry_by_id{$key}{'wins'} <= $collapse_up ) {
					$entry_by_id{$entry_by_id{$key}{'opponent'}}{'opponent'} = 0;
					$entry_by_id{$key}{'opponent'} = 0;
				}
			}
			#When this loops back it should repeat with the collapsed brackets; note how sub setbracket works
		}

		if ( unpaired(\%entry_by_id, \%bracket) == 0 ) {
			$error_log .= "Successfully paired the $x-win bracket\n\n";
		}

		$x--;
	}


	# PAIRINGS ARE DONE, NOW MARK WHICH TEAM IS IN WHICH BRACKET

	my $bracket_value;
	foreach my $key ( keys %entry_by_id ) {
		$bracket_value = $entry_by_id{$key}{'wins'};

		if ($entry_by_id{$entry_by_id{$key}{'opponent'}}{'wins'} > $bracket_value ) {
			$bracket_value = $entry_by_id{$entry_by_id{$key}{'opponent'}}{'wins'};
		}

		$bracket_value = 0 unless $bracket_value;

		$entry_by_id{$key}{'bracket'} = $bracket_value;
		$entry_by_id{$entry_by_id{$key}{'opponent'}}{'bracket'} = $bracket_value;
	}

	#SAVE

	#make sure there are sides assigned or it won't save
	foreach my $key (keys %entry_by_id) {
		my $opponent = $entry_by_id{$key}{'opponent'};
		if ( $entry_by_id{$key}{'sidedue'} == 0 ) {
			$entry_by_id{$key}{'sidedue'} = 1;
			$entry_by_id{$opponent}{'sidedue'} = 2;
		}
		if ( $entry_by_id{$key}{'sidedue'} == $entry_by_id{$opponent}{'sidedue'}  ) {
			$entry_by_id{$key}{'sidedue'} = 1;
			$entry_by_id{$opponent}{'sidedue'} = 2;
			if ( $entry_by_id{$opponent}{'aff_count'} < $entry_by_id{$key}{'neg_count'} ) {
				$entry_by_id{$key}{'sidedue'} = 2;
				$entry_by_id{$opponent}{'sidedue'} = 1;
			}
		}
	}

	eval {
		write_round($round, \%entry_by_id, \%event_settings);
	};

	$round->paired_at($now);
	$round->update;

	$error_log .= "\n\n" ;

</%perl>

%	if ($debugme) {

		</span>
		<h4><% $round->realname %> Debugging Info:</h4>

		<& "/funclib/tablesorter.mas", table => "bracketed" &>

		<table id="bracketed">

			<thead>

				<tr class="smallish yellowrow">
					<th>key</th>
					<th>code</th>
					<th>school</th>
					<th>wins</th>
					<th>seed</th>
					<th>oppseed</th>
					<th>oppwins</th>
					<th>SOP</th>
					<th>sidedue</th>
					<th>opp</th>
					<th>opp code</th>
				</tr>

			</thead>

			<tbody>

%				foreach my $key (sort {$entry_by_id{$a}->{'seed'} <=> $entry_by_id{$b}->{'seed'} } keys(%entry_by_id)) {

%					next unless ($key and $key > -1);

					<tr>
						<td><%$key%></td>
						<td><%$entry_by_id{$key}{'code'}%></td>
						<td><%$entry_by_id{$key}{'school'}%></td>
						<td><%$entry_by_id{$key}{'wins'}%></td>
						<td><%$entry_by_id{$key}{'seed'}%></td>
						<td><%sprintf("%.3f", $entry_by_id{$key}{'oppseed'})%></td>
						<td><%sprintf("%.3f", $entry_by_id{$key}{'opp_wins'})%></td>
						<td><%sprintf("%.3f", $entry_by_id{$key}{'SOP'})%></td>
						<td><%$entry_by_id{$key}{'sidedue'}%></td>
						<td><%$entry_by_id{$key}{'opponent'}%></td>
						<td><%$entry_by_id{$entry_by_id{$key}{'opponent'}}{'code'}%></td>
					</tr>
%				}
			</tbody>
		</table>
%		$m->flush_buffer();
%	}

<%perl>


	$error_log .= "Total spots paired including bye:".$entry_count."\n\n" ;
	$x = 0;

	foreach my $key ( keys %entry_by_id ) {
		if ( $entry_by_id{$key} != 0 ) { $x++; }
	}

	$error_log .= "Total teams paired with opponent including bye:".$x."\n\n" ;
	$error_log .= "All done and saved!\n\n" ;

	# Test that it's worked, and it it hasn't, kick it over to disaster mode

	my $allpaired = 1;

	$error_log .= "checking for round pair success.\n\n" ;

	foreach my $key ( keys %entry_by_id ) {

		$error_log .= $key." opponent is ".$entry_by_id{$key}{'opponent'}."\n\n" ;

		if ( $entry_by_id{$key}{'opponent'} == 0 or $entry_by_id{$key}{'opponent'} == -999 ) {
			undef $allpaired;
		}
	}

	if ($allpaired) {

		$error_log .= "<strong>Round successfully paired.</strong>\n\n";

		if ($debugme) {
			$m->print("<h2>Error Log Output</h2>");
			$m->print("<pre>");
			$m->print($error_log);
			$m->print("</pre>");
			$m->print("</div>");
			undef $error_log;
			undef $debugme;
			$m->flush_buffer;
			$m->abort;
		}

	} else {

		$error_log .= "Round pair failed -- kicking into disaster mode\n\n";

		if ($debugme) {

			$m->print("<h2>Error Log Output</h2>");
			$m->print($error_log);
			$m->print("</div>");
			undef $debugme;
			undef $error_log;
			$m->flush_buffer;

		} else {

			$m->comp("pair_powered.mas",
				round  => $round,
				person => $person
			);

		}
	}

	# SET SIDES IF IT'S AN ODD NUMBERED ROUND USING THE SERPENTINE THING

	# (unless APDA/pullup_minimize)

	if ($sidelock_against eq "RANDOM") {

		$m->comp("/panel/manipulate/random_sides.mhtml", round_id => $round->id);

	} elsif ($side_locked || $pullup_minimize) {

	} else {
		$m->comp("/panel/manipulate/snake_sides.mhtml", round_id => $round->id, from => "autopair");
	}

	return;

	# SUBFUNCTIONS

	sub setbracket {

		# receives a bracket to fill, returns a hash with teams in that bracket
		my ($round_type, $side_locked, $winbracket, $pullup_method, $pullup_repeat,
			$pullup_minimize, $entry_by_id_ref, $bracket_ref, $precluded_ref) = @_;

		$error_log .= " side locked:".$side_locked." winbracket=".$winbracket." -- now setting the bracket\n" ;
		my %entry_by_id = %{$entry_by_id_ref};

		foreach my $key ( keys %entry_by_id ) {
			if ($key <= 0 && $key != -1 ) { delete( $entry_by_id{$key} ); }
		}

		my %team;

		#if a high-high round, dump them all in 1 bracket and be done with it
		if ($round_type eq "highhigh") {

			foreach my $key ( keys %entry_by_id ) {
				next unless $key;
				$team{$key}{'side'} = $entry_by_id{$key}{'sidedue'};
				$entry_by_id{$key}{'opponent'} = -999;
			}

			return %team;
		}

		# Total teams in the event; necessary to test for the last bracket
		my $totalentries = keys %entry_by_id;

		# Populate the bracket

		foreach my $key ( keys %entry_by_id ) {

			if ($key <= 0 && $key != -1) { delete( $entry_by_id{$key} ); }
			next unless $key;
			next unless $entry_by_id{$key};

			# $error_log .= $entry_by_id{$key}{'code'}." has ".$entry_by_id{$key}{'wins'}." wins
			# and current opponent is ".$entry_by_id{$key}{'opponent'}." \n" ;

			if ($entry_by_id{$key}{'wins'} >= $winbracket
				&& ($entry_by_id{$key}{'opponent'} == 0
				|| $entry_by_id{$key}{'opponent'} == -999)
			) {
				$team{$key}{'side'} = $entry_by_id{$key}{'sidedue'};
				$entry_by_id{$key}{'opponent'} = -999;
			}
		}

		# Loop and pull up until the bracket is even

		my $bracketeven = 0;
		my $brackettries = 0;

		while ( $bracketeven == 0 ) {

			# Count the number of tries
			$brackettries++;

			# Need to know how many teams have already been paired so you can
			# see if this is the last bracket

			my $paired_already = 0;

			foreach my $key ( keys %entry_by_id ) {
				$paired_already++ if $entry_by_id{$key}{'opponent'} != 0;
			}

			# Count total, aff, and neg teams and how many are from the same
			# school

			my $nteams = keys %team;
			my $aff;
			my %affschool;
			my $neg;
			my %negschool;

			foreach my $key ( keys %team ) {

				$aff++ if $team{$key}{'side'} == 1;
				$neg++ if $team{$key}{'side'} == 2;

				$affschool{$entry_by_id{$key}{'school'}}++ if $team{$key}{'side'} < 2;
				$negschool{$entry_by_id{$key}{'school'}}++ if $team{$key}{'side'} == 2;

			}

			$error_log .= "\n" ;

			# test for an even bracket in an non-sidelocked round or if
			# pullup_minimize is set (APDA system)

			unless ($nteams % 2) {
				if ($pullup_minimize) {
					$bracketeven++;
				} elsif (not defined $side_locked) {
					$bracketeven++;
				}
			}

			# test for an even bracket in a sidelocked round

			if ($side_locked and $aff == $neg) {
				$bracketeven = 1;
			}

			# Make sure the school composition of the bracket makes a pairing
			# possible

			# NOTE: Probably need to change this to hasconflict rather than
			# just school but for now I can't think of how to do that without
			# pairing the bracket

			# Number of teams in the largest school entry in the bracket
			my $n_hischool_aff;

			# Cchool number of the school with the most teams in the bracket
			my $hischool_key_aff;

			# The side you need to pull from if its a sidelocked round
			my $fixed_pullup_side;

			# Count school with most teams in aff bracket
			foreach my $key ( keys %affschool ) {
				if ( $affschool{$key} > $n_hischool_aff ) {
					$n_hischool_aff = $affschool{$key};
					$hischool_key_aff = $key;
				}
			}

			# Repeat for neg

			# Number of teams in the largest school entry in the bracket
			my $n_hischool_neg;

			# School number of the school with the most teams in the bracket
			my $hischool_key_neg;

			foreach my $key ( keys %negschool ) {
				if ( $negschool{$key} > $n_hischool_neg ) {
					$n_hischool_neg = $negschool{$key};
					$hischool_key_neg = $key;
				}
			}

			# count possible opponents in opposite bracket

			# negative opponents who aren't from the school in the aff bracket
			# with the most teams
			my $neg_opp_for_affhischool;

			# negative opponents who aren't from the school in the aff bracket
			# with the most teams
			my $aff_opp_for_neghischool;

			# CLP fixed the below; it used to add an opponent per school by
			# using ++ but it should instead add one per opponent and thus the
			# += $negschool{$key}.

			foreach my $key ( keys %negschool ) {
				$neg_opp_for_affhischool += $negschool{$key} if $key != $hischool_key_aff;
			}

			foreach my $key ( keys %affschool ) {
				$aff_opp_for_neghischool += $affschool{$key} if $key != $hischool_key_neg;
			}

			if ( $side_locked ) {

				if ( $neg_opp_for_affhischool < $n_hischool_aff ) {
					$bracketeven = 0;
					$fixed_pullup_side = 2;
					$error_log .= "\n\nI have $neg_opp_for_affhischool opponents on neg for $n_hischool_aff affs from $hischool_key_aff \n\n" ;
				}

				if ( $aff_opp_for_neghischool < $n_hischool_neg ) {
					$bracketeven = 0;
					$fixed_pullup_side = 1;
					$error_log .= "\n\nI have $aff_opp_for_neghischool opponents on aff for $n_hischool_neg negs from $hischool_key_neg \n\n" ;
				}

			} else {

				if ( ($nteams - $n_hischool_aff) < $n_hischool_aff ) {
					$error_log .= "\n\nToo many teams from one school; pulling up more:";
					$bracketeven = 0;
				}

			}

			# test for this being the last bracket and needing a bye
			$bracketeven = 1 if $paired_already == $totalentries;

			# Exit if the bracket is even
			if ( $bracketeven == 1 ) { last; }

			# Kick into "make it work" mode if can't even the bracket
			if ( $brackettries > 100 ) { last; }

			# Bracket not even, so pull up
			my $sidetopull = 0;

			$sidetopull = 1 if ($side_locked && $aff < $neg);
			$sidetopull = 2 if ($side_locked && $aff > $neg);
			$sidetopull = $fixed_pullup_side if ($side_locked && $fixed_pullup_side);

			if ($sidetopull < 0) {
				$error_log .= "<br>Need to pull up! Affs $aff and negs $neg.\n" ;
			}

			my $pullup = pullup(
				$sidetopull,
				$pullup_method,
				$pullup_repeat,
				0,
				$entry_by_id_ref,
				$bracket_ref,
				$precluded_ref
			);

			$error_log .= "<br>Pulled up ". $pullup." ".$entry_by_id{$pullup}{'code'}."<br>" ;

			$team{$pullup}{'side'} = $entry_by_id{$pullup}{'sidedue'} ;

			# Stores a temporary opponent so they won't get pulled up again
			$entry_by_id{$pullup}{'opponent'} = -999;

		}

		$error_log .= "There are now ".(keys %team)." teams in the bracket..." ;
		return %team;
	}

	sub pullup {

		# identifies which side you need to pull up; zero means either is OK

		my (
			$side,
			$pullup_method,
			$pullup_repeat,
			$pullup_protect,
			$entry_by_id_ref,
			$bracket_ref,
			$precluded_ref
		) = @_;

		my %entry_by_id = %{$entry_by_id_ref};

		# If pullup_protect is defined, it means that you tried pulling one
		# team up and it didn't work so this sets a flag that won't allow a
		# pullup until you get past the last team you tried to pull up

		my $protect_flag = 1 unless $pullup_protect;

		my @order;

		#default sortorder is sop

		@order =
			sort { $entry_by_id{$b}->{'wins'} <=> $entry_by_id{$a}->{'wins'}
				|| $entry_by_id{$b}->{'oppseed'} <=> $entry_by_id{$a}->{'oppseed'}
				|| $entry_by_id{$b}->{'seed'} <=> $entry_by_id{$a}->{'seed'}
			} keys(%entry_by_id);

		if ($pullup_method eq "oppwin") {
			@order =
				sort { $entry_by_id{$b}->{'wins'} <=> $entry_by_id{$a}->{'wins'}
					|| $entry_by_id{$a}->{'opp_wins'} <=> $entry_by_id{$b}->{'opp_wins'}
					|| $entry_by_id{$b}->{'seed_nowins'} <=> $entry_by_id{$a}->{'seed_nowins'}
				} keys(%entry_by_id);
		}

		if (
			$pullup_method eq "middle"
			or $pullup_method eq "lowseed"
			or $pullup_method eq "highseed"
		) {
			@order = sort {
				$entry_by_id{$b}->{'wins'} <=> $entry_by_id{$a}->{'wins'}
				|| $entry_by_id{$a}->{'seed'} <=> $entry_by_id{$b}->{'seed'}
			} keys(%entry_by_id);
		}

		my $oppwins = 0;
		my $bracket = 0;
		my @candidates;

		$error_log .= "Order of side wins is @order for bye candidates \n";

		foreach my $order_team ( @order ) {

			my $key = $order_team;

			# Make sure they are on the right side of the bracket

			my $sidematch = 1;

			$sidematch = 0 if $side > 0 and $entry_by_id{$key}{'sidedue'} != $side;

			# Make sure they can debate at least one team in the bracket

			my $allconflicts = 0;

			foreach my $key2 ( keys %{$bracket_ref} ) {

				my $oktodebate = 1;

				if ( hasconflict($key, $key2, $precluded_ref) == 1 ) {
					$oktodebate = 0;
				}

				if ( $side > 0 and $entry_by_id{$key}{'sidedue'} == ${$bracket_ref}{$key2}{'side'} ) {
					$oktodebate = 0;
				}
				if ( $oktodebate == 1 ) {
					$allconflicts = 0;
					last;
				}
			}

			my $tabs;
			$tabs++ if length($entry_by_id{$key}{'code'}) < 16;
			$tabs++ if length($entry_by_id{$key}{'code'}) < 8;

			$error_log .= "\n".$entry_by_id{$key}{'code'};
			foreach my $tab (1 .. $tabs) {
				$error_log .= "\t";
			}
			$error_log .= "\tWins:".$entry_by_id{$key}{'wins'}."";
			$error_log .= "\tSide match: ".$sidematch;
			$error_log .= "\t# conflicts:".$allconflicts;
			$error_log .= "\t opponent:".$entry_by_id{$entry_by_id{$key}{'opponent'}}{'code'};

			# Moved this here so sop will consider second pullups; originally
			# it came after sop b/c Gary thinks sop should ignore it

			my $second_pullup = 0;

			if ( $pullup_repeat == 0 and $entry_by_id{$key}{'pullup'} > 0 ) {
				$error_log .= "Not pulling up $entry_by_id{$key}{'code'} b/c they were pulled up before<br>" ;
				$second_pullup = 1;
			}

			if ( $second_pullup == 0
				and $entry_by_id{$key}{'opponent'} == 0
				and $sidematch == 1
				and $allconflicts == 0
				and $pullup_method eq "sop"
				and $protect_flag == 1
			) {

				return $key;
			}

			# should only get this far if you are using the oppwin method

			# Don't pull up a second time depending on settings; sop ignores
			# this, so don't calculate it unless you get this far pullups are
			# added and subtracted, so if you are pulled up and pulled down
			# your setting is zero.  Positive numbers mean you've been pulled
			# up more than you've been pulled down.

			if ( $entry_by_id{$key}{'opponent'} == 0
				and $sidematch == 1
				and $allconflicts == 0
				and $second_pullup == 0
				and $pullup_method ne "sop"
				and $protect_flag == 1 ) {

				if ( $oppwins == 0 ) {
					$oppwins = $entry_by_id{$key}{'opp_wins'};
					$bracket = $entry_by_id{$key}{'wins'};
				}

				if ( ($entry_by_id{$key}{'wins'} == $bracket)
					and (
						$entry_by_id{$key}{'opp_wins'} == $oppwins
						or $pullup_method ne 'sop'
					)
				) {

					$error_log .= "Bracket is $bracket.  Marking key $key ".$entry_by_id{$key}{'code'};
					$error_log .= " with ".$entry_by_id{$key}{'wins'}." wins ";
					$error_log .= " and ".$entry_by_id{$key}{'opp_wins'}." opp_wins as a pullup candidate\n\n";
					$candidates[scalar(@candidates)] = $key;
				}
			}

			if ( $key == $pullup_protect ) {
				$protect_flag = 1;
			}

		}

		#disaster mode -- if there's nobody to pull up, do this
		if ( scalar(@candidates) == 0 ) {

			foreach my $order_team ( @order ) {

				my $key = $order_team;

				# Make sure they are on the right side of the bracket
				my $sidematch = 1;

				$sidematch = 0
					if $side > 0
					and $entry_by_id{$key}{'sidedue'} != $side;

				if ( $entry_by_id{$key}{'opponent'} == 0 and $sidematch == 1 ) {

					$error_log .= "Couldn't find anyone to pull up so ignoring everything but side match.  Marking key $key ".$entry_by_id{$key}{'code'};

					$error_log .= " as a pullup candidate\n\n";
					$candidates[scalar(@candidates)] = $key;
				}
			}

		}

		# Pulls from the lowest seed
		if ( $pullup_method eq "lowseed" ) {
			$error_log .= "...pulling up worst seed who is ".$entry_by_id{$candidates[$#candidates]}{'code'}."\n\n" ;
			return $candidates[$#candidates];
		}

		# Pulls up the highest seed
		if ( $pullup_method eq "highseed" ) {
			$error_log .= "...pulling up best seed who is ".$entry_by_id{$candidates[$#candidates]}{'code'}."\n\n" ;
			return $candidates[0];
		}

		# God I hate this method.
		if ( $pullup_method eq "middle" ) {

			my $num = int((scalar(@candidates)/2) + .5);
			$num--;
			if ( scalar(@candidates) == 1 ) { $num = 0; }

			$error_log .= "There are ".scalar(@candidates)." teams with $oppwins opp wins in
				the $bracket win bracket: @candidates \n" ;

			$error_log .= "...pulling up ".$entry_by_id{$candidates[$num]}{'code'}."
				from the middle of the seeds.";

			return $candidates[$num];

		}

		# This is better

		if ( $pullup_method eq "oppwin") {

			@candidates = sort {
				$entry_by_id{$b}->{'wins'} <=> $entry_by_id{$a}->{'wins'}
				|| $entry_by_id{$a}->{'opp_wins'} <=> $entry_by_id{$b}->{'opp_wins'}
				|| $entry_by_id{$b}->{'seed_nowins'} <=> $entry_by_id{$a}->{'seed_nowins'}
			} @candidates;

			my $pullup = shift @candidates;

			$error_log .= " Original pullup candidate is $pullup<br>";
			$error_log .= " there are ".scalar(@candidates)." candidates. current one is $pullup<br>";

			if ( scalar(@candidates) > 1 && $pullup == -1 ) {
				my $pullup = pop @candidates;
			}

			$error_log .= "There are ".scalar(@candidates)." teams with ".$entry_by_id{$pullup}{'opp_wins'}." opp wins in the $bracket win bracket: @candidates \n" ;

			$error_log .= "...pulling up ".$entry_by_id{$pullup}{'code'};
			$error_log .= " who has ".$entry_by_id{$pullup}{'wins'}." wins";
			$error_log .= " and ".$entry_by_id{$pullup}{'opp_wins'}." avg opp wins <br>" ;

			return $pullup;

		}

		# BTW, there's no method here about what to do if method=sop.  Think
		# that's by design....

		# if nobody has been pulled up yet, pull the last

		if ( scalar(@candidates) > 0 ) {
			my $pullup = pop @candidates;
			return $pullup;
		}

		#if it gets this far something has failed

		$error_log .= "Exiting pullup sub without finding a team to pull up<br>" ;
		return 0;
	}

	sub make_pullup_array {

		# receives a bracket list and full entry list, returns an array of
		# teams pulled up

		my ($win_bracket, $entry_by_id_ref, $bracket_ref) = @_;

		my %entry_by_id = %{$entry_by_id_ref};

		my @pullup_list;

		foreach my $key ( keys (%{$bracket_ref}) ) {
			if ( ${$entry_by_id_ref}{$key}{'wins'} < $win_bracket ) {
				push @pullup_list, $key;
			}
		}

		return @pullup_list;

	}

	sub count_possible_opponents {

		#variables are passed by ref; this gives them identical local names

		my ($entry_by_id_ref,
			 $precluded_ref,
			 $side_locked_ref,
			 $min_possible_opponents_ref,
			 $bracket_ref
		) = @_;

		my %entry_by_id = %{$entry_by_id_ref};
		my %precluded = %{$precluded_ref};
		my $side_locked = ${$side_locked_ref};
		my $min_possible_opponents = ${$min_possible_opponents_ref};
		my %bracket = %{$bracket_ref};

		foreach my $key ( keys %entry_by_id ) {
			$entry_by_id{$key}{'possible_opponents'} = 0;
		}

		foreach my $key ( keys %bracket ) {

			$entry_by_id{$key}{'random'} = int(rand(1000))+1;

			KEY:
			foreach my $key2 ( keys %bracket ) {

				next if (hasconflict($key, $key2, \%precluded) == 1);

				next if ($key == $key2);

				next if (
					$side_locked
					and $entry_by_id{$key}{'sidedue'} == $entry_by_id{$key2}{'sidedue'}
				);

				next if ( $entry_by_id{$key2}{'opponent'} > 0 );
				$entry_by_id{$key}{'possible_opponents'}++;
			}

			$entry_by_id{$key}{'possible_opponents'} = 0
				unless $entry_by_id{$key}{'possible_opponents'};

			if ( $entry_by_id{$key}{'possible_opponents'} < $min_possible_opponents ) {
				$min_possible_opponents = $entry_by_id{$key}{'possible_opponents'};
			}

		}

		${$min_possible_opponents_ref} = $min_possible_opponents;

	}

	sub pairbracket {

		my ($side_locked, $powermatch_method, $pullup_minimize, $round_name,
			$entry_by_id_ref, $bracket_ref, $precluded_ref) = @_;

		# Figure out how many teams are in the bracket; you'll use this below
		my $nteams = keys %{$bracket_ref};

		bracket_pair(
			$side_locked,
			$powermatch_method,
			$pullup_minimize,
			$round_name,
			0,
			$entry_by_id_ref,
			$bracket_ref,
			$precluded_ref
		);

		#make sure they're all paired, and if they are, bail
		my $unpaired_teams = unpaired($entry_by_id_ref, $bracket_ref);

		if ($unpaired_teams == 0) { return "Success"; }

		# Now you know it got to the last 2 teams and got stuck, so you have to
		# roll back some existing pairings

		# Sort the bracket in reverse order, and unpair one debate at a time.

		# Then pair the problem team, and then finish the bracket with a normal
		# hi-lo pair.

		my $problemchild = get_problem_child($entry_by_id_ref, $bracket_ref);

		my $n_bracket_tries = 0;
		my $n_problemchild_tries;

		my $ok_to_start = 0;

		foreach my $key (
			sort { ${$bracket_ref}{$b}->{'SOP'} <=> ${$bracket_ref}{$a}->{'SOP'} }
			keys(%{$bracket_ref})
		) {

			if ( ${$entry_by_id_ref}{$problemchild}{'opponent'} != 0 && $problemchild > 0 ) {
				$problemchild = get_problem_child($entry_by_id_ref, $bracket_ref);
			}

			if ( $problemchild == $key ){
				$ok_to_start = 1;
			}

			if ($key != $problemchild
				and ${$entry_by_id_ref}{$key}{'opponent'} > 0
				and $ok_to_start == 1
			) {

 				${$entry_by_id_ref}{${$entry_by_id_ref}{$key}{'opponent'}}{'opponent'} = 0;
				${$entry_by_id_ref}{$key}{'opponent'} = 0;

				#now pair the problem child
				$error_log .= " Now pairing the problem child<br>" ;

				bracket_pair(
					$side_locked,
					$powermatch_method,
					0,
					$round_name,
					$problemchild,
					$entry_by_id_ref,
					$bracket_ref,
					$precluded_ref
				);

				#now try to finish the bracket
				$error_log .= " Now pairing the rest of the bracket<br>" ;

				bracket_pair(
					$side_locked,
					$powermatch_method,
					0,
					$round_name,
					0,
					$entry_by_id_ref,
					$bracket_ref,
					$precluded_ref
				);

				#if it worked, bail, and otherwise loop back and undo the next pairing
				if (unpaired($entry_by_id_ref, $bracket_ref) == 0) {
					$error_log .= "Successfully paired the bracket<br>";
					last;
				} else {
					$error_log .= "<br>Failed to pair the rest of the bracket<br>";
				}

			}

		}

		if (unpaired($entry_by_id_ref, $bracket_ref) == 0) { return "Success"; }
		return "Fail";

	}

	sub get_problem_child {
		my ($entry_by_id_ref, $bracket_ref) = @_;

		my $problemchild;
		my $pc_sop = -100;

		foreach my $key (
			sort { ${$bracket_ref}{$a}->{'SOP'} <=> ${$bracket_ref}{$b}->{'SOP'} }
			keys(%{$bracket_ref})
		) {

			if (
				${$entry_by_id_ref}{$key}{'opponent'} == 0
				and ${$entry_by_id_ref}{$key}{'SOP'} > $pc_sop
			) {
				$problemchild = $key; $pc_sop = ${$entry_by_id_ref}{$key}{'SOP'};
			}
		}
		return $problemchild;
	}

	sub bracket_pair {

		my ($side_locked,
			$powermatch_method,
			$pullup_minimize,
			$round_name,
			$problemchild,
			$entry_by_id_ref,
			$bracket_ref,
			$precluded_ref
		) = @_;

		# pair it like an non-sidelocked round if pullup_minimize is set
		undef $side_locked if $pullup_minimize;

		# start from the top of the {$bracket_ref}, and then go backwards up
		# from the bottom of the {$bracket_ref} looking for an opponent who
		# fits pair if it's a match

		# major conceptual idea:  WHY do we start at the top of the AFF
		# {$bracket_ref}?  What if the top of the NEG {$bracket_ref} is a lower
		# seed?  In fact, why don't we do the high/low starting with the
		# highest unpaired seed REGARDLESS of whether they are AFF or NEG?  The
		# coding is easier AND its more consistent with the HiLo pair
		# philosophy

		# for future reference:  see also Tie::SortHash

		my @sorted_bracket;
		my @opp_bracket;

		if ($powermatch_method eq "sop") {

			@sorted_bracket =
				sort {
					${$bracket_ref}{$a}->{'SOP'} <=> ${$bracket_ref}{$b}->{'SOP'}
					|| ${$bracket_ref}{$a}->{'seed'} <=> ${$bracket_ref}{$b}->{'seed'}
				} keys(%{$bracket_ref});

			@opp_bracket =
				sort {
					${$bracket_ref}{$b}->{'SOP'} <=> ${$bracket_ref}{$a}->{'SOP'}
					|| ${$bracket_ref}{$b}->{'seed'} <=> ${$bracket_ref}{$a}->{'seed'}
				} keys(%{$bracket_ref});

			$error_log .= "Just did a sop sort<br>" ;

		} else {

			@sorted_bracket =
				sort {
					${$bracket_ref}{$a}->{'seed_nowins'} <=> ${$bracket_ref}{$b}->{'seed_nowins'}
				} keys(%{$bracket_ref});

			if ($powermatch_method eq "seed") {

				@opp_bracket =
					sort {
						${$bracket_ref}{$b}->{'seed_nowins'} <=> ${$bracket_ref}{$a}->{'seed_nowins'}
					} keys(%{$bracket_ref});

				$error_log .= "Just did a seed sort<br>" ;

			} elsif ($powermatch_method eq "highhigh") {

				@sorted_bracket =
					sort {
						${$bracket_ref}{$a}->{'seed'} <=> ${$bracket_ref}{$b}->{'seed'}
					} keys(%{$bracket_ref});

				@opp_bracket =
					sort {
						${$bracket_ref}{$a}->{'seed'} <=> ${$bracket_ref}{$b}->{'seed'}
					} keys(%{$bracket_ref});

				$error_log .= "Just did a high-high sort<br>" ;
			}

		}

		# If there's a bye, assign it to the best seed before doing the hilo;
		# otherwise, the top team in the bracket will get the bye and not the
		# bottom team

		if ( ${$bracket_ref}{-1} and ${$entry_by_id_ref}{-1}{'opponent'} == 0 ) {

			$error_log .= "There's an unpaired bye in this here bracket!\n\n" ;

			foreach my $element (reverse @sorted_bracket) {

				if (
					${$entry_by_id_ref}{$element}{'opponent'} == 0
					and $element != -1
					and (
						${$entry_by_id_ref}{-1}{'sidedue'} == 0
						|| ${$entry_by_id_ref}{-1}{'sidedue'} != ${$entry_by_id_ref}{$element}{'sidedue'}
					)
					and hasconflict($element, -1, $precluded_ref) == 0
				) {

					${$entry_by_id_ref}{$element}{'opponent'} = -1;
					${$entry_by_id_ref}{-1}{'opponent'} = $element;
					last;
				}
			}
		}

		$error_log .= "The sorted bracket is:\n";

		foreach my $key ( @sorted_bracket ) {
			$error_log .= ${$entry_by_id_ref}{$key}{'code'}."\n";
		}

		foreach my $key ( @sorted_bracket ) {
			$error_log .= ${$entry_by_id_ref}{$key}{'code'}."\n";

			#if it's an sidelocked round, only loop through the aff
			my $sidemarker = 1;

			$sidemarker = 0 if ($side_locked and ${$bracket_ref}{$key}{'side'} == 2);

			# if there's a problem child, only find an opponent for that team

			if ($problemchild) {
				if ($key != $problemchild) { $sidemarker = 0; }
				if ($key == $problemchild) { $sidemarker = 1; }
			}

			# This used to check if the debater being paired was over 0 and
			# thus would never pair the bye against the worst in the bracket.
			# I removed that limitation:

			if ( ${$entry_by_id_ref}{$key}{'opponent'} == 0 and $sidemarker == 1) {

				$error_log .= "*Pairing ".$entry_by_id_ref->{$key}{'code'}."\n";
				$error_log .= "School ID is ".$entry_by_id_ref->{$key}{'school'}."\n";

				OPP:
				foreach my $opp_bracket_member ( @opp_bracket ) {

					next unless $opp_bracket_member;
					my $oppkey = $opp_bracket_member;
					next unless ${$entry_by_id_ref}{$oppkey};

					if (${$entry_by_id_ref}{$oppkey}{'opponent'} != 0) {
						$error_log .= "\t".${$entry_by_id_ref}{$oppkey}{'code'}." already paired vs ".
						${$entry_by_id_ref}{${$entry_by_id_ref}{$oppkey}{'opponent'}}{'code'}." \n" ;
						next OPP;
					}

					if (hasconflict($key, $oppkey, $precluded_ref) == 1) {
						$error_log .= "\t".${$entry_by_id_ref}{$oppkey}{'code'}." is a conflict\n";
						next OPP;
					}

					if ($key == $oppkey) {
						$error_log .= "\t".${$entry_by_id_ref}{$oppkey}{'code'}." is me\n";
						next OPP;
					}

					if (
						$side_locked
						and ${$bracket_ref}{$key}{'side'} == ${$bracket_ref}{$oppkey}{'side'}
					) {
						$error_log .= "\t".${$entry_by_id_ref}{$oppkey}{'code'}." is due the same side\n";
						next OPP;
					}

					$error_log .= ${$entry_by_id_ref}{$oppkey}{'code'}." is chosen\n";
					${$entry_by_id_ref}{$key}{'opponent'} = $oppkey;
					${$entry_by_id_ref}{$oppkey}{'opponent'} = $key;

					last;
				}
			}
		}

		$error_log .= "\n";

	}

	sub unpaired {

		my ($entry_by_id_ref, $bracket_ref) = @_;
		my $returnvalue = 0;

		foreach my $key ( keys %{$bracket_ref} ) {
			if (
				${$entry_by_id_ref}{$key}{'opponent'} == 0
				or ${$entry_by_id_ref}{$key}{'opponent'} == -999
			) {
				$returnvalue++;
			}
		}

		return $returnvalue;
	}

	sub hasconflict {

		my ($team1, $team2, $precluded_ref) = @_;
		my $returnvalue = 0;

		if ($precluded_ref->{$team1}{$team2} == 1) {
			$returnvalue = 1;
		}

		if ($precluded_ref->{$team2}{$team1} == 1) {
			$returnvalue = 1;
		}

		return $returnvalue;
	}

	sub erase_current_round {

		my $round = shift;

		#Out with the old.

		Tab::Score->set_sql( delete_round => "
			delete score from score, ballot, panel
			where panel.round = ?
			and panel.id = ballot.panel
			and ballot.id = score.ballot
		");

		Tab::Ballot->set_sql( delete_round => "
			delete ballot from ballot, panel
			where panel.round = ?
			and panel.id = ballot.panel
		");

		Tab::Panel->set_sql( delete_round => "
			delete from panel where round = ?
		");

		Tab::Score->sql_delete_round->execute($round->id);
		Tab::Ballot->sql_delete_round->execute($round->id);
		Tab::Panel->sql_delete_round->execute($round->id);

	}

	sub justmakeitwork {

		my ($bracket_ref, $entry_by_id_ref, $side_locked, $precluded_ref) = @_;

		my %bracket = %{$bracket_ref};
		my %entry_by_id = %{$entry_by_id_ref};
		my %precluded = %{$precluded_ref};

		# NOTE: This counts the number of possible opponents and then pairs a
		# high-high based on that it may be possible to fuse this into another
		# routine, but there's no high-high pairing here now, so I'm not

		# normal powermatching has failed, so this just tries to pair the
		# bracket

		$error_log .= "\n\nin the 'just make it work' disaster pairing mode\n\n" ;
		$error_log .= " Bracket has ".scalar(keys %bracket)." teams\n\n" ;

		# clear any current opponents & count the number of possible opponents

		foreach my $key ( keys %bracket ) {
			$entry_by_id{$key}{'opponent'} = 0;
		}

		my $min_possible_opponents;
		my $pair_fail=0;

		#now pair it
		do {
			#re-count number of possible opponents
			count_possible_opponents(
				\%entry_by_id,
				\%precluded,
				\$side_locked,
				\$min_possible_opponents,
				\%bracket
			);

			foreach my $key (
				sort { $entry_by_id{$a}->{'possible_opponents'}
						<=> $entry_by_id{$b}->{'possible_opponents'
					}
				|| $entry_by_id{$a}->{'random'} <=> $entry_by_id{$b}->{'random'} }
				keys(%bracket)
			) {

				next unless $key;
				next unless $entry_by_id{$key};

				# if it's an sidelocked round, only loop through the aff -- but WHY?
				# Disabled!  What are you doing, past self!

				# my $sidemarker = 1;
				# if ($side_locked and $bracket{$key}{'side'} == 2) { $sidemarker = 0; }
				# if ( $entry_by_id{$key}{'opponent'} == 0 and $sidemarker == 1 ) { }

				if ( $entry_by_id{$key}{'opponent'} == 0 ) {

					OPP:
					foreach my $oppkey (
						sort {
							$entry_by_id{$a}->{'possible_opponents'} <=> $entry_by_id{$b}->{'possible_opponents'}
						} keys(%bracket)) {

						next unless $oppkey;
						next unless $entry_by_id{$oppkey};

						if ($entry_by_id{$oppkey}{'opponent'} != 0) {
							$error_log .= $entry_by_id{$oppkey}{'code'}." has opponent already.\n" ;
							next OPP;
						}

						if (hasconflict($key, $oppkey, $precluded_ref) == 1) {
							$error_log .= "Teams have conflict.\n" ;
							next OPP;
						}

						next OPP if ($key == $oppkey);

						if ( $side_locked and $bracket{$key}{'side'} == $bracket{$oppkey}{'side'} ) {
							$error_log .= "Teams on same side\n" ;
							next OPP;
						}

						$entry_by_id{$key}{'opponent'} = $oppkey;
						$entry_by_id{$oppkey}{'opponent'} = $key;
						last;
					}

					if ($entry_by_id{$key}{'opponent'} == 0 ) {
						$pair_fail = 1;
					}
				}
			}

		} until ( unpaired(\%entry_by_id, \%bracket) == 0 || $pair_fail == 1 );
			#bail if all paired or couldn't pair last team

		if ( unpaired(\%entry_by_id, \%bracket) == 0 ) { return "Success"; }
		return "Fail";
	}

	sub write_round {

		my ($round, $entry_by_id_ref, $event_settings) = @_;
		my %entry_by_id = %{$entry_by_id_ref};

		my $letter = 1;
		$letter = "A" if $event_settings->{"panel_labels"} eq "letters";

		my %done;

		foreach my $key (keys %entry_by_id) {

			next unless $entry_by_id{$key}{'opponent'};
			next if $entry_by_id{$key}{'opponent'} == -999;
			next if $done{$key}++;

			if ( $key > -1
				and ($entry_by_id{$key}{'sidedue'} == 1
					or $entry_by_id{$key}{'opponent'} == -1
				)
			) {

				my $bye = 0;
				$bye = 1 if $entry_by_id{$key}{'opponent'} == -1;

				my $panel = Tab::Panel->create({
					round   => $round->id,
					bye     => $bye,
					letter  => $letter,
					flight  => 1,
					bracket => $entry_by_id{$key}{'bracket'}
				});

				#save aff ballot
				my $pullup = 0;
				my $opponent = $entry_by_id{$key}{'opponent'};
				$pullup = 1 if $entry_by_id{$key}{'wins'} < $entry_by_id{$opponent}{'wins'};
				my $side = $entry_by_id{$key}{'sidedue'};
				$side = 1 unless $side;

				my $ab = eval {
					return Tab::Ballot->create({
						panel => $panel->id,
						bye   => $bye,
						audit => $bye,
						entry => $key,
						side  => $side
					});
				};

				#save neg ballot

				if ( $bye == 0 and $opponent > 0 ) {

					my $pullup = 0;
					$pullup = 1 if $entry_by_id{$key}{'wins'} > $entry_by_id{$opponent}{'wins'};
					$side = $entry_by_id{$opponent}{'sidedue'};
					$side = 2 unless $side;

					my $nb = eval {
						return Tab::Ballot->create({
							panel  => $panel->id,
							bye    => $bye,
							entry  => $opponent,
							side   => $side
						});
					};
				}

				$letter++;

			}
		}
	}

	undef $debugme;
	undef $error_log;

	return;

</%perl>
