<%args>
	$round_id
	$bracket_to_pair
	$delete_existing => undef
</%args>
<%perl>

	my $round = Tab::Round->retrieve( $round_id );
	my $event = $round->event;
	my $powermatch_method = $event->setting("powermatch");
	
	#will take a first crack at pairing a single bracket; erases all current pairings for the bracket

	#load stuff in

	use POSIX;
	use Time::HiRes qw( time );

	my $oddround=1; if (int($round->name/2) == $round->name/2) { $oddround= 0 };

	my @round_dummy = Tab::Round->search( name=>$round->name-1, event=>$round->event );	

	my $round_for_seeding = Tab::Round->retrieve( $round_dummy[0]->id ) if @round_dummy;
	my $start = time(); 
		
	my ($entry_by_id_hash_ref, $precluded_hash_ref) = $m->comp("/funclib/make_pairing_hash.mas", round_id => $round->id);			
	my %entry_by_id = %{$entry_by_id_hash_ref};
	my %precluded = %{$precluded_hash_ref};

	my $end = time();

	print "Finished loop for SOP:  "; printf("%.2f\n", $end - $start); print "<br>";

#set the bracket

	my %bracket; 
	
	foreach my $key ( keys %entry_by_id ) {
		if ($entry_by_id{$key}{'placement'} == $bracket_to_pair) { 
			$bracket{$key}{'SOP'} = $entry_by_id{$key}{'SOP'};
			$bracket{$key}{'wins'} = $entry_by_id{$key}{'wins'};
			$bracket{$key}{'seed'} = $entry_by_id{$key}{'seed'};
			$bracket{$key}{'seed_nowins'} = $entry_by_id{$key}{'seed_nowins'};
			$bracket{$key}{'side'} = $entry_by_id{$key}{'sidedue'}; 
			if ($delete_existing) { $entry_by_id{$key}{'opponent'} = 0; }
		}
	}

#pair it


	my @order;
	@order = sort { $bracket{$a}->{'seed_nowins'} <=> $bracket{$b}->{'seed_nowins'} || $bracket{$a}->{'seed'} <=> $bracket{$b}->{'seed'} } keys(%bracket);
	if ( $powermatch_method eq "sop" ) {
		@order = sort { $bracket{$a}->{'SOP'} <=> $bracket{$b}->{'SOP'} || $bracket{$a}->{'seed'} <=> $bracket{$b}->{'seed'} } keys(%bracket);
	}

#	left here for future debugging;
#	foreach my $order_team ( @order ) {
#		my $key=$order_team;
#		print $key." ";
#		print $entry_by_id{$key}{'code'}." ";
#		print "wins:".$bracket{$key}{'wins'};
#		print "seed_nowins:".$bracket{$key}{'seed_nowins'};
#		print " seed:".$bracket{$key}{'seed'}."<br>";
#	}
			

		foreach my $order_team ( @order ) {
			my $key=$order_team;

			#if it's an even round, only loop through the aff
			my $sidemarker = 1;
			if ($oddround == 0 and $bracket{$key}{'side'} == 2) { 
				$sidemarker = 0; 
			}

			if ( $entry_by_id{$key}{'opponent'} == 0 and $sidemarker == 1 ) {

				#print "Finding opponent for ".$entry_by_id{$key}{'code'}."<br>";
				foreach my $oppkey (sort { $bracket{$b}->{'SOP'} <=> $bracket{$a}->{'SOP'} || $bracket{$b}->{'seed'} <=> $bracket{$a}->{'seed'} } keys(%bracket)) {

					my $canpair = 1;

					if ($entry_by_id{$oppkey}{'opponent'} != 0) {
						$canpair = 0; #already has opponent
						#print " has opponent";
					}

					if ($precluded{$key}{$oppkey} == 1 or $precluded{$oppkey}{$key} == 1) {
						$canpair = 0; #teams have a preclusion
						#print " has preclusion";
					}

					if ($key == $oppkey) {
						$canpair = 0;  #its the same team
						#print " same team";
					} 

					if ( $oddround == 0 and $bracket{$key}{'side'} == $bracket{$oppkey}{'side'} ) {
						$canpair = 0; #wrong side
						#print " wrong side";
					} 

					if ( $canpair == 0 ) {
						#print "CAN'T pair vs. ".$entry_by_id{$oppkey}{'code'}."<Br>";
					}
	
					if ( $canpair == 1 ) {
						#print "Pairing ".$entry_by_id{$key}{'code'}." vs. ".$entry_by_id{$oppkey}{'code'}."<Br>";
						$entry_by_id{$key}{'opponent'} = $oppkey;
						$entry_by_id{$oppkey}{'opponent'} = $key;
						if ($entry_by_id{$key}{'sidedue'} == 0 and $oddround == 1) { 
							$entry_by_id{$key}{'sidedue'} = 1;
							$entry_by_id{$oppkey}{'sidedue'} = 2;
						}
						last;
					}
				}
			}
		}

	#erase existing panels

	if ($delete_existing) {
		$m->comp("dump_bracket.mas", round_id => $round->id, bracket_to_pair => $bracket_to_pair);			
	}

		#save them
		my $letter; my $pullup; my $position; my $bye; my $opponent;

		foreach my $key ( keys %bracket ) {		
			#print "key:".$key." side due:".$entry_by_id{$key}{'sidedue'}." opponent:".$entry_by_id{$key}{'opponent'}."<br>";	

			if ( $key > -1 and ($entry_by_id{$key}{'sidedue'} == 1 or $entry_by_id{$key}{'opponent'} == -1 ) ) {

				#create the panel
				$letter++;
				$bye = 0; 
				$bye = 1 if $entry_by_id{$key}{'opponent'} == 1;

				my $panel = Tab::Panel->create({
					round   => $round->id,
					bye     => $bye,
					audit   => $bye,
					letter  => $letter,
					flight  => 1,
					bracket => $bracket_to_pair
				});
				
				#save aff ballot
				$pullup = 0;
				$opponent = $entry_by_id{$key}{'opponent'};

				if ( $entry_by_id{$key}{'wins'} < $entry_by_id{$opponent}{'wins'} ) { $pullup = 1; }
				
				Tab::Ballot->create({
					panel        => $panel->id,
					judge        => 0,
					entry        => $key,
					side	     => $entry_by_id{$key}{'sidedue'},
					seed         => $entry_by_id{$key}{'seed'},
					pullup       => $pullup
				});
				
				#save neg ballot
				if ( $bye == 0 and $opponent > 0 ) {
					$pullup = 0;
					if ( $entry_by_id{$key}{'wins'} > $entry_by_id{$opponent}{'wins'} ) { $pullup = 1; }
					Tab::Ballot->create({
						panel        => $panel->id,
						judge        => 0,
						entry        => $opponent,
						side		 => $entry_by_id{$opponent}{'sidedue'},
						seed         => $entry_by_id{$opponent}{'seed'},
						pullup       => $pullup
					});
				}
			}		
		}

#get back

	$m->redirect("/panel/manipulate/manual_powermatch.mhtml?round_id=$round_id&bracket=$bracket_to_pair&msg=Bracket has been paired using $powermatch_method method to powermatch");

</%perl>
