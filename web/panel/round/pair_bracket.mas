<%args>
	$round_id
	$bracket_to_pair
	$delete_existing => undef
</%args>
<%perl>

#will take a first crack at pairing a single bracket; erases all current pairings for the bracket

#load stuff in

	use POSIX;
	use Time::HiRes qw( time );

	my $round = Tab::Round->retrieve($round_id);
	my $oddround=1; if (int($round->name/2) == $round->name/2) { $oddround= 0 };

	my @round_dummy = Tab::Round->search( name=>$round->name-1, event=>$round->event );	

	my $round_for_seeding = Tab::Round->retrieve( $round_dummy[0]->id );
	my $start = time(); 
		
	my ($entry_by_id_hash_ref, $precluded_hash_ref) = $m->comp("/funclib/make_pairing_hash.mas", round_id => $round->id);			
	my %entry_by_id = %{$entry_by_id_hash_ref};
	my %precluded = %{$precluded_hash_ref};

	my $end = time();

	print "Finished loop for SOP:  "; printf("%.2f\n", $end - $start); print "<br>";

#set the bracket

	my %bracket; 
	
	foreach my $key ( keys %entry_by_id ) {
		if ($entry_by_id{$key}{'placement'} == $bracket_to_pair) { 
			$bracket{$key}{'SOP'} = $entry_by_id{$key}{'SOP'};
			$bracket{$key}{'seed'} = $entry_by_id{$key}{'seed'};
			$bracket{$key}{'side'} = $entry_by_id{$key}{'sidedue'}; 
			if ($delete_existing) { $entry_by_id{$key}{'opponent'} = 0; }
		}
	}

#pair it

	foreach my $key ( sort { $bracket{$a}->{'SOP'} <=> $bracket{$b}->{'SOP'} || $bracket{$a}->{'seed'} <=> $bracket{$b}->{'seed'} } keys(%bracket) ) {

			#if it's an even round, only loop through the aff
			my $sidemarker = 1;
			if ($oddround == 0 and $bracket{$key}{'side'} == 2) { 
				$sidemarker = 0; 
			}

			if ( $entry_by_id{$key}{'opponent'} == 0 and $sidemarker == 1 ) {

				#print "Finding opponent for ".$entry_by_id{$key}{'code'}."<br>";
				foreach my $oppkey (sort { $bracket{$b}->{'SOP'} <=> $bracket{$a}->{'SOP'} || $bracket{$b}->{'seed'} <=> $bracket{$a}->{'seed'} } keys(%bracket)) {

					my $canpair = 1;

					if ($entry_by_id{$oppkey}{'opponent'} != 0) {
						$canpair = 0; #already has opponent
						#print " has opponent";
					}

					if ($precluded{$key}{$oppkey} == 1 or $precluded{$oppkey}{$key} == 1) {
						$canpair = 0; #teams have a preclusion
						#print " has preclusion";
					}

					if ($key == $oppkey) {
						$canpair = 0;  #its the same team
						#print " same team";
					} 

					if ( $oddround == 0 and $bracket{$key}{'side'} == $bracket{$oppkey}{'side'} ) {
						$canpair = 0; #wrong side
						#print " wrong side";
					} 

					if ( $canpair == 0 ) {
						#print "CAN'T pair vs. ".$entry_by_id{$oppkey}{'code'}."<Br>";
					}
	
					if ( $canpair == 1 ) {
						#print "Pairing ".$entry_by_id{$key}{'code'}." vs. ".$entry_by_id{$oppkey}{'code'}."<Br>";
						$entry_by_id{$key}{'opponent'} = $oppkey;
						$entry_by_id{$oppkey}{'opponent'} = $key;
						last;
					}
				}
			}
		}

#erase existing panels

	if ($delete_existing) {
		$m->comp("dump_bracket.mas", round_id => $round->id, bracket_to_pair => $bracket_to_pair);			
	}

#save them

		my $letter; my $pullup; my $position; my $bye; my $opponent;
		foreach my $key ( keys %bracket ) {		

			if ( $key > -1 and ($entry_by_id{$key}{'sidedue'} == 1 or $entry_by_id{$key}{'opponent'} == -1 ) ) {

				#create the panel
				$letter++;
				$bye = 0; 
				if ( $entry_by_id{$key}{'opponent'} == 1 ) { $bye = 1; }
				my $panel = Tab::Panel->create({
					round   => $round->id,
					bye     => $bye,
					letter  => $letter,
					flight  => 1,
					bracket => $bracket_to_pair
				});
				
				#save aff ballot
				$pullup = 0;
				$opponent = $entry_by_id{$key}{'opponent'};

				if ( $entry_by_id{$key}{'wins'} < $entry_by_id{$opponent}{'wins'} ) { $pullup = 1; }
				
				Tab::Ballot->create({
					panel        => $panel->id,
					judge        => 0,
					entry        => $key,
					side		 => $entry_by_id{$key}{'sidedue'},
					seed         => $entry_by_id{$key}{'seed'},
					pullup       => $pullup
				});
				
				#save neg ballot
				if ( $bye == 0 and $opponent > 0 ) {
					$pullup = 0;
					if ( $entry_by_id{$key}{'wins'} > $entry_by_id{$opponent}{'wins'} ) { $pullup = 1; }
					Tab::Ballot->create({
						panel        => $panel->id,
						judge        => 0,
						entry        => $opponent,
						side		 => $entry_by_id{$opponent}{'sidedue'},
						seed         => $entry_by_id{$opponent}{'seed'},
						pullup       => $pullup
					});
				}
			}		
		}

#get back

	$m->redirect("manual_pair_debate.mhtml?round_id=$round_id&bracket=$bracket_to_pair&msg=Bracket has been paired");

</%perl>
