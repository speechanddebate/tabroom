<%args>
	$round    => undef
	$round_id => undef
</%args>
<%perl>

	use POSIX;
	use List::Util 'shuffle';

	$round = Tab::Round->retrieve($round_id) unless $round > 0;
	my $event = $round->event;
	my %event_settings = $event->all_settings;

	my $tourn = $event->tourn;

	$event_settings{"ncfl"} = $tourn->setting("ncfl");
	$event_settings{"region_avoid"}++ if $event_settings{"ncfl"};
	$event_settings{"nsda_nats"}     = $tourn->setting("nsda_nats");
	$event_settings{"nsda_district"} = $tourn->setting("nsda_district");

	my $dio_regions = $event->category->setting("conflict_region_judges");

	Tab::Round->set_sql(reset_prelim => '
		update round set type="prelim" 
		where type="preset" 
		and event = ?');

	Tab::Round->sql_reset_prelim->execute($event->id);

	my $round_type = $round->type;

	my $round_limit = "and round.name < ".$round->name 
		if $round_type eq "highlow" || $round_type eq "highhigh";

	$round_limit = 'and round.type = "prelim" and round.name != '.$round->name 
		if $round_type eq "prelim";

	my $sidelock_against = $round->setting("sidelock_against");

	my $no_side_constraints++ if $event_settings{"no_side_constraints"};

	$no_side_constraints++ if $sidelock_against eq "NONE";
	$no_side_constraints++ if $sidelock_against eq "RANDOM";

	my $dbh = Tab::DBI->db_Main();

	my $entry_sth = $dbh->prepare('
		select distinct entry.id, 
			school.region, school.id, 
			entry.code, dioregion.value
		from (entry, school)

		left join region_setting dioregion 
			on dioregion.region = school.region 
			and dioregion.tag = ?

		left join chapter on school.chapter = chapter.id

		where entry.event = ? 
		and entry.school = school.id
		and entry.active = 1
	');

	my @entries;

	my %entry_info;
	my %school_info;
	my %seed_count;

	$entry_sth->execute("region-".$event->id, $event->id);

	while (
		my ($entry_id, $region, $school, $code, $dioregion)
		= $entry_sth->fetchrow_array() 
	) {

		next unless $entry_id;

		push @entries, $entry_id;

		if ($event_settings{"nsda_nats"}) { 

			$entry_info{$entry_id}{"school"} = $school;
			$entry_info{$entry_id}{"region"} = $region;
			$school_info{"size"}{$region}++;

		} elsif ($event_settings{"ncfl"}) { 

			$entry_info{$entry_id}{"school"} = $region;
			$entry_info{$entry_id}{"region"} = $dioregion;
			$school_info{"size"}{$region}++;

		} else {

			$entry_info{$entry_id}{"school"} = $school;
			$entry_info{$entry_id}{"region"} = $region;
			$school_info{"size"}{$school}++;

		}

		$entry_info{$entry_id}{"code"} = $code;
	}

	my @seed_settings = $m->comp(
		"/funclib/event_entry_settings.mas", 
			tag   => "pairing_seed",
			event => $event
	);

	foreach my $setting (@seed_settings) { 
		$entry_info{$setting->entry->id}{"seed"} = $setting->value;
	}

	my @seeds;
	my $max_seed;

	my @pods;

	my @pod_settings = $m->comp(
		"/funclib/event_entry_settings.mas", 
		tag   => "pod",
		event => $event
	);

	foreach my $pod (@pod_settings) { 
		$entry_info{$pod->entry->id}{"pod"} = $pod->value;
	}

	foreach my $entry (@entries) { 

		$entry_info{$entry}{'seed'} = 0 
			unless $entry_info{$entry}{'seed'};

		$seed_count{$entry_info{$entry}{"seed"}}++;

		$max_seed = $entry_info{$entry}{'seed'} 
			if $entry_info{$entry}{'seed'} > $max_seed;

		push @seeds, $entry_info{$entry}{'seed'};
		push @pods, $entry_info{$entry}{"pod"};
	}

    my $school_debates_self++ 
		if $event_settings{"school_debates_self"};

    my $hybrids_can_hit++ 
		if $event_settings{"hybrids_can_hit"};

    unless ($school_debates_self || $hybrids_can_hit) {

        #pull hybrid school conflicts
        my @strikes = Tab::Strike->search( 
			tourn => $tourn,
			type  => 'hybrid' 
		);

        foreach my $strike (@strikes) { 
			$entry_info{$strike->entry->id}{"hybrid"} = $strike->school->id;
        }
    }   

	my %seen = (); 
	@pods = grep { ! $seen{$_} ++ } @pods;

	my $ballot_sth = $dbh->prepare('

		select distinct 
			entry.id, 
			opponent.id, opp_school.id, opp_school.region,
			ballot.side

		from (entry, entry as opponent, 
			ballot, panel, round, 
			ballot as opp_ballot, school as opp_school)

		left join chapter on opp_school.chapter = chapter.id

		where entry.event = ? 
		and entry.id = ballot.entry
		and ballot.panel = panel.id
		and panel.round = round.id
		'.$round_limit.'
		and round.id != ? 
		and opp_ballot.panel = ballot.panel
		and opp_ballot.entry = opponent.id
		and opponent.school = opp_school.id
		and opponent.id != entry.id
		and panel.bye != 1
		and ballot.bye != 1
	');

	$ballot_sth->execute($event->id, $round->id);

	my %dio_region;

	if ($event_settings{"ncfl"} && $dio_regions) { 
		foreach my $diocese (
			$m->comp("/funclib/tourn_regions.mas", tourn => $tourn)
		) { 
			$dio_region{$diocese->id} = $diocese->setting("region");
		}   
	}

	while( 
		my ($entry_id, $opp_id, $opp_school, $opp_region, $side) 
		= $ballot_sth->fetchrow_array() 
	) {

		$entry_info{$entry_id}{"hits-".$opp_id}++;

		$entry_info{$entry_id}{"oppside-".$opp_id."-".$side}++ 
			unless $no_side_constraints;

		$entry_info{$entry_id}{"school_hit-".$opp_school}++;
		$entry_info{$entry_id}{"region_hit-".$opp_region}++;

		$entry_info{$entry_id}{"dioregion_hit-".$dio_region{$opp_region}}++ 
			if $dio_regions;

		push @{$entry_info{$entry_id}{"opponents"}}, $opp_id;
	}

	my $seed_byes_as;

	my $round_side;
	my $round_care;

	unless ($no_side_constraints) { 

		if ($sidelock_against) { 

			$round_side = " and round.id = ".$sidelock_against;
			$round_care = $sidelock_against;

		} elsif ($round->name % 2 ) { 

			# Odd presets mean I care about the next prelim round in case we're
			# repaneling for seeding, if it exists 

			Tab::Round->set_sql(next_even => "
				select round.*
				from round
				where round.event = ? 
				and round.name > ? 
				and round.type = 'prelim'
				order by round.name limit 1
			");

			$round_care = Tab::Round->search_next_even($event->id, $round->name)->first;

		} else { 

			# Even presets sidelock against the last round

			Tab::Round->set_sql(next_even => "
				select round.*
				from round
				where round.event = ? 
				and round.name < ? 
				and round.type = 'prelim'
				order by round.name DESC limit 1
			");

			$round_care = Tab::Round->search_next_even($event->id, $round->name)->first;

		}
	}

	# Still need to do this to assure the same team/school doesn't get a bye
	# 2x even if it's not sidelocked. 

	my $sides_sth = $dbh->prepare('
		select distinct ballot.entry, ballot.side, ballot.bye, panel.bye, round.id
		from ballot, panel, entry, round
		where ballot.entry = entry.id
		and round.id != ? 
		and entry.event = ?
		and ballot.panel = panel.id
		and panel.round = round.id
		'.$round_side.'
	');

	$sides_sth->execute($round->id, $event->id);

	while (
		my ($entry_id, $side, $bye, $panel_bye, $round) 
		= $sides_sth->fetchrow_array() 
	) { 

		$entry_info{$entry_id}{"byes"}++ 
			if $bye || $panel_bye;

		$school_info{$entry_info{$entry_id}{"school"}}{"byes"}++ 
			if $bye || $panel_bye;
	
		next if $no_side_constraints;
		next if $bye || $panel_bye;
		next if $round != $round_care;

		$entry_info{$entry_id}{"affs"}++ if $side == 1;
		$entry_info{$entry_id}{"negs"}++ if $side == 2;
	}

	#uniq
	my %s_seen = (); 
	@seeds = grep { ! $s_seen{$_} ++ } @seeds; 

	my %e_seen = (); 
	@entries = grep { ! $e_seen{$_} ++ } @entries;

	my $best_score;
	my $bye;

	if ($event_settings{"round_robin"}) { 

		my @rounds = $event->rounds( type => "prelim");

		# In a round robin, seeds are pods
		my $num_pods = scalar @pods;
		next unless $num_pods;

		my $pod_size = ceil(scalar @entries / $num_pods);

		$pod_size++ if $pod_size % 2;
		my $num_rounds = $pod_size -1; 

		unless ($num_rounds == scalar @rounds) { 

			my $err = "You do not have the correct number of preset rounds for ";
			$err .= scalar @entries." debaters for $num_pods pods.  Please make ";
			$err .= "sure you have $num_rounds presets";

			$m->redirect("/setup/schedule/event.mhtml?event_id=".$event->id."&err=$err");
		}

		my %panel_entries = ();
		my %round_panels = ();
		my %panel_pod = ();
		my $tick;

		foreach my $pod (@pods) { 

			my @pod;
			my %pod_panels = ();

			foreach my $entry (@entries) { 
				push @pod, $entry if $entry_info{$entry}{"pod"} == $pod;
			}

			# Make sure it's an even number.  Fill blanks with byes
			my $bye_present;

			if ( (scalar @pod) % 2 ) { 
				push @pod, "BYE";
				$bye_present++;
			}

			foreach my $round (@rounds) { 

				foreach ( 1 .. (scalar @pod) / 2 ) { 
					$tick++;
					push @{$pod_panels{$round->id}}, $tick;
					$panel_pod{$tick} = $pod;
				}

				# Remove the second entry and push them to the end.  The RR
				# pairing algorithm is that you keep the first slot stationary
				# and rotate everyone else around them to get a full pairing.

				my $second = splice(@pod, 1, 1);
				push @pod, $second;

				my @copy = @pod;

				my $counter = $round->name - 1;

				foreach my $panel (@{$pod_panels{$round->id}}) { 
					
					next unless $panel_pod{$panel} == $pod;

					if ($counter++ % 3) { 
						$panel_entries{$panel}{"aff"} = shift @copy;
						$panel_entries{$panel}{"neg"} = pop @copy;
					} else { 
						$panel_entries{$panel}{"aff"} = pop @copy;
						$panel_entries{$panel}{"neg"} = shift @copy;
					}
				}
			}

			foreach my $round (@rounds) { 
				foreach my $panel (@{$pod_panels{$round->id}}) { 
					next if $panel_entries{$panel}{"neg"} eq "BYE";
					next if $panel_entries{$panel}{"aff"} eq "BYE";
				}
			}

			my $lowest;
			my $highest;

			my $num_debates = scalar @rounds;
			$num_debates -= $bye_present;

			if ( $num_debates % 2 ) { 
				$highest = ceil($num_debates / 2);
				$lowest = floor($num_debates / 2);
			} else { 
				$highest = $num_debates / 2;
				$lowest = $num_debates / 2;
			}

			my $not_ok = 1;

			# There is surely an algorithm that would do this properly but I'm
			# not going to waste any more time finding it.  So brute force the
			# fucker 50 times and call it a day.

			my %side_counter;
			my %aff_count;
			my %neg_count;

			foreach my $round (@rounds) { 

				PANEL:
				foreach my $panel (@{$pod_panels{$round->id}}) { 

					my $aff = $panel_entries{$panel}{"aff"};
					my $neg = $panel_entries{$panel}{"neg"};

					next if $aff eq "BYE" || $neg eq "BYE"; # not a round, doesn't count

					if (
						($aff_count{$aff} < $neg_count{$aff}) 
						|| ($neg_count{$neg} < $aff_count{$neg})
					) {
						$aff_count{$aff}++;
						$neg_count{$neg}++;
						next PANEL;
					}

					if (
						($aff_count{$aff} == $neg_count{$aff})
						&& ($neg_count{$neg} == $aff_count{$neg})
					) { 

						# Flip a coin so the random trials are actually not
						# always seeded the same way. 

						if (rand(100) % 2) { 
							$aff_count{$aff}++;
							$neg_count{$neg}++;
							next PANEL;
						}
					}
					
					$panel_entries{$panel}{"aff"} = $neg;
					$panel_entries{$panel}{"neg"} = $aff;

					$neg_count{$aff}++;
					$aff_count{$neg}++;

				}
			}

			foreach (1 .. 15000) {
			
				# in theory I could make this a while loop but since I'm not 100%
				# it will always work this is better than infinite looping

				next unless $not_ok;
				undef $not_ok;

				my %in_a_row;

				foreach my $round (sort {$a->name <=> $b->name} @rounds) { 

					PANEL:
					foreach my $panel (@{$pod_panels{$round->id}}) { 

						my $aff = $panel_entries{$panel}{"aff"};
						my $neg = $panel_entries{$panel}{"neg"};

						next if $aff eq "BYE" || $neg eq "BYE"; # not a round, doesn't count

						$in_a_row{$aff}{"aff"}++;
						$in_a_row{$neg}{"neg"}++;

						undef $in_a_row{$aff}{"neg"};
						undef $in_a_row{$neg}{"aff"};

						next if $in_a_row{$aff}{"aff"} < 3 && $in_a_row{$neg}{"neg"} < 3;

						$panel_entries{$panel}{"aff"} = $neg;
						$panel_entries{$panel}{"neg"} = $aff;

						$aff_count{$aff}--;
						$neg_count{$neg}--;

						$neg_count{$aff}++;
						$aff_count{$neg}++;

					}

				}

				foreach my $round (shuffle @rounds) { 

					PANEL:
					foreach my $panel (@{$pod_panels{$round->id}}) { 

						my $aff = $panel_entries{$panel}{"aff"};
						my $neg = $panel_entries{$panel}{"neg"};

						next if $aff eq "BYE" || $neg eq "BYE"; # not a round, doesn't count

						unless ($in_a_row{$aff}{"aff"} > 2 || $in_a_row{$neg}{"neg"} > 2) {
							next PANEL if $aff_count{$aff} < $neg_count{$aff};
							next PANEL if $neg_count{$neg} < $aff_count{$neg};
							next PANEL if $aff_count{$aff} == $neg_count{$aff};
							next PANEL if $neg_count{$neg} == $aff_count{$neg};
						}

						$panel_entries{$panel}{"aff"} = $neg;
						$panel_entries{$panel}{"neg"} = $aff;

						$aff_count{$aff}--;
						$neg_count{$neg}--;

						$neg_count{$aff}++;
						$aff_count{$neg}++;

					}
				}

				foreach my $entry (@pod) { 
					next if $entry eq "BYE";
					if ($aff_count{$entry} < $lowest || $aff_count{$entry} > $highest) {
						$not_ok++;
					}
				}

				foreach my $round (sort {$a->name <=> $b->name} @rounds) { 

					PANEL:
					foreach my $panel (@{$pod_panels{$round->id}}) { 

						my $aff = $panel_entries{$panel}{"aff"};
						my $neg = $panel_entries{$panel}{"neg"};

						next if $aff eq "BYE" || $neg eq "BYE"; # not a round, doesn't count

						$in_a_row{$aff}{"aff"}++;
						$in_a_row{$neg}{"neg"}++;

						undef $in_a_row{$aff}{"neg"};
						undef $in_a_row{$neg}{"aff"};

						$not_ok++ if $in_a_row{$aff}{"aff"} > 2;
						$not_ok++ if $in_a_row{$neg}{"neg"} > 2;
					}
				}
			}

			foreach my $round (@rounds) { 
				foreach my $panel (@{$pod_panels{$round->id}}) { 
					push @{$round_panels{$round->id}}, $panel;
				}
			}

		}

		foreach my $round (@rounds) { 

			my %final_panels = ();
			my @byes;

			foreach my $panel (@{$round_panels{$round->id}}) { 

				push @byes, $panel_entries{$panel}{"aff"} 
					if $panel_entries{$panel}{"neg"} eq "BYE";

				push @byes, $panel_entries{$panel}{"neg"} 
					if $panel_entries{$panel}{"aff"} eq "BYE";

			}

			foreach my $panel (@{$round_panels{$round->id}}) { 

				next if $panel_entries{$panel}{"aff"} eq "BYE";
				next if $panel_entries{$panel}{"neg"} eq "BYE";
				push @{$final_panels{$panel}}, $panel_entries{$panel}{"aff"};
				push @{$final_panels{$panel}}, $panel_entries{$panel}{"neg"};

			}

			write_round($round, \%final_panels, 0, \@byes);

		}

	} else { 

		my %final_panels = ();
		my %panel_score;

		foreach my $pass (1 .. 4) { 

			my %panels;

			@entries = shuffle(@entries);

			@entries = sort {
				$entry_info{$b}{"school"} 
				<=> 
				$entry_info{$a}{"school"}
			} @entries;

			@entries = 
				sort {
					$school_info{"size"}{$entry_info{$b}{"school"}} 
						<=> 
					$school_info{"size"}{$entry_info{$a}{"school"}}
				}
			@entries;

			my %bye_seed;
			my $seed_aim;

			if ($event_settings{"seed_presets"} eq "balance") { 

				@entries = 
					sort { $entry_info{$a}{'seed'} 
					<=> $entry_info{$b}{'seed'} }  
				@entries;

				my $position = 1;

				foreach my $entry (@entries) { 
					$entry_info{$entry}{'seed'} = $position++;
				}

				my %opp_position;
				my $opps_taken;

				foreach my $entry (@entries) { 

					foreach my $opp (@{$entry_info{$entry}{"opponents"}}) { 
						$opp_position{$entry} += $entry_info{$opp}{'seed'};
						$opps_taken++;
					}

					if ($entry_info{$entry}{"byes"}) { 
						$opp_position{$entry} += scalar @entries;
					}

				}

				@entries = 
					sort {$opp_position{$b} <=> $opp_position{$a}} 
					@entries if $opps_taken;

				$position = 1;

				foreach my $entry (@entries) { 
					$entry_info{$entry}{"need_position"} = $position++ 
						if $opp_position{$entry} || $entry_info{$entry}{"byes"};
				}

			} elsif ($event_settings{"seed_presets"} eq "all") {

				foreach my $entry (@entries) { 
					SEED:
					foreach my $seed (@seeds) { 

						foreach my $opp (@{$entry_info{$entry}{"opponents"}}) { 
							next SEED if $seed eq $entry_info{$opp}{'seed'};
						}

						$entry_info{$entry}{"need_seed"}{$seed}++;

						$entry_info{$entry}{"needs_print"} .= " ".$seed 
							unless $entry_info{$entry}{"needs_print"} eq " ".$seed;
					}
				}

				my $top_count;

				foreach my $seed (@seeds) { 
					$top_count = $seed_count{$seed} if $seed_count{$seed} > $top_count;
				}

				foreach my $seed (@seeds) { 
					$bye_seed{$seed}++ if $seed_count{$seed} == $top_count;
				}

				$seed_byes_as = scalar @entries + 1;

			} elsif ($event_settings{"seed_presets"} eq "inverse") {

				my $got_bye;
				$seed_byes_as = 4;

				foreach my $entry (@entries) { 

					my @seeds = (2,3) if (
						$entry_info{$entry}{'seed'} == 1 
						|| $entry_info{$entry}{'seed'} == 4
					);

					@seeds = (1,4) if (
						$entry_info{$entry}{'seed'} == 2 
						|| $entry_info{$entry}{'seed'} == 3
					);

					
					SEED:
					foreach my $seed (@seeds) { 

						next SEED if ($entry_info{$entry}{"byes"} > 0) && ($seed == 4);

						foreach my $opp (@{$entry_info{$entry}{"opponents"}}) { 
							next SEED if $seed eq $entry_info{$opp}{'seed'};
						}

						$entry_info{$entry}{"need_seed"}{$seed}++;
						$entry_info{$entry}{"needs_print"} .= " ".$seed;

					}
				}

			}

			@entries = shuffle @entries;

			my @due_aff;
			my @due_neg;
			my @due_whatever;

			my %due;

			my $flip = rand(100) % 2;
			undef $flip if @due_aff || @due_neg;

			my $whole = scalar(@entries);
			$whole++ if $whole % 2;

			my $quarter = ceil( $whole / 4);
			my $threequarter = floor( 3 * $whole/ 4);

			@entries = sort {
				$entry_info{$a}{"seed"} 
				<=> 
				$entry_info{$b}{"seed"}
			} @entries 
			if $event_settings{"seed_presets"} eq "balance";

			ENTRY:
			foreach my $entry (@entries) { 

				next if $entry == $bye;

				if ($entry_info{$entry}{"negs"} > $entry_info{$entry}{"affs"}) { 

					push @due_aff, $entry;
					$due{$entry} = 1;

				} elsif ($entry_info{$entry}{"negs"} < $entry_info{$entry}{"affs"}) { 

					push @due_neg, $entry;
					$due{$entry} = 2;

				} elsif (
					$event_settings{"seed_presets"} eq "inverse" 
					&! $entry_info{$entry}{"byes"}
				) { 

					if ($flip == 1) { 

						push @due_neg, $entry 
							if $entry_info{$entry}{'seed'} == 2 
							|| $entry_info{$entry}{'seed'} == 3;

						push @due_aff, $entry 
							if $entry_info{$entry}{'seed'} == 1 
							|| $entry_info{$entry}{'seed'} == 4;

					} else { 

						push @due_aff, $entry 
							if $entry_info{$entry}{'seed'} == 2 
							|| $entry_info{$entry}{'seed'} == 3;

						push @due_neg, $entry 
							if $entry_info{$entry}{'seed'} == 1 
							|| $entry_info{$entry}{'seed'} == 4;
					}

				} elsif (
					$event_settings{"seed_presets"} eq "balance" 
					&! $entry_info{$entry}{"byes"}
				) { 
					
					if (
						$entry_info{$entry}{'seed'} < $quarter 
						|| $entry_info{$entry}{'seed'} > $threequarter
					) { 
						if ($flip == 1) { 
							push @due_neg, $entry;
						} else { 
							push @due_aff, $entry;
						}

					} else { 
						if ($flip == 1) { 
							push @due_aff, $entry;
						} else { 
							push @due_neg, $entry;
						}
					}

				} else { 

					push @due_whatever, $entry;
					$due{$entry} = 0;

				}

			}

			my %used;

			if ((scalar @entries) % 2) { 

				# Pull a bye from whatever entry randomly shuffled to the top
				# from among those who have not had a bye.  

				my @tried;
				my @candidates;
				my $average = (scalar @entries) / 2;

				@candidates = @due_aff if scalar @due_aff > scalar @due_neg;
				@candidates = @due_neg if scalar @due_aff < scalar @due_neg;
				@candidates = @entries if scalar @due_aff == scalar @due_neg;

				if ($event_settings{"seed_presets"} eq "balance") {
					@candidates = 
						sort { 
							abs($entry_info{$a}{'seed'} - $average) 
								<=> 
						 	abs($entry_info{$b}{'seed'} - $average)
						} @candidates;


					# this sorts the candidates so that the bye is more likely
					# to come from the middle

					if ($entry_info{$entries[0]}{"need_position"}) { 
						@candidates = 
							sort {
								$entry_info{$b}{"need_position"} 
									<=> 
								$entry_info{$a}{"need_position"}
							} @candidates ;
					}

				}

				while (not defined $bye) { 

					unless (@candidates) { 
						@tried = shuffle @tried;
						$bye = shift @tried;
					}

					my $test = shift @candidates;

					if ($test) { 

						my $nope;

						$nope++ if $entry_info{$test}{"byes"};
						$nope++ if $school_info{$entry_info{$test}{"school"}}{"byes"};

						if (keys %bye_seed) { 
							unless ($bye_seed{ $entry_info{$test}{'seed'} }) { 
								push @tried, $test;
								$nope++;
							}
						} elsif ($event_settings{"seed_presets"} eq "inverse" ) { 

							unless ($entry_info{$test}{"need_seed"}{$seed_byes_as} > 0) { 
								push @tried, $test;
								$nope++;
							}

						} else { 
							push @tried, $test;
						}

						$bye = $test unless $nope;
					}

				}

				if ($bye) { 

					undef $due{$bye};
					$used{$bye}++;

					my $index = 0;
					$index++ until $due_aff[$index] eq $bye || $index > scalar @due_aff;
					splice(@due_aff, $index, 1);

					$index = 0;
					$index++ until $due_neg[$index] eq $bye || $index > scalar @due_neg;
					splice(@due_neg, $index, 1);

					$index = 0;
					$index++ until $due_whatever[$index] eq $bye || $index > scalar @due_whatever;
					splice(@due_whatever, $index, 1);

				}

			}

			my %seen = (); 
			@due_whatever = grep { ! $seen{$_} ++ } @due_whatever;
			@due_aff = grep { ! $seen{$_} ++ } @due_aff;
			@due_neg = grep { ! $seen{$_} ++ } @due_neg;

			my %partner;
			my $average = (scalar @entries) / 2;

			if ($event_settings{"seed_presets"} eq "balance") {
				@due_whatever = sort { 
					abs($entry_info{$a}{'seed'} - $average) 
					<=> 
					abs($entry_info{$b}{'seed'} - $average) 
				} @due_whatever;
			}

			WHATEVER:
			while (@due_whatever) { 

				# Randomly sprinkle the whatevers until both sides are even.
				# We do this now instead of waiting until the end to prevent
				# the byes from always hitting one another, since if there are
				# multiple byes at this point, they're almost certainly
				# screwups who don't deserve that kind of consideration.

				@due_whatever = shuffle @due_whatever 
					unless $event_settings{"seed_presets"} eq "balance";

				my $pull = shift @due_whatever;
				next if $used{$pull}++;

				my $partner = pop @due_whatever 
					if @due_whatever 
					&& $event_settings{"seed_presets"} eq "balance";

				$used{$partner}++;

				$partner{$pull} = $partner;
				$partner{$partner} = $pull;

				my $opp1;
				my $opp2;

				if (scalar @due_neg < scalar @due_aff) { 
					push @due_neg, $pull;
					push @due_aff, $partner if $partner;
				} else { 
					push @due_aff, $pull;
					push @due_neg, $partner if $partner;
				}

			}

			@due_aff = shuffle @due_aff;
			@due_neg = shuffle @due_neg;

			if ($event_settings{"seed_presets"} eq "balance") { 

				@due_aff = sort { 
					abs($entry_info{$a}{'seed'} - $average) 
						<=> 
					abs($entry_info{$b}{'seed'} - $average) 
				} @due_aff;

				@due_neg = sort { 
					abs($entry_info{$a}{'seed'} - $average) 
						<=> 
					abs($entry_info{$b}{'seed'} - $average) 
				} @due_neg;
			}

			while (scalar @due_aff > scalar @due_neg) { 
				#Shift some poor suckers over
				push @due_neg, shift @due_aff;
			}

			while (scalar @due_aff < scalar @due_neg) { 
				#Shift some poor suckers over
				push @due_aff, shift @due_neg;
			}

			my %is_due_aff = map {$_ => 1} @due_aff;
			my %is_due_neg = map {$_ => 1} @due_neg;

			my $counter = 1;
			my @panel_keys;

			if ($event_settings{"seed_presets"} eq "protect") { 
				@due_aff = sort {$entry_info{$a}{'seed'} <=> $entry_info{$b}{'seed'}} @due_aff;
				@due_neg = sort {$entry_info{$b}{'seed'} <=> $entry_info{$a}{'seed'}} @due_neg;
			}

			if ($event_settings{"seed_presets"} eq "balance") { 

				@due_aff = sort { 
					abs($entry_info{$b}{'seed'} - $average) 
					<=> 
					abs($entry_info{$a}{'seed'} - $average)
				} @due_aff;

				@due_neg = sort { 
					abs($entry_info{$a}{'seed'} - $average) 
					<=> 
					abs($entry_info{$b}{'seed'} - $average)
				} @due_neg;
			}

			my %done;
			my $negs;

			foreach my $aff (@due_aff) { 

				next if $done{$aff}++;
				my $neg;

				my $shifter;

				if ($entry_info{$aff}{"needs_print"}) { 

					# This segment manages seeded presets and matches people
					# based on ideal seeding needs.  Only invoked for inverse &
					# all seed_protect settings.

					@due_neg = shuffle @due_neg 
						unless $event_settings{"seed_presets"} eq "balance";

					if ($event_settings{"seed_presets"} eq "inverse") { 

						if ($shifter++ % 2) { 

							@due_neg = 
								sort {$entry_info{$a}{'seed'} <=> $entry_info{$b}{"seed"}} 
								@due_neg;

						} else { 

							@due_neg = 
								sort {$entry_info{$b}{'seed'} <=> $entry_info{$a}{"seed"}} 
								@due_neg;
						}
					}

					foreach my $debate_me_maybe (@due_neg) { 

						next if $done{"maybe_".$debate_me_maybe};

						next unless $entry_info{$debate_me_maybe}{"need_seed"}{$entry_info{$aff}{'seed'} };
						next unless $entry_info{$aff}{"need_seed"}{ $entry_info{$debate_me_maybe}{"seed"} } ;

						next if $entry_info{$aff}{"school"} 
							== $entry_info{$debate_me_maybe}{"school"};

						if (
							$event_settings{"region_constrain"} 
							|| $event_settings{"region_avoid"}
						) { 
							next if $entry_info{$aff}{"region"} 
								&& $entry_info{$aff}{"region"} == $entry_info{$debate_me_maybe}{"region"};
						}

						# If we made it this far, WE NEED ONE ANOTHER.  IT IS DESTINY.

						$neg = $debate_me_maybe;
						$done{"maybe_".$debate_me_maybe}++;
						last if $neg;
					}

					# I found no opponent who is not a perfect fit.  So, I cope
					# as best I can.  Find someone whose need I fit while not
					# fitting mine, if such exists.	

					unless ($neg) { 

						foreach my $debate_me_maybe (@due_neg) { 

							next unless $entry_info{$neg}{"need_seed"}{$entry_info{$aff}{"seed"}};
							$neg = $debate_me_maybe;
							$done{"maybe_".$debate_me_maybe}++;
							last if $neg;
						}

					}

					# All right, try the inverse if that didn't work.
					unless ($neg) { 
						foreach my $debate_me_maybe (@due_neg) { 
							next unless $entry_info{$aff}{"need_seed"}{$entry_info{$neg}{"seed"}};
							$neg = $debate_me_maybe;
							$done{"maybe_".$debate_me_maybe}++;
							last if $neg;
						}
					}

					# If we're still doomed the next bit will just pick any old
					# neg.  If this is just because randomization doomed us, the
					# swapper later will help.

				} elsif ($event_settings{"seed_presets"} eq "balance") {

					my $current_diff = 0;
					my $current_clash = 8301239291;

					foreach my $maybe_neg (@due_neg) { 

						next if $done{$maybe_neg};

						my $clash = 0;

						$clash++ if $entry_info{$aff}{"school"} 
									== $entry_info{$maybe_neg}{"school"};

						$clash++ 
							if $entry_info{$aff}{"school"} 
								== $entry_info{$partner{$maybe_neg}}{"school"};

						$clash++ 
							if $entry_info{$maybe_neg}{"school"} 
								== $entry_info{$partner{$aff}}{"school"};

						if ($event_settings{"region_avoid"} 
							|| $event_settings{"region_constrain"}
						) { 

							$clash++ 
								if $entry_info{$aff}{"region"} 
									== $entry_info{$maybe_neg}{"region"};

							$clash++ 
								if $entry_info{$aff}{"region"} 
									== $entry_info{$partner{$maybe_neg}}{"region"};

							$clash++ 
								if $entry_info{$maybe_neg}{"region"} 
									== $entry_info{$partner{$aff}}{"region"};
						}

						my $diff; 

						if ($entry_info{$aff}{"need_position"}) { 

							$diff = 
								abs( $entry_info{$aff}{"need_position"} 
									- $entry_info{$maybe_neg}{"seed"});

							$diff += 
								abs(  $entry_info{$maybe_neg}{"need_position"} 
									- $entry_info{$aff}{"seed"});
						}


						if ($clash < $current_clash) { 
							$neg = $maybe_neg;
							$current_clash = $clash;
							$current_diff = $diff;
						} elsif (
							($clash == $current_clash) 
							&& ($diff < $current_diff)
						) {
							$neg = $maybe_neg;
							$current_diff = $diff;
						}


						last if $neg && $clash == 0 and $diff == 0;

					}

				}

				unless ($neg) { 
					foreach my $test_neg (@due_neg) { 
						$neg = $test_neg unless $done{$test_neg};
						last if $neg;
					}
				}

				$done{$neg}++;
				$negs++;

				push @{$panels{$counter}}, $aff;
				push @{$panels{$counter}}, $neg;

				increase_school_hit(\%entry_info, \@{$panels{$counter}}, "initial");
						
				if ($event_settings{"region_constrain"}) { 
					increase_region_hit(\%entry_info, \@{$panels{$counter}}, "initial");
				}

				push @panel_keys, $counter++;

				if ($partner{$aff} 
					&& $partner{$neg} 
					&! $done{$partner{$aff}} 
					&! $done{$partner{$neg}}
				) { 

					if ($is_due_aff{$partner{$aff}} 
						&& $is_due_neg{$partner{$neg}}
					) { 
					
						if ($entry_info{$partner{$aff}}{"school"} 
							!= $entry_info{$partner{$neg}}{"school"} 
						) { 

							if (
								(not defined $event_settings{"region_constrain"})
								|| ( 
									$entry_info{$partner{$aff}}{"region"} 
									!= $entry_info{$partner{$neg}}{"region"}
								)
							) { 

								push @{$panels{$counter}}, $partner{$aff};
								push @{$panels{$counter}}, $partner{$neg};
			
								push @panel_keys, $counter++;
								increase_school_hit(\%entry_info, \@{$panels{$counter}}, "initial 2");
								if ($event_settings{"region_constrain"}) { 
									increase_region_hit(\%entry_info, \@{$panels{$counter}}, "initial 2");
								}

								$done{$partner{$aff}}++;
								$done{$partner{$neg}}++;
								$negs++;

							}
						}
					}
				}
			}

			foreach my $pkey (@panel_keys) { 

				my ($aff, $neg) = @{$panels{$pkey}};

				my $aff_school = $entry_info{$aff}{"school"};
				my $neg_school = $entry_info{$neg}{"school"};
			}

			my $no_improvement = 1;

			foreach my $counter (1 .. 5) {

				next if $no_improvement == 0;

				$no_improvement = 0;

				foreach my $panel_key (shuffle @panel_keys) {

					my ($aff1, $neg1) = @{$panels{$panel_key}};

					my $current_diff;
					my $swap_key;
					my $swap_cross;

					my $baseline_panel1_score = score_preset(
						\@{$panels{$panel_key}},
						\%entry_info,
						1,
						\%event_settings
					);

					next if $baseline_panel1_score < 1;

					OTHERPANEL:
					foreach my $other_key (@panel_keys) {
					
						next if $other_key == $panel_key;

						my @panel2 = @{$panels{$other_key}};
						my $baseline_panel2_score = score_preset(
							\@panel2,
							\%entry_info,
							"", 
							\%event_settings
						);

						my $aff2 = shift @panel2;
						my $neg2 = shift @panel2;

						if (
							$event_settings{"seed_presets"} eq "protect" 
							|| $event_settings{"seed_presets"} eq "inverse"
						) { 

							if (
									($entry_info{$aff1}{'seed'} != $entry_info{$aff2}{'seed'}) 
								|| 	($entry_info{$neg1}{'seed'} != $entry_info{$neg2}{'seed'})
							) { 

								#Cannot swap due to seeding conflicts
								@panel2 = ($aff2, $neg2);
								next OTHERPANEL;
							}
						}

						my @new_1 = ($aff1, $neg2);
						my @new_2 = ($aff2, $neg1);

						my $swap_panel1_score = score_preset(
							\@new_1,
							\%entry_info,
							"",
							\%event_settings
						);

						my $swap_panel2_score = score_preset(
							\@new_2,
							\%entry_info,
							"",
							\%event_settings
						); 

						my $new_score = $swap_panel1_score + $swap_panel2_score;
						my $baseline = $baseline_panel1_score + $baseline_panel2_score;

						my $diff = $baseline - $new_score;

						if ( $diff >= 0 && $diff >= $current_diff) {
							$current_diff = $diff;
							$swap_key = $other_key;
							undef $swap_cross;
							last OTHERPANEL if $new_score == 0;
						}

						# Attempt various cross side swaps if that makes things
						# better and they're not side constrained.

						unless ($due{$aff1} == 1 || $due{$neg2} == 2)  { 

							my @new_1 = ($neg2, $neg1);
							my @new_2 = ($aff2, $aff1);

							my $dont;

							if ($event_settings{"seed_presets"} eq "protect") { 
								if ($entry_info{$neg2}{'seed'} != $entry_info{$aff1}{'seed'}) { 
									#Cannot swap due to seeding conflicts
									@panel2 = ($aff2, $neg2);
									$dont++;
								}
							}

							unless ($dont) { 

								my $swap_panel1_score = score_preset(
									\@new_1,
									\%entry_info,
									"",
									\%event_settings
								);

								my $swap_panel2_score = score_preset(
									\@new_2,
									\%entry_info,
									"",
									\%event_settings
								); 

								my $new_score = $swap_panel1_score + $swap_panel2_score;
								my $baseline = $baseline_panel1_score + $baseline_panel2_score;
								my $diff = $baseline - $new_score;

								if ( $diff >= 0 && $diff >= $current_diff) {
									$current_diff = $diff;
									$swap_key = $other_key;
									$swap_cross = 1;
								}
							}

						}

						unless ($due{$aff2} == 1 || $due{$neg1} == 2)  { 

							my @new_1 = ($aff1, $aff2);
							my @new_2 = ($neg1, $neg2);

							my $dont;

							if ($event_settings{"seed_presets"} eq "protect") { 
								if ($entry_info{$neg1}{'seed'} != $entry_info{$aff2}{'seed'}) { 
									#Cannot swap due to seeding conflicts
									@panel2 = ($aff2, $neg2);
									$dont++;
								}
							}

							unless ($dont) { 

								my $swap_panel1_score = score_preset(
									\@new_1,
									\%entry_info,
									"",
									\%event_settings
								);

								my $swap_panel2_score = score_preset(
									\@new_2,
									\%entry_info,
									"",
									\%event_settings
								);

								my $new_score = $swap_panel1_score + $swap_panel2_score;
								my $baseline = $baseline_panel1_score + $baseline_panel2_score;
								my $diff = $baseline - $new_score;

								if ( $diff >= 0 && $diff >= $current_diff) {
									$current_diff = $diff;
									$swap_key = $other_key;
									$swap_cross = 2;
								}
							}
						}
					}

					if ($swap_key) { 

						my @new_1;
						my @new_2;

						my @swap_panel = @{$panels{$swap_key}};

						my ($aff2, $neg2) = @{$panels{$swap_key}};

						if ($swap_cross == 1) { 
							@new_1 = ($neg2, $neg1);
							@new_2 = ($aff2, $aff1);
						} elsif ($swap_cross == 2) { 
							@new_1 = ($aff1, $aff2);
							@new_2 = ($neg1, $neg2);
						} else { 
							@new_1 = ($aff1, $neg2);
							@new_2 = ($aff2, $neg1);
						}

						reduce_school_hit(\%entry_info, \@{$panels{$panel_key}});
						reduce_school_hit(\%entry_info, \@{$panels{$swap_key}});

						increase_school_hit(\%entry_info, \@new_1, "double swap");
						increase_school_hit(\%entry_info, \@new_2, "double swap");

						if ($event_settings{"region_constrain"}) { 
							reduce_region_hit(\%entry_info, \@{$panels{$panel_key}});
							reduce_region_hit(\%entry_info, \@{$panels{$swap_key}});

							increase_region_hit(\%entry_info, \@new_1, "double swap");
							increase_region_hit(\%entry_info, \@new_2, "double swap");
						}

						@{$panels{$panel_key}} = @new_1;
						@{$panels{$swap_key}} = @new_2;

						$no_improvement++;  # Fail

					}

				}

				foreach my $panel_key (shuffle @panel_keys) {

					#Try some triple swaps;
					my ($aff1, $neg1) = @{$panels{$panel_key}};

					my $current_diff;

					my $swap_key_1;
					my $swap_cross_1;

					my $swap_key_2;
					my $swap_cross_2;

					my $swap_key_3;
					my $swap_cross_3;

					my $baseline_panel1_score = score_preset(
						\@{$panels{$panel_key}},
						\%entry_info,
						"",
						\%event_settings
					);

					next if $baseline_panel1_score < 1;


					my $aff2;
					my $neg2;

					my $baseline_panel2_score;
					my $swapped_panel2_score;

					OTHERPANEL:
					foreach my $other_key (@panel_keys) {

						next if $other_key == $panel_key;

						my @panel2 = @{$panels{$other_key}};

						$baseline_panel2_score = score_preset(
							\@panel2,
							\%entry_info,
							"",
							\%event_settings
						);

						$aff2 = shift @panel2;
						$neg2 = shift @panel2;

						my @new2 = ($aff1, $neg2);

						$swapped_panel2_score = score_preset(
							\@new2,
							\%entry_info,
							"",
							\%event_settings
						);

						my $diff = $baseline_panel2_score - $swapped_panel2_score;

						if ($diff >= $current_diff) { 
							$swap_key_2 = $other_key;
							$current_diff = $diff;
						}
					}

					if ($swap_key_2) { 

						undef $current_diff;

						OTHERPANEL:
						foreach my $other_key (@panel_keys) {

							next if $other_key == $panel_key;
							next if $other_key == $swap_key_2;

							my @panel3 = @{$panels{$other_key}};

							my $baseline_panel3_score = score_preset(
								\@panel3,
								\%entry_info,
								"",
								\%event_settings
							);

							my $aff3 = shift @panel3;
							my $neg3 = shift @panel3;

							my @new3 = ($aff2, $neg3);

							my $swapped_panel3_score = score_preset(
								\@new3,
								\%entry_info,
								"",
								\%event_settings
							);

							my @new1 = ($aff3, $neg1);

							my $swapped_panel1_score = score_preset(
								\@new1,
								\%entry_info,
								"",
								\%event_settings
							);

							my $baseline = $baseline_panel1_score 
								+ $baseline_panel2_score 
								+ $baseline_panel3_score;

							my $swapped = $swapped_panel1_score 
								+ $swapped_panel2_score 
								+ $swapped_panel3_score;

							my $diff = $baseline - $swapped;

							if ($diff >= $current_diff) { 
								$swap_key_3 = $other_key;
								$current_diff = $diff;
							}
						}
					}

					if ($swap_key_2 && $swap_key_3) { 

						my ($aff2, $neg2) = @{$panels{$swap_key_2}};
						my ($aff3, $neg3) = @{$panels{$swap_key_3}};

						my @new_1 = ($aff3, $neg1);
						my @new_2 = ($aff1, $neg2);
						my @new_3 = ($aff2, $neg3);

						reduce_school_hit(\%entry_info, \@{$panels{$panel_key}});
						reduce_school_hit(\%entry_info, \@{$panels{$swap_key_2}});
						reduce_school_hit(\%entry_info, \@{$panels{$swap_key_3}});

						increase_school_hit(\%entry_info, \@new_1, "triple swap");
						increase_school_hit(\%entry_info, \@new_2, "triple swap");
						increase_school_hit(\%entry_info, \@new_3, "triple swap");
		
						if ($event_settings{"region_constrain"}) { 
							reduce_school_hit(\%entry_info, \@{$panels{$panel_key}});
							reduce_school_hit(\%entry_info, \@{$panels{$swap_key_2}});
							reduce_school_hit(\%entry_info, \@{$panels{$swap_key_3}});

							increase_school_hit(\%entry_info, \@new_1, "triple swap");
							increase_school_hit(\%entry_info, \@new_2, "triple swap");
							increase_school_hit(\%entry_info, \@new_3, "triple swap");
						}

						@{$panels{$panel_key}} = @new_1;
						@{$panels{$swap_key_2}} = @new_2;
						@{$panels{$swap_key_3}} = @new_3;

						$no_improvement++;  # Fail

					}

				}

			}

			my $new_score;

			foreach my $panel_key (shuffle @panel_keys) {

				my $score = score_preset(
					\@{$panels{$panel_key}},
					\%entry_info,
					"",
					\%event_settings
				);

				$panel_score{$panel_key} = $score;
				$new_score += $score;

			}

			if ($new_score < $best_score || not defined $best_score) { 
				%final_panels = %panels;
				$best_score = $new_score;
			}

		}

		my @byes;
		push @byes, $bye;

		write_round($round, \%final_panels, \%panel_score, \@byes);

	}

	sub write_round {

		my ($round, $final_panref, $scoreref, $byeref) = @_;

		my @byes = @{$byeref};

		#Out with the old.

		Tab::Score->set_sql( delete_round => "
			delete score from score, ballot, panel
			where panel.round = ?
			and panel.id = ballot.panel
			and ballot.id = score.ballot
		");

		Tab::Ballot->set_sql( delete_round => "
			delete ballot from ballot, panel
			where panel.round = ?
			and panel.id = ballot.panel
		");

		Tab::Panel->set_sql( delete_round => "
			delete from panel where round = ?
		");

		Tab::Score->sql_delete_round->execute($round->id);
		Tab::Ballot->sql_delete_round->execute($round->id);
		Tab::Panel->sql_delete_round->execute($round->id);

		my $letter = 1;
		$letter = "A" if $round->event->setting("panel_labels") eq "letters";

		my %used;

		my @keys = sort {$a <=> $b} keys %{$final_panref};

		foreach my $key (@keys) { 

			my $aff = shift @{${$final_panref}{$key}};
			my $neg = shift @{${$final_panref}{$key}};

			next if $used{$aff} && $used{$neg};

			next unless $aff || $neg;

			my $score = ${$scoreref}{$key} if $scoreref;
					
			my $panel = Tab::Panel->create({
				round  => $round->id,
				letter => $letter,
				flight => 1,
				score  => $score
			});

			if ($letter eq "Z") { 
				$letter = "AA";
			} elsif ($letter eq "AZ") { 
				$letter = "BA";
			} elsif ($letter eq "BZ") {
				$letter = "CA";
			} elsif ($letter eq "CZ") {
				$letter = "DA";
			} elsif ($letter eq "DZ") {
				$letter = "EA";
			} elsif ($letter eq "EZ") {
				$letter = "FA";
			} else { 
				$letter++;
			}

			my $aff_ballot = Tab::Ballot->create({
				panel => $panel->id,
				judge => 0,
				entry => $aff,
				side  => 1
			}) unless $used{$aff}++;

			my $neg_ballot = Tab::Ballot->create({
				panel => $panel->id,
				judge => 0,
				entry => $neg,
				side  => 2
			}) unless $used{$neg}++;

		}

		foreach my $bye (@byes) { 

			next unless $bye && $bye > 1;

			my $panel = Tab::Panel->create({
				round  => $round->id,
				letter => $letter++,
				bye    => 1,
				flight => 1
			});

			my $bye_ballot = Tab::Ballot->create({
				panel => $panel->id,
				judge => 0,
				entry => $bye,
				side  => 1,
				audit => 1
			});

		}

		my $now = DateTime->now;
		$round->created($now);
		$round->update;
	}

    sub score_preset {

        my ($panref, $entry_info, $baseline, $event_settings) = @_;

		return unless @{$panref};
		my $aff = shift @{$panref};

		return unless @{$panref};
		my $neg = shift @{$panref};

        my $score = 0;

		if (${$entry_info}{$neg}{"school"} == ${$entry_info}{$aff}{"school"} ||
			${$entry_info}{$neg}{"school"} == ${$entry_info}{$aff}{"hybrid"} ||
			${$entry_info}{$neg}{"hybrid"} == ${$entry_info}{$aff}{"school"}) { 
			# We are from the same school.  Highest penalty.
			$score += 10000;   
		}   

		# We have debated against each other previously
		$score += 1000 * ${$entry_info}{$aff}{"hits-".$neg};
		$score += 1000 * ${$entry_info}{$neg}{"hits-".$aff};

		# We have debated against each other on this side.
		$score += 1000 * ${$entry_info}{$aff}{"oppside-".$neg."-1"};

		if ($event_settings->{"region_avoid"}) { 
			if (${$entry_info}{$neg}{"region"}) { 
				
				# If are from the same region.  Moderate penalty to avoid.
				if (${$entry_info}{$neg}{"region"} == ${$entry_info}{$aff}{"region"}) { 
					$score += 50;
				}

				$score += ${$entry_info}{$aff}{"region_hit-".${$entry_info}{$neg}{"region"}} * 2;
				$score += ${$entry_info}{$neg}{"region_hit-".${$entry_info}{$aff}{"region"}} * 2;

			}
		}

		if ($event_settings->{"region_constrain"}) { 

			# If we are from the same region, treat penalty the same as schools

			if (${$entry_info}{$neg}{"region"} == ${$entry_info}{$aff}{"region"}) { 
				$score += 10000;
			}

			$score += ${$entry_info}{$aff}{"region_hit-".${$entry_info}{$neg}{"region"}} * 5;
			$score += ${$entry_info}{$neg}{"region_hit-".${$entry_info}{$aff}{"region"}} * 5;

		}

		if ($event_settings->{"seed_presets"} eq "all") { 
			$score += 10 unless ${$entry_info}{"need_seed"}{$aff}{${$entry_info}{$neg}{"seed"}};
			$score += 10 unless ${$entry_info}{"need_seed"}{$neg}{${$entry_info}{$aff}{"seed"}};
		}

		if ($event_settings->{"seed_presets"} eq "inverse") { 

			if ($baseline) { 

				my $aff_seed = ${$entry_info}{$aff}{"seed"};
				my $neg_seed = ${$entry_info}{$neg}{"seed"};

				my $aff_code = ${$entry_info}{$aff}{"code"};
				my $neg_code = ${$entry_info}{$neg}{"code"};

				my $neg_need = ${$entry_info}{$neg}{"needs_print"};
				my $aff_need = ${$entry_info}{$aff}{"needs_print"};

				my $neg_score = ${$entry_info}{$neg}{"need_seed"}{$aff_seed};
				my $aff_score = ${$entry_info}{$aff}{"need_seed"}{$neg_seed};

			}

			my $aff_seed = ${$entry_info}{$aff}{"seed"};
			my $neg_seed = ${$entry_info}{$neg}{"seed"};

			my $aff_need = ${$entry_info}{$aff}{"need_seed"}{$neg_seed};
			my $neg_need = ${$entry_info}{$neg}{"need_seed"}{$aff_seed};

			$score += 100 unless ($aff_need);
			$score += 100 unless ($neg_need);
		}

		if ($event_settings->{"seed_presets"} eq "balance") { 

			my $aff_diff = abs(${$entry_info}{$aff}{"need_position"} - ${$entry_info}{$neg}{"seed"});
			my $neg_diff = abs(${$entry_info}{$neg}{"need_position"} - ${$entry_info}{$aff}{"seed"});

			$score += 10 * $aff_diff 
				if ${$entry_info}{$aff}{"need_position"};

			$score += 10 * $neg_diff 
				if ${$entry_info}{$neg}{"need_position"};
		}

		# We have debated against someone else from that same school.  Lowest
		# penalty.

		$score += ${$entry_info}{$aff}{"school_hit-".${$entry_info}{$neg}{"school"}} * 10;
		$score += ${$entry_info}{$neg}{"school_hit-".${$entry_info}{$aff}{"school"}} * 10;

		my $aff_school = ${$entry_info}{$aff}{"school"};
		my $neg_school = ${$entry_info}{$neg}{"school"};

		$score += (${$entry_info}{"school_hit"}{$aff_school}{$neg_school} - 2 ) * 2;  
		$score += (${$entry_info}{"school_hit"}{$neg_school}{$aff_school} - 2 ) * 2;

		$score += ${$entry_info}{$neg}{"region_hit-".${$entry_info}{$aff}{"region"}};

		@{$panref} = ($aff, $neg);

        return $score;

    }

	sub reduce_school_hit {

        my ($entry_info, $panref) = @_;

		my ($aff, $neg) = @{$panref} if $panref && @{$panref};

		return unless $aff && $neg;

		my $aff_school = ${$entry_info}{$aff}{"school"};
		my $neg_school = ${$entry_info}{$neg}{"school"};

		return if $aff_school == $neg_school;

		unless ($aff_school == $neg_school) { 
			${$entry_info}{"school_hit"}{$aff_school}{$neg_school}--;
			${$entry_info}{"school_hit"}{$neg_school}{$aff_school}--;
		}

		return;
	}

	sub increase_school_hit {

        my ($entry_info, $panref, $reason) = @_;

		my ($aff, $neg) = @{$panref} if $panref && @{$panref};

		return unless $aff && $neg;

		my $aff_school = ${$entry_info}{$aff}{"school"};
		my $neg_school = ${$entry_info}{$neg}{"school"};

		return if $aff_school == $neg_school;

		unless ($aff_school == $neg_school) { 			
			${$entry_info}{"school_hit"}{$aff_school}{$neg_school}++;
			${$entry_info}{"school_hit"}{$neg_school}{$aff_school}++;
		}

		return;
	}

	sub reduce_region_hit {

        my ($entry_info, $panref) = @_;

		my ($aff, $neg) = @{$panref} if $panref && @{$panref};

		return unless $aff && $neg;

		my $aff_region = ${$entry_info}{$aff}{"region"};
		my $neg_region = ${$entry_info}{$neg}{"region"};

		return if $aff_region == $neg_region;

		unless ($aff_region == $neg_region) { 
			${$entry_info}{"region_hit"}{$aff_region}{$neg_region}--;
			${$entry_info}{"region_hit"}{$neg_region}{$aff_region}--;
		}

		return;
	}

	sub increase_region_hit {

        my ($entry_info, $panref, $reason) = @_;

		my ($aff, $neg) = @{$panref} if $panref && @{$panref};

		return unless $aff && $neg;

		my $aff_region = ${$entry_info}{$aff}{"region"};
		my $neg_region = ${$entry_info}{$neg}{"region"};

		return if $aff_region == $neg_region;

		unless ($aff_region == $neg_region) { 			
			${$entry_info}{"region_hit"}{$aff_region}{$neg_region}++;
			${$entry_info}{"region_hit"}{$neg_region}{$aff_region}++;
		}

		return;
	}

</%perl>
