<%args>
	$round    => undef
	$round_id => undef
</%args>
<%perl>

	use POSIX;
	use List::Util 'shuffle';

	my $dbh = Tab::DBI->db_Main();
	my $now = DateTime->now();

	$round = Tab::Round->retrieve($round_id) unless $round > 0;
	my $event = $round->event;
	my %ess = $event->all_settings;
	my $event_settings = \%ess;

	#Ugly hack in the waning days of perl!
	$event_settings->{dbh} = $dbh;
	$event_settings->{now} = $now;

	my $tourn = $event->tourn;

	if ($tourn->setting("ncfl")) {
		$event_settings->{"region_constrain"}++;
		$event_settings->{"region_avoid"}++;
	}

	$event_settings->{"nsda_district"} = $tourn->setting("nsda_district");

	if (
		$event_settings->{"nsda_district"}
		&& (not defined $event_settings->{"round_robin"})
		&& $round->name > 2
	) {
		$round->type("highlow");
		$round->update();
		my $err = "You may only preset rounds 1 and 2 at Districts when not running a round robin. ";
		$err .= "Round ".$round->name." has been changed to a powermatched round.  Please go now pair it again.";
		$m->redirect("/panel/schemat/show.mhtml?round=".$round->id."&err=$err");
	}

	Tab::Round->set_sql(reset_prelim => '
		update round set type="prelim"
		where type="preset"
		and event = ?');

	Tab::Round->sql_reset_prelim->execute($event->id);

	my $round_limit = 'and round.type = "prelim" and round.name != '.$round->name;

	my $sidelock_against = $round->setting("sidelock_against");
	my $no_side_constraints++ if $event_settings->{"no_side_constraints"};

	$no_side_constraints++ if $sidelock_against eq "NONE";
	$no_side_constraints++ if $sidelock_against eq "RANDOM";

	my $entry_sth = $dbh->prepare('
		select distinct entry.id,
			school.region, school.id,
			area.value area,
			entry.code,
			pairing_school.value
		from (entry, school)

		left join school_setting pairing_school
			on pairing_school.school = school.id
			and pairing_school.tag = "pairing_school"

		left join chapter on school.chapter = chapter.id

		left join region_setting area
			on area.region = school.region
			and area.tag = "area"

		where entry.event = ?
			and entry.school = school.id
			and entry.active = 1
	');

	my @entries;

	my %entry_info;
	my %school_info;
	my %seed_count;

	$entry_sth->execute($event->id);

	while (
		my ($entry_id, $region, $school, $area, $code, $pair_school)
		= $entry_sth->fetchrow_array()
	) {

		next unless $entry_id;
		push @entries, $entry_id;

		$entry_info{$entry_id}{"code"} = $code;

		if ($region) {

			if ($event_settings->{'diocese_regions'}) {
				$entry_info{$entry_id}{"region"} = $event_settings->{"diocese_regions"}{$region};
			} elsif ($area) {
				$entry_info{$entry_id}{"area"} = $area;
			} else {
				$entry_info{$entry_id}{"region"} = $region;
			}
		}

		if ($event_settings->{region_constrain}) {
			$entry_info{$entry_id}{"school"} = $region;
			$school_info{"size"}{$region}++;

		} else {

			$entry_info{$entry_id}{"school"} = $pair_school || $school;

			if ($pair_school) {
				$school_info{"size"}{$pair_school}++;
			} else {
				$school_info{"size"}{$school}++;
			}
		}
	}

	my @byes;

	if ($event_settings->{"autobye_nojudge"}) {

		my $bye_sth = $dbh->prepare('
			select entry.id, round.id
				from entry, round, panel, ballot
			where entry.id = ballot.entry
				and ballot.panel = panel.id
				and panel.round = round.id
				and (ballot.bye = 1 or panel.bye = 1)
				and entry.event = ?
		');

		$bye_sth->execute($event->id);

		while (
			my (
				$entry_id, $round_id
			) = $bye_sth->fetchrow_array()
		) {
			$entry_info{$entry_id}{"bye_count"}++;
		}

		my $available_judges = $m->comp("/funclib/round_available_judges.mas", round => $round, );

		my $num_flights = $round->flighted;
		$num_flights = 1 unless $num_flights;

		my $num_judges = $round->setting('num_judges');
		$num_judges = 1 unless $num_judges;

		$available_judges = $available_judges * $num_flights;
		my $num_debates = POSIX::floor( (scalar @entries) / (2 * $num_judges));

		# Sort entries so those with fewer byes go to the front
		@entries = shuffle @entries;

		@entries = sort {
			$entry_info{$a}{"bye_count"} <=> $entry_info{$b}{"bye_count"}
		} @entries;

		while ($num_debates > $available_judges) {
			my $excluded = shift @entries;
			push @byes, $excluded;
			$num_debates = POSIX::floor( (scalar @entries) / 2);
		}
	}

	my $setting_sth = $dbh->prepare("
		select entry.id,
			pod.value pod,
			pairing_seed.value seed,
			online_hybrid.value online
		from entry

			left join entry_setting pod
			on pod.entry = entry.id
			and pod.tag = 'pod'

			left join entry_setting pairing_seed
			on pairing_seed.entry = entry.id
			and pairing_seed.tag = 'pairing_seed'

			left join entry_setting online_hybrid
			on online_hybrid.entry = entry.id
			and online_hybrid.tag = 'online_hybrid'

		where entry.event = ?
	");

	$setting_sth->execute($event->id);

	my %settings = eval {
		return map {$_->{id} => $_} @{$setting_sth->fetchall_hash};
	};

	$setting_sth->finish();

	foreach my $id (keys %settings) {
		$entry_info{$id}{"seed"}   = $settings{$id}{"seed"};
		$entry_info{$id}{"pod"}    = $settings{$id}{"pod"};

		unless ($event_settings->{"nsda_district"}) {
			if ($event_settings->{"online_hybrid"}) {
				$entry_info{$id}{"online"} = $settings{$id}{"online"};
			}
		}
	}

	my @seeds;
	my $max_seed;
	my @pods;

	foreach my $entry (@entries) {

		$entry_info{$entry}{'seed'} = $entry_info{$entry}{'seed'} || 0;
		$seed_count{$entry_info{$entry}{"seed"}}++;

		if ($entry_info{$entry}{'seed'} > $max_seed) {
			$max_seed = $entry_info{$entry}{'seed'};
		}

		push @seeds, $entry_info{$entry}{'seed'};
		push @pods, $entry_info{$entry}{"pod"};
	}

    my $school_debates_self++
		if $event_settings->{"school_debates_self"};

    my $hybrids_can_hit++
		if $event_settings->{"hybrids_can_hit"};

    unless ($school_debates_self || $hybrids_can_hit) {

        #pull hybrid school conflicts
        my @strikes = Tab::Strike->search(
			tourn => $tourn,
			type  => 'hybrid'
		);

        foreach my $strike (@strikes) {
			$entry_info{$strike->entry->id}{"hybrid"} = $strike->school->id;
        }
    }

	my %seen = ();
	@pods = grep { ! $seen{$_} ++ } @pods;

	my $ballot_sth = $dbh->prepare('
		select distinct
			entry.id, entry.code, entry.school, entry_school.region,
			opponent.id, opp_school.id, opp_school.region,
			ballot.side

		from (entry, entry as opponent,
			ballot, panel, round,
			ballot as opp_ballot, school as opp_school)

		left join chapter on opp_school.chapter = chapter.id
			left join school entry_school on entry_school.id = entry.school

		where entry.event = ?
			and entry.id = ballot.entry
			and ballot.panel = panel.id
			and panel.round = round.id
			'.$round_limit.'
			and round.id != ?
			and opp_ballot.panel = ballot.panel
			and opp_ballot.entry = opponent.id
			and opponent.school = opp_school.id
			and opponent.id != entry.id
			and panel.bye != 1
			and ballot.bye != 1
	');

	$ballot_sth->execute($event->id, $round->id);

	my %dio_region = $event_settings->{"diocese_regions"};
	my $dio_regions = $event_settings->{"conflict_dioregion_judges"};

	while(
		my (
			$entry_id, $entry_code, $entry_school, $entry_region,
			$opp_id, $opp_school, $opp_region, $side
		) = $ballot_sth->fetchrow_array()
	) {

		$entry_info{$entry_id}{"hits-".$opp_id}++;

		unless ($no_side_constraints) {
			$entry_info{$entry_id}{"oppside-".$opp_id."-".$side}++;
		}

		#Translate the school to do the diocese and the dioregion to the region

		if ($event_settings->{'diocese_regions'}) {
			$entry_region = $dio_region{$entry_region};
			$opp_region   = $dio_region{$opp_region};
		}

		if ($event_settings->{region_constrain}) {
			$entry_school = $entry_region;
			$opp_school = $opp_region;
		} else {
			$entry_info{$entry_id}{"region_hit"}{$opp_region}++;
		}

		$entry_info{$entry_id}{"school_hit"}{$opp_school}++;
		$entry_info{"school_hit"}{$entry_school}{$opp_school}++;

		if ($opp_region) {
			$entry_info{"region_hit"}{$entry_region}{$opp_region}++;
		}

		if ($dio_regions) {
			$entry_info{$entry_id}{"dioregion_hit"}{$dio_region{$opp_region}}++;
		}

		push @{$entry_info{$entry_id}{"opponents"}}, $opp_id;
	}

	my $seed_byes_as;
	my $round_side;
	my $round_care;

	unless ($no_side_constraints) {

		if ($sidelock_against) {

			$round_side = " and round.id = ".$sidelock_against;
			$round_care = $sidelock_against;

		} elsif ($round->name % 2 ) {

			# Odd presets mean I care about the next prelim round in case we're
			# repaneling for seeding, if it exists

			Tab::Round->set_sql(next_even => "
				select round.*
					from round
				where round.event = ?
					and round.name > ?
					and round.type = 'prelim'
				order by round.name limit 1
			");

			$round_care = Tab::Round->search_next_even($event->id, $round->name)->first;

		} else {

			# Even presets sidelock against the last round

			Tab::Round->set_sql(next_even => "
				select round.*
					from round
				where round.event = ?
					and round.name < ?
					and round.type = 'prelim'
				order by round.name DESC limit 1
			");

			$round_care = Tab::Round->search_next_even($event->id, $round->name)->first;
		}
	}

	# Still need to do this to assure the same team/school doesn't get a bye
	# 2x even if it's not sidelocked.

	my $sides_sth = $dbh->prepare('
		select distinct ballot.entry, ballot.side, ballot.bye, panel.bye, round.id
			from ballot, panel, entry, round
		where ballot.entry = entry.id
			and round.id != ?
			and entry.event = ?
			and ballot.panel = panel.id
			and panel.round = round.id
		'.$round_side.'
	');

	$sides_sth->execute($round->id, $event->id);

	while (
		my ($entry_id, $side, $bye, $panel_bye, $round)
		= $sides_sth->fetchrow_array()
	) {

		$entry_info{$entry_id}{"byes"}++ if $bye || $panel_bye;

		$school_info{$entry_info{$entry_id}{"school"}}{"byes"}++ if $bye || $panel_bye;

		next if $no_side_constraints;
		next if $bye || $panel_bye;
		next if $round != $round_care;

		$entry_info{$entry_id}{"affs"}++ if $side == 1;
		$entry_info{$entry_id}{"negs"}++ if $side == 2;
	}

	#uniq
	my %s_seen = ();
	@seeds = grep { ! $s_seen{$_} ++ } @seeds;

	my %e_seen = ();
	@entries = grep { ! $e_seen{$_} ++ } @entries;

	my $best_score;
	my $bye;

	if ($event_settings->{"round_robin"}) {

		my @rounds = $event->rounds( type => "prelim");

		if ($event_settings->{"nsda_district"}) {
			my $protocol = Tab::Protocol->search(tourn => $tourn->id, name => "Round Robin")->first;
			if ($protocol) {
				foreach my $round (@rounds) {
					$round->protocol($protocol);
					$round->update();
				}
			}
		}

		@entries = shuffle(@entries);

		# In a round robin, seeds are pods
		my $num_pods = scalar @pods;
		next unless $num_pods;

		my $pod_size = ceil(scalar @entries / $num_pods);

		$pod_size++ if $pod_size % 2;
		my $num_rounds = $pod_size -1;

		unless ($num_rounds == scalar @rounds) {

			my $err = "You do not have the correct number of preset rounds for ";
			$err .= scalar @entries." debaters for $num_pods pods.  Please make ";
			$err .= "sure you have $num_rounds presets";

			if ($ARGS{"autoqueue"}) {
				return;
			} else {
				$m->redirect("/setup/schedule/event.mhtml?event_id=".$event->id."&err=$err");
			}
		}

		my %panel_entries = ();
		my %round_panels = ();
		my %panel_pod = ();
		my $tick;

		foreach my $pod (@pods) {

			my @pod;
			my %pod_panels = ();

			foreach my $entry (@entries) {
				push @pod, $entry if $entry_info{$entry}{"pod"} == $pod;
			}

			# Make sure it's an even number.  Fill blanks with byes
			my $bye_present;

			if ( (scalar @pod) % 2 ) {
				push @pod, "BYE";
				$bye_present++;
			}

			foreach my $round (@rounds) {

				foreach ( 1 .. (scalar @pod) / 2 ) {
					$tick++;
					push @{$pod_panels{$round->id}}, $tick;
					$panel_pod{$tick} = $pod;
				}

				# Remove the second entry and push them to the end.  The RR
				# pairing algorithm is that you keep the first slot stationary
				# and rotate everyone else around them to get a full pairing.

				my $second = splice(@pod, 1, 1);
				push @pod, $second;

				my @copy = @pod;

				my $counter = $round->name - 1;

				foreach my $panel (@{$pod_panels{$round->id}}) {

					next unless $panel_pod{$panel} == $pod;

					if ($counter++ % 3) {
						$panel_entries{$panel}{"aff"} = shift @copy;
						$panel_entries{$panel}{"neg"} = pop @copy;
					} else {
						$panel_entries{$panel}{"aff"} = pop @copy;
						$panel_entries{$panel}{"neg"} = shift @copy;
					}
				}
			}

			foreach my $round (@rounds) {
				foreach my $panel (@{$pod_panels{$round->id}}) {
					next if $panel_entries{$panel}{"neg"} eq "BYE";
					next if $panel_entries{$panel}{"aff"} eq "BYE";
				}
			}

			my $lowest;
			my $highest;

			my $num_debates = scalar @rounds;
			$num_debates -= $bye_present;

			if ( $num_debates % 2 ) {
				$highest = ceil($num_debates / 2);
				$lowest = floor($num_debates / 2);
			} else {
				$highest = $num_debates / 2;
				$lowest = $num_debates / 2;
			}

			my $not_ok = 1;

			# There is surely an algorithm that would do this properly but I'm
			# not going to waste any more time finding it.  So brute force the
			# mess 50 times and call it a day.

			my %side_counter;
			my %aff_count;
			my %neg_count;

			foreach my $round (@rounds) {

				PANEL:
				foreach my $panel (@{$pod_panels{$round->id}}) {

					my $aff = $panel_entries{$panel}{"aff"};
					my $neg = $panel_entries{$panel}{"neg"};

					next if $aff eq "BYE" || $neg eq "BYE"; # not a round, doesn't count

					if (
						($aff_count{$aff} < $neg_count{$aff})
						|| ($neg_count{$neg} < $aff_count{$neg})
					) {
						$aff_count{$aff}++;
						$neg_count{$neg}++;
						next PANEL;
					}

					if (
						($aff_count{$aff} == $neg_count{$aff})
						&& ($neg_count{$neg} == $aff_count{$neg})
					) {

						# Flip a coin so the random trials are actually not
						# always seeded the same way.

						if (rand(100) % 2) {
							$aff_count{$aff}++;
							$neg_count{$neg}++;
							next PANEL;
						}
					}

					$panel_entries{$panel}{"aff"} = $neg;
					$panel_entries{$panel}{"neg"} = $aff;

					$neg_count{$aff}++;
					$aff_count{$neg}++;

				}
			}

			foreach (1 .. 128) {

				# in theory I could make this a while loop but since I'm not 100%
				# it will always work this is better than infinite looping

				next unless $not_ok;
				undef $not_ok;

				my %in_a_row;

				foreach my $round (sort {$a->name <=> $b->name} @rounds) {

					PANEL:
					foreach my $panel (@{$pod_panels{$round->id}}) {

						my $aff = $panel_entries{$panel}{"aff"};
						my $neg = $panel_entries{$panel}{"neg"};

						next if $aff eq "BYE" || $neg eq "BYE"; # not a round, doesn't count

						$in_a_row{$aff}{"aff"}++;
						$in_a_row{$neg}{"neg"}++;

						undef $in_a_row{$aff}{"neg"};
						undef $in_a_row{$neg}{"aff"};

						next if $in_a_row{$aff}{"aff"} < 3 && $in_a_row{$neg}{"neg"} < 3;

						$panel_entries{$panel}{"aff"} = $neg;
						$panel_entries{$panel}{"neg"} = $aff;

						$aff_count{$aff}--;
						$neg_count{$neg}--;

						$neg_count{$aff}++;
						$aff_count{$neg}++;

					}

				}

				foreach my $round (shuffle @rounds) {

					PANEL:
					foreach my $panel (@{$pod_panels{$round->id}}) {

						my $aff = $panel_entries{$panel}{"aff"};
						my $neg = $panel_entries{$panel}{"neg"};

						next if $aff eq "BYE" || $neg eq "BYE"; # not a round, doesn't count

						unless ($in_a_row{$aff}{"aff"} > 2 || $in_a_row{$neg}{"neg"} > 2) {
							next PANEL if $aff_count{$aff} < $neg_count{$aff};
							next PANEL if $neg_count{$neg} < $aff_count{$neg};
							next PANEL if $aff_count{$aff} == $neg_count{$aff};
							next PANEL if $neg_count{$neg} == $aff_count{$neg};
						}

						$panel_entries{$panel}{"aff"} = $neg;
						$panel_entries{$panel}{"neg"} = $aff;

						$aff_count{$aff}--;
						$neg_count{$neg}--;

						$neg_count{$aff}++;
						$aff_count{$neg}++;

					}
				}

				foreach my $entry (@pod) {
					next if $entry eq "BYE";
					if ($aff_count{$entry} < $lowest || $aff_count{$entry} > $highest) {
						$not_ok++;
					}
				}

				foreach my $round (sort {$a->name <=> $b->name} @rounds) {

					PANEL:
					foreach my $panel (@{$pod_panels{$round->id}}) {

						my $aff = $panel_entries{$panel}{"aff"};
						my $neg = $panel_entries{$panel}{"neg"};

						next if $aff eq "BYE" || $neg eq "BYE"; # not a round, doesn't count

						$in_a_row{$aff}{"aff"}++;
						$in_a_row{$neg}{"neg"}++;

						undef $in_a_row{$aff}{"neg"};
						undef $in_a_row{$neg}{"aff"};

						$not_ok++ if $in_a_row{$aff}{"aff"} > 2;
						$not_ok++ if $in_a_row{$neg}{"neg"} > 2;
					}
				}
			}

			foreach my $round (@rounds) {
				foreach my $panel (@{$pod_panels{$round->id}}) {
					push @{$round_panels{$round->id}}, $panel;
				}
			}

		}

		foreach my $round (@rounds) {

			my %final_panels = ();
			undef @byes;

			foreach my $panel (@{$round_panels{$round->id}}) {

				push @byes, $panel_entries{$panel}{"aff"}
					if $panel_entries{$panel}{"neg"} eq "BYE";

				push @byes, $panel_entries{$panel}{"neg"}
					if $panel_entries{$panel}{"aff"} eq "BYE";

			}

			foreach my $panel (@{$round_panels{$round->id}}) {
				next if $panel_entries{$panel}{"aff"} eq "BYE";
				next if $panel_entries{$panel}{"neg"} eq "BYE";
				push @{$final_panels{$panel}}, $panel_entries{$panel}{"aff"};
				push @{$final_panels{$panel}}, $panel_entries{$panel}{"neg"};
			}

			write_round($round, \%final_panels, \@byes, $event_settings, \%entry_info);

		}

	} else {

		my %final_panels = ();
		my %score_cache = ();

		PASS:
		foreach my $pass (1 .. 6) {

			my %panels;

			@entries = shuffle(@entries);

			@entries = sort {
				$school_info{"size"}{$entry_info{$b}{"school"}} <=> $school_info{"size"}{$entry_info{$a}{"school"}}
				|| $entry_info{$b}{"school"} <=> $entry_info{$a}{"school"}
			} @entries;

			my %bye_seed;
			my $seed_aim;

			if ($event_settings->{"seed_presets"} eq "balance") {

				@entries = sort { $entry_info{$a}{'seed'} <=> $entry_info{$b}{'seed'} } @entries;
				my $position = 1;

				foreach my $entry (@entries) {
					$entry_info{$entry}{'seed'} = $position++;
				}

				my %opp_position;
				my $opps_taken;

				foreach my $entry (@entries) {
					foreach my $opp (@{$entry_info{$entry}{"opponents"}}) {
						$opp_position{$entry} += $entry_info{$opp}{'seed'};
						$opps_taken++;
					}

					if ($entry_info{$entry}{"byes"}) {
						$opp_position{$entry} += scalar @entries;
					}
				}

				if ($opps_taken) {

					$position = 1;
					@entries = sort { $opp_position{$b} <=> $opp_position{$a} } @entries;

					foreach my $entry (@entries) {
						$entry_info{$entry}{"need_position"} = $position++;
					}
				}

			} elsif ($event_settings->{"seed_presets"} eq "all") {

				foreach my $entry (@entries) {

					SEED:
					foreach my $seed (@seeds) {

						foreach my $opp (@{$entry_info{$entry}{"opponents"}}) {
							if ($seed eq $entry_info{$opp}{'seed'}) {
								next SEED;
							}
						}

						$entry_info{$entry}{"need_seed"}{$seed}++;

						unless ($entry_info{$entry}{"needs_print"} eq " ".$seed) {
							$entry_info{$entry}{"needs_print"} .= " ".$seed;
						}
					}
				}

				my $top_count;

				foreach my $seed (@seeds) {
					$top_count = $seed_count{$seed} if $seed_count{$seed} > $top_count;
				}

				foreach my $seed (@seeds) {
					$bye_seed{$seed}++ if $seed_count{$seed} == $top_count;
				}

				$seed_byes_as = scalar @entries + 1;

			} elsif ($event_settings->{"seed_presets"} eq "inverse") {

				my $got_bye;
				$seed_byes_as = 4;

				foreach my $entry (@entries) {

					my @seeds = (2,3) if (
						$entry_info{$entry}{'seed'} == 1
						|| $entry_info{$entry}{'seed'} == 4
					);

					@seeds = (1,4) if (
						$entry_info{$entry}{'seed'} == 2
						|| $entry_info{$entry}{'seed'} == 3
					);

					SEED:
					foreach my $seed (@seeds) {

						next SEED if ($entry_info{$entry}{"byes"} > 0) && ($seed == 4);

						foreach my $opp (@{$entry_info{$entry}{"opponents"}}) {
							next SEED if $seed eq $entry_info{$opp}{'seed'};
						}

						$entry_info{$entry}{"need_seed"}{$seed}++;
						$entry_info{$entry}{"needs_print"} .= " ".$seed;
					}
				}
			}

			@entries = shuffle @entries;

			my @due_aff;
			my @due_neg;
			my @due_whatever;

			my %due;

			my $flip = rand(100) % 2;
			undef $flip if @due_aff || @due_neg;

			my $whole = scalar(@entries);
			$whole++ if $whole % 2;

			my $quarter = ceil( $whole / 4);
			my $threequarter = floor( 3 * $whole/ 4);

			if ($event_settings->{"seed_presets"} eq "balance") {
				@entries = sort {
					$entry_info{$a}{"seed"} <=> $entry_info{$b}{"seed"}
				} @entries;
			}

			ENTRY:
			foreach my $entry (@entries) {

				next if $entry == $bye;

				if ($entry_info{$entry}{"negs"} > $entry_info{$entry}{"affs"}) {

					push @due_aff, $entry;
					$due{$entry} = 1;

				} elsif ($entry_info{$entry}{"negs"} < $entry_info{$entry}{"affs"}) {

					push @due_neg, $entry;
					$due{$entry} = 2;

				} elsif (
					$event_settings->{"seed_presets"} eq "inverse"
					&! $entry_info{$entry}{"byes"}
				) {

					if ($flip == 1) {

						push @due_neg, $entry
							if $entry_info{$entry}{'seed'} == 2
							|| $entry_info{$entry}{'seed'} == 3;

						push @due_aff, $entry
							if $entry_info{$entry}{'seed'} == 1
							|| $entry_info{$entry}{'seed'} == 4;

					} else {

						push @due_aff, $entry
							if $entry_info{$entry}{'seed'} == 2
							|| $entry_info{$entry}{'seed'} == 3;

						push @due_neg, $entry
							if $entry_info{$entry}{'seed'} == 1
							|| $entry_info{$entry}{'seed'} == 4;
					}

				} elsif (
					$event_settings->{"seed_presets"} eq "balance"
					&! $entry_info{$entry}{"byes"}
				) {

					if (
						$entry_info{$entry}{'seed'} < $quarter
						|| $entry_info{$entry}{'seed'} > $threequarter
					) {
						if ($flip == 1) {
							push @due_neg, $entry;
						} else {
							push @due_aff, $entry;
						}

					} else {
						if ($flip == 1) {
							push @due_aff, $entry;
						} else {
							push @due_neg, $entry;
						}
					}
				} else {
					push @due_whatever, $entry;
					$due{$entry} = 0;
				}
			}

			my %used;

			if ((scalar @entries) % 2) {

				# Pull a bye from whatever entry randomly shuffled to the top
				# from among those who have not had a bye.

				my @tried;
				my @candidates;
				my $average = (scalar @entries) / 2;

				@candidates = @due_aff if scalar @due_aff > scalar @due_neg;
				@candidates = @due_neg if scalar @due_aff < scalar @due_neg;
				@candidates = @entries if scalar @due_aff == scalar @due_neg;

				if ($event_settings->{"seed_presets"} eq "balance") {

					@candidates = sort {
						abs($entry_info{$a}{'seed'} - $average) <=> abs($entry_info{$b}{'seed'} - $average)
					} @candidates;

					# this sorts the candidates so that the bye is more likely
					# to come from the middle

					if ($entry_info{$entries[0]}{"need_position"}) {
						@candidates = sort {
							$entry_info{$b}{"need_position"} <=> $entry_info{$a}{"need_position"}
						} @candidates;
					}
				}

				while (not defined $bye) {

					unless (@candidates) {
						@tried = shuffle @tried;
						$bye = shift @tried;
					}

					my $test = shift @candidates;

					if ($test) {

						my $nope;

						$nope++ if $entry_info{$test}{"byes"};
						$nope++ if $school_info{$entry_info{$test}{"school"}}{"byes"};

						if (keys %bye_seed) {
							unless ($bye_seed{ $entry_info{$test}{'seed'} }) {
								push @tried, $test;
								$nope++;
							}
						} elsif ($event_settings->{"seed_presets"} eq "inverse" ) {

							unless ($entry_info{$test}{"need_seed"}{$seed_byes_as} > 0) {
								push @tried, $test;
								$nope++;
							}

						} else {
							push @tried, $test;
						}

						$bye = $test unless $nope;
					}
				}

				if ($bye) {

					undef $due{$bye};
					$used{$bye}++;

					my $index = 0;
					$index++ until $due_aff[$index] eq $bye || $index > scalar @due_aff;
					splice(@due_aff, $index, 1);

					$index = 0;
					$index++ until $due_neg[$index] eq $bye || $index > scalar @due_neg;
					splice(@due_neg, $index, 1);

					$index = 0;
					$index++ until $due_whatever[$index] eq $bye || $index > scalar @due_whatever;
					splice(@due_whatever, $index, 1);

				}
			}

			my %seen = ();
			@due_whatever = grep { ! $seen{$_} ++ } @due_whatever;
			@due_aff = grep { ! $seen{$_} ++ } @due_aff;
			@due_neg = grep { ! $seen{$_} ++ } @due_neg;

			my %partner;
			my $average = (scalar @entries) / 2;

			if ($event_settings->{"seed_presets"} eq "balance") {
				@due_whatever = sort {
					abs($entry_info{$a}{'seed'} - $average) <=> abs($entry_info{$b}{'seed'} - $average)
				} @due_whatever;
			}

			WHATEVER:
			while (@due_whatever) {

				# Randomly sprinkle the whatevers until both sides are even. We
				# do this now instead of waiting until the end to prevent the
				# byes from always hitting one another, since if there are
				# multiple byes at this point, they're almost certainly
				# screwups who don't deserve that kind of consideration.

				unless ($event_settings->{"seed_presets"} eq "balance") {
					@due_whatever = shuffle @due_whatever;
				}

				my $pull = shift @due_whatever;
				next if $used{$pull}++;

				my $partner = pop @due_whatever
					if @due_whatever
					&& $event_settings->{"seed_presets"} eq "balance";

				$used{$partner}++;

				$partner{$pull} = $partner;
				$partner{$partner} = $pull;

				my $opp1;
				my $opp2;

				if (scalar @due_neg < scalar @due_aff) {
					push @due_neg, $pull;
					push @due_aff, $partner if $partner;
				} else {
					push @due_aff, $pull;
					push @due_neg, $partner if $partner;
				}

			}

			@due_aff = shuffle @due_aff;
			@due_neg = shuffle @due_neg;

			while (scalar @due_aff > scalar @due_neg) {
				#Shift some poor suckers over
				push @due_neg, shift @due_aff;
			}

			while (scalar @due_aff < scalar @due_neg) {
				#Shift some poor suckers over
				push @due_aff, shift @due_neg;
			}

			my %is_due_aff = map {$_ => 1} @due_aff;
			my %is_due_neg = map {$_ => 1} @due_neg;

			my $counter = 1;

			if ($event_settings->{"seed_presets"} eq "protect") {
				@due_aff = sort {$entry_info{$a}{'seed'} <=> $entry_info{$b}{'seed'}} @due_aff;
				@due_neg = sort {$entry_info{$b}{'seed'} <=> $entry_info{$a}{'seed'}} @due_neg;
			}

			if ($event_settings->{"seed_presets"} eq "balance") {

				@due_aff = sort {
					abs($entry_info{$b}{'seed'} - $average) <=> abs($entry_info{$a}{'seed'} - $average)
				} @due_aff;

				@due_neg = sort {
					abs($entry_info{$a}{'seed'} - $average) <=> abs($entry_info{$b}{'seed'} - $average)
				} @due_neg;
			}

			my %done;
			my $negs;

			foreach my $aff (@due_aff) {

				next if $done{$aff}++;
				my $neg;
				my $shifter;

				if ($entry_info{$aff}{"needs_print"}) {

					# This segment manages seeded presets and matches people
					# based on ideal seeding needs.  Only invoked for inverse &
					# all seed_protect settings.

					unless ($event_settings->{"seed_presets"} eq "balance") {
						@due_neg = shuffle @due_neg;
					}

					if ($event_settings->{"seed_presets"} eq "inverse") {
						if ($shifter++ % 2) {
							@due_neg =
								sort {$entry_info{$a}{'seed'} <=> $entry_info{$b}{"seed"}}
								@due_neg;
						} else {
							@due_neg =
								sort {$entry_info{$b}{'seed'} <=> $entry_info{$a}{"seed"}}
								@due_neg;
						}
					}

					foreach my $debate_me_maybe (@due_neg) {

						next if $done{"maybe_".$debate_me_maybe};

						next unless $entry_info{$debate_me_maybe}{"need_seed"}{$entry_info{$aff}{'seed'} };
						next unless $entry_info{$aff}{"need_seed"}{ $entry_info{$debate_me_maybe}{"seed"} } ;

						next if $entry_info{$aff}{"school"} == $entry_info{$debate_me_maybe}{"school"};

						if ($event_settings->{"region_avoid"}) {

							if ($entry_info{$aff}{"region"}
								&& $entry_info{$aff}{"region"} == $entry_info{$debate_me_maybe}{"region"}
							) {
								next;
							}

							if (
								$entry_info{$aff}{'area'} &&
								$entry_info{$aff}{'area'} == $entry_info{$debate_me_maybe}{"area"}
							) {
								next;
							}
						}

						# If we made it this far, WE NEED ONE ANOTHER.  IT IS
						# DESTINY.

						$neg = $debate_me_maybe;
						$done{"maybe_".$debate_me_maybe}++;
						last if $neg;
					}

					# I found no opponent who is not a perfect fit.  So, I cope
					# as best I can.  Find someone whose need I fit while not
					# fitting mine, if such exists.

					unless ($neg) {

						foreach my $debate_me_maybe (@due_neg) {
							next unless $entry_info{$neg}{"need_seed"}{$entry_info{$aff}{"seed"}};
							$neg = $debate_me_maybe;
							$done{"maybe_".$debate_me_maybe}++;
							last if $neg;
						}

					}

					# All right, try the inverse if that didn't work.
					unless ($neg) {
						foreach my $debate_me_maybe (@due_neg) {
							next unless $entry_info{$aff}{"need_seed"}{$entry_info{$neg}{"seed"}};
							$neg = $debate_me_maybe;
							$done{"maybe_".$debate_me_maybe}++;
							last if $neg;
						}
					}

					# If we're still doomed the next bit will just pick any old
					# neg.  If this is just because randomization doomed us, the
					# swapper later will help.

				} elsif ($event_settings->{"seed_presets"} eq "balance") {

					my $current_diff = 0;
					my $current_clash = 8301239291;

					foreach my $maybe_neg (@due_neg) {

						next if $done{$maybe_neg};

						my $clash = 0;

						if ($entry_info{$aff}{"school"} == $entry_info{$maybe_neg}{"school"}) {
							$clash++;
						}

						if ($entry_info{$aff}{"school"} == $entry_info{$partner{$maybe_neg}}{"school"}) {
							$clash++;
						}

						if ($entry_info{$maybe_neg}{"school"} == $entry_info{$partner{$aff}}{"school"}) {
							$clash++;
						}

						if ($event_settings->{"region_avoid"}) {

							if ($entry_info{$aff}{"region"} == $entry_info{$maybe_neg}{"region"}) {
								$clash++;
							}

							if ($entry_info{$aff}{"region"} == $entry_info{$partner{$maybe_neg}}{"region"}) {
								$clash++;
							}

							if ($entry_info{$maybe_neg}{"region"} == $entry_info{$partner{$aff}}{"region"}) {
								$clash++;
							}

							if ($entry_info{$aff}{"area"} && ($entry_info{$aff}{"area"} == $entry_info{$maybe_neg}{"area"})) {
								$clash++;
							}
						}

						my $diff;

						if ($entry_info{$aff}{"need_position"}) {
							$diff = abs( $entry_info{$aff}{"need_position"} - $entry_info{$maybe_neg}{"seed"});
							$diff += abs(  $entry_info{$maybe_neg}{"need_position"} - $entry_info{$aff}{"seed"});
						}

						if ($clash < $current_clash) {
							$neg = $maybe_neg;
							$current_clash = $clash;
							$current_diff = $diff;
						} elsif (
							($clash == $current_clash)
							&& ($diff < $current_diff)
						) {
							$neg = $maybe_neg;
							$current_diff = $diff;
						}

						if ($neg && $clash == 0 and $diff == 0) {
							last;
						}
					}
				}

				unless ($neg) {

					foreach my $test_neg (@due_neg) {

						next if $neg;
						next if $done{$test_neg};
						if ($entry_info{$test_neg}{"school"} == $entry_info{$aff}{"school"}) {
							next;
						}

						$neg = $test_neg;
						$done{$test_neg}++;
						last;
					}
				}

				unless ($neg) {
					foreach my $test_neg (@due_neg) {
						next if $neg;
						next if $done{$test_neg};
						$neg = $test_neg;
						$done{$test_neg}++;
						last;
					}
				}

				$negs++;

				push @{$panels{$counter}}, $aff;
				push @{$panels{$counter}}, $neg;

				$done{$neg}++;

				#increase_school_hit(\%entry_info, \@{$panels{$counter}}, "initial");

				$counter++;

				if ($partner{$aff}
					&& $partner{$neg}
					&! $done{$partner{$aff}}
					&! $done{$partner{$neg}}
				) {

					if ($is_due_aff{$partner{$aff}} && $is_due_neg{$partner{$neg}}) {

						if ($entry_info{$partner{$aff}}{"school"} != $entry_info{$partner{$neg}}{"school"}) {

							if (
								$entry_info{$partner{$aff}}{"region"} != $entry_info{$partner{$neg}}{"region"}
							) {

								push @{$panels{$counter}}, $partner{$aff};
								push @{$panels{$counter}}, $partner{$neg};

								increase_school_hit(\%entry_info, \@{$panels{$counter}}, "initial 2");
								#if ($event_settings->{"region_constrain"}) {
								#	increase_region_hit(\%entry_info, \@{$panels{$counter}}, "initial 2");
								#}

								$counter++;
								$done{$partner{$aff}}++;
								$done{$partner{$neg}}++;
								$negs++;

							}
						}
					}
				}
			}

			my %sort_score;
			my $total_score;

			COUNTER:
			foreach my $counter (1 .. 7) {

				foreach my $key (sort {$a <=> $b } keys %panels) {

					my ($aff, $neg) = @{$panels{$key}};
					$event_settings->{baseline} = 1;

					my $a1 = $entry_info{$aff};
					my $n1 = $entry_info{$neg};

					$score_cache{$aff}{$neg} = score_preset(
						\@{$panels{$key}},
						\%entry_info,
						$event_settings,
					);

					delete $event_settings->{baseline};
					$total_score += $score_cache{$aff}{$neg};
					$sort_score{$key} = $score_cache{$aff}{$neg};

				}

				if ($total_score < 1) {
					%final_panels = %panels;
					last PASS;
				}

				my $swaps_made;

				PANEL:
				foreach my $panel_key (sort {$sort_score{$b} <=> $sort_score{$a}} keys %panels) {

					my ($aff1, $neg1) = @{$panels{$panel_key}};

					my $baseline_panel1_score = $score_cache{$aff1}{$neg1};

					if ($baseline_panel1_score == 0) {
						next PANEL;
					}

					my $current_diff;
					my $swap_key;
					my $swap_cross;

					OTHERPANEL:
					foreach my $other_key (keys %panels) {

						next if $other_key == $panel_key;
						my @panel2 = @{$panels{$other_key}};

						my $aff2 = shift @panel2;
						my $neg2 = shift @panel2;

						my $baseline_panel2_score = $score_cache{$aff2}{$neg2};

						if (
							$event_settings->{"seed_presets"} eq "protect"
							|| $event_settings->{"seed_presets"} eq "inverse"
						) {

							if (
								($entry_info{$aff1}{'seed'} != $entry_info{$aff2}{'seed'})
								|| 	($entry_info{$neg1}{'seed'} != $entry_info{$neg2}{'seed'})
							) {
								#Cannot swap due to seeding conflicts
								@panel2 = ($aff2, $neg2);
								next OTHERPANEL;
							}
						}

						unless (defined $score_cache{$aff1}{$neg2}) {
							my @new_1 = ($aff1, $neg2);
							$score_cache{$aff1}{$neg2} = score_preset(
								\@new_1,
								\%entry_info,
								$event_settings
							);
						}

						my $swap_panel1_score = $score_cache{$aff1}{$neg2};

						unless (defined $score_cache{$aff2}{$neg1}) {
							my @new_2 = ($aff2, $neg1);
							$score_cache{$aff2}{$neg1} = score_preset(
								\@new_2,
								\%entry_info,
								$event_settings
							);
						}

						my $swap_panel2_score = $score_cache{$aff2}{$neg1};

						my $new_score = $swap_panel1_score + $swap_panel2_score;
						my $baseline = $baseline_panel1_score + $baseline_panel2_score;
						my $diff = $baseline - $new_score;

						my $a1 = $entry_info{$aff1};
						my $n1 = $entry_info{$neg1};

						my $a2 = $entry_info{$aff2};
						my $n2 = $entry_info{$neg2};

						if ( $diff >= 0 && $diff >= $current_diff) {
							$current_diff = $diff;
							$swap_key = $other_key;
							undef $swap_cross;

							if ( $diff > 0 ) {
								$swaps_made++;
							}
							if ($new_score == 0) {
								last OTHERPANEL;
							}
						}

						# Attempt various cross side swaps if that makes things
						# better and they're not side constrained.

						unless ($due{$aff1} == 1 || $due{$neg2} == 2)  {

							my @new_1 = ($neg2, $neg1);
							my @new_2 = ($aff2, $aff1);

							my $dont;

							if ($event_settings->{"seed_presets"} eq "protect") {
								if ($entry_info{$neg2}{'seed'} != $entry_info{$aff1}{'seed'}) {
									#Cannot swap due to seeding conflicts
									@panel2 = ($aff2, $neg2);
									$dont++;
								}
							}

							unless ($dont) {

								unless (defined $score_cache{$neg2}{$neg1}) {
									$score_cache{$neg2}{$neg1} = score_preset(
										\@new_1,
										\%entry_info,
										$event_settings
									);
								}

								$swap_panel1_score = $score_cache{$neg2}{$neg1};

								unless (defined $score_cache{$aff2}{$aff1}) {
									$score_cache{$aff2}{$aff1} = score_preset(
										\@new_2,
										\%entry_info,
										$event_settings
									);
								}

								$swap_panel2_score = $score_cache{$aff2}{$aff1};

								my $new_score = $swap_panel1_score + $swap_panel2_score;
								my $baseline = $baseline_panel1_score + $baseline_panel2_score;
								my $diff = $baseline - $new_score;

								if ( $diff >= 0 && $diff >= $current_diff) {
									$current_diff = $diff;
									$swap_key = $other_key;
									$swap_cross = 1;

									if ( $diff > 0 ) {
										$swaps_made++;
									}
									last OTHERPANEL if $new_score == 0;
								}
							}
						}

						unless ($due{$aff2} == 1 || $due{$neg1} == 2)  {

							my @new_1 = ($aff1, $aff2);
							my @new_2 = ($neg1, $neg2);

							my $dont;

							if ($event_settings->{"seed_presets"} eq "protect") {
								if ($entry_info{$neg1}{'seed'} != $entry_info{$aff2}{'seed'}) {
									#Cannot swap due to seeding conflicts
									@panel2 = ($aff2, $neg2);
									$dont++;
								}
							}

							unless ($dont) {

								unless (defined $score_cache{$aff1}{$aff2}) {
									$score_cache{$aff1}{$aff2} = score_preset(
										\@new_1,
										\%entry_info,
										$event_settings
									);
								}

								$swap_panel1_score = $score_cache{$aff1}{$aff2};

								unless (defined $score_cache{$neg1}{$neg2}) {
									$score_cache{$neg1}{$neg2} = score_preset(
										\@new_2,
										\%entry_info,
										$event_settings
									);
								}

								$swap_panel2_score = $score_cache{$neg1}{$neg2};

								my $new_score = $swap_panel1_score + $swap_panel2_score;
								my $baseline = $baseline_panel1_score + $baseline_panel2_score;
								my $diff = $baseline - $new_score;

								if ( $diff >= 0 && $diff >= $current_diff) {
									$current_diff = $diff;
									$swap_key = $other_key;
									$swap_cross = 2;
									if ( $diff > 0 ) {
										$swaps_made++;
									}
									last OTHERPANEL if $new_score == 0;
								}
							}
						}
					}

					if ($swap_key) {

						my @new_1;
						my @new_2;

						my @swap_panel = @{$panels{$swap_key}};
						my ($aff2, $neg2) = @{$panels{$swap_key}};

						if ($swap_cross == 1) {
							@new_1 = ($neg2, $neg1);
							@new_2 = ($aff2, $aff1);
						} elsif ($swap_cross == 2) {
							@new_1 = ($aff1, $aff2);
							@new_2 = ($neg1, $neg2);
						} else {
							@new_1 = ($aff1, $neg2);
							@new_2 = ($aff2, $neg1);
						}

						#reduce_school_hit(\%entry_info, \@{$panels{$panel_key}});
						#reduce_school_hit(\%entry_info, \@{$panels{$swap_key}});

						#increase_school_hit(\%entry_info, \@new_1, "double swap");
						#increase_school_hit(\%entry_info, \@new_2, "double swap");

						#if ($event_settings->{"region_constrain"}) {
						#	reduce_region_hit(\%entry_info, \@{$panels{$panel_key}});
						#	reduce_region_hit(\%entry_info, \@{$panels{$swap_key}});

						#	increase_region_hit(\%entry_info, \@new_1, "double swap");
						#	increase_region_hit(\%entry_info, \@new_2, "double swap");
						#}

						@{$panels{$panel_key}} = @new_1;
						@{$panels{$swap_key}} = @new_2;
					}
				}

				foreach my $panel_key (shuffle (keys %panels)) {

					#Try some triple swaps;
					my ($aff1, $neg1) = @{$panels{$panel_key}};

					my $current_diff;

					my $swap_key_1;
					my $swap_cross_1;

					my $swap_key_2;
					my $swap_cross_2;

					my $swap_key_3;
					my $swap_cross_3;

					my $baseline_panel1_score = $score_cache{$aff1}{$neg1};
					next if $baseline_panel1_score < 1;

					my $aff2;
					my $neg2;

					my $baseline_panel2_score;
					my $swapped_panel2_score;

					OTHERPANEL:
					foreach my $other_key (keys %panels) {

						next if $other_key == $panel_key;

						my @panel2 = @{$panels{$other_key}};
						my ($aff2, $neg2) = @{$panels{$other_key}};

						my $baseline_panel2_score = $score_cache{$aff2}{$neg2};
						my @new2 = ($aff1, $neg2);

						unless (defined $score_cache{$aff1}{$neg2}) {
							$score_cache{$aff1}{$neg2} = score_preset(
								\@new2,
								\%entry_info,
								$event_settings
							);
						}

						$swapped_panel2_score = $score_cache{$aff1}{$neg2};
						my $diff = $baseline_panel2_score - $swapped_panel2_score;

						if ($diff >= $current_diff) {
							$swap_key_2 = $other_key;
							$current_diff = $diff;
						}
					}

					if ($swap_key_2) {

						undef $current_diff;

						OTHERPANEL:
						foreach my $other_key (keys %panels) {

							next if $other_key == $panel_key;
							next if $other_key == $swap_key_2;

							my @panel3 = @{$panels{$other_key}};
							my ($aff3, $neg3) = @{$panels{$other_key}};

							unless (defined $score_cache{$aff3}{$neg3}) {
								$score_cache{$aff3}{$neg3} = score_preset(
									\@panel3,
									\%entry_info,
									$event_settings
								);
							}

							my $baseline_panel3_score = $score_cache{$aff3}{$neg3};

							unless (defined $score_cache{$aff2}{$neg3}) {
								my @new3 = ($aff2, $neg3);
								$score_cache{$aff2}{$neg3} = score_preset(
									\@new3,
									\%entry_info,
									$event_settings
								);
							}

							my $swapped_panel3_score = $score_cache{$aff2}{$neg3};

							unless (defined $score_cache{$aff3}{$neg1}) {
								my @new1 = ($aff3, $neg1);
								$score_cache{$aff3}{$neg1} = score_preset(
									\@new1,
									\%entry_info,
									$event_settings
								);
							}

							my $swapped_panel1_score = $score_cache{$aff3}{$neg1};

							my $baseline = $baseline_panel1_score
								+ $baseline_panel2_score
								+ $baseline_panel3_score;

							my $swapped = $swapped_panel1_score
								+ $swapped_panel2_score
								+ $swapped_panel3_score;

							my $diff = $baseline - $swapped;

							if ($diff >= $current_diff) {
								$swap_key_3 = $other_key;
								$current_diff = $diff;
								if ( $diff > 0 ) {
									$swaps_made++;
								}
							}
						}
					}

					if ($swap_key_2 && $swap_key_3) {

						my ($aff2, $neg2) = @{$panels{$swap_key_2}};
						my ($aff3, $neg3) = @{$panels{$swap_key_3}};

						my @new_1 = ($aff3, $neg1);
						my @new_2 = ($aff1, $neg2);
						my @new_3 = ($aff2, $neg3);

						#reduce_school_hit(\%entry_info, \@{$panels{$panel_key}});
						#reduce_school_hit(\%entry_info, \@{$panels{$swap_key_2}});
						#reduce_school_hit(\%entry_info, \@{$panels{$swap_key_3}});

						#increase_school_hit(\%entry_info, \@new_1, "triple swap");
						#increase_school_hit(\%entry_info, \@new_2, "triple swap");
						#increase_school_hit(\%entry_info, \@new_3, "triple swap");

						#if ($event_settings->{"region_constrain"}) {
						#	reduce_school_hit(\%entry_info, \@{$panels{$panel_key}});
						#	reduce_school_hit(\%entry_info, \@{$panels{$swap_key_2}});
						#	reduce_school_hit(\%entry_info, \@{$panels{$swap_key_3}});

						#	increase_school_hit(\%entry_info, \@new_1, "triple swap");
						#	increase_school_hit(\%entry_info, \@new_2, "triple swap");
						#	increase_school_hit(\%entry_info, \@new_3, "triple swap");
						#}

						@{$panels{$panel_key}} = @new_1;
						@{$panels{$swap_key_2}} = @new_2;
						@{$panels{$swap_key_3}} = @new_3;
					}
				}

				if ($swaps_made < 2) {
					last COUNTER;
				}
			}

			my $new_score;

			foreach my $panel_key (shuffle keys %panels) {

				my ($aff, $neg) = @{$panels{$panel_key}};

				$score_cache{$aff}{$neg} = score_preset(
					\@{$panels{$panel_key}},
					\%entry_info,
					$event_settings,
					"shout",
				);
				$new_score += $score_cache{$aff}{$neg};
			}

			my $improvements_made = 0;

			if ($new_score < $best_score || (not defined $best_score)) {
				%final_panels = %panels;
				$best_score = $new_score;
				$improvements_made++;
			}

			if ($new_score == 0) {
				last PASS;
			}

			if ($improvements_made < 1) {
				last;
			}
		}

		foreach my $panel (sort {$a <=> $b} keys %final_panels) {
			my ($aff, $neg) = @{$final_panels{$panel}};
		}

		push @byes, $bye;
		write_round($round, \%final_panels, \@byes, $event_settings, \%entry_info);
	}

	return;

	sub write_round {

		my ($round, $final_panref, $byeref, $event_settings, $entry_info) = @_;

		my @byes = eval {
			return @{$byeref};
		};

		#Out with the old.

		Tab::Score->set_sql( delete_round => "
			delete score from score, ballot, panel
			where panel.round = ?
			and panel.id = ballot.panel
			and ballot.id = score.ballot
		");

		Tab::Ballot->set_sql( delete_round => "
			delete ballot from ballot, panel
			where panel.round = ?
			and panel.id = ballot.panel
		");

		Tab::Panel->set_sql( delete_round => "
			delete from panel where round = ?
		");

		Tab::Score->sql_delete_round->execute($round->id);
		Tab::Ballot->sql_delete_round->execute($round->id);
		Tab::Panel->sql_delete_round->execute($round->id);

		my $letter = 1;
		$letter = "A" if $event_settings->{"panel_labels"} eq "letters";

		my %used;
		my @keys = sort {$a <=> $b} keys %{$final_panref};

		foreach my $key (@keys) {

			my $aff = shift @{${$final_panref}{$key}};
			my $neg = shift @{${$final_panref}{$key}};

			next if $used{$aff} && $used{$neg};
			next unless $aff || $neg;

			my $aff_ref = $entry_info->{$aff};
			my $neg_ref = $entry_info->{$neg};

			my $panel = Tab::Panel->create({
				round  => $round->id,
				letter => $letter,
				flight => 1
			});

			if ($letter eq "Z") {
				$letter = "AA";
			} elsif ($letter eq "AZ") {
				$letter = "BA";
			} elsif ($letter eq "BZ") {
				$letter = "CA";
			} elsif ($letter eq "CZ") {
				$letter = "DA";
			} elsif ($letter eq "DZ") {
				$letter = "EA";
			} elsif ($letter eq "EZ") {
				$letter = "FA";
			} else {
				$letter++;
			}

			unless ($used{$aff}++) {
				eval {
					Tab::Ballot->create({
						side  => 1,
						panel => $panel->id,
						entry => $aff,
					});
				};
			}

			unless ( (not defined $neg) || $used{$neg}++) {
				eval {
					Tab::Ballot->create({
						side  => 2,
						entry => $neg,
						panel => $panel->id,
					});
				};
			}
		}

		foreach my $bye_entry (@byes) {

			next unless $bye_entry && $bye_entry > 1;

			my $panel = Tab::Panel->create({
				round  => $round->id,
				letter => $letter++,
				bye    => 1,
				flight => 1
			});

			my $bye_ballot = Tab::Ballot->create({
				panel => $panel->id,
				entry => $bye_entry,
				side  => 1,
				audit => 1
			});

		}

		my $dbh = $event_settings->{dbh};
		my $now = $event_settings->{now};
		my $sth = $dbh->prepare('update round set paired_at = ? where id = ?');
		$sth->execute(DateTime::Format::MySQL->format_datetime($now), $round->id);
	}

    sub score_preset {

        my ($panref, $entry_info, $event_settings) = @_;

		return unless @{$panref};
		my $aff_id = shift @{$panref};

		return unless @{$panref};
		my $neg_id = shift @{$panref};

		my $aff = $entry_info->{$aff_id};
		my $neg = $entry_info->{$neg_id};

        my $score = 0;

		if (
			($neg->{"school"} > 0 && $neg->{"school"} == $aff->{"school"})
			|| ($aff->{"hybrid"} > 0 && $neg->{"school"} == $aff->{"hybrid"})
			|| ($neg->{"hybrid"} > 0 && $neg->{"hybrid"} == $aff->{"school"})
		) {

			# We are from the same school.  Highest penalty.
			$score += 10000;
		}

		# We have debated against each other previously
		$score += 1000 * $aff->{"hits-".$neg_id};
		$score += 1000 * $neg->{"hits-".$aff_id};

		# We have debated against each other on this side.
		$score += 1000 * $aff->{"oppside-".$neg_id."-1"};

		# It's hybrid online world and we want meatspace debates as much as
		# possible

		if ($aff->{"online"} && $aff->{"online"} != $neg->{"online"}) {
			$score += 100;
		}

		# If are from the same area.  Moderate penalty to avoid.
		if ( $neg->{"area"} && $neg->{"area"} == $aff->{"area"}) {
			$score += 20;
		}

		if ($event_settings->{"region_avoid"}) {
			if ($neg->{"region"} && $aff->{"region"}) {
				# If are from the same region.  Moderate penalty to avoid.
				if ($neg->{"region"} == $aff->{"region"}) {
					$score += 50;
				}

				$score += $aff->{"region_hit"}{$neg->{"region"}} * 2;
				$score += $neg->{"region_hit"}{$aff->{"region"}} * 2;
			}
		}

		if ($event_settings->{"seed_presets"} eq "all") {
			if ($neg->{"seed"}) {
				$score += 10 unless $entry_info->{"need_seed"}{$aff_id}{$neg->{"seed"}};
			}
			if ($aff->{"seed"}) {
				$score += 10 unless $entry_info->{"need_seed"}{$neg_id}{$aff->{"seed"}};
			}
		}

		if ($event_settings->{"seed_presets"} eq "inverse") {

			if ($event_settings->{"baseline"}) {

				my $aff_seed = $aff->{"seed"};
				my $neg_seed = $neg->{"seed"};

				my $aff_code = $aff->{"code"};
				my $neg_code = $neg->{"code"};

				my $neg_need = $neg->{"needs_print"};
				my $aff_need = $aff->{"needs_print"};

				my $neg_score = $neg->{"need_seed"}{$aff_seed};
				my $aff_score = $aff->{"need_seed"}{$neg_seed};

			}

			my $aff_seed = $aff->{"seed"};
			my $neg_seed = $neg->{"seed"};

			my $aff_need = $aff->{"need_seed"}{$neg_seed};
			my $neg_need = $neg->{"need_seed"}{$aff_seed};

			$score += 100 unless ($aff_need);
			$score += 100 unless ($neg_need);
		}

		if ($event_settings->{"seed_presets"} eq "balance") {

			my $aff_diff = abs($aff->{"need_position"} - $neg->{"seed"});
			my $neg_diff = abs($neg->{"need_position"} - $aff->{"seed"});

			my $position_score = 0;


			if ($aff_diff > 0 && $aff->{need_position}) {
				$position_score += 10 * $aff_diff;
			}

			if ($neg_diff > 0 && $neg->{need_position}) {
				$position_score += 10 * $neg_diff;
			}

			$score+= $position_score;
		}

		# We have debated against someone else from that same school.  Lowest penalty.

		if ($neg->{"school"}) {
			$score += $aff->{"school_hit"}{$neg->{"school"}} * 10;
		}

		if ($aff->{"school"}) {
			$score += $neg->{"school_hit"}{$aff->{"school"}} * 10;
		}

		if ($aff->{"school"} && $neg->{"school"}) {
			if ($entry_info->{"school_hit"}{$aff->{"school"}}{$neg->{"school"}} > 0) {
				$score += $entry_info->{"school_hit"}{$aff->{"school"}}{$neg->{"school"}};
			}

			if ($entry_info->{"school_hit"}{$neg->{"school"}}{$aff->{"school"}} > 0) {
				$score += $entry_info->{"school_hit"}{$neg->{"school"}}{$aff->{"school"}};
			}
		}

		@{$panref} = ($aff_id, $neg_id);

        return $score || 0;
    }

	sub reduce_school_hit {

        my ($entry_info, $panref) = @_;

		my ($aff, $neg) = @{$panref} if $panref && @{$panref};

		return unless $aff > 0 && $neg > 0;

		my $aff_school = $entry_info->{$aff}{"school"};
		my $neg_school = $entry_info->{$neg}{"school"};

		return unless $aff_school > 0;
		return unless $neg_school > 0;

		return if $aff_school == $neg_school;

		unless ($aff_school == $neg_school) {
			$entry_info->{"school_hit"}{$aff_school}{$neg_school}--;
			$entry_info->{"school_hit"}{$neg_school}{$aff_school}--;
		}

		if ($entry_info->{"school_hit"}{$aff_school}{$neg_school} < 0) {
			$entry_info->{"school_hit"}{$aff_school}{$neg_school} = 0;
		}

		if ($entry_info->{"school_hit"}{$neg_school}{$aff_school} < 0) {
			$entry_info->{"school_hit"}{$neg_school}{$aff_school} = 0;
		}

		return;
	}

	sub increase_school_hit {

        my ($entry_info, $panref, $reason) = @_;
		my ($aff, $neg) = @{$panref} if $panref && @{$panref};

		return unless $aff > 0 && $neg > 0;

		my $aff_school = $entry_info->{$aff}{"school"};
		my $neg_school = $entry_info->{$neg}{"school"};

		return unless $aff_school > 0;
		return unless $neg_school > 0;
		return if $aff_school == $neg_school;

		unless ($aff_school == $neg_school) {
			$entry_info->{"school_hit"}{$aff_school}{$neg_school}++;
			$entry_info->{"school_hit"}{$neg_school}{$aff_school}++;
		}

		return;
	}

	sub reduce_region_hit {

        my ($entry_info, $panref) = @_;

		my ($aff, $neg) = @{$panref} if $panref && @{$panref};

		return unless $aff && $neg;

		my $aff_region = $entry_info->{$aff}{"region"};
		my $neg_region = $entry_info->{$neg}{"region"};

		return if $aff_region == $neg_region;

		unless ($aff_region == $neg_region) {
			$entry_info->{"region_hit"}{$aff_region}{$neg_region}--;
			$entry_info->{"region_hit"}{$neg_region}{$aff_region}--;
		}

		return;
	}

	sub increase_region_hit {

        my ($entry_info, $panref, $reason) = @_;

		my ($aff, $neg) = @{$panref} if $panref && @{$panref};

		return unless $aff && $neg;

		my $aff_region = $entry_info->{$aff}{"region"};
		my $neg_region = $entry_info->{$neg}{"region"};

		return if $aff_region == $neg_region;

		unless ($aff_region == $neg_region) {
			$entry_info->{"region_hit"}{$aff_region}{$neg_region}++;
			$entry_info->{"region_hit"}{$neg_region}{$aff_region}++;
		}

		return;
	}

</%perl>
