<%args>
	$round_id
	$team1
	$seed1 => undef
	$wins1
	$team2
	$seed2 => undef
	$wins2
	$bracket_to_return
</%args>
<%flags>
        inherit => undef
</%flags>
<%init>

	#print "Round:".$round_id."<br>";
	#print "Team1:".$team1."<br>";
	#print "Seed1:".$seed1."<br>";
	#print "wins1:".$wins1."<br>";
	#print "Team2:".$team2."<br>";
	#print "Seed2:".$seed2."<br>";
	#print "wins2:".$wins2."<br>";

	my $bye = 0;
	my $bracket = $wins1;

	my $round = Tab::Round->retrieve($round_id);

	Tab::Panel->set_sql(check_already => "
		select distinct panel.*
		from panel, ballot
		where panel.round = ? 
		and panel.id = ballot.panel
		and ballot.entry = ? 
	");

	my $already1 = Tab::Panel->search_check_already($round_id, $team1)->first;
	my $already2 = Tab::Panel->search_check_already($round_id, $team2)->first;

	if ($already1 || $already2) { 

		return;

	} else { 

		Tab::Round->set_sql( max_letter => "select max(cast(letter as signed)) from panel where round = ?");
		my $letter = Tab::Round->sql_max_letter->select_val($round_id);
		$letter++;

		if ( $wins2 > $wins1 ) { 
			$bracket = $wins2; 
		}
		
		if ($team2 == -1) { 
			$bye = 1; 
		}

		my $panel = Tab::Panel->create({
			round   => $round_id,
			bye     => $bye,
			letter  => $letter,
			bracket => $bracket,
			flight  => 1
		});

		#necessary for return value
		if ($panel->id) { 
			$m->print($panel->id);
		} else { 
			$m->print("FAIL");
		}
			
		my $pullup = 0;

		if ( $wins2 > $wins1 ) { 
			$pullup = 1; 
		}

		Tab::Ballot->create({
			panel  => $panel->id,
			judge  => 0,
			entry  => $team1,
			side   => 1,
			audit  => $bye,
			seed   => $seed1,
			pullup => $pullup
		});

		if ($team2 > -1) {

			$pullup = 0;

			if ($wins1 > $wins2) { 	
				$pullup = 1; 
			}

			unless (
				Tab::Ballot->search( 
					panel => $panel->id,
					entry => $team2,
					judge => 0
				)
			) { 

				Tab::Ballot->create({
					panel  => $panel->id,
					judge  => 0,
					entry  => $team2,
					side   => 2,
					audit  => $bye,
					seed   => $seed2,
					pullup => $pullup
				});

			}
		
		}

		my $sidelock = 1 unless int($round->name) % 2;

		unless ($sidelock) { 
			undef $sidelock if $round->event->setting("no_side_constraints");
		}

		my $sla = $round->setting("sidelock_against");

		if ($sla eq "NONE" || $sla eq "RANDOM") { 
			undef $sidelock;
		} elsif ($sla) { 
			$sidelock++;
		}

		$round->setting("sides_not_set", 1) unless $sidelock;

		unless ( $bracket_to_return == -42 ) {
			$m->redirect("manual_powermatch.mhtml?round_id=$round_id&bracket=$bracket_to_return");
		}

	}

	return;
	
</%init>
