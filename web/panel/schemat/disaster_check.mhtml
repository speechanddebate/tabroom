<%args>
	$tourn
	$tourn_settings
	$round_id => undef
	$event_id => undef
	$dbh
	$person
</%args>
<%init>

	my @rounds;
	my $issues_only;
	my $event;
	my %event_settings;

	my %tags;
	my %problems;
	my %titles;

	if ($event_id) {
		@rounds = Tab::Round->search(event => $event_id);

		if (@rounds) {
			$event = $rounds[0]->event;
			%event_settings = $event->all_settings();
			$issues_only++;
		} else {
			$m->comp("/funclib/abort.mas", message => "No valid event ID sent");
		}
	} elsif ($round_id) {

		push @rounds, Tab::Round->retrieve($round_id);
		$event = $rounds[0]->event;
		%event_settings = $event->all_settings();

		if ($rounds[0]->setting("use_normal_rooms")) {
			$event_settings{"online_mode"} = "sync";
		}
	}

	my $aff_string = $event_settings{"aff_string"};
	$aff_string = "Aff" unless $aff_string;

	my $neg_string = $event_settings{"neg_string"};
	$neg_string = "Neg" unless $neg_string;

	my $event_type;

	if ($event) {
		$event_type = "speech" if $event->type eq "speech";
		$event_type = "congress" if $event->type eq "congress";
		$event_type = "debate" unless $event_type;
	}

	foreach my $round (@rounds) {

		next unless $round->panels;

		$m->comp("/funclib/round_clean.mas",
			dbh    => $dbh,
			person => $person,
			round  => $round
		);

		my $checked = $round->setting("disaster_checked");
		my $now = DateTime->now();
		$checked->{$now} = $person->id." ".$person->email;
		$round->setting("disaster_checked", "json", $checked);

		my $timeslot = $round->timeslot();
		my $round_realname = $round->realname();

		unless ($issues_only) {
			undef $round_realname;
		}

		my ($error, $garbage) = $m->comp("/funclib/online_usage.mas",
			tourn          => $tourn,
			round          => $round,
			return         => 1,
			env            => \%ENV,
			district       => $tourn_settings->{"nsda_district"}
		);

		if ($person->site_admin && $tourn->webname eq 'harvard') {
			$tags{"harvard"} = "This appears to be the Harvard tournament";
			$problems{"harvard"} .= '<p class="warning padless marno">Tournament is an inherent disaster '. $round_realname .'</p>';
		}

		unless (
			$event_settings{"online_mode"} eq "async"
			&& (not defined $event_settings{"dumb_half_async_thing"})
		) {

			#DOUBLE-BOOKED ROOMS

			$tags{"double_booked_rooms"} = "Rooms double booked";

			my $double_rooms_sth = $dbh->prepare("

				select distinct room.id, room.name room,
					panel.id, panel.letter, event.abbr,
					cloneround.name cloneround,
					cloneround.id cloneround_id,
					clonepanel.id cloneid, clonepanel.letter cloneletter, cloneevent.abbr cloneabbr

				from room, panel, panel clonepanel, round, round cloneround,
					timeslot, timeslot clonetimeslot,
					event, event cloneevent

				where panel.round = ?
					and panel.room = room.id
					and clonepanel.room = room.id
					and panel.flight = clonepanel.flight

					and panel.round = round.id
					and round.timeslot = timeslot.id

					and clonepanel.round = cloneround.id
					and cloneround.timeslot = clonetimeslot.id

					and clonetimeslot.start < timeslot.end
					and clonetimeslot.end > timeslot.start

					and cloneround.event = cloneevent.id
					and round.event = event.id

					and panel.id != clonepanel.id
			");

			$double_rooms_sth->execute($round->id);

			my $double_rooms_ref = $double_rooms_sth->fetchall_hash();

			if ($double_rooms_ref) {
				foreach my $dub (@{$double_rooms_ref}) {
					$problems{"double_booked_rooms"} .= '<p class="warning padless marno">Room '
						. $dub->{"room"}." is double-booked (".$dub->{"abbr"}." ".$dub->{"letter"}." and ";
					$problems{"double_booked_rooms"} .= "<a href='/panel/schemat/show.mhtml?round_id=".$dub->{"cloneround_id"}."'>";
					$problems{"double_booked_rooms"} .= $dub->{"cloneabbr"}." Rd ".$dub->{"cloneround"}." section ".$dub->{"cloneletter"}."</a>)</p>";
				}
			}
		}

		unless (
			$event_settings{"online_mode"}
			&& $event_settings{"online_mode"} eq "async"
			&& (not defined $event_settings{"dumb_half_async_thing"})
		) {

			#DOUBLE-BOOKED JUDGES

			$tags{"double_booked_judges"} = "Judges double booked within round";

			my $double_judges_sth = $dbh->prepare("

				select distinct judge.*

				from judge, panel, panel clonepanel, ballot, ballot cloneballot

				where panel.round = ?
					and clonepanel.round = panel.round
					and panel.flight = clonepanel.flight
					and panel.id != clonepanel.id
					and panel.id = ballot.panel
					and ballot.judge = judge.id
					and clonepanel.id = cloneballot.panel
					and cloneballot.judge = judge.id
			");

			$double_judges_sth->execute($round->id);

			while (
				my ($judge, $panel, $clonepanel, $ballot, $cloneballot)
				= $double_judges_sth->fetchrow_array()
			) {
				my $judge_info = Tab::Judge->retrieve($judge);
				$problems{"double_booked_judges"} .= '<p class="warning padless marno">'
					. $judge_info->first." ".$judge_info->last." is double-booked ".$round_realname ."!</p>";
			}

			$double_judges_sth->finish();

			# JUDGES MOVING ROOMS BETWEEN FLIGHTS

			$tags{"judges_moving_rooms"} = "Judges moving rooms between flights";

			my $moving_judges_sth = $dbh->prepare("

				select distinct judge.id, judge.first, judge.last, room.name, cloneroom.name

				from (judge, panel, panel clonepanel, ballot, ballot cloneballot)
					left join room on panel.room = room.id
					left join room cloneroom on clonepanel.room = cloneroom.id

				where panel.round = ?
					and clonepanel.round = panel.round
					and panel.flight != clonepanel.flight
					and panel.id != clonepanel.id
					and panel.id = ballot.panel
					and panel.room < clonepanel.room
					and ballot.judge = judge.id
					and clonepanel.id = cloneballot.panel
					and cloneballot.judge = judge.id
			");

			$moving_judges_sth->execute($round->id);

			while (
				my ($judge_id, $judge_first, $judge_last, $room1, $room2)
				= $moving_judges_sth->fetchrow_array()
			) {
				my $judge_info = Tab::Judge->retrieve($judge_id);
				$problems{"judges_moving_rooms"} .= '<p class="warning padless marno">'
					. $judge_info->first." ".$judge_info->last." is judging flights in multiple rooms ($room1, $room2) ".$round_realname ."</p>";
			}

			#TIMESLOT (CROSS-EVENT) DOUBLE-SCHEDULING

			$tags{"timeslot_double_booked_judges"} = "Judges double booked at this time";

			my $timeslot_double_judges_sth = $dbh->prepare("
				select judge.id, judge.first, judge.last, round.id, round.name, round.label, event.abbr

				from judge, round, panel, ballot, timeslot, event,
					timeslot myt, round myr, panel myp, ballot myb

					where round.timeslot = timeslot.id
					and round.id         = panel.round
					and panel.id         = ballot.panel
					and ballot.judge     = judge.id
					and round.event      = event.id

					and timeslot.start <= myt.end
					and timeslot.end >= myt.start

					and myt.id = myr.timeslot
					and myr.id = ?
					and myr.id != round.id
					and myr.id = myp.round
					and myp.id = myb.panel
					and myb.judge = judge.id

				group by judge.id
				order by judge.id, round.id asc
			");

			$timeslot_double_judges_sth->execute($round->id);

			while (
				my (
					$judge_id, $first, $last, $roundid, $roundname, $roundlabel, $event
				) = $timeslot_double_judges_sth->fetchrow_array()
			) {

				my $round;

				if ($roundlabel) {
					$round = $roundlabel;
				} else {
					$round = "Round ".$roundname;
				}

				$problems{"timeslot_double_booked_judges"}
					.= '<p class="warning padless marno">'. $first." ".$last
					." is also judging $round of $event ".$round_realname ."</p>";
			}
		}

		if ($round->setting("same_room_timeslot")) {
			#JUDGES WHO MOVE ROOMS FROM THE LOCKED ROUND
			$tags{"non_same_room"} = "Judges not in the same room as locked timeslot";

			my $non_same_room_sth = $dbh->prepare("
				select judge.id, judge.first, judge.last,
						timeslot.name timeslot_name,
						r2.name r2_name, r2.label r2_label, event.abbr,
						room.name room_name, rm2.name rm2_name

					from judge, panel, ballot, round, round_setting rs, room,
						round r2, panel p2, ballot b2, room rm2,
						event, timeslot

					where round.id = ?
						and panel.round = round.id
						and panel.id = ballot.panel
						and ballot.judge = judge.id
						and rs.tag = 'same_room_timeslot'
						and rs.round = round.id
						and rs.value = timeslot.id

						and r2.timeslot = timeslot.id
						and r2.event = event.id
						and r2.id = p2.round
						and p2.id = b2.panel

						and b2.judge = judge.id

						and p2.room = rm2.id
						and panel.room = room.id
						and p2.room != panel.room
				group by judge.id
			");

			$non_same_room_sth->execute($round->id);
			my $results = $non_same_room_sth->fetchall_hash();

			foreach my $ref (@{$results}) {
				$problems{"non_same_room"}
					.= '<p class="warning padless marno">'. $ref->{first}." ".$ref->{last}
					." moved to room ".$ref->{rm2_name}." from timeslot ".$ref->{timeslot_name}
					." ".$ref->{abbr}." ".($ref->{r2_label} || $ref->{r2_name})
					." ".$ref->{room_name}."</p>";
			}
		}

		if ($round->jpools) {

			#JUDGES NOT IN THE JUDGE POOL FOR THIS ROUND
			$tags{"non_pool_judges"} = "Judges not in the judge pool for this round";

			my $non_pool_judges_sth = $dbh->prepare("
				select judge.id, judge.first, judge.last
					from judge, panel, ballot
				where panel.round = ?
					and panel.id = ballot.panel
					and ballot.judge = judge.id

					and not exists (
						select jpj.id
							from jpool_judge jpj, jpool_round jpr
						where jpj.judge = judge.id
							and jpj.jpool = jpr.jpool
							and jpr.round = panel.round
					)
				group by judge.id
			");

			$non_pool_judges_sth->execute($round->id);

			while (
				my (
					$judge_id, $first, $last
				) = $non_pool_judges_sth->fetchrow_array()
			) {

				$problems{"non_pool_judges"}
					.= '<p class="warning padless marno">'. $first." ".$last
					." is not in judge pool(s) for this round ".$round_realname ."</p>";
			}

		}

		if ($event_type eq "debate") {

			if ($tourn_settings->{"nsda_district"}
				&& ($round->type eq "prelim" || $round->type eq "highlow")
			) {
				# DISTRICTS PRELIMS NEED POINTS
				my %tb_types = $m->comp(
					"/funclib/tiebreak_types.mas",
					round => $round
				);

				$tags{"sides_uneven"} = "Incorrect tiebreakers? ";

				unless ($tb_types{'point'})  {
					$problems{"sides_uneven"} .= '<p class="warning padless marno">';
					$problems{"sides_uneven"} .= "Your tiebreak set for this round does not ask ";
					$problems{"sides_uneven"} .= "for speaker points, as is required for Districts ";
					$problems{"sides_uneven"} .= "in prelim rounds.  Change your tiebreakers to Debate,";
					$problems{"sides_uneven"} .= "not Debate Elim or anything else.";
					$problems{"sides_uneven"} .= '</p>';

				}
			}

			# RIGHT NUMBER OF AFF/NEGS

			my $side_locked;
			my $side_lock_against = $round->setting("sidelock_against");

			if ($side_lock_against) {

				if ($side_lock_against ne "NONE" && $side_lock_against ne "RANDOM") {
					$side_locked++;
				}

			} else {
				$side_locked++ unless ($round->name % 2);
				undef $side_locked if $event_settings{"no_side_constraints"};
			}

			undef $side_locked if $event_settings{"round_robin"};

			undef $side_locked if $round->type eq "elim"
				|| $round->type eq "final"
				|| $round->type eq "runoff";

			if ($side_locked) {

				$tags{"sides_uneven"} = "Entries on the wrong side?";

				my $round_number = $round->name;

				while ( (not defined $side_lock_against) && ($round_number > 0)) {
					#Find previous round
					$round_number--;
					my $sla = Tab::Round->search(
						event => $event->id,
						name  => $round_number
					)->first;
					$side_lock_against = $sla->id if $sla;
				}

				if ($side_lock_against) {

					my $sides_sth = $dbh->prepare("
						select entry.code, b1.side, b2.side
						from entry,
							ballot b1, panel p1,
							ballot b2, panel p2

							where b1.entry = entry.id
							and b1.panel = p1.id
							and p1.bye != 1

							and b2.entry = entry.id
							and b2.panel = p2.id
							and p2.bye != 1

							and p1.round = ".$round->id."
							and p2.round = ".$side_lock_against."
					");

					$sides_sth->execute();

					my %side_done;

					while (my ($entry, $side1, $side2)  = $sides_sth->fetchrow_array() ) {
						next if $side_done{$entry}++;
						if ($side1 == $side2) {
							$problems{"sides_uneven"} .= '<p class="warning padless marno">'. $entry." should ";
							$problems{"sides_uneven"} .= "be on the opposite side this round! ".$round_realname ." </p>";
						}
					}
				}
			}

			$tags{"sides_same"} = "Entries on the same side in the same debate";
			my $round_number = $round->name;

			my $sides_sth = $dbh->prepare("
				select entry.code, e2.code, b1.side, b2.side
				from entry, entry e2,
					panel p1,
					ballot b1, ballot b2

				where b1.entry = entry.id
					and b1.panel = p1.id
					and p1.bye != 1
					and b2.entry = e2.id
					and b2.panel = p1.id
					and b2.side = b1.side
					and e2.id > entry.id
					and p1.round = ?
				group by entry.id
			");

			$sides_sth->execute($round->id);

			while (my ($entry, $e2, $side1, $side2)  = $sides_sth->fetchrow_array() ) {
				if ($side1 == 0 || $side2 == 0) {
					$problems{"sides_same"} .= '<p class="warning padless marno">'. $entry." vs ";
					$problems{"sides_same"} .= $e2." have no marked sides ".$round_realname ." </p>";
				} elsif ($side1 == $side2) {
					$problems{"sides_same"} .= '<p class="warning padless marno">'. $entry." vs ".$e2." both marked aff?  ".$round_realname ." </p>" if $side1 == 1;
					$problems{"sides_same"} .= '<p class="warning padless marno">'. $entry." vs ".$e2." both marked neg? ".$round_realname ." </p>" if $side1 == 2;
				}
			}

			if ($event_settings{"round_robin"}) {

				#SIDES WORK OUT IN A ROUND ROBIN
				$tags{"round_robin_side_count"} = "Round Robin: Inequal numbers of ".$aff_string."s/".$neg_string."s";
				$tags{"round_robin_side_order"} = "Round Robin: Too many of the same side in a row";

				my $sth = $dbh->prepare("
					select distinct round.name, ballot.side as side, ballot.bye as bye, panel.bye as pbye
						from round, ballot, panel
					where ballot.entry = ?
						and ballot.panel = panel.id
						and panel.round = round.id
					group by round.name
					order by round.name
				");

				foreach my $entry ($m->comp("/funclib/round_entries.mas", round => $round)) {

					$sth->execute($entry->id);

					my $aff_count;
					my $neg_count;
					my $in_a_row;
					my $current_side;
					my $byes;

					while (my ($name, $side, $bye, $pbye) = $sth->fetchrow_array() ) {

						if ($bye || $pbye) {
							$byes++;
							undef $current_side;
							next;
						}

						if ($side == $current_side) {
							$in_a_row++;
						} else {
							$in_a_row = 1;
							$current_side = $side;
						}

						if ($in_a_row > 2) {
							my $sidename = $aff_string;
							$sidename = $neg_string if $side == 2;
							$problems{"round_robin_side_order"}
								.= '<p class="warning padless marno">'.
								$entry->code." debates on $sidename $in_a_row times in a row ".$round_realname ." </p>";
						}
						$aff_count++ if $side == 1;
						$neg_count++ if $side == 2;
					}

					next if $aff_count == $neg_count;
					next if ($aff_count + 1) == $neg_count;
					next if ($neg_count + 1) == $aff_count;
					next if ($aff_count + $byes + 1) == $neg_count;
					next if ($neg_count + $byes + 1) == $aff_count;

					$problems{"round_robin_side_count"}
						.= '<p class="warning padless marno">'
						. $entry->code." has a side imbalance.  $byes byes, $aff_count on $aff_string, $neg_count on $neg_string". $round_realname ."</p>";

				}
			} elsif (
				$round->type ne "final"
				&& $round->type ne "elim"
				&& $round->type ne "runoff"
				&& not defined $event_settings{"no_side_constraints"}
			) {

				my $sth = $dbh->prepare("
					select
						entry.id, entry.code,
						ballot.side,
						ballot.panel,
						round.id round, round.name, round.label,
						ballot.bye, ballot.forfeit, panel.bye pbye

					from (entry, ballot, panel, round)

					where round.event = ?
						and round.name <= ?
						and round.id = panel.round
						and panel.id = ballot.panel
						and ballot.entry = entry.id
				");

				$sth->execute($event->id, $round->name);
				my $results = $sth->fetchall_hash();
				my %side_count;
				$tags{"side_way_bad"} = "Entries with excessive side imbalances";

				foreach my $result (@{$results}) {

					if (
						$result->{bye}
						|| $result->{pbye}
						|| $result->{forfeit}
					) {
						$side_count{$result->{id}}{"byes"}{$result->{panel}}++;
					} else {
						next if $side_count{$result->{id}}{$result->{round}}++;
						$side_count{$result->{id}}{"sides"}{$result->{side}}++;
						$side_count{$result->{id}}{"code"} = $result->{code};
					}
				}

				foreach my $entry (keys %side_count) {

					my $diff = abs($side_count{$entry}{"sides"}{1} - $side_count{$entry}{"sides"}{2});
					$side_count{$entry}{"sides"}{1} = 0 unless $side_count{$entry}{"sides"}{1};
					$side_count{$entry}{"sides"}{2} = 0 unless $side_count{$entry}{"sides"}{2};

					my $bye_count = scalar (keys %{$side_count{$entry}{"byes"}});

					if ($diff > (1 + $bye_count)) {
						$problems{"side_way_bad"}
							.= '<p class="warning padless marno">'
							. $side_count{$entry}{"code"}." has a side imbalance: "
							. $side_count{$entry}{"sides"}{1}." on $aff_string, "
							. $side_count{$entry}{"sides"}{2}." on $neg_string "
							. $bye_count." byes or forfeits "
							. '</p>';
					}
				}
			}

			if (
				$event_settings{"max_pref"} > 0
				|| $event_settings{"max_nobreak_pref"} > 0
			) {

				# PREF STRIKES
				$tags{"max_prefs"} = "Judge over maxmium allowed pref given";
				my $threshold = $round->name - $event_settings{"break_point"};
				my $prefs = $event->category->setting("prefs");

				if ($prefs eq "ordinals") {

					my $sth = $dbh->prepare("
						select
							panel.letter, room.name,
							judge.first, judge.last, entry.code,
							rating.percentile,
							panel.bracket

						from (round, panel, ballot, entry, rating, judge)

							left join room ON room.id = panel.room
						where round.id = ?
							and round.id = panel.round
							and panel.id = ballot.panel
							and ballot.entry = entry.id
							and ballot.judge = judge.id
							and entry.id = rating.entry
							and rating.judge = judge.id
					");

					$sth->execute($round->id);

					while (
						my (
							$letter, $room, $first, $last, $code, $rating, $bracket
						) = $sth->fetchrow_array()
					) {

						if ($bracket < $threshold) {
							if
								($event_settings{"max_nobreak_pref"} > 0
								&& ($rating <= $event_settings{"max_nobreak_pref"})
							) {
								next;
							}
						} else {
							if
								($event_settings{"max_pref"} > 0
								&& ($rating <= $event_settings{"max_pref"})
							) {
								next;
							}
						}

						$problems{"max_prefs"}.= '<p class="warning padless marno">Judge '.$first." ".$last." in ";
						if ($room) {
							$problems{"max_prefs"}.= " room $room ";
						} else {
							$problems{"max_prefs"}.= " sect $letter ";
						}
						$problems{"max_prefs"}.= " above max pref for $bracket-".($round->name - 1 - $bracket)." $code ($rating) </p>";
					}

				} elsif ($prefs eq "tiered_round" || $prefs eq "tiered") {


					my $sth = $dbh->prepare("
						select
							panel.letter, room.name,
							judge.first, judge.last, entry.code,
							rating_tier.name,
							panel.bracket

						from (round, panel, ballot, entry, rating, judge, rating_tier)

							left join room ON room.id = panel.room
						where round.id = ?
							and round.id = panel.round
							and panel.id = ballot.panel
							and ballot.entry = entry.id
							and ballot.judge = judge.id
							and entry.id = rating.entry
							and rating.judge = judge.id
							and rating.rating_tier = rating_tier.id
						group by ballot.id
					");

					$sth->execute($round->id);

					while (
						my (
							$letter, $room, $first, $last, $code, $rating, $bracket
						) = $sth->fetchrow_array()
					) {

						next unless $rating;

						if ($bracket < $threshold) {
							if
								($event_settings{"max_nobreak_pref"} > 0
								&& ($rating <= $event_settings{"max_nobreak_pref"})
							) {
								next;
							}
						} else {
							if
								($event_settings{"max_pref"} > 0
								&& ($rating <= $event_settings{"max_pref"})
							) {
								next;
							}
						}

						$problems{"max_prefs"}.= '<p class="warning padless marno">Judge '.$first." ".$last." in ";
						if ($room) {
							$problems{"max_prefs"}.= " room $room ";
						} else {
							$problems{"max_prefs"}.= " sect $letter ";
						}

						$problems{"max_prefs"}.= " above max pref for $bracket-".($round->name - 1 - $bracket)." $code ($rating) </p>";
					}
				}
			}
		}

		# UNSCHEDULED ENTRIES

		$tags{"unscheduled_entries"} = "Entries left out of the round";

		unless ($round->type eq "elim" || $round->type eq "final" || $round->type eq "runoff") {

			Tab::Entry->set_sql( not_assigned => "
				select entry.*
				from entry
				where entry.event = ?
				and entry.active = 1
				and not exists (
					select ballot.id
					from ballot, panel
					where panel.round = ?
					and ballot.panel = panel.id
					and ballot.entry = entry.id)"
			);

			foreach my $entry (Tab::Entry->search_not_assigned( $event->id, $round->id )) {
				$problems{"unscheduled_entries"}.= '<p class="warning padless marno">
				'. $entry->code. " is not scheduled ". $round_realname ."</p>";
			}
		}

		# ENTRIES SCHEDULED TOO MANY TIMES

		$tags{"double_scheduled_entries"} = "Entries scheduled more than once";

		Tab::Entry->set_sql( assigned_twice => "
			select entry.*
			from entry, ballot b1, panel p1, ballot b2, panel p2

			where entry.id = b1.entry
			and b1.panel = p1.id
			and entry.id = b2.entry
			and b2.panel = p2.id

			and p1.id > p2.id
			and p1.round = ?
			and p1.round = p2.round
			group by entry.id
		");

		foreach my $entry (Tab::Entry->search_assigned_twice($round->id )) {
			$problems{"double_scheduled_entries"}.= '<p class="warning padless marno">'
				. $entry->code. " is scheduled twice in the same round ". $round_realname ."</p>";
		}

		#MEETING OWN DISTRICT
		if ($tourn_settings->{"nsda_nats"}) {

			my $district_sth = $dbh->prepare("
				select entry.id, entry.code, entry.name,
					panel.letter, panel.id panel_id,
					district.id as district_id, district.name as district_name, district.code as district_code

				from (entry, ballot, panel, round)

					left join school on entry.school = school.id
					left join district on district.id = school.district

				where 1=1
					and entry.id = ballot.entry
					and ballot.panel = panel.id
					and panel.round = round.id
					and round.id = ?
					and round.type != 'final'
				group by entry.id
				order by panel.id, district.id
			");

			my %edone = ();
			$district_sth->execute($round->id);

			my $entries = $district_sth->fetchall_hash();

			my %districts;
			my %sections;
			my %district_totals;

			foreach my $entry (@{$entries}) {

				unless ($districts{$entry->{district_id}}) {
					$districts{$entry->{district_id}} = ({
						name => $entry->{district_name},
						code => $entry->{district_code},
					});
				}

				if ($entry->{district_id}) {
					$district_totals{$entry->{district_id}}{$entry->{letter}}++;
					$districts{$entry->{district_id}}{"total"}++;
					$sections{$entry->{letter}}++;
				}
			}

			my $num_sections = scalar(keys %sections);

			foreach my $district_id (keys %districts) {

				my $district = $districts{$district_id};
				my $num_entries = $districts{$district_id}{total};

				if ($num_sections > $num_entries) {

					foreach my $letter (keys %{$district_totals{$district_id}}) {

						if ($district_totals{$district_id}{$letter} > 1) {
							$problems{"same_district_sections"} .= '<p class="warning padless marno">';
							$problems{"same_district_sections"} .= "$round_realname Section $letter has ";
							$problems{"same_district_sections"} .= $district_totals{$district_id}{$letter}." ";
							$problems{"same_district_sections"} .= "entries from district ".$district->{code}."</p>";
						}
					}
				}
			}



			$tags{"same_district_sections"} = "Entry: same district hits";
			Tab::Entry->columns("TEMP", "distname");

			Tab::Entry->set_sql( same_district_sections => "
				select entry.*, opp.code as othername, district.name as distname
					from entry, ballot, panel, school, round,
					entry opp, ballot oballot, school oppschool, district

				where entry.id = ballot.entry
					and ballot.panel = oballot.panel
					and oballot.entry = opp.id
					and ballot.panel = panel.id
					and panel.round = round.id
					and round.id = ?
					and round.type != 'final'
					and opp.school = oppschool.id
					and entry.school = school.id
					and school.district > 0
					and school.district = oppschool.district
					and school.district = district.id
					and opp.id < entry.id
			");

			my %done;

			foreach my $entry (Tab::Entry->search_same_district_sections($round->id )) {
				next if $done{$entry->code."-".$entry->othername}++;
				$problems{"same_district_sections"} .= '<p class="warning padless marno">';
				$problems{"same_district_sections"} .= $entry->code." and ".$entry->othername;
				$problems{"same_district_sections"} .= " are from the ".$entry->distname." district! ". $round_realname ."</p>";
			}

			if ($event_type eq "congress") {

                if ($tourn_settings->{'district_regions'} ) {

					$tags{"same_district_regions"} = "Entry: same metro regional hits";

					my %district_region;

                    my %regions_by_id = map {$_->id => $_} $tourn->regions;

                    eval {
                        %district_region = %{JSON::decode_json $tourn_settings->{'district_regions'}};
                    };

					my $dr_sth = $dbh->prepare("
						select
							panel.id, panel.letter, entry.code, school.district
						from  (panel, ballot, entry, school, round)
						where panel.round = round.id
							and round.id = ?
							and round.type != 'final'
							and panel.id = ballot.panel
							and ballot.entry = entry.id
							and entry.active = 1
							and entry.school = school.id
					");

					$dr_sth->execute($round->id);

					my %counter;
					my $result_refs = $dr_sth->fetchall_hash();

					my %done;
					my %tourn_regions = map {$_->id => $_->code} $tourn->regions;

					foreach my $result (@{$result_refs}) {

						my $region = $district_region{$result->{"district"}};
						my $code = $counter{$result->{"id"}}{$region};

						if ($region) {
							if (
								$code
								&& $code ne $result->{code}
								&& (not defined $done{$code}{$result->{code}})
							) {
								$problems{"same_district_regions"} .= '<p class="warning padless marno">';
								$problems{"same_district_regions"} .= 'Section '.$result->{letter}.': ';
								$problems{"same_district_regions"} .= $code." and ".$result->{"code"};
								$problems{"same_district_regions"} .= " are both from the ".$tourn_regions{$region}." metro region ". $round_realname ."</p>";
								$done{$code}{$result->{code}}++;
								$done{$result->{code}}{$code}++;
							} else {
								$counter{$result->{"id"}}{$region} = $result->{"code"};
							}
						}

					}


                }
			}
		}

		unless (
			$event_type eq "speech"
			|| $event_type eq "congress"
			|| $round->type eq "elim"
			|| $round->type eq "final"
		) {

			$tags{"same_school_sections"} = "Entry: same school hits";

			Tab::Entry->set_sql( same_school_sections => "
				select entry.*, opp.code as othername
					from entry, ballot, panel, entry opp, ballot oballot
				where entry.id = ballot.entry
					and ballot.panel = oballot.panel
					and oballot.entry = opp.id
					and ballot.panel = panel.id
					and panel.round = ?
					and opp.school = entry.school
					and opp.id < entry.id
			");

			my %done;

			foreach my $entry (Tab::Entry->search_same_school_sections($round->id )) {
				next if $done{$entry->code."-".$entry->othername}++;
				$problems{"same_school_sections"} .= '<p class="warning padless marno">';
				$problems{"same_school_sections"} .= $entry->code." and ".$entry->othername;
				$problems{"same_school_sections"} .= " are from the same school! ". $round_realname ."</p>";
			}

			if ($tourn->webname eq "texasopen") {

				Tab::Entry->set_sql( same_school_sections => "
					select entry.*, opp.code as othername
						from entry, ballot, panel, entry opp, ballot oballot, school_setting pairing_school
					where entry.id = ballot.entry
						and ballot.panel = oballot.panel
						and oballot.entry = opp.id
						and ballot.panel = panel.id
						and panel.round = ?
						and opp.school = pairing_school.school
						and pairing_school.tag = 'pairing_school'
						and pairing_school.value = entry.school
				");

				my %done;

				foreach my $entry (Tab::Entry->search_same_school_sections($round->id )) {
					next if $done{$entry->code."-".$entry->othername}++;
					$problems{"same_school_sections"} .= '<p class="warning padless marno">';
					$problems{"same_school_sections"} .= $entry->code." and ".$entry->othername;
					$problems{"same_school_sections"} .= " are from the same school! ". $round_realname ."</p>";
				}
			}
		}

		#MEETING OWN SCHOOL

		unless (
			$event_type eq "speech"
			|| $event_type eq "congress"
			|| $round->type eq "elim"
			|| $round->type eq "final"
		) {

			$tags{"same_school_sections"} = "Entry: same school hits";

			Tab::Entry->set_sql( same_school_sections => "
				select entry.*, opp.code as othername
				from entry, ballot, panel,
				entry opp, ballot oballot

					where entry.id = ballot.entry
					and ballot.panel = oballot.panel
					and oballot.entry = opp.id
					and ballot.panel = panel.id
					and panel.round = ?
					and opp.school = entry.school
					and opp.id < entry.id
			");

			my %done;

			foreach my $entry (Tab::Entry->search_same_school_sections($round->id )) {
				next if $done{$entry->code."-".$entry->othername}++;
				$problems{"same_school_sections"} .= '<p class="warning padless marno">';
				$problems{"same_school_sections"} .= $entry->code." and ".$entry->othername;
				$problems{"same_school_sections"} .= " are from the same school! ". $round_realname ."</p>";
			}
		}

		if ($event_type eq "debate"
			&& $round->type ne "elim"
			&& $round->type ne "final"
		) {

			# TWO BYES

			$tags{"two_entry_byes"} = "Entries with more than one bye";

			my $twobyes_sth = $dbh->prepare("

				select entry.id, entry.code, otherround.id, otherround.name

				from entry, ballot, panel, round,
					ballot otherballot, panel otherpanel, round otherround

				where round.id = ?
					and panel.round = round.id
					and ballot.panel = panel.id
					and ballot.entry = entry.id
					and (
						ballot.bye = 1
						or panel.bye = 1
					)

					and otherballot.entry = entry.id
					and otherballot.panel = otherpanel.id
					and otherpanel.round = otherround.id
					and otherround.id != round.id
					and (
						otherballot.bye = 1
						or otherpanel.bye = 1
					)
					and otherround.type NOT IN ('elim', 'final')
			");

			$twobyes_sth->execute($round->id);

			while(
				my ($entry, $code, $otherround, $othername) = $twobyes_sth->fetchrow_array()
			) {
				$problems{"two_entry_byes"} .= '<p class="warning padless marno">';
				$problems{"two_entry_byes"} .= $code." also got a bye in round $othername  ". $round_realname ."</p>";
			}
		}

		if ($event_settings{"region_avoid"}
			|| $event_settings{"region_constrain"}
		) {

			#MEETING OWN REGION

			$tags{"same_region_sections"} = "Entries hits within region";

			if ($tourn_settings->{"ncfl"}) {
				$tags{"same_region_sections"} = "Entries hits within diocese";
			}

			my $region_sth = $dbh->prepare("
				select entry.id, entry.code, entry.name,
					panel.letter, panel.id panel_id,
					region.id as region_id, region.name as region_name, region.code as region_code

				from (entry, ballot, panel, round)

					left join school on entry.school = school.id
					left join region on region.id = school.region

				where 1=1
					and entry.id = ballot.entry
					and ballot.panel = panel.id
					and panel.round = round.id
					and round.id = ?
					and round.type != 'final'
				group by entry.id
				order by panel.id, region.id
			");

			my %edone = ();
			$region_sth->execute($round->id);

			my $entries = $region_sth->fetchall_hash();

			my %regions;
			my %sections;
			my %region_totals;

			foreach my $entry (@{$entries}) {

				unless ($regions{$entry->{region_id}}) {
					$regions{$entry->{region_id}} = ({
						name => $entry->{region_name},
						code => $entry->{region_code},
					});
				}

				if ($entry->{region_id}) {
					$region_totals{$entry->{region_id}}{$entry->{letter}}++;
					$regions{$entry->{region_id}}{"total"}++;
					$sections{$entry->{letter}}++;
				}
			}

			my $num_sections = scalar(keys %sections);

			foreach my $region_id (keys %regions) {

				my $region = $regions{$region_id};
				my $num_entries = $regions{$region_id}{total};

				if ($num_sections > $num_entries) {

					foreach my $letter (keys %{$region_totals{$region_id}}) {

						if ($region_totals{$region_id}{$letter} > 1) {
							$problems{"same_region_sections"} .= '<p class="warning padless marno">';
							$problems{"same_region_sections"} .= "$round_realname Section $letter has ";
							$problems{"same_region_sections"} .= $region_totals{$region_id}{$letter}." ";
							$problems{"same_region_sections"} .= "entries from region ".$region->{code}." </p>";
						}
					}
				}
			}
		}

		# TOURNAMENT IS GOING TO END AND YOUR WORLD WILL END WITH IT

		$tags{"tournament_ends_first_$round"} = "Round extends past tournament end time";

		if ($timeslot->end->epoch > $tourn->end->epoch) {

			my $end_time = $m->comp("/funclib/showtime.mas",
				dt     => $tourn->end,
				tzname => 'yes',
				tz     => $tourn->tz,
				length => "formalday",
				return => 1
			);

			$problems{"tournament_ends_first_$round"}
				= '<p class="warning padless marno"> Tournament end is scheduled at '.$end_time.', which is before '.$round->realname.' concludes.  Judges will lose access to online ballots, NSDA points will post, and Campus rooms will shut down at that time.  Please correct one or the other!</p>';
			$titles{"tournament_ends_first_$round"} = "DO NOT PUMPKIN THE TOURNAMENT";
		}

		# DEBATES SHORT ON FULL PANELS OF JUDGING

		my $num_judges = $round->setting('num_judges') || 1;
		$num_judges++ if $event_type eq "congress"; #count the parli!

		$tags{"judge_short_sections_$round"} = "Judges panels short of the required ".$num_judges;
		$tags{"judge_short_sections_$round"} = "Judges missing" if $num_judges == 1;

		my $short_panel_sth = $dbh->prepare("
			select panel.letter, count(distinct judge.id), room.name
			from (panel, ballot)
			left join room on room.id = panel.room
			left join judge on ballot.judge = judge.id
			where panel.round = ?
			and panel.id = ballot.panel
			and panel.bye != 1
			group by panel.id
			order by room.name, panel.id
		");

		$short_panel_sth->execute($round->id);

		my %panel_judgecount = ();
		my %panel_judgeroom = ();

		my $has_judges;

		while (
			my ($panel, $count, $room)
			= $short_panel_sth->fetchrow_array()
		) {

			$has_judges += $count;

			next if $count >= $num_judges;

			$panel_judgecount{$panel} = $count;
			$panel_judgecount{$panel} = 0 unless $count;
			$panel_judgeroom{$panel} = $room;

			$problems{"judge_short_sections_$round"}
				.= '<p class="warning padless marno">'
				. "Room ".$panel_judgeroom{$panel}." has ". $panel_judgecount{$panel} ." judges.  ". $round_realname ."</p>";

		}

		foreach my $panel ($round->panels) {
			next if $num_judges <= $panel_judgecount{$panel};
		}

		unless ($has_judges > 0) {
			$problems{"judge_short_sections_$round"}
				= '<p class="warning padless marno"> No judges have been assigned to '. $round_realname .'</p>';
		}

		undef %panel_judgecount;
		undef $num_judges;

		unless (
			$event_settings{"online_mode"}
			&& $event_settings{"online_mode"} ne "sync"
			&& (not defined $event_settings{"online_hybrid"})
		) {

			#ROOMS: ROUNDS WITH NO ROOMS

			$tags{"roomless_sections"} = "Rooms assigned ";

			Tab::Panel->set_sql( roomless_sections => "
				select distinct panel.*, e1.code as opp, e2.code as pos, room.name as roomname, room.id as roomid
				from (panel, ballot b1, ballot b2, entry e1, entry e2)
				left join room on panel.room = room.id

				where panel.round = ?
				and panel.bye != 1
				and panel.id = b1.panel
				and b1.bye !=1
				and b1.forfeit !=1
				and b1.entry = e1.id

				and panel.id = b2.panel
				and b2.bye !=2
				and b2.forfeit !=2
				and b2.entry = e2.id

				AND (
					not exists ( select es2.id from entry_setting es2 where es2.entry = e2.id and es2.tag = 'online_hybrid')
					OR not exists ( select es1.id from entry_setting es1 where es1.entry = e1.id and es1.tag = 'online_hybrid')
				)

				group by panel.id
			");

			my $roomy_sections = $dbh->prepare("select count(panel.id) from panel, room where panel.room = room.id and panel.round = ?");
			$roomy_sections->execute($round->id);
			my $value = $roomy_sections->fetch();

			my $any_rooms;

			Tab::Panel->columns(TEMP => "roomid");

			foreach my $panel (Tab::Panel->search_roomless_sections($round->id )) {

				if ($panel->roomid > 0) {
					$any_rooms++;
				} else {
					if ($event_type eq "debate") {

						$problems{"roomless_sections"}
						.= '<p class="warning padless marno">'.
							"Section ".$panel->letter." between "
							.$panel->opp." and ".$panel->pos." has no room!  ". $round_realname ."</p>";

					} else {

						$problems{"roomless_sections"}
						.= '<p class="warning padless marno">'.
							"Section ".$panel->letter." has no room!  ". $round_realname ."</p>";
					}

					undef $panel;
				}
			}

			unless ($any_rooms) {
				delete $problems{"roomless_sections"};
				$problems{"roomless_sections"} .= '<p class="warning padless marno"> No rooms have been assigned to round '. $round_realname .'</p>';
			}
		}

		if ($tourn_settings->{'nsda_district'}) {
			#SIDELOCK SETTINGS
			$tags{"sidelock_setting"} = "Side-locks set incorrectly";

			my $sidelock_sth = $dbh->prepare("
				select distinct rs.id
					from round_setting rs
					where rs.round = ?
					and rs.tag = 'sidelock_against'
			");

			$sidelock_sth->execute($round->id);

			my $bad = $sidelock_sth->fetch();

			if ($bad) {
				$problems{"sidelock_setting"}.= '<p class="warning padless marno"> '.$round->realname.' has a sidelock setting which is not appropriate for Districts.  Please correct in Settings tab of the schematic</p>';
			}
		}

		if (
			($event_type eq "debate" && $round->type ne "elim" && $round->type ne "final")
			|| (
				($tourn_settings->{'ncfl'} || $tourn_settings->{'nsda_nats'})
				&& $event_type eq "speech"
				&& $round->type eq "prelim"
			)
		) {

			#ENTRIES PREVIOUS MET
			$tags{"hit_before"} = "Entries who previously met";

			my $limit;
			if ($event_type eq "speech") {
				$limit = "and otherround.type = 'prelim'";
			}

			my $second_hit_sth = $dbh->prepare("
				select distinct me.code,
					opp.code othername, otherround.name roundname,
					me_b1.side side1, me_b2.side side2,
					otherround.type

				from entry me, entry opp, round otherround,

					ballot me_b1, ballot opp_b1, panel p1,
					ballot me_b2, ballot opp_b2, panel p2

					where me_b1.entry = me.id
					and opp_b1.entry  = opp.id
					and me_b1.panel   = opp_b1.panel
					and me_b1.panel   = p1.id

					and p1.round = ?

					and me_b2.entry  = me.id
					and opp_b2.entry = opp.id
					and me_b2.panel  = opp_b2.panel
					and me_b2.panel  = p2.id
					and p2.round 	!= p1.round
					and p2.round     = otherround.id
					$limit

					and me.id > opp.id
			");

			$second_hit_sth->execute($round->id);

			while (
				my ($entry, $opp, $round, $side1, $side2, $type)
				= $second_hit_sth->fetchrow_array()
			) {

				if ($event_type eq "speech" || $event_type eq "congress") {

					$problems{"hit_before"}.= '<p class="warning padless marno">'
						. "Entry $entry hit $opp in round $round ";

				} else {

					$problems{"hit_before"}.= '<p class="warning padless marno">'
						. "Entry $entry debated $opp already in round $round ";
					$problems{"hit_before"}.= "on the SAME SIDE  ". $round_realname ."</p>" if $side1 == $side2;
					$problems{"hit_before"}.= "on the OPPOSITE SIDE  ". $round_realname ."</p>" if $side1 != $side2;
				}
			}

		}

		if ($event_type eq 'speech' || $event_type eq "congress") {

			# UNBALANCED SECTIONS OR CHAMBERS

			$tags{"unbalanced"} = "Unbalanced section sizes" if $event_type eq "speech";
			$tags{"unbalanced"} = "Unbalanced chamber sizes" if $event_type eq "congress";

			#check to make sure this honors school preclusions
			my $unbalance_sth = $dbh->prepare("
				select panel.id, panel.letter, count(distinct ballot.entry), room.name
				from (panel, ballot, entry)
				left join room on room.id = panel.room
				where panel.round = ?
					and panel.id = ballot.panel
					and ballot.entry = entry.id
					and entry.active = 1
				group by panel.id
			");

			my $min_size;
			my $max_size;
			my %panels_at_size;

			$unbalance_sth->execute($round->id);

			while (
				my ($panel_id, $panel_letter, $ballot_count, $room_name) = $unbalance_sth->fetchrow_array()
			) {

				$panels_at_size{$ballot_count} .= ", " if $panels_at_size{$ballot_count};
				$panels_at_size{$ballot_count} .= $panel_letter;
				$panels_at_size{$ballot_count} .= " in ".$room_name if $room_name;

				$max_size = $ballot_count if ($ballot_count > $max_size);
				$min_size = $ballot_count if (not defined $min_size);
				$min_size = $ballot_count if $ballot_count < $min_size;
			}

			if ( ($max_size - $min_size) > 1) {

				if ($event_type eq "congress") {
					$problems{"unbalanced"}.= '<p class="warning padless marno">'
						." Chambers with $min_size: ".$panels_at_size{$min_size}
						."<br/> Chambers with $max_size: ".$panels_at_size{$max_size}
						."  ". $round_realname ."</p>";

				} else {
					$problems{"unbalanced"}.= '<p class="warning padless marno">'
						." Sections with $min_size: ".$panels_at_size{$min_size}
						." Sections with $max_size: ".$panels_at_size{$max_size}
						."  ". $round_realname ."</p>";
				}
			}
		}

		#JUDGES: HEARING A BLOCKED TEAM/SCHOOL

		$tags{"judge_preclusion"} = "Judges constraints/preclusions violated";

		#check to make sure this honors school preclusions
		my $strikes_sth = $dbh->prepare("
			select judge.first, judge.last, entry.code, panel.id, panel.letter, strike.type
				from strike, ballot, entry, judge, panel
			where panel.round = ?
				and panel.id =  ballot.panel
				and ballot.entry = entry.id
				and ballot.judge = judge.id
				and strike.entry = entry.id
				and strike.judge = judge.id
		");

		$strikes_sth->execute($round->id);

		while (
			my ($judge_first, $judge_last, $entry, $panel, $panel_letter, $type)
			= $strikes_sth->fetchrow_array()
		) {
			$type = ucfirst($type);
			$problems{"judge_preclusion"}.= '<p class="warning padless marno">'
				." $judge_first $judge_last is judging $entry in section $panel_letter,
					but has a preclusion of type $type  ". $round_realname ."</p>";
		}

		$strikes_sth = $dbh->prepare("
			select judge.first, judge.last, entry.code, panel.id, panel.letter, strike.type, school.name
				from strike, ballot, entry, judge, panel, school
			where panel.round = ?
				and panel.id =  ballot.panel
				and ballot.entry = entry.id
				and ballot.judge = judge.id
				and school.id = entry.school
				and strike.school = school.id
				and strike.judge = judge.id
		");

		$strikes_sth->execute($round->id);

		while (
			my ($judge_first, $judge_last, $entry, $panel, $panel_letter, $type, $school)
			= $strikes_sth->fetchrow_array()
		) {
			$type = ucfirst($type);
			$problems{"judge_preclusion"}.= '<p class="warning padless marno"> Section '.$panel_letter.": ";
			$problems{"judge_preclusion"}.= "$judge_first $judge_last judging $entry from $school, preclusion $type $round_realname";
			$problems{"judge_preclusion"}.= "</p>";
		}

		$strikes_sth = $dbh->prepare("
			select judge.first, judge.last, entry.code, panel.id, panel.letter, strike.type, region.code
				from strike, ballot, entry, judge, panel, school, region
			where panel.round = ?
				and panel.id =  ballot.panel
				and ballot.entry = entry.id
				and ballot.judge = judge.id
				and school.id = entry.school
				and strike.region = school.region
				and school.region = region.id
				and strike.judge = judge.id
		");

		$strikes_sth->execute($round->id);

		while (
			my ($judge_first, $judge_last, $entry, $panel, $panel_letter, $type, $region)
			= $strikes_sth->fetchrow_array()
		) {
			$type = ucfirst($type);
			$problems{"judge_preclusion"}.= '<p class="warning padless marno"> Section '.$panel_letter.": ";
			$problems{"judge_preclusion"}.= "$judge_first $judge_last judging $entry from $region, preclusion $type $round_realname";
			$problems{"judge_preclusion"}.= "</p>";
		}

		#JUDGES NOT AVAILABLE THIS ROUND

		$tags{"judge_timestrike"} = "Judges used but not currently available";

		my $time_strikes_sth = $dbh->prepare("
			select distinct judge.id, judge.first, judge.last
				from judge, ballot, panel, round, strike, timeslot
			where round.id = ?
				and round.id = panel.round
				and panel.id = ballot.panel
				and ballot.judge = judge.id
				and strike.judge = judge.id
				and timeslot.id = round.timeslot
				and strike.start <= timeslot.end
				and strike.end >= timeslot.start
		");

		$time_strikes_sth->execute($round->id);

		while (
			my ($id, $first, $last)
			= $time_strikes_sth->fetchrow_array()
		) {
			$problems{"judge_timestrike"}.= '<p class="warning padless marno">
				Judge '. $first." ".$last." is unavailable for this round! ". $round_realname ."</p>";
		}

		# MY OWN HIRES

		if ($event->category->setting("auto_conflict_hires")) {

			$tags{"hired_judging_me"} = "Hires judging the program paying them";

			Tab::JudgeHire->set_sql( "hires_judging_me" => "
				select distinct judge_hire.*
					from judge, ballot, judge_hire, entry, panel
				where panel.round = ?
					and panel.id = ballot.panel
					and ballot.judge = judge.id
					and ballot.entry = entry.id
					and entry.school = judge_hire.school
					and judge.id = judge_hire.judge
				group by entry.id
			");

			foreach my $conflict (Tab::JudgeHire->search_hires_judging_me($round_id)) {
				$problems{"hired_judging_me"} = $conflict->judge->first." ".$conflict->judge->last."
					is judging ".$conflict->school->name." who has hired them.";
			}

		}

		# ENTRY: ADA rooms
		$tags{"ada_room"} = "ADA requirements not met";

		Tab::Entry->set_sql("ada" => "
			select distinct me.*, room.name othername
			from entry me,
			ballot, panel, room
			where panel.round = ?
				and ballot.panel = panel.id
				and ballot.entry = me.id
				and panel.room = room.id
				and room.ada != 1
				and me.ada = 1
		");

		foreach my $entry (Tab::Entry->search_ada($round->id)) {
			$problems{"ada_room"} .= '<p class="warning padless marno"> Entry '
				. $entry->code." is in non-ADA room ".$entry->othername."  ". $round_realname ."</p>";
		}

		# JUDGE: ADA rooms
		Tab::Judge->columns(TEMP => qw/othername/);
		Tab::Judge->set_sql("ada" => "
			select distinct me.*, room.name othername
			from judge me,
			ballot, panel, room
			where panel.round = ?
				and ballot.panel = panel.id
				and ballot.judge = me.id
				and panel.room = room.id
				and room.ada != 1
				and me.ada = 1
		");

		foreach my $judge (Tab::Judge->search_ada($round->id)) {
			$problems{"ada_room"} .= '<p class="warning padless marno"> Judge '
				.$judge->first." ".$judge->last." is in non-ADA room ".$judge->othername."  ". $round_realname ."</p>";
		}

		# ROOM RESERVATIONS
		Tab::Judge->columns(TEMP => qw/inroom reserved/);
		Tab::Judge->set_sql("reserved" => "
			select distinct me.*, room.name inroom, reserved_room.name reserved
			from judge me,
				ballot, panel, room, judge_setting reserved, room reserved_room
			where panel.round = ?
				and ballot.panel = panel.id
				and ballot.judge = me.id
				and panel.room = room.id
				and room.id != reserved.value
				and reserved.judge = me.id
				and reserved.tag = 'room_reserved'
				and reserved.value = reserved_room.id
		");

		$tags{"reserved_room"} = "Room Reservation requirements not met";
		foreach my $judge (Tab::Judge->search_reserved($round->id)) {
			$problems{"reserved_room"} .= '<p class="warning padless marno"> Judge '
				.$judge->first." ".$judge->last." is room ".$judge->inroom."  ". $round_realname ." but reserved to ".$judge->reserved."</p>";
		}

		if ($event_type eq "debate") {

			unless ($event_settings{"hybrids_can_hit"}) {

				# ENTRY: HIT HYBRID PARTNER

				$tags{"hybrid_team_hit"} = "Entries hitting a hybrid preclusion";

				Tab::Entry->set_sql( "hybrid" => "
					select distinct me.*, otherschool.name othername

					from entry me, school otherschool,
					strike hybrid,
					ballot b1, ballot b2, entry opp,
					panel

					where panel.round = ?
						and panel.id = b1.panel
						and b1.panel = b2.panel
						and b1.entry != b2.entry
						and b1.entry = me.id

						and b1.entry = hybrid.entry
						and hybrid.type = 'hybrid'
						and hybrid.school = opp.school
						and opp.id = b2.entry
						and opp.school = otherschool.id
				");

				foreach my $entry (Tab::Entry->search_hybrid($round->id)) {
					$problems{"hybrid_team_hit"} .= '<p class="warning padless marno">'
						. $entry->code." debates against hybrid precluded school ".$entry->othername."  ". $round_realname ."</p>";
				}
			}

			if (scalar ($event->rounds( type => "prelim")) < 4) {

				# ENTRY: HIT SAME SCHOOL TWICE IN PRESETS

				if ($round->type eq "prelim") {

					$tags{"same_school_twice"} = "Entries debating a program twice in presets";

					Tab::Entry->set_sql( "same_school_twice" => "

						select distinct me.*, otherschool.name othername

						from entry me, school otherschool,
							entry opp1, ballot b1, panel p1, ballot ob1,
							entry opp2, ballot b2, panel p2, ballot ob2, round r2

							where me.id = b1.entry
							and b1.panel = p1.id
							and ob1.panel = p1.id
							and opp1.id = ob1.entry
							and ob1.entry != me.id

							and me.id = b2.entry
							and b2.panel = p2.id
							and ob2.panel = p2.id
							and opp2.id = ob2.entry
							and ob2.entry != me.id

							and p1.round != p2.round
							and p1.round = ?
							and p2.round = r2.id
							and r2.type = 'prelim'

							and opp1.id != opp2.id
							and opp1.school = opp2.school
							and opp1.school = otherschool.id

					");

					foreach my $entry (Tab::Entry->search_same_school_twice($round->id)) {
						$problems{"same_school_twice"} .= '<p class="warning padless marno">'
							. $entry->code." debates against entries from  ".$entry->othername
							." twice in presets.  ". $round_realname ."</p>";
					}

				}

				# ENTRY: HIT SAME REGION TWICE IN PRESETS

				if ($round->type eq "prelim"
					&& ($event_settings{"region_avoid"}
					|| $event_settings{"region_constrain"})
				) {

					$tags{"same_region_twice"} = "Entries debating a region twice in presets";

					Tab::Entry->set_sql( same_region_twice => "

						select distinct me.*, otherregion.name othername
						from entry me, region otherregion,
							entry opp1, ballot b1, panel p1, ballot ob1, school s1,
							entry opp2, ballot b2, panel p2, ballot ob2, school s2, round r2

							where me.id = b1.entry
							and b1.panel = p1.id
							and ob1.panel = p1.id
							and opp1.id = ob1.entry
							and ob1.entry != me.id

							and me.id = b2.entry
							and b2.panel = p2.id
							and ob2.panel = p2.id
							and opp2.id = ob2.entry
							and ob2.entry != me.id

							and p1.round != p2.round
							and p1.round = ?
							and p2.round = r2.id
							and r2.type = 'prelim'

							and opp1.school = s1.id
							and opp2.school = s2.id

							and s1.region = s2.region
							and s1.region = otherregion.id

							and opp1.school != opp2.school
					");

					foreach my $entry (Tab::Entry->search_same_region_twice($round->id)) {
						$problems{"same_region_twice"} .= '<p class="warning padless marno">'.
							$entry->code." debates against entries from
							".$entry->othername." twice in presets.  ". $round_realname ."</p>";
					}

				}
			}
		}

		# JUDGES: HEARD ENTRY BEFORE

		$tags{"judged_before"} = "Judges judging an entry twice";

		my $second_judged_sth = $dbh->prepare("

			select distinct entry.code, judge.first, judge.last, round.name, b1.side, b2.side, round.type,
				b1.chair, b2.chair, round.type

			from entry, judge, ballot b1, ballot b2, panel p1, panel p2, round

				where p1.round = ?
				and p1.id = b1.panel
				and b1.entry = entry.id
				and b1.judge = judge.id

				and p2.round != p1.round
				and p2.id = b2.panel
				and b2.entry = entry.id
				and b2.judge = judge.id
				and round.id = p2.round

		");

		$second_judged_sth->execute($round->id);

		my $allow_elim = $event_settings{"allow_repeat_elims"};

		unless (
			($allow_elim && $round->type eq "elim")
			|| ($allow_elim && $round->type eq "final")
			|| ($allow_elim && $round->type eq "runoff")
		) {

			while (
				my ($entry, $first, $last, $roundname, $side1, $side2, $type,
					$chair1, $chair2, $roundtype2)
				= $second_judged_sth->fetchrow_array()
			) {

				next if $allow_elim && $type eq "elim";
				next if $allow_elim && $type eq "final";
				next if $allow_elim && $type eq "runoff";

				next if $event_type eq "congress"
					&& ($chair1 == $chair2)
					&& ($round->type eq $roundtype2);

				$problems{"judged_before"} .= '<p class="warning padless marno">';
				$problems{"judged_before"} .= "Judge $first $last already judged $entry in round $roundname ";
				unless ($event_type eq "speech" || $event_type eq "congress") {
					$problems{"judged_before"} .= "on the SAME SIDE  ". $round_realname ."</p>" if $side1 == $side2;
					$problems{"judged_before"} .= "on the OPPOSITE SIDE  ". $round_realname ."</p>" if $side1 != $side2;
				}
			}
		}

		# JUDGES: SAME SCHOOL AND/OR REGION

		unless ($tourn_settings->{"nsda_nats"}) {

			if ($event_settings{"region_avoid"}
				|| $event_settings{"region_constrain"}
				|| $event_settings{"region_judge_forbid"}
				|| $tourn_settings->{"ncfl"}
			) {

				my $region_judged_sth;

				$tags{"judged_region"} = "Judges judging their own ";

				if ($tourn_settings->{"ncfl"}) {
					$tags{"judged_region"} .= " diocese";
				} else {
					$tags{"judged_region"} .= " region";
				}

				$region_judged_sth = $dbh->prepare("
					select distinct entry.code, judge.first, judge.last, region.name
						from entry, judge, panel, ballot,
							school judgeschool, school entryschool, region
						where panel.round = ?
							and ballot.panel = panel.id
							and ballot.entry = entry.id
							and ballot.judge = judge.id
							and judge.school = judgeschool.id
							and entry.school = entryschool.id
							and judgeschool.region = entryschool.region
							and entryschool.region = region.id
				");

				$region_judged_sth->execute($round->id);

				while (my ($entry, $first, $last, $name)  = $region_judged_sth->fetchrow_array() ) {
					$problems{"judged_region"} .= '<p class="warning padless marno">';
					$problems{"judged_region"} .= "Judge $first $last is judging $entry, both are from $name ";
				}
			}
		}

		# SAME STATE  (NSDA NATS)

		if (
			$tourn_settings->{"nsda_nats"}
			&& ($round->name < $event_settings{"state_constraint_threshold"}
				|| (not defined $event_settings{"state_constraint_threshold"})
			)
		) {

			$tags{"judged_state"} = "Judges judging their own state";

			my $state_judged_sth;

			$state_judged_sth = $dbh->prepare("
				select distinct entry.code, judge.first, judge.last, entryregion.code, panel.letter
					from entry, judge, panel, ballot,
						school entryschool, region entryregion,
						school judgeschool, region judgeregion

					where panel.round = ?
					and ballot.panel = panel.id
					and ballot.entry = entry.id
					and ballot.judge = judge.id
					and entry.school = entryschool.id
					and entryschool.region = entryregion.id

					and judge.school = judgeschool.id
					and judgeschool.region = judgeregion.id

					and judgeregion.id = entryregion.id
			");

			$state_judged_sth->execute($round->id);

			while (my ($entry, $first, $last, $state, $letter)  = $state_judged_sth->fetchrow_array() ) {

				$problems{"judged_state"} .=
					'<p class="warning padless marno"> Section'." $letter: $first $last judging $entry ($state)";
			}


			$tags{"judged_district"} = "Judges judging their own district";

			my $district_judged_sth;

			$district_judged_sth = $dbh->prepare("
				select distinct entry.code, judge.first, judge.last, entrydistrict.code
					from entry, judge, panel, ballot,
						school entryschool, district entrydistrict,
						school judgeschool, district judgedistrict

					where panel.round = ?
					and ballot.panel = panel.id
					and ballot.entry = entry.id
					and ballot.judge = judge.id
					and entry.school = entryschool.id
					and entryschool.district = entrydistrict.id

					and judge.school = judgeschool.id
					and judgeschool.district = judgedistrict.id

					and judgedistrict.id = entrydistrict.id
			");

			$district_judged_sth->execute($round->id);

			while (my ($entry, $first, $last, $district)  = $district_judged_sth->fetchrow_array() ) {

				$problems{"judged_district"} .=
					'<p class="warning padless marno">'. "$first $last judging $entry ($district)";
			}


			if ($event_type eq "debate") {
				if ($round->type eq "prelim") {

					# SAME STATE TWICE IN PRESETS

					$tags{"same_state_twice"} = "Entries debating a state twice in prelims";

					Tab::Entry->set_sql( "same_state_twice" => "

						select distinct me.*, c1.state othername
							from entry me,
								entry opp1, ballot b1, panel p1, ballot ob1, school s1, chapter c1,
								entry opp2, ballot b2, panel p2, ballot ob2, school s2, chapter c2,
								round r2

						where me.id = b1.entry
							and b1.panel = p1.id
							and ob1.panel = p1.id
							and opp1.id = ob1.entry
							and ob1.entry != me.id

							and me.id = b2.entry
							and b2.panel = p2.id
							and ob2.panel = p2.id
							and opp2.id = ob2.entry
							and ob2.entry != me.id

							and p1.round != p2.round
							and p1.round = ?
							and p2.round = r2.id
							and r2.type = 'prelim'

							and opp1.id != opp2.id
							and opp1.school = s1.id
							and s1.chapter = c1.id

							and opp2.school = s2.id
							and s2.chapter = c2.id

							and c2.state = c1.state
							and c1.state is not null
							and c1.state != 0
					");

					foreach my $entry (Tab::Entry->search_same_state_twice($round->id)) {
						$problems{"same_state_twice"}
							.= '<p class="warning padless marno">'
							. $entry->code." debates against entries from  ".$entry->othername." twice in prelims.  ". $round_realname ."</p>";
					}
				}
			}
		}

		unless ($event_settings{"region_constrain"}) {

			my %dupes;
			my $own_judged_sth;
			$tags{"judged_own"} = "Judges judging their own program";

			$own_judged_sth = $dbh->prepare("
				select distinct entry.code, judge.id, judge.first, judge.last, school.name
					from entry, judge, panel, ballot, school
					where panel.round = ?
					and ballot.panel = panel.id
					and ballot.entry = entry.id
					and ballot.judge = judge.id
					and judge.school = entry.school
					and judge.school = school.id

					and not exists (
						select neutral.id
							from judge_setting neutral
						where neutral.judge = judge.id
							and neutral.tag = 'neutral'
					)
			");

			$own_judged_sth->execute($round->id);

			while (
				my ($entry, $judge_id, $first, $last, $name) = $own_judged_sth->fetchrow_array()
			) {

				next if $dupes{$judge_id}{$name}++;

				$problems{"judged_own"}.= '<p class="warning padless marno">'
				."Judge $first $last is judging entries from $name ";
			}

		}

		# JUDGES: HEARING BLOCKED DIVISION
		# ROOMS: ROOMS USED TOO MANY TIMES
		# ROOMS: NOT AVAILABLE


		## JUDGES FROM SAME STATE
		if ($tourn_settings->{"nsda_nats"}){
			@tags{"judges_from_same_state"} = "Judges from Same State";

			my $judges_from_same_state_sth = $dbh->prepare("
				SELECT DISTINCT panel.id, j1.first, j1.last, r1.code, j2.first, j2.last, r2.code
				FROM round, panel,
					ballot b1, school s1, chapter c1, judge j1, region r1,
					ballot b2, school s2, chapter c2, judge j2, region r2

				WHERE round.id = ?
				AND panel.round = round.id
				AND b1.panel = panel.id
				AND b1.judge = j1.id
				AND j1.school = s1.id
				AND s1.chapter = c1.id
				AND s1.region = r1.id

				AND b2.panel = panel.id
				AND b2.judge = j2.id
				AND j2.school = s2.id
				AND s2.chapter = c2.id
				AND s2.region = r2.id

				AND j1.id > j2.id
				AND r1.id = r2.id
			");
			$judges_from_same_state_sth->execute($round->id);

			while (
				my ($panel, $j1_first, $j1_last, $j1_state, $j2_first, $j2_last, $j2_state)
				= $judges_from_same_state_sth->fetchrow_array()
			) {
				$problems{"judges_from_same_state"}.='<p class="warning padless marno">
					Judges '. $j1_first .' '. $j1_last .' & '. $j2_first . ' ' . $j2_last .' are both from ' . $j1_state . ' '. $round_realname .'</p>';
			}


			@tags{"judges_from_same_district"} = "Judges from Same District";

			my $judges_from_same_district_sth = $dbh->prepare("
				SELECT DISTINCT panel.id, j1.first, j1.last, r1.code, j2.first, j2.last, r2.code
				FROM round, panel,
					ballot b1, school s1, chapter c1, judge j1, district r1,
					ballot b2, school s2, chapter c2, judge j2, district r2

				WHERE round.id = ?
				AND panel.round = round.id
				AND b1.panel = panel.id
				AND b1.judge = j1.id
				AND j1.school = s1.id
				AND s1.chapter = c1.id
				AND s1.district = r1.id

				AND b2.panel = panel.id
				AND b2.judge = j2.id
				AND j2.school = s2.id
				AND s2.chapter = c2.id
				AND s2.district = r2.id

				AND j1.id > j2.id
				AND r1.id = r2.id
			");
			$judges_from_same_district_sth->execute($round->id);

			while (
				my ($panel, $j1_first, $j1_last, $j1_district, $j2_first, $j2_last, $j2_district)
				= $judges_from_same_district_sth->fetchrow_array()
			) {
				$problems{"judges_from_same_district"}.='<p class="warning padless marno">
					Judges '. $j1_first .' '. $j1_last .' & '. $j2_first . ' ' . $j2_last .' are both from ' . $j1_district . ' '. $round_realname .'</p>';
			}
		}
	}

	</%init>

	<div class="main">
%		if ($event_id) {
			<h2><% $event->name %> disaster checks</h2>
%		} else {
			<h2><% $rounds[0]->realname %> disaster checks</h2>
%		}
<%perl>

		my @tags = sort {
			length $problems{$b} <=> length $problems{$a}
			|| $tags{$a} cmp $tags{$b}
		} keys %tags;

		foreach my $tag (@tags) {

			next if $issues_only && (not defined $problems{$tag});
</%perl>
			<div class="row full marvertno" title="<% $titles{$tag} %>">

				<span class="twofifths padvert semibold <% $problems{$tag} ? "orangetext" : "" %>">
					<span class="spacer"></span>
					<% $tags{$tag} %>
				</span>

%				if ($tag eq "sides_same" && $problems{$tag}) {
					<span class="threefifths nospace padleft">
						<% $problems{$tag} %>
					</span>
%				} else {
					<span class="threefifths nospace padleft">
						<% $problems{$tag}
							? $problems{$tag}
							: '<span class="centeralign full fa fa-lg nospace fa-check greentext"></span>'
						%>
					</span>
%				}
			</div>
% 		}

	</div>

	<div class="menu">
		<div class="sidenote">
%			foreach my $round (sort {$a->name <=> $b->name} @rounds) {
				<a
					class="full blue"
					href="/panel/schemat/show.mhtml?round_id=<% $round->id %>"
				>
					<% $round->realname %>
				</a>
%			}
		</div>
	</div>
