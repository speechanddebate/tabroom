<%args>
	$type
	$event
	@breaks
	$numpanels
	$round
</%args>
<%init> 

	# Snaking involves putting students in panels based on power.  They should
	# already be in order by seeding.  

	my $tourn = $event->tournament;

   # Preset panels
    my @panels = $round->panels;

	my $letter = "A";

	my %judges_by_panel = ();

	PANEL:
	foreach (1 .. $numpanels) { 
		
		#If there's already a panel here, use that instead
		my $key = $_ - 1;

        #If there's already a panel here, use that instead
        if ($panels[$key]) {
            $letter = $panels[$key]->letter;
            next PANEL;
        }

		my $panel = Tab::Panel->create({ 
			letter => $letter,
			round => $round->id,
			event => $event->id,
			type => $type
		});

		$letter++;

		push (@panels, $panel); 
	} 

	my @tmp_panels;
	my $rev = 1;
	my $seed;

	my %panel_by_break = ();


	foreach my $break (@breaks) {

		unless (@tmp_panels) { #if tmp_panels doesn't exist, reverse and resort

			$seed++;
			@tmp_panels = ( $rev == 0 ) ? @panels : reverse @panels;
		    $rev = ( $rev == 0 ) ? 1 : 0;

		}

		my $panel = shift @tmp_panels;

		$panel_by_break{$break->id} = $panel;

		foreach my $judge ($panel->judges) { 
	
			#Create the kid a ballot for each preset judge

			my $ballot = Tab::Ballot->create({
				panel => $panel->id,
				comp  => $break->id,
				judge  => $judge->id,
				speechnumber => 1,
				speakerorder => 0,
				seed => $seed
			});

		}

		unless ($panel->judges) { 

			#Create a ballot without a judge if there are no judges.

			my $ballot = Tab::Ballot->create({
				panel => $panel->id,
				comp  => $break->id,
				speechnumber => 1,
				speakerorder => 0,
				seed => $seed
			});
		}

	} #end of foreach break

	# Now check to see if any of the schools in the panel have a fixable
	# situation. 


	BREAK:
	foreach my $break (@breaks) {

		my $best_panel;
		my $switch_with;

		my $already_panel = $panel_by_break{$break->id};

		my $score = $already_panel->comp_school_score($break);

		next unless $score;


		foreach my $pan (@panels) { 
			$pan->tmp_score($pan->comp_school_score($break));
		}
	
		PANEL:
		foreach my $panel (sort {$a->tmp_score <=> $b->tmp_score} @panels) { 

			# If we haven't gotten to the point where we can productively move
			# this kid when the potential panel score is equal to the score of
			# the panel the kid is already in, move on in defeat. 

			next BREAK unless $panel->tmp_score < $score;

			# If this panel has a better score for my current kid, and it's the
			# lowest score so far (by the sort) then try to find a kid from
			# this panel who can move into the panel this kid came from.

			my $break_seed = $break->seed($already_panel);
			my $break_prelim_cume = $break->prelim_cume;
			my $break_cume = $break->cume;

			COMP:
			foreach my $comp ($panel->comps) { 

				# Basis is seed
				if ($tourn->method->elim_method_basis eq "seed") {
					next COMP unless $comp->seed($panel) eq $break_seed;
				}

				# Basis is preliminary round cumulative score
				if ($tourn->method->elim_method_basis eq "prelim_cume") { 
					next COMP unless $comp->prelim_cume eq $break_prelim_cume;
				}
				
				# Basis is overall cumulative score
				if ($tourn->method->elim_method_basis eq "overall_cume") { 
					next COMP unless $comp->cume eq $break_cume;
				}

				if ($already_panel->comp_school_score($comp) == 0 && $panel->comp_school_score($comp) > 0) { 
					$switch_with = $comp;
					$best_panel = $panel;
					#We have solved two problems here.  Woot.
					last PANEL;
				}

				if ($already_panel->comp_school_score($comp) == 0) { 
					$switch_with = $comp;
					$best_panel = $panel;
					next COMP;
				}

				if ($already_panel->comp_school_score($comp) <= $panel->comp_school_score($comp)) { 
					$switch_with = $comp;
					$best_panel = $panel;
				}

			} #end of foreach competitor

		
			if ($best_panel && $switch_with) { 

				$m->comp("/panel/comp_move.mas",    
					shut_up => "yes",
                   	tourn => $tourn,
               		comp_id => $break->id,
               		panel_id => $best_panel->id );

				$m->comp("/panel/comp_move.mas",    
					shut_up => "yes",
                   	tourn => $tourn,
               		comp_id => $switch_with->id,
               		panel_id => $already_panel->id );
			 
				$panel_by_break{$break->id} = $best_panel;
				$panel_by_break{$switch_with->id} = $already_panel;

			}

		}

	}

	foreach ($round->empties) { $_->delete; }
    $round->preset(0);
    $round->update;

	return;

</%init> 
