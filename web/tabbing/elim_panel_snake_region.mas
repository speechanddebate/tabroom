<%args>
	$type
	$event
	@breaks
	$numpanels
	$round
	$debug => undef
</%args>
<%init> 

	# Snaking involves putting students in panels based on power.  They should
	# already be in order by seeding.  
	my $tourn = $event->tournament;

   # Preset panels
    my @panels = $round->panels if $round->preset;

	my $letter = "A";

	my %judges_by_panel = ();

	PANEL:
	foreach (1 .. $numpanels) { 
		
		#If there's already a panel here, use that instead
		my $key = $_ - 1;

        #If there's already a panel here, use that instead
        if ($panels[$key]) {
            $letter = $panels[$key]->letter;
            next PANEL;
        }

		my $panel = Tab::Panel->create({ 
			letter => $letter,
			round => $round->id,
			event => $event->id,
			type => $type
		});

		$letter++;

		push (@panels, $panel); 
	} 

	system "/usr/bin/logger I have ".scalar @panels." panels and ".scalar @breaks." breaks." if $debug == 1;

	my @tmp_panels;
	my $rev = 1;
	my $seed;

	my %panel_by_break = ();

	foreach my $break (@breaks) {

		unless (@tmp_panels) { #if tmp_panels doesn't exist, reverse and resort
			$seed++;
			@tmp_panels = ( $rev == 0 ) ? @panels : reverse @panels;
		    $rev = ( $rev == 0 ) ? 1 : 0;
		}

		my $panel = shift @tmp_panels;

		$panel_by_break{$break->id} = $panel;

		foreach my $judge ($panel->judges) { 
	
			#Create the kid a ballot for each preset judge

			my $ballot = Tab::Ballot->create({
				speakerorder => 0,
				panel => $panel->id,
				entry  => $break->id,
				judge => $judge->id,
				speechnumber => 1,
				seed => $seed
			});

		}

		unless ($panel->judges) { 

			#Create a ballot without a judge if there are no judges.

			my $ballot = Tab::Ballot->create({
				speakerorder => 0,
				panel => $panel->id,
				entry  => $break->id,
				speechnumber => 1,
				seed => $seed
			});
		}

	} #end of foreach break

	# Now check to see if any of the regions in the panel have a fixable
	# situation. 

	BREAK:
	foreach my $break (@breaks) {

		my $best_panel;
		my $switch_with;

		my $already_panel = $panel_by_break{$break->id};

		my $score = $already_panel->entry_region_score($break);

		next unless $score;

		system "/usr/bin/logger Score for ".$break->code." is $score" if $debug == 1;

		foreach my $pan (@panels) { 
			$pan->tmp_score($pan->entry_region_score($break));
		}
	
		PANEL:
		foreach my $panel (sort {$a->tmp_score <=> $b->tmp_score} @panels) { 

			# If we haven't gotten to the point where we can productively move
			# this kid when the potential panel score is equal to the score of
			# the panel the kid is already in, move on in defeat. 

			next BREAK unless $panel->tmp_score < $score;

			# If this panel has a better score for my current kid, and it's the
			# lowest score so far (by the sort) then try to find a kid from
			# this panel who can move into the panel this kid came from.

			my $break_seed = $break->seed($already_panel);
			my $break_prelim_cume = $break->prelim_cume;
			my $break_cume = $break->cume;


			COMP:
			foreach my $entry ($panel->entries) { 

				# Basis is seed
				if ($tourn->method->elim_method_basis eq "seed") {
					next COMP unless $entry->seed($panel) eq $break_seed;
				}

				# Basis is preliminary round cumulative score
				if ($tourn->method->elim_method_basis eq "prelim_cume") { 
					next COMP unless $entry->prelim_cume eq $break_prelim_cume;
				}
				
				# Basis is overall cumulative score
				if ($tourn->method->elim_method_basis eq "overall_cume") { 
					next COMP unless $entry->cume eq $break_cume;
				}

				if ($already_panel->entry_region_score($entry) == 0 && $panel->entry_region_score($entry) > 0) { 
					$switch_with = $entry;
					$best_panel = $panel;
					#We have solved two problems here.  Woot.
					last PANEL;
				}

				if ($already_panel->entry_region_score($entry) == 0) { 
					$switch_with = $entry;
					$best_panel = $panel;
					last PANEL;
				}


				if ($switch_with) { 

					if ($already_panel->entry_region_score($entry) <= $panel->entry_region_score($entry)
				 	&& $already_panel->entry_region_score($entry) < $already_panel->entry_region_score($switch_with)) { 
						$switch_with = $entry;
						$best_panel = $panel;
					}
				} else { 

					if ($already_panel->entry_region_score($entry) <= $panel->entry_region_score($entry)) {

						$switch_with = $entry;
						$best_panel = $panel;

					}
				}

			} #end of foreach competitor

		} #end of foreach panel
		

		if ($best_panel && $switch_with) { 

			system "/usr/bin/logger Swapping ".$switch_with->code." into ".$already_panel->letter." and ".$break->code." into ".$best_panel->letter if $debug == 1;
			
			$panel_by_break{$break->id} = $best_panel;
			$panel_by_break{$switch_with->id} = $already_panel;

			$m->comp("/panel/entry_move.mas",    
				shut_up => "yes",
               	tourn => $tourn,
           		entry_id => $break->id,
           		panel_id => $best_panel->id );

			$m->comp("/panel/entry_move.mas",    
				shut_up => "yes",
              	tourn => $tourn,
           		entry_id => $switch_with->id,
           		panel_id => $already_panel->id );

		}

	}

	foreach ($round->empties) { $_->delete; }
    $round->preset(0);
    $round->update;

	return;

</%init> 
