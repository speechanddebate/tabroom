<%args>
	$round
	$section        => undef
	$nsda           => undef
	$seed_skip      => undef
	$skip_wins      => undef
	$breakout       => undef
	$opp_wins_only  => undef
	$composite_set  => undef
	$parent_set     => undef
	$protocol       => undef
	$all_entries    => undef
	$never_redirect => undef
</%args>
<%init>

	return unless $round;
	use feature qw(switch);

	#i do so hate you Perl
	no warnings 'experimental::smartmatch';
	no warnings 'uninitialized';

	my $event = $round->event;
	my $event_type = $event->type;
	my $byes_on_team_basis++ if $event_type eq "wsdc";

	$event_type = "debate"
		if $event_type eq "wsdc"
		|| $event_type eq "mock_trial"
		|| $event_type eq "wudc";

	my $tourn = $event->tourn;
	my $seed = $tourn->start->epoch;

	my $this_round_name = $round->name;

	unless ($this_round_name > 0 ) {
		my $warning = "This round has no round number, which is likely because it has no timeslot. ";
		$warning .= "Round numbers are how Tabroom determines whether a round counts in a result or not";
		$warning .= "Please give the round a timeslot at the link below, or save the event schedule ";
		$warning .= "under Settings -&gt; Schedule to give each round a round number";

		$m->comp("/funclib/abort.mas",
			link => "/panel/schemat/show.mhtml?round_id=".$round->id."&default=settings",
			warning => $warning
		);
	}

	my $this_round_id = $round->id;
	my $this_round_sequence;

	if ($composite_set) {

		# Check against composites of composites

		foreach my $tiebreak ($composite_set->tiebreaks) {

			if ($tiebreak->child > 0) {
				$m->print('<div class="main">');
				$m->print("<h3>No, not gonna do it</h3>");

				$m->print('<p class="strong redtext">You have a composite rank based on other composite ranks. </p>');
				$m->print('<p>That can lead to excessively long computation times and bring down the Tabroom server.</p>');
				$m->print('<p>Thus, they are not permitted.  Please reconfigure your tiebreakers</p>');

				$m->print('<p></p>');
				$m->print("<p>Tiebreak set ".$composite_set->name." used in ".$round->realname." of ".$event->abbr." has composite tiebreaker ".$tiebreak->child->name." for ".$tiebreak->name." priority ".$tiebreak->priority."</p>");

				$m->print("<p>Composite ID $composite_set, round TB ID ".$round->protocol."</p>");

				if ($ARGS{"return"}) {
					return;
				} else {
					$m->abort();
				}
			}

			if ($tiebreak->name eq "opp_seed") {
				$m->print('<div class="main">');
				$m->print("<h3>No, not gonna do it</h3>");
				$m->print('<p class="semibold redtext">You have a composite rank based on opponent seeds. </p>');
				$m->print('<p>That means your composite depends on calcuating itself, which in </p>');
				$m->print('<p>computing is called an infinite loop, and so certainly not what you want.</p>');
				$m->print('<p>Please reconfigure your tiebreakers</p>');
				if ($ARGS{"return"}) {
					return;
				} else {
					$m->abort();
				}
			}
		}

		$protocol = $composite_set;

	} elsif (not defined $protocol) {
		$protocol = $round->protocol;
	}

	unless ($protocol) {
		return if $nsda;

		if ($ARGS{"return"} || $never_redirect) {
			return;
		} else {
			$m->abort();
		}

		my $err = "Round ".$round->realname." does not have a tiebreaker set applied to it.";
		$err .= "Please pick one and try again";
		$m->redirect("/setup/schedule/event.mhtml?event_id=".$event->id."&err=$err");
	}

	my %protocol_settings = $protocol->all_settings;
	my %event_settings = $event->all_settings;
	my %tourn_settings = $tourn->all_settings;

	if (
		$tourn_settings{"nsda_nats"}
		&& $nsda
		&& $event_type eq "speech"
	) {
		$protocol = Tab::Protocol->search(
			tourn => $tourn,
			name  => "IE Prelim Composite"
		)->first;
	}

	my $truncate_to_smallest;
	my $forfeits_never_break = $protocol_settings{"forfeits_never_break"};

	# Get the data you'll need for Teh Sortingz.
	my $dbh = Tab::DBI->db_Main();

	my $round_sth = $dbh->prepare("
		select round.id, round.name, round.type
		from round
		where round.event = ?
		and round.type != 'runoff'
		and not exists (
			select rs.id
			from round_setting rs
			where rs.tag = 'ignore_results'
			and rs.round = round.id
		)
		order by round.name
	");

	$round_sth->execute($event);
	my $event_rounds = $round_sth->fetchall_hash();
	$round_sth->finish();

	my %rounds = map {$_->{'id'} => $_} @{$event_rounds};
	my %rounds_by_name = map {$_->{'name'} => $_} @{$event_rounds};

	foreach my $round (keys %rounds) {
		$rounds{$round}{"type"} = "prelim" if $rounds{$round}{"type"} eq "highlow";
		$rounds{$round}{"type"} = "prelim" if $rounds{$round}{"type"} eq "snaked_prelim";
		$rounds{$round}{"type"} = "prelim" if $rounds{$round}{"type"} eq "highhigh";
	}

	# Redundant and harmful
	undef $event_settings{"team_points"} if $event_type eq "congress";
	undef $event_settings{"team_points"} if $event_type eq "speech";

	undef $event_settings{"round_robin"}
		if $round->type eq "elim"
		|| $round->type eq "final"
		|| $round->type eq "runoff";

	my %tb_tiers = ();
	my %tb_info = ();
	my %opp_results = ();

	if ($opp_wins_only) {

		# This includes opp seeds and opp ballot count BECAUSE I SAY SO

		$tb_info{1}{count} = "prelim";
		$tb_info{2}{count} = "prelim";
		$tb_info{3}{count} = "prelim";

		$tb_info{1}{multiplier} = 1;
		$tb_info{2}{multiplier} = 1;
		$tb_info{3}{multiplier} = 1;

		$tb_info{1}{name} = "opp_wins";
		$tb_info{2}{name} = "opp_ballots";
		$tb_info{3}{name} = "opp_seed";

		push @{$tb_tiers{1}}, 1;
		push @{$tb_tiers{2}}, 2;
		push @{$tb_tiers{3}}, 3;

	} else {

		my $need_opp_results;

		TB:
		foreach my $tb ($protocol->tiebreaks) {

			$tb_info{$tb->id}{count} = $tb->count;

			# This will only aggregate the present round for Points purposes.
			$tb_info{$tb->id}{count} = "previous" if $nsda;

			if ($tb_info{$tb->id}{count} eq "specific") {
				if ($rounds{$tb->count_round}) {
					$tb_info{$tb->id}{round} = $rounds{$tb->count_round};
				} elsif ($rounds_by_name{$tb->count_round}) {
					$tb_info{$tb->id}{round} =  Tab::Round->retrieve($rounds_by_name{$tb->count_round}->{id});
				} else {
					next TB;
				}
			}

			if ($tb->result) {
				$tb_info{$tb->id}{"result"} = $tb->result;
				$need_opp_results++;
			}

			if ($nsda
				&& $round->type ne "elim"
				&& $round->type ne "final"
				&& $round->type ne "runoff"
			) {
				# If we're doing autopoints post on a prelim we have to not drop
				# scores or all will be tied.
				$tb->highlow("");
				$tb->highlow_count("");
			}

			$truncate_to_smallest++ if $tb->truncate_smallest;

			$tb_info{$tb->id}{"name"}              = $tb->name;
			$tb_info{$tb->id}{"child"}             = $tb->child if $tb->child > 0;
			$tb_info{$tb->id}{"truncate"}          = $tb->truncate;
			$tb_info{$tb->id}{"truncate_smallest"} = $tb->truncate_smallest;
			$tb_info{$tb->id}{"multiplier"}        = $tb->multiplier;
			$tb_info{$tb->id}{"chair"}             = $tb->chair;
			$tb_info{$tb->id}{"violation"}         = $tb->violation;
			$tb_info{$tb->id}{"priority"}          = $tb->priority;

			if ($tb->highlow) {
				$tb_info{$tb->id}{"highlow"}           = $tb->highlow;
				$tb_info{$tb->id}{"highlow_count"}     = $tb->highlow_count;
				$tb_info{$tb->id}{"highlow_threshold"} = $tb->highlow_threshold;
				$tb_info{$tb->id}{"highlow_target"}    = $tb->highlow_target;
			}

			push @{$tb_tiers{$tb->priority}}, $tb->id;
		}

		if ($need_opp_results) {
			%opp_results = $m->comp("/funclib/opponent_records.mas", event_id => $event->id);
		}
	}


	my %pods = ();
	my %scores = ();
	my %panels = ();
	my %entries = ();

	my @entries;

	my $dropped_limit = " and entry.active = 1 ";

	# Unsure why this exists, because it apparently allows drops to advance and
	# clear into results sheets for districts.  When this inevitably breaks
	# some bullshit part of the process, please document here why this exists,
	# self. -CLP 12.20.2019

	# undef $dropped_limit if $tourn_settings{"nsda_district"};

	# Aha I did it because the threshold of how many kids were ranked in the
	# round which is also the max rank was raising by 1 when you dropped a kid.
	# So instead I will filter the drops below and remove this

	undef $dropped_limit;

	my $section_limit;
	$section_limit = "and panel.letter = ".$section->letter if $section;

	my $sth = $dbh->prepare("
		select
			entry.id, entry.code, entry.name, entry.dropped, dq.value, entry.school,
			round.type, round.name, round.id,
			score.id, score.tag, score.value, score.student, score.speech,
			ballot.id, ballot.judge, ballot.forfeit, ballot.bye, ballot.tv, ballot.chair,
			panel.id, panel.bye, panel.letter

		from (ballot, panel, round, entry)
			left join score on score.ballot = ballot.id
			left join entry_setting dq on dq.entry = entry.id and dq.tag = 'dq'

		where ballot.panel = panel.id
			and panel.round = round.id
			$section_limit

			and round.event = ?
			and ballot.entry = entry.id
			$dropped_limit
			and entry.waitlist != 1
			and entry.unconfirmed != 1

			and not exists (
				select round_setting.id
				from round_setting
				where round_setting.tag = 'ignore_results'
				and round_setting.round = round.id
			)

		group by score.id, ballot.id, score.speech
		order by round.event, round.name
	");

	$sth->execute($event->id);

	my %already = ();
	my $sequence;

	while (
		my (
			$entry_id, $entry_code, $entry_name, $entry_dropped, $entry_dq, $entry_school_id,
			$round_type, $round_name, $round_id,
			$score_id, $score_tag, $score_value, $score_student, $score_speech,
			$ballot_id, $ballot_judge, $ballot_forfeit, $ballot_bye, $ballot_tv, $ballot_chair,
			$panel_id, $panel_bye, $panel_letter
		)  = $sth->fetchrow_array()
	) {

		unless ($ballot_forfeit || $ballot_bye || $panel_bye) {
			next if $score_tag eq "rfd";
			next if $score_tag eq "comments";
			next if $score_tag eq "time";
			next if $score_tag eq "title";
			next if $score_tag eq "categories";
			next if $score_tag eq "rubric";
			next if $score_tag eq "po";
			next if $score_tag eq "strike";
			next if $score_tag eq "no_strike";
		}

		unless ($already{"sequence"}{$round_id}++) {
			$sequence++;
		}

		push @{$rounds{$round_id}{"panels"}}, $panel_id;

		if ($all_entries) {
			push @entries, $entry_id unless $already{$entry_id}++;
		} elsif ($round_id == $this_round_id) {
			push @entries, $entry_id unless $already{$entry_id}++;
		}

		$entries{"rounds"}{$entry_id}{$round_id}++;
		push @{$entries{"panels"}{$entry_id}}, $panel_id;

		undef $score_student if $score_student == 0;
		push @{$entries{"students"}}, $score_student;

		unless ($entries{"school_id"}{$entry_id}) {

			$entries{"code"}{$entry_id} = $entry_code;
			$entries{"name"}{$entry_id} = $entry_name;
			$entries{"school_id"}{$entry_id} = $entry_school_id;

			$entries{"dq"}{$entry_id} = $entry_dq;
			$entries{"dropped"}{$entry_id} = $entry_dropped;
		}

		if ($round_id == $this_round_id) {
			$entries{"letter"}{$entry_id} = $panel_letter;
			$this_round_sequence = $sequence;
		}

		$entries{"forfeit"}{$entry_id}++ if $ballot_forfeit;
		$entries{"round_forfeit"}{$round_id}{$entry_id}++ if $ballot_forfeit;
		$entries{"panel_can_haz_forfeit"}{$panel_id}++ if $ballot_forfeit;
		$entries{"round_bye"}{$round_id}{$entry_id}++ if $ballot_bye;

		if (
			$event_type eq "debate"
			&& $panel_bye
			&& (not defined $event_settings{"round_robin"})
		) {
			$entries{"round_panel_bye"}{$round_id}{$entry_id} = 1;
			$entries{"bye"}{$entry_id}++;
		}

		if ($score_id) {

			unless ($entries{"round_panel"}{$entry_id}{$round_id}) {
				$entries{"round_panel"}{$entry_id}{$round_id} = $panel_id;
				push @{$panels{$panel_id}{"entries"}}, $entry_id;
			}

			unless ($ballot_forfeit) {
				$entries{"section_count"}{$entry_id}{$round_id}{$panel_id}++;
			}

			push @{$entries{"scores"}{$entry_id}}, $score_id;
			push @{$entries{"round_scores"}{$entry_id}{$round_id}}, $score_id;
			push @{$entries{"judge_scores"}{$entry_id}{$round_id}{$ballot_judge}}, $score_id;

			$scores{"tag"}{$score_id}      = $score_tag;
			$scores{"value"}{$score_id}    = $score_value;
			$scores{"speech"}{$score_id}   = $score_speech;
			$scores{"panel"}{$score_id}    = $panel_id;
			$scores{"judge"}{$score_id}    = $ballot_judge;
			$scores{"round"}{$score_id}    = $round_name;
			$scores{"round_id"}{$score_id} = $round_id;

			if ($ballot_tv) {

				$scores{"tv"}{$score_id} = $ballot_tv;

				unless ($entries{"tv_judge"}{$entry_id}{$round_id}{$ballot_judge}++) {
					$entries{"tv_yes"}{$entry_id}{$round_id}++;
				}

			} else {

				unless ($entries{"tv_judge"}{$entry_id}{$round_id}{$ballot_judge}++) {
					$entries{"tv_no"}{$entry_id}{$round_id}++;
				}
			}

			$scores{"student"}{$score_id}  = $score_student;
			$scores{"chair"}{$score_id}    = $ballot_chair;

		} elsif ($event_type eq "debate" && $panel_bye && $tourn_settings{"nsda_district"}) {

			unless ($entries{"round_panel"}{$entry_id}{$round_id}) {
				$entries{"round_panel"}{$entry_id}{$round_id} = $panel_id;
				push @{$panels{$panel_id}{"entries"}}, $entry_id;
			}
		}

		$panels{$panel_id}{"section"} = $panel_letter;
		$panels{$panel_id}{"roundorder"} = $sequence;

		unless ($round_type eq "runoff") {
			$panels{$panel_id}{"roundname"} = $round_name;
			$panels{$panel_id}{"round"} = $round_id;
		}

	}

	$sth->finish();

	my %eseen = ();
	@entries = grep { ! $eseen{$_} ++ } @entries;

	if ($event_settings{"show_panel_averages"}) {

		$byes_on_team_basis++;

		foreach my $entry_id (@entries) {

			my %panel_scores;
			my %done_scores;
			my %panel_keepers;

			foreach my $score_id (@{$entries{"scores"}{$entry_id}}) {

				next if $done_scores{$score_id}++;

				my $panel_id = $scores{"panel"}{$score_id};

				if (
					$scores{"tag"}{$score_id} eq "rank"
					|| $scores{"tag"}{$score_id} eq "point"
				) {
					push @{$panel_scores{$panel_id}}, $score_id;
				} else {
					push @{$panel_keepers{$panel_id}}, $score_id;
				}

			}

			my %done_panel;

			foreach my $panel_id (@{$entries{"panels"}{$entry_id}}) {

				next if $done_panel{$panel_id}++;

				my %points_id;
				my %points_total;
				my %points_count;

				my %ranks_id;
				my %ranks_total;
				my %ranks_count;

				my $round_id;
				my $judge_id;

				foreach my $score_id (@{$panel_scores{$panel_id}}) {

					my $student_id = $scores{"student"}{$score_id};
					$student_id = 0 unless $student_id;

					if ($scores{"tag"}{$score_id} eq "rank") {

						$ranks_id{$student_id} = $score_id unless $ranks_id{$student_id};
						$ranks_total{$student_id} += $scores{"value"}{$score_id};
						$ranks_count{$student_id}++;

					} elsif ($scores{"tag"}{$score_id} eq "point") {

						$points_id{$student_id} = $score_id unless $points_id{$student_id};
						$points_total{$student_id} += $scores{"value"}{$score_id};
						$points_count{$student_id}++;
					}

					$round_id = $scores{"round_id"}{$score_id};
					$judge_id = $scores{"judge"}{$score_id};
				}

				undef @{$entries{"round_scores"}{$entry_id}{$round_id}};

				if ($panel_keepers{$panel_id}) {
					push @{$entries{"round_scores"}{$entry_id}{$round_id}}, @{$panel_keepers{$panel_id}};
				}

				if (keys %ranks_id) {

					foreach my $student_id (keys %ranks_total) {

						my $ranks_average = Math::Round::nearest(.01, $ranks_total{$student_id} / $ranks_count{$student_id});
						my $ranks_id = $ranks_id{$student_id};

						push @{$entries{"round_scores"}{$entry_id}{$round_id}}, $ranks_id;

						$scores{"tag"}{$ranks_id}      = "rank";
						$scores{"value"}{$ranks_id}    = $ranks_average;
						$scores{"panel"}{$ranks_id}    = $panel_id;
						$scores{"judge"}{$ranks_id}    = $judge_id;
						$scores{"round_id"}{$ranks_id} = $round_id;
					}
				}

				if (keys %points_id) {

					foreach my $student_id (keys %points_total) {

						my $points_average = Math::Round::nearest(.01, $points_total{$student_id} / $points_count{$student_id});
						my $points_id = $points_id{$student_id};

						push @{$entries{"round_scores"}{$entry_id}{$round_id}}, $points_id;

						$scores{"tag"}{$points_id}      = "point";
						$scores{"value"}{$points_id}    = $points_average;
						$scores{"panel"}{$points_id}    = $panel_id;
						$scores{"judge"}{$points_id}    = $judge_id;
						$scores{"round_id"}{$points_id} = $round_id;

					}
				}
			}
		}
	}

	my %eligible = ();

	if ($breakout) {

		my @breakout_settings = $m->comp(
			"/funclib/event_entry_settings.mas",
			event => $event,
			tag   => "breakout_".$breakout
		);

		foreach my $bs (@breakout_settings) {
			$eligible{$bs->entry->id}++;
		}

		if ($round->type ne "elim"
			&& $round->type ne "final"
			&& $event_settings{"breakout_".$breakout."_exclude_elims"}
		) {

			my @in_elims = $m->comp("/funclib/event_entries.mas",
				event    => $event,
				in_elims => "yessiree!"
			);

			foreach my $in_elim (@in_elims) {
				undef $eligible{$in_elim->id};
			}
		}

	}

	my @all_rounds;

	foreach my $all_round (@{$event_rounds}) {

		my $all_round_id = $all_round->{"id"};

		next if $rounds{$all_round_id}{"done"}++;

		# Do not measure the future.  the Doctor will get angry at us.
		next if $rounds{$all_round_id}{"name"} > $this_round_name;

		push @all_rounds, $all_round_id;

		# Uniq the panels so there's no double counting

		my %pseen = ();

		@{$rounds{$all_round_id}{"panels"}} =
			grep { ! $pseen{$_}++ }
			@{$rounds{$all_round_id}{"panels"}};

		foreach my $panel (@{$rounds{$all_round}{"panels"}}) {
			# Uniq the panel entries so there's no double counting;
			my %eseen = ();

			@{$panels{$panel}{"entries"}} =
				grep { ! $eseen{$_} ++ }
				@{$panels{$panel}{"entries"}};
		}
	}

	my %dq_panel_threshold = ();

	unless ($tourn_settings{"nsda_district"} || $tourn_settings{"nsda_nats"}) {

		my @keys = keys %{$entries{"dq"}};

		foreach my $entry (keys %{$entries{"dq"}}) {

			next unless $entries{"dq"}{$entry};

			foreach my $score (@{$entries{"scores"}{$entry}}) {
				next unless $scores{"tag"}{$score} eq "rank";
				my $panel = $scores{"panel"}{$score};
				my $judge = $scores{"judge"}{$score};
				my $value = $scores{"value"}{$score};
				$dq_panel_threshold{$panel}{$judge}{$value} = 1;
			}
		}
	}

	my %smallest;

	if ($truncate_to_smallest) {

		foreach my $round (@all_rounds) {

			foreach my $panel (@{$rounds{$round}{"panels"}}) {

				my $size = scalar @{$panels{$panel}{"entries"}}
					if $panels{$panel}{"entries"};

				next unless $size > 0;

				unless ($smallest{$round}) {
					$smallest{$round} = $size;
				}

				if ($smallest{$round} > $size) {
					$smallest{$round} = $size;
				}
			}
		}
	}

	my %max_score_count;

	if (
		$round
		&& ( $round->type eq "elim"
			|| $round->type eq "final"
		)
	) {

		# Eliminate everyone who has not advanced to the elim round in question.

		my @counted;
		my %last_round;
		my %done;

		foreach my $entry (@entries) {

			next if $done{$entry}++;

			my @panels = @{$entries{"panels"}{$entry}};

			foreach my $panel (@{$entries{"panels"}{$entry}}) {
				$last_round{$entry} = $panels{$panel}{"roundname"}
					if $last_round{$entry} < $panels{$panel}{"roundname"};
			}

			next if $last_round{$entry} < $this_round_name;
			push @counted, $entry;
		}
		@entries = @counted;
	}

	if ($event_type eq "debate" || $event_settings{"team_points"}) {

		my $limit;
		$limit = ", ballot.judge" if $event_settings{"show_panel_averages"};

		my $round_max = $dbh->prepare("
			select distinct(round.id) round, score.tag, ballot.entry, count(score.id) count
				from round, panel, ballot, score

				where round.event = ?
				and round.id = panel.round
				and panel.id = ballot.panel
				and ballot.id = score.ballot
				and score.tag in ('winloss', 'rank', 'point')
				and (score.value > 0 or score.tag = 'winloss')
				group by round.id,
					score.tag,
					ballot.entry $limit
		");

		$round_max->execute($event->id);
		my $results = $round_max->fetchall_hash();

		foreach my $ref (@{$results}) {
			if ($event_settings{"show_panel_averages"} && $ref->{tag} eq "point") {
				next;
			}

			if ($event_settings{"team_points"}) {
				$max_score_count{$ref->{tag}}{$ref->{round}} = 1;
			} elsif ($ref->{count} > $max_score_count{$ref->{tag}}{$ref->{round}}) {
				$max_score_count{$ref->{tag}}{$ref->{round}} = $ref->{count};
			}
		}
	}

	my %tier_descs      = ();
	my %tier_long_descs = ();
	my %tier_dir        = ();

	my %needs = ();
	my %composite_rounds;

	foreach my $key (sort {$a <=> $b} keys %tb_tiers) {

		TB:
		foreach my $tb_id (sort {$a <=> $b} @{$tb_tiers{$key}}) {

			if (
				$tb_info{$tb_id}{count} eq "specific"
				&& (not defined $tb_info{$tb_id}{round})
			) {
				next TB;
			}

			$needs{"ranks"}++ if $tb_info{$tb_id}{name} eq "ranks";
			$needs{"ranks"}++ if $tb_info{$tb_id}{name} eq "reciprocals";
			$needs{"ranks"}++ if $tb_info{$tb_id}{name} eq "chair_ranks";
			$needs{"ranks"}++ if $tb_info{$tb_id}{name} eq "non_chair_ranks";

			$needs{"best_po"}++ if $tb_info{$tb_id}{name} eq "best_po";

			$needs{'student_vote'}++ if $tb_info{$tb_id}{name} eq "student_nominee";
			$needs{'student_vote'}++ if $tb_info{$tb_id}{name} eq "student_rank";
			$needs{'student_vote'}++ if $tb_info{$tb_id}{name} eq "student_recip";

			$needs{'student_vote'}++ if $tb_info{$tb_id}{name} eq "entry_vote_one";
			$needs{'student_vote'}++ if $tb_info{$tb_id}{name} eq "entry_vote_all";

			$needs{"points"}++ if $tb_info{$tb_id}{name} eq "points";

			$needs{"speech"}++ if $tb_info{$tb_id}{name} eq "congress_speech";
			$needs{"speech"}++ if $tb_info{$tb_id}{name} eq "po_points";

			$needs{"seed"}++ if $tb_info{$tb_id}{name} eq "opp_seed";
			$needs{"seed"}++ if $tb_info{$tb_id}{name} eq "seed";

			$needs{"winloss"}++ if $tb_info{$tb_id}{name} eq "winloss";
			$needs{"winloss"}++ if $tb_info{$tb_id}{name} eq "ballots";
			$needs{"winloss"}++ if $tb_info{$tb_id}{name} eq "opp_wins";

			$needs{"judgevar"}++ if $tb_info{$tb_id}{name} eq "judgevar";
			$needs{"judgevar"}++ if $tb_info{$tb_id}{name} eq "judgevar2";

			my $losses_needed;
			if ($tb_info{$tb_id}{name} eq "losses") {
				$needs{"losses"}++;
				$losses_needed++;
			}

			$needs{"opp_ranks"}++ if $tb_info{$tb_id}{name} eq "opp_ranks";
			$needs{"opp_points"}++ if $tb_info{$tb_id}{name} eq "opp_points";

			if ($tb_info{$tb_id}{"child"} > 0) {

				foreach my $round (@all_rounds) {

					if ($tb_info{$tb_id}{count} eq "prelim") {

						push @{$composite_rounds{$tb_id}}, $round if $rounds{$round}{"type"} eq "prelim";
						push @{$composite_rounds{$tb_id}}, $round if $rounds{$round}{"type"} eq "snaked_prelim";
						push @{$composite_rounds{$tb_id}}, $round if $rounds{$round}{"type"} eq "highhigh";
						push @{$composite_rounds{$tb_id}}, $round if $rounds{$round}{"type"} eq "highlow";

					} elsif ($rounds{$round}{"type"} eq $tb_info{$tb_id}{count}) {

						push @{$composite_rounds{$tb_id}}, $round;

					} elsif ($tb_info{$tb_id}{count} eq "all") {

						push @{$composite_rounds{$tb_id}}, $round;

					} elsif ($tb_info{$tb_id}{count} eq "previous") {
						push @{$composite_rounds{$tb_id}}, $round if $round == $this_round_id;
					}
				}
			}

			if ($needs{"winloss"} && (not defined $entries{"tb_wins"}{$tb_id}) ) {

				if ($tb_info{$tb_id}{count} eq "previous") {

					%{$entries{"tb_wins"}{$tb_id}} = $m->comp(
							"/funclib/entry_wins.mas",
							event    => $event,
							round    => $round,
							chair    => $tb_info{$tb_id}{"chair"},
							last     => 1
						);

				} elsif ($tb_info{$tb_id}{count} eq "specific") {

					%{$entries{"tb_wins"}{$tb_id}} = $m->comp(
							"/funclib/entry_wins.mas",
							event    => $event,
							round    => $tb_info{$tb_id}{round},
							chair    => $tb_info{$tb_id}{"chair"},
							last     => 1
						);

				} elsif ($tb_info{$tb_id}{count} eq "all") {

					%{$entries{"tb_wins"}{$tb_id}} = $m->comp(
						"/funclib/entry_wins.mas",
							event    => $event,
							chair    => $tb_info{$tb_id}{"chair"},
							round    => $round
						);

				} else {

					%{$entries{"tb_wins"}{$tb_id}} = $m->comp(
						"/funclib/entry_wins.mas",
						event    => $event,
						round    => $round,
						chair    => $tb_info{$tb_id}{"chair"},
						type     => $tb_info{$tb_id}{count}
					);
				}
			}

			if ($losses_needed) {

				if ($tb_info{$tb_id}{count} eq "previous") {

					%{$entries{"tb_losses"}{$tb_id}} =
						$m->comp("/funclib/entry_losses.mas",
							event    => $event,
							round    => $round,
							chair    => $tb_info{$tb_id}{"chair"},
							last     => 1
						);

				} elsif ($tb_info{$tb_id}{count} eq "specific") {

					%{$entries{"tb_wins"}{$tb_id}} =
						$m->comp("/funclib/entry_losses.mas",
							event    => $event,
							round    => $tb_info{$tb_id}{round},
							chair    => $tb_info{$tb_id}{"chair"},
							last     => 1
						);

				} elsif ($tb_info{$tb_id}{count} eq "all") {

					%{$entries{"tb_losses"}{$tb_id}}
						= $m->comp("/funclib/entry_losses.mas",
							event    => $event,
							round    => $round,
							chair    => $tb_info{$tb_id}{"chair"},
							all      => 1
						);

				} else {

					%{$entries{"tb_losses"}{$tb_id}}
						= $m->comp("/funclib/entry_losses.mas",
							event => $event,
							round => $round,
							chair    => $tb_info{$tb_id}{"chair"},
							type  => $tb_info{$tb_id}{count}
						);
				}
			}
		}
	}

	if ($needs{"student_vote"}) {

		my $sv_sth = $dbh->prepare("
			select
				vote.id, round.id, vote.entry, vote.tag, vote.value
			from student_vote vote, panel, round
			where vote.panel = panel.id
				and panel.round = round.id
				and round.event = ?
			group by vote.id
		");

		$sv_sth->execute($event->id);

		while (
			my ($vote, $round, $entry, $tag, $value) = $sv_sth->fetchrow_array()
		) {

			if ($tag eq "winloss") {
				if ($value == 1) {
					$entries{"student_wins"}{$entry}{$round}++;
				} else {
					$entries{"student_loss"}{$entry}{$round}++;
				}
			} elsif ($tag eq "rank") {
				push @{$entries{"student_rank"}{$entry}{$round}}, $value;
			} elsif ($tag eq "nominee") {
				push @{$entries{"student_nominee"}{$entry}{$round}}, $value;
			}
		}

		$sv_sth->finish();
	}

	# Runoff?

	if ($round->runoff > 0) {

		my $runoff = $round->runoff;

		if ($runoff == $round) {
			$m->comp("/funclib/abort.mas",
				message => "You have made round ".$round->realname." a runoff/tiebreaker for itself.  That does not work. Please adjust round settings to continue");
		}

		if (
			(not defined $runoff->id)
			|| (not defined $runoff->event)
			|| ($runoff->event != $event)
		) {
			$round->runoff(0);
			$round->update;
		} elsif (not defined $runoff->protocol) {
			$m->comp("/funclib/abort.mas",
				message => "Your runoff round ".$runoff->realname." has no tiebreakers set, so Tabroom is unable to determine its results.  Please set tiebreakers to continue");
		} else {

			my $key = "999";

			$tb_info{$key}{"round"}    = $runoff;
			$tb_info{$key}{"protocol"} = $runoff->protocol;
			$tb_info{$key}{"priority"} = 999;
			$tb_info{$key}{"name"}     = "runoff";
			$tier_dir{$key}            = "up";
			$tier_descs{$key}          = "RO ".$runoff->name;
			$tier_long_descs{$key}     = "Ranking from ".$runoff->label;

			push @{$tb_tiers{999}}, "999";

			my @results = $m->comp(
				"/tabbing/results/order_entries.mas",
				round         => $runoff,
				section_rank  => 1
			);

			my $full_entries_ref = pop @results;

			if (${$full_entries_ref}{"by_place"}) {
				foreach my $rank (sort {$a <=> $b} keys %{${$full_entries_ref}{"by_place"}}) {
					foreach my $entry_id (@{${${$full_entries_ref}{"by_place"}}{$rank}}) {
						$entries{"tbs"}{$entry_id}{$key} = $rank * 100;
						$entries{"tiebreak"}{$key}{$entry_id} = $rank * 100;
					}
				}
			}
		}
	}

	# The factors that going into calculating jvar and jvar2 (aka z scores)

	my (
		$judge_avg_ref,
		$judge_ballot_count_ref,
		$judge_total_ref,
		$judge_stddev_ref,
		$total_avg,
		$total_std,
		$judge_z2_avg_ref,
		$judge_z2_ballot_count_ref,
		$judge_z2_total_ref,
		$judge_z2_stddev_ref
	) = $m->comp(
		"/funclib/judge_points_average.mas",
			event => $event
	) if $needs{"judgevar"};

	# Calculate the composite ranks if that's a thing:

	foreach my $key (sort {$a <=> $b} keys %tb_tiers) {

		next if $key == "999";

		TB:
		foreach my $tb_id (sort {$a <=> $b} @{$tb_tiers{$key}}) {

			#Avoid recursion
			next if $tb_info{$tb_id}{"child"} && $tb_info{$tb_id}{"child"} == $protocol;

			my %comp_seen = ();

			my @comp_rounds =  @{$composite_rounds{$tb_id}} if $composite_rounds{$tb_id};
			@comp_rounds = grep { ! $comp_seen{$_} ++ } @comp_rounds;

			next unless @comp_rounds;

			foreach my $round_id (@comp_rounds) {

				my $rank_round = Tab::Round->retrieve(int($round_id));
				my $doubledown++ if $tourn_settings{"nsda_speech_method"} eq "doubledown";

				my @results = $m->comp(
					"/tabbing/results/order_entries.mas",
					round         => $rank_round,
					composite_set => $tb_info{$tb_id}{"child"},
					parent_set    => $protocol,
					section_rank  => 1,
					doubledown    => $doubledown,
					return        => 1
				);

				my $full_entries_ref = pop @results;

				foreach my $panel (@{$rounds{$rank_round}{"panels"}}) {

					foreach my $entry (@{$panels{$panel}{"entries"}}) {

						my $rank = $full_entries_ref->{"section_rank"}{$entry};
						my $unbroken_rank = $full_entries_ref->{"section_ub_rank"}{$entry};

						$entries{"unbroken_rank"}{$entry}{$rank_round} = $unbroken_rank;
						$entries{"composite_rank"}{$entry}{$rank_round} = $rank;
						$entries{"composite_rank_count"}{$panel}{$rank}++;

					}
				}
			}
		}
	}

	if ($event_type eq "debate") {

		ENTRY:
		foreach my $entry (@entries) {

			foreach my $this_round (@all_rounds) {

				next if $rounds{$this_round}{"type"} eq "elim";
				next if $rounds{$this_round}{"type"} eq "runoff";
				next if $rounds{$this_round}{"type"} eq "final";

				next if $entries{"round_bye"}{$this_round}{$entry};
				next if $entries{"round_panel_bye"}{$this_round}{$entry};

				my %erseen = ();

				@{$entries{"round_scores"}{$entry}{$this_round}} =
					grep { ! $erseen{$_}++ }
					@{$entries{"round_scores"}{$entry}{$this_round}};

				unless (
					(scalar @{$entries{"round_scores"}{$entry}{$this_round}} > 0)
					|| $entries{"round_bye"}{$this_round}{$entry}
					|| $entries{"round_panel_bye"}{$this_round}{$entry}
				) {
					$entries{"forfeit"}{$entry}++;
					next ENTRY;
				}
			}
		}
	}

	my $bye_min;

	if ($event_settings{"round_robin"}) {

		my @pods = $m->comp("/funclib/event_entry_settings.mas",
			tag   => "pod",
			event => $event
		);

		%{$entries{"pod"}} = map {$_->entry->id => $_->value} @pods;

		foreach my $entry (sort {$entries{"bye"}{$b} <=> $entries{"bye"}{$a}} @entries) {

			push @{$pods{$entries{"pod"}{$entry}}}, $entry;

			$bye_min = $entries{"bye"}{$entry}
				if $entries{"bye"}{$entry}
				&& not defined $bye_min;

			$bye_min = $entries{"bye"}{$entry}
				if $entries{"bye"}{$entry} < $bye_min;
		}
	}

	my $test_round;
	my $seed_skipper++;

	if ($needs{"seed"}) {

		$test_round = $round if (
			$round->type ne "elim"
			&& $round->type ne "final"
			&& $round->type ne "runoff"
		);

		unless ($test_round) {

			my $test_round_id;

			# Rounds are in order by name so this will yield the last prelim round.
			foreach my $round (@all_rounds) {
				$test_round_id = $round if $rounds{$round}{"type"} eq "prelim";
			}

			$test_round = Tab::Round->retrieve($test_round_id);
			undef $seed_skipper;
		}

		unless ($seed_skip) {

			my ($entries_ref, @others) = $m->comp(
				"/tabbing/results/order_entries.mas",
				round     => $test_round,
				seed_skip => $seed_skipper
			);

			foreach my $key (sort {$a <=> $b} keys %{$entries_ref}) {
				foreach my $entry (@{${$entries_ref}{$key}}) {
					$entries{"seed"}{$entry} = $key;
				}
			}
		}
	}

	my $seed_done;
	my $opp_seed_done;
	my $opp_wins_done;

	foreach my $key (sort keys %tb_tiers) {

		next if $key eq "runoff";
		next if $key eq "999";

		my $tier_desc;
		my $tier_long_desc;

		next if $seed_done && $seed_skip;
		next if $opp_seed_done && $seed_skip;

		TB:
		foreach my $tb_id (sort {$a <=> $b} @{$tb_tiers{$key}}) {

			my $tb_name = $tb_info{$tb_id}{name};
			next if $tb_name eq "runoff";

			# Tiebreakers where high values are better

			$tier_dir{$key} = "down" if (
				$tb_name eq "winloss"
				|| $tb_name eq "reciprocals"
				|| $tb_name eq "points"
				|| $tb_name eq "po_points"
				|| $tb_name eq "point_diff"
				|| $tb_name eq "ballots"
				|| $tb_name eq "rounds"
				|| $tb_name eq "judgepref"
				|| $tb_name eq "student_nominee"
				|| $tb_name eq "three_way_point"
				|| $tb_name eq "3way_pts_worst"
				|| $tb_name eq "three_way_recip"
				|| $tb_name eq "3way_rcp_worst"
				|| $tb_name eq "headtohead"
				|| $tb_name eq "opp_points"
				|| $tb_name eq "opp_wins"
				|| $tb_name eq "opp_ballots"
				|| $tb_name eq "judgevar"
				|| $tb_name eq "recipinround"
				|| $tb_name eq "judgevar2"
				|| $tb_name eq "preponderance"
				|| $tb_name eq "num_ballots"
				|| $tb_name eq "student_ballot"
				|| $tb_name eq "entry_vote_one"
				|| $tb_name eq "entry_vote_all"
				|| $tb_name eq "student_recip"
				|| $tb_name eq "best_po"
			);

			# Tiebreakers where low values are better

			$tier_dir{$key} = "up" if (
				$tb_name eq "ranks"
				|| $tb_name eq "opp_seed"
				|| $tb_name eq "seed"
				|| $tb_name eq "opp_ranks"
				|| $tb_name eq "chair_ranks"
				|| $tb_name eq "non_chair_ranks"
				|| $tb_name eq "rankinround"
				|| $tb_name eq "downs"
				|| $tb_name eq "runoff"
				|| $tb_name eq "losses"
				|| $tb_name eq "coinflip"
				|| $tb_name eq "student_rank"
			);

			$tier_desc .= "+" if $tier_desc;
			$tier_long_desc .= "+" if $tier_long_desc;

			my $digits = 0;

			given ($tb_name) {

				when ('ranks') {
					$tier_desc .= "Rk";
					$tier_long_desc .= "Ranks";
					$digits = 2 if $digits < 2;
				}

				when ("reciprocals") {
					$tier_desc .= "Rcp";
					$tier_long_desc .= "Reciprocals";
					$digits = 2 if $digits < 2;
				}

				when ("points") {
					$tier_desc .= "Pts";
					$tier_long_desc .= " Entry" if $event_settings{"team_points"};
					$tier_long_desc .= " Points";

					if ($event_settings{"point_increments"} eq "tenths"
						|| $event_settings{"point_increments"} eq "half"
					) {
						$digits = 1 if $digits < 1;
					} elsif ($event_settings{"point_increments"} eq "fourths") {
						$digits = 2 if $digits < 2;
					}
				}

				when ("po_points") {
					$tier_desc .= "POPt";
					$tier_long_desc .= " Points while Presiding";
				}

				when ("congress_speech") {
					$tier_desc .= "CSps";
					$tier_long_desc .= " Congress Speech Points";
				}

				when ("point_diff") {
					$tier_desc .= "PtDf";
					$tier_long_desc .= "Average Point Differential";
					$digits = 2 if $digits < 2;
				}

				when ("judgepref") {
					$tier_desc .= "JP";
					$tier_long_desc .= "Judge Preferences";
				}

				when ("three_way_point") {
					$tier_desc .= "3WPB";
					$tier_long_desc .= "Points if 3-Way Tie, Remove Best";
				}
				when ("3way_pts_worst") {
					$tier_desc .= "3WPW";
					$tier_long_desc .= "Points if 3-Way Tie, Remove Worst";
				}

				when ("three_way_recip") {
					$tier_desc .= "3WRB";
					$tier_long_desc .= "Reciprocals if 3-Way Tie, Remove Best";
				}
				when ("3way_rcp_worst") {
					$tier_desc .= "3WRW";
					$tier_long_desc .= "Reciprocals if 3-Way Tie, Remove Worst";
				}

				when ("preponderance") {
					$tier_desc .= "PRE";
					$tier_long_desc .= "Preponderance: Majority of Judges vote 1";
				}

				when ("headtohead") {
					$tier_desc .= "H2H";
					$tier_long_desc .= "Head to Head Ballots";
				}

				when ("coinflip") {
					$tier_desc .= "Rand";
					$tier_long_desc .= "Random";
					$digits = 2 if $digits < 2;
				}

				when ("opp_ranks") {
					$tier_desc .= "ORk";
					$tier_long_desc .= "Opponents' ranks";
					$digits = 2 if $digits < 2;
				}

				when ("chair_ranks") {
					$tier_desc .= "PRk";
					$tier_long_desc .= "Parliamentarian rank";
				}

				when ("best_po") {
					$tier_desc .= "BPO";
					$tier_long_desc .= "Parliamentarian Best PO";
				}

				when ("student_rank") {
					$tier_desc .= "AvSRk";
					$tier_long_desc .= "Average Student Rank";
					$digits = 2 if $digits < 2;
				}

				when ("entry_vote_one") {
					$tier_desc .= "EV1";
					$tier_long_desc .= "Entry Vote Winner (Together as One Win)";
				}

				when ("entry_vote_all") {
					$tier_desc .= "EVA";
					$tier_long_desc .= "Entry Vote Winner (All Votes Count)";
				}

				when ("student_nominee") {
					$tier_desc .= "SNom";
					$tier_long_desc .= "Student Nominee";
				}

				when ("student_recip") {
					$tier_desc .= "SRcp";
					$tier_long_desc .= "Student Rank Reciprocals";
					$digits = 2 if $digits < 2;
				}

				when ("non_chair_ranks") {
					$tier_desc .= "NParlRk";
					$tier_long_desc .= "Non-parliamentarian rank";
				}

				when ("winloss") {
					$tier_desc .= "Win";
					$tier_long_desc .= "Wins";
				}

				when ("losses") {
					$tier_desc .= "Loss";
					$tier_long_desc .= "Losses";
				}

				when ("downs") {
					$tier_desc .= "Dwn";
					$tier_long_desc .= "Ranked Down (Bottom Half of Room)";
				}

				when ("seed") {
					$tier_desc .= "Sd";
					$tier_long_desc .= "Prelim seed";
				}

				when ("opp_seed") {
					$tier_desc .= "OSd";
					$tier_long_desc .= "Opponent Average Seed";
					$digits = 2 if $digits < 2;
				}

				when ("opp_wins") {
					$tier_desc .= "OpW";
					$tier_long_desc .= "Opponent Wins Average";
					$digits = 2 if $digits < 2;
				}

				when ("opp_points") {
					$tier_desc .= "OPt";
					$tier_long_desc .= "Opponent Points Average";
					$digits = 2 if $digits < 2;
				}

				when ("judgevar") {
					$tier_desc .= "Z1";
					$tier_long_desc .= "ZScore1: Judge Points Variance";
					$digits = 2 if $digits < 2;
				}

				when ("judgevar2") {
					$tier_desc .= "Z2";
					$tier_long_desc .= "ZScore2: Sampled Judge Points Variance";
					$digits = 2 if $digits < 2;
				}

				when ("ballots") {
					$tier_desc .= "Bal";
					$tier_long_desc .= "Ballot Total";
				}

				when ("opp_ballots") {
					$tier_desc .= "OpB";
					$tier_long_desc .= "Opponent Ballot Average";
					$digits = 2 if $digits < 2;
				}

				when ("num_ballots") {
					$tier_desc .= "Spoke";
					$tier_long_desc .= "Number of sections this entry spoke in";
				}

				when ("rounds") {
					$tier_desc .= "Rnds";
					$tier_long_desc .= "Rounds Debated In";
				}

				default {
				}
			}

			if ($tb_info{$tb_id}{result} eq "win") {
				$tier_desc .= "W";
				$tier_long_desc .= " in wins";
			} elsif ($tb_info{$tb_id}{result} eq "loss") {
				$tier_desc .= "L";
				$tier_long_desc .= " in losses";
			} elsif ($tb_info{$tb_id}{result} eq "split") {
				$tier_desc .= "S";
				$tier_long_desc .= " in splits";
			}

			if ($tb_info{$tb_id}{count} eq "final") {
				$tier_desc .= "Fn";
				$tier_long_desc .= " in Finals";
			} elsif ($tb_info{$tb_id}{count} eq "elim") {
				$tier_desc .= "Em";
				$tier_long_desc .= " in Elims";
			} elsif ($tb_info{$tb_id}{count} eq "prelim") {
				$tier_desc .= "Pm";
				$tier_long_desc .= " in Prelims";
			} elsif ($tb_info{$tb_id}{count} eq "previous") {
				$tier_desc .= "Lst";
				$tier_long_desc .= " in the previous round";
			} elsif ($tb_info{$tb_id}{count} eq "specific") {
				$tier_desc .= "R".$rounds{$tb_info{$tb_id}{round}}{name};
				$tier_long_desc .= " in Round ".$rounds{$tb_info{$tb_id}{round}}{name};
			}

			$entries{"tb_digits"}{$key} = $digits;

			my $tb_highlow = $tb_info{$tb_id}{highlow};

			if ($tb_info{$tb_id}{highlow_target}) {

				if ($tb_highlow == 1 || $tb_highlow == 2) {
					$tier_long_desc .= " middle ".$tb_info{$tb_id}{highlow_target}." scores ";
				} elsif ($tb_highlow == 3) {
					$tier_long_desc .= " best ".$tb_info{$tb_id}{highlow_target}." scores ";
				} elsif ($tb_highlow == 4) {
					$tier_long_desc .= " worst ".$tb_info{$tb_id}{highlow_target}." scores ";
				}
				$tier_desc .= "  ".$tb_info{$tb_id}{highlow_target}."sc ";

			} elsif ($tb_highlow) {

				$tier_desc .= " -".$tb_info{$tb_id}{highlow_count};
				$tier_long_desc .= " dropping ".$tb_info{$tb_id}{highlow_count};

				if ($tb_highlow == 1 || $tb_highlow == 2) {
					$tier_desc .= "HL";
					$tier_long_desc .= " best & worst";
				}

				if ($tb_highlow == 3) {
					$tier_desc .= "H";
					$tier_long_desc .= " best";
				}

				if ($tb_highlow == 4) {
					$tier_desc .= "L";
					$tier_long_desc .= " worst";
				}

				if ($tb_info{$tb_id}{highlow_threshold}) {
					$tier_long_desc .= " ".$tb_info{$tb_id}{highlow_threshold}."+ scores ";
					$tier_desc .= "  if ".$tb_info{$tb_id}{highlow_threshold}." ";
				}

				if ($tb_highlow == 5) {
					$tier_desc = "B".$tb_info{$tb_id}{highlow_count}.$tier_desc;
					$tier_long_desc = "The best ".$tb_info{$tb_id}{highlow_count}.$tier_long_desc;
				}
			}

			if ($tb_info{$tb_id}{child} > 0 ) {
				$tier_desc = "C".$tier_desc;
				$tier_long_desc .= " Composite based on ".$tb_info{$tb_id}{child}->name;
			}

			if ($tb_info{$tb_id}{"multiplier"} != 1) {
				$tier_long_desc .= " multplied by ".$tb_info{$tb_id}{"multiplier"};
				$tier_desc .= " x".$tb_info{$tb_id}{"multiplier"};
			}

			if ($tb_info{$tb_id}{"violation"} > 0) {
				$tier_long_desc .= " + ".$tb_info{$tb_id}{"violation"}." for violations";
			}

		}

		$tier_desc = "SOP" if $tier_desc eq "Sd+OSd";
		$tier_desc = "SOP" if $tier_desc eq "OSd+Sd";

		$tier_descs{$key} = $tier_desc;
		$tier_long_descs{$key} = $tier_long_desc;

		TB:
		foreach my $tb_id (@{$tb_tiers{$key}}) {

			if ($tb_info{$tb_id}{count} eq "specific") {

				if ($tb_info{$tb_id}{round} > 0) {
					push (@{$tb_info{$tb_id}{"rounds"}}, $tb_info{$tb_id}{round});
					push (@{$tb_info{$tb_id}{"round_ids"}}, $tb_info{$tb_id}{round}->id);
				}

			} else {

				foreach my $oround (@all_rounds) {

					if ($rounds{$oround}{"type"} eq $tb_info{$tb_id}{count}) {
						push (@{$tb_info{$tb_id}{"rounds"}}, $oround);
						push (@{$tb_info{$tb_id}{"round_ids"}}, $oround);
					}

					if ($tb_info{$tb_id}{count} eq "all") {
						push (@{$tb_info{$tb_id}{"rounds"}}, $oround);
						push (@{$tb_info{$tb_id}{"round_ids"}}, $oround);
					}

					if ($tb_info{$tb_id}{count} eq "previous"
						&& $rounds{$oround}{"name"} == $round->name
					) {
						push (@{$tb_info{$tb_id}{"rounds"}}, $oround);
						push (@{$tb_info{$tb_id}{"round_ids"}}, $oround);

						if ($event_type eq "congress") {
							my @ties = $m->comp("/funclib/congress_ties.mas", round => $round);
							if (@ties) {
								@{$tb_info{$tb_id}{"rounds"}} = @ties;

								foreach my $tie (@ties) {
									push (@{$tb_info{$tb_id}{"round_ids"}}, $tie->id);
								}
							}
						}
					}
				}
			}
		}

		ENTRY:
		foreach my $entry (@entries) {

			my %seen = ();
			@{$entries{"panels"}{$entry}} =
				grep { ! $seen{$_} ++ }
				@{$entries{"panels"}{$entry}};

			my $tier_total;
			my $round_averages;

			TB:
			foreach my $tb_id (@{$tb_tiers{$key}}) {

				my $name = $tb_info{$tb_id}{"name"};

				next unless $tb_info{$tb_id}{"round_ids"};

				my %raw_rounds = map {$_ => 1} @{$tb_info{$tb_id}{"round_ids"}};
				my @rounds = sort keys %raw_rounds;

				my $tb_highlow = $tb_info{$tb_id}{"highlow"};
				my $tb_highlow_count = $tb_info{$tb_id}{"highlow_count"};
				my $tb_highlow_threshold = $tb_info{$tb_id}{"highlow_threshold"};
				my $tb_highlow_target = $tb_info{$tb_id}{"highlow_target"};

				my $total;

				# WINS WINLOSS
				if ($name eq "winloss") {

					$total += Math::Round::nearest(1, 100 * $entries{"tb_wins"}{$tb_id}{$entry})
						unless $skip_wins;

				# LOSSES

				} elsif ($name eq "losses") {

					$total += Math::Round::nearest(1, 100 * $entries{"tb_losses"}{$tb_id}{$entry})
						unless $skip_wins;

				# NUMBER OF BALLOTS NUMBER OF SPEECHES COMPETED IN

				} elsif (
					$name eq "num_ballots"
				) {

					my $subtotal;
					foreach my $round_id (@rounds) {
						$subtotal += scalar (keys %{$entries{"section_count"}{$entry}{$round_id}});
					}

					$total += 100 * $subtotal;

				# RANKS RANKINGS RECIPS RECIPROCALS ONES TWOS

				} elsif (
					$name eq "ranks"
					|| $name eq "reciprocals"
					|| $name eq "chair_ranks"
					|| $name eq "non_chair_ranks"
				) {

					if ($name eq "chair_ranks") {
						$name = "ranks";
						$tb_info{$tb_id}{"chair"} = "chair";
					}

					if ($name eq "non_chair_ranks") {
						$name = "ranks";
						$tb_info{$tb_id}{"chair"} = "nonchair";
					}

					my @drop_best;
					my @drop_worst;
					my @drop_order;

					my $count;
					my $bye;
					my $max_score;

					ROUND:
					foreach my $this_round (@rounds) {

						$max_score = $max_score_count{"rank"}{$this_round};

						if (
							($entries{"round_panel_bye"}{$this_round}{$entry})
							|| (
								($entries{"round_bye"}{$this_round}{$entry} || $entries{"round_forfeit"}{$this_round}{$entry})
								&& (not defined $entries{"round_scores"}{$entry}{$this_round})
							)
						) {
							$bye += $max_score_count{"rank"}{$this_round};
							next ROUND;
						}

						my %used_scores;
						my $round_count;
						my $round_score;
						my %round_done;

						foreach my $score (@{$entries{"round_scores"}{$entry}{$this_round}}) {

							next if $round_done{$entry}{$this_round};

							if ($scores{"tag"}{$score} eq "rank"
								||	($scores{"tag"}{$score} eq "winloss" && $tb_info{$tb_id}{"child"}
							)) {

								my $rank;

								if ($tb_info{$tb_id}{"child"}) {

									if ($tourn_settings{"nsda_speech_method"} eq "doubledown") {

										$rank = $entries{"unbroken_rank"}{$entry}{$this_round};
										$entries{"used_composite"}{$entry}{$this_round} = $rank;

									} else {

										if ($scores{"tag"}{$score} eq "winloss") {

											$tier_descs{$key} =~ s/Rk/Wins/g;
											$tier_long_descs{$key} = "Composite Wins";
											$tier_dir{$key} =  "down";
											$entries{"tb_digits"}{$key} = 0;

											$rank++ if $entries{"composite_rank"}{$entry}{$this_round} == 1;
											$entries{"used_composite"}{$entry}{$this_round} = $rank;

										} else {
											$rank = $entries{"composite_rank"}{$entry}{$this_round};
											$entries{"used_composite"}{$entry}{$this_round} = $rank;
										}
									}

									# Bump the rank up if it's a violation.  Truncation below will
									# correct if this makes it bigger (ie if the TV was last place);
									my $this_panel = $scores{"panel"}{$score};
									my $this_judge = $scores{"judge"}{$score};

									if ($dq_panel_threshold{$this_panel}{$this_judge}) {
										foreach my $threshold (keys %{$dq_panel_threshold{$this_panel}{$this_judge}}) {
											$rank-- if $threshold < $rank;
										}
									}

									if (
										$tb_info{$tb_id}{"violation"}
										&& ($entries{"tv_yes"}{$entry}{$this_round} > $entries{"tv_no"}{$entry}{$this_round})
									) {
										$rank++;
									}

									if ($tb_info{$tb_id}{"truncate"}) {
										#Tiebreaker specific truncation limit
										$rank = $tb_info{$tb_id}{"truncate"} if $rank > $tb_info{$tb_id}{"truncate"};
									}

									if ($tb_info{$tb_id}{"truncate_smallest"}) {
										$rank = $smallest{$this_round} if $rank > $smallest{$this_round};
									}

									$round_done{$entry}{$this_round}++;

								} else {

									if ($tb_info{$tb_id}{"chair"} eq "chair") {
										next if $scores{"chair"}{$score} < 1;
									} elsif ($tb_info{$tb_id}{"chair"} eq "nonchair") {
										next if $scores{"chair"}{$score} > 0;
									}

									next if $used_scores{$score}++;
									$round_count++;

									$rank = $scores{"value"}{$score};
									my $this_panel = $scores{"panel"}{$score};
									my $this_judge = $scores{"judge"}{$score};

									if ($dq_panel_threshold{$this_panel}{$this_judge}) {
										foreach my $threshold (keys %{$dq_panel_threshold{$this_panel}{$this_judge}}) {
											$rank-- if $threshold < $rank;
										}
									}

									# Bump the rank up if it's a violation.  Truncation below will
									# correct if this makes it bigger (ie if the TV was last place);

									if ($scores{"tv"}{$score} && $tb_info{$tb_id}{"violation"}) {
										$rank++;
									}

									if ($tb_info{$tb_id}{"truncate"}) {
										#Tiebreaker specific truncation limit
										if ($rank > $tb_info{$tb_id}{"truncate"}) {
											$rank = $tb_info{$tb_id}{"truncate"};
										}
									}

									if ($tb_info{$tb_id}{"truncate_smallest"}) {
										$rank = $smallest{$this_round} if $rank > $smallest{$this_round};
									}

									#Rank cannot be greater than the size of the round
									my $panel_id = $entries{"round_panel"}{$entry}{$this_round};

									$rank = scalar @{$panels{$panel_id}{"entries"}}
										if $rank > scalar @{$panels{$panel_id}{"entries"}}
										&& $event_type ne "debate";
								}

								$round_score += Math::Round::nearest(1, 100 * $rank)
									if $name eq "ranks"
									|| $name eq "chair_ranks"
									|| $name eq "non_chair_ranks";

								$total += Math::Round::nearest(1, 100 * ( 1 / $rank ))
									if $rank > 0
									&& $name eq "reciprocals";

								$count++ if $name eq "ranks";

								if ($tb_highlow_target) {

									push @drop_best, $rank;

								} elsif ($tb_highlow) {

									#drop the best
									if ($tb_highlow == 1 || $tb_highlow == 2 || $tb_highlow == 3) {
										if (scalar @drop_best < $tb_highlow_count) {
											push @drop_best, $rank;
										} else {
											my $least_best = pop @drop_best;

											if ($least_best <= $rank) {
												push @drop_best, $least_best;
											} else {
												push @drop_best, $rank;
											}
										}
										@drop_best = sort {$a <=> $b} @drop_best;
									}

									#drop the worst
									if ( $tb_highlow == 1 || $tb_highlow == 2 || $tb_highlow == 4) {
										if (scalar @drop_worst < $tb_highlow_count) {
											push @drop_worst, $rank;
										} else {
											my $least_worst = pop @drop_worst;
											push @drop_worst, $least_worst if $least_worst >= $rank;
											push @drop_worst, $rank if $least_worst < $rank;
										}
										@drop_worst = sort {$b <=> $a} @drop_worst;
									}
								}
							}
						}

						if ($name eq "ranks"
							|| $name eq "chair_ranks"
							|| $name eq "non_chair_ranks"
						) {

							if ($event_settings{"mavericks"} eq "double") {

								if ($round_count
									&& $round_count < $max_score_count{"rank"}{$this_round}
								) {
									$round_score = $round_score
										* $max_score_count{"rank"}{$this_round}
										/ $round_count;

									$count +=
										($max_score_count{"rank"}{$this_round} / $round_count)
										- 1;
								}
							} else {

								if ($round_count
									&& $round_count < $max_score_count{"rank"}{$this_round}
								) {
									my $missing = $max_score_count{"rank"}{$this_round} - $round_count;
									#100 because we're 100x to avoid floats
									$round_score += 100 * $missing * 2 * $max_score_count{"rank"}{$this_round};
									$count +=  ($max_score_count{"rank"}{$this_round} / $round_count) - 1;
								}
							}
						}

						$total += Math::Round::nearest(1, $round_score)
							if $name eq "ranks"
							|| $name eq "chair_ranks"
							|| $name eq "best_po"
							|| $name eq "non_chair_ranks";
					}

					$bye = $bye - ($bye_min * $max_score) if $event_settings{"round_robin"};

					my $average;

					if ($bye) {
						$average = $total / $count if $count;
						$total += Math::Round::nearest(1, ($average * $bye));
						$entries{"tb_digits"}{$key} = 2 if $entries{"tb_digits"}{$key} < 2;
					}

					if ($tb_highlow_target > 0) {

						@drop_best = sort {$a <=> $b} @drop_best;
						while ( (scalar @drop_best) > $tb_highlow_target) {
							if ($tb_highlow == 1) {
								my $junk = shift @drop_best;
								$total -= Math::Round::nearest(1, 100 * $junk);
								$junk = pop @drop_best;
								$total -= Math::Round::nearest(1, 100 * $junk);
							} elsif ($tb_highlow == 3) {
								my $junk = shift @drop_best;
								$total -= Math::Round::nearest(1, 100 * $junk);
							} elsif ($tb_highlow == 4) {
								my $junk = pop @drop_best;
								$total -= Math::Round::nearest(1, 100 * $junk);
							}
						}

					} elsif (
						(not defined $tb_highlow_threshold)
						|| $tb_highlow_threshold <= $count
					) {
						foreach my $rank (@drop_best, @drop_worst) {

							$total -= Math::Round::nearest(1, 100 * $rank)
								if $name eq "ranks"
								|| $name eq "chair_ranks"
								|| $name eq "best_po"
								|| $name eq "non_chair_ranks";

							$total -= Math::Round::nearest(1, 100 * (1 / $rank))
								if $rank
								&& $name eq "reciprocals";

							$count-- if $name eq "ranks";
							$total = 0 if $total < 0;
						}
					}

					$entries{"ranks"}{$entry} = $total / $count if $count;

				} elsif ($name eq "best_po") {

					foreach my $this_round (@rounds) {

						foreach my $score (@{$entries{"round_scores"}{$entry}{$this_round}}) {

							if ($tb_info{$tb_id}{"chair"} eq "chair") {
								next if $scores{"chair"}{$score} < 1;
							} elsif ($tb_info{$tb_id}{"chair"} eq "nonchair") {
								next if $scores{"chair"}{$score} > 0;
							}

							if ($scores{"tag"}{$score} eq "best_po") {
								$total = 100;
							}
						}
					}

				# STUDENT VOTE ON A WIN LOSS BASIS STUDENT WINLOSS (ALL SV COUNTS AS ONE VOTE)
				} elsif (
					$name eq "entry_vote_one"
				) {

					my $tally;

					foreach my $this_round (@rounds) {
						if ( $entries{"student_wins"}{$entry}{$this_round}
							 > $entries{"student_loss"}{$entry}{$this_round}
						) {
							$tally++;
						}
					}

					$total += ($tally * 100);

				# STUDENT VOTE ON A WIN LOSS BASIS STUDENT WINLOSS (ALL SVS COUNT INDIVIDUALLY)
				} elsif (
					$name eq "entry_vote_all"
				) {

					my $tally;

					foreach my $this_round (@rounds) {
						$tally += $entries{"student_wins"}{$entry}{$this_round};
					}

					$total += ($tally * 100);

				# STUDENT VOTE FOR LEADERSHIP BOWLS ETC
				} elsif (
					$name eq "student_rank"
					|| $name eq "student_recip"
				) {

					my $truncate = $event_settings{"student_truncate_fill"};
					my @votes;

					$truncate = $tb_info{$tb_id}{"truncate"}
						if ($tb_info{$tb_id}{"truncate"} > 0 && $truncate > $tb_info{$tb_id}{"truncate"})
						|| ($tb_info{$tb_id}{"truncate"} > 0 && $truncate < 1);

					if ($entries{"student_rank"}{$entry}) {

						foreach my $this_round (@rounds) {

							next unless $entries{"student_rank"}{$entry}{$this_round};

							foreach my $vote (@{$entries{"student_rank"}{$entry}{$this_round}}) {
								push @votes, $vote;
							}

							if ($truncate > 0) {
								my @push;
								foreach my $rank (@votes) {
									$rank = $truncate if $rank > $truncate;
									push @push, $rank;
								}
								@votes = @push;
							}

							@votes = sort {$a <=> $b} @votes;

							if ($name eq "student_rank") {

								if ($tb_highlow) {

									my $count = $tb_highlow_count;

									#drop the best
									if ($tb_highlow == 1 || $tb_highlow == 2 || $tb_highlow == 3) {
										while ($count-- > 0) {
											shift @votes;
										}
									}

									$count = $tb_highlow_count;

									#drop the worst
									if ( $tb_highlow == 1 || $tb_highlow == 2 || $tb_highlow == 4) {
										while ($count-- > 0) {
											pop @votes;
										}
									}
								}

								my $subt;
								foreach my $v (@votes) {
									$subt += $v;
								}

								my $vote_count = scalar @votes;
								my $avg;

								if ($vote_count > 1) {
									$avg = Math::Round::nearest(.01, ($subt / $vote_count));
								}
								$total += $avg * 100;

								undef @votes;
							}
						}

						if ($name eq "student_recip") {

							if ($tb_highlow) {

								my $count = $tb_highlow_count;

								#drop the best
								if ($tb_highlow == 1 || $tb_highlow == 2 || $tb_highlow == 3) {
									while ($count-- > 0) {
										shift @votes;
									}
								}

								$count = $tb_highlow_count;

								#drop the worst
								if ( $tb_highlow == 1 || $tb_highlow == 2 || $tb_highlow == 4) {
									while ($count-- > 0) {
										pop @votes;
									}
								}
							}


							foreach my $vote (@votes) {
								$total += Math::Round::nearest(1, 100 * (1 / $vote)) if $vote;
							}

						}
					}

				} elsif ($name eq "student_nominee") {

					if ($entries{"student_nominee"}{$entry}) {
						foreach my $this_round (@rounds) {
							next unless $entries{"student_nominee"}{$entry}{$this_round};

							foreach my $vote (@{$entries{"student_nominee"}{$entry}{$this_round}}) {
								$total += $vote * 100;
							}
						}
					}

				# DOWNS DOUBLEDOWN DROPS DOUBLEDROPS

				} elsif ($name eq "downs") {

					foreach my $this_round (@rounds) {

						my $panel_id   = $entries{"round_panel"}{$entry}{$this_round};
						my $rank       = $entries{"composite_rank"}{$entry}{$this_round};
						my $rank_count = $entries{"composite_rank_count"}{$panel_id}{$rank};

						$entries{"used_composite"}{$entry}{$this_round} = $rank;

						my $size_of_panel =
							scalar @{$panels{$panel_id}{"entries"}}
							if $panels{$panel_id}{"entries"};

						my $first_limit = POSIX::floor($size_of_panel / 2);
						my $absolute_limit = POSIX::ceil($size_of_panel / 2);

						$absolute_limit++ if $first_limit == $absolute_limit;

						# The NSDA.  Where formulas take a backseat to lists.

						if ($tourn_settings{"nsda_district"}) {

							given ($size_of_panel) {

								when (4) {
									$first_limit    = 2;
									$absolute_limit = 4;
								}

								when (5) {
									$first_limit    = 3;
									$absolute_limit = 4;
								}

								when (6) {
									$first_limit    = 3;
									$absolute_limit = 4;
								}

								when (7) {
									$first_limit    = 3;
									$absolute_limit = 4;
								}
							}
						}

						my $rank_position = $rank + ($rank_count - 1);

						if ($rank_count > 1) {
							$total++ if $rank_position > $absolute_limit;
						} else {
							$total++ if $rank_position > $first_limit;
						}
					}

					$total = $total * 100;

				# SPEAKS SPEAKER POINTS
				} elsif ($name eq "points") {

					my $bye;
					my $count;
					my $averages;
					my $num_rounds;
					my @student_ids;

					my @drop_best;
					my @drop_worst;
					my %points_have_bye;

					my $max_score;
					my %student_points = ();
					my %round_average = ();
					my $rounds_with_scores;

					foreach my $this_round (@rounds) {

						my $got_one;
						my %judge_totals;

						SCORE:
						foreach my $score (@{$entries{"round_scores"}{$entry}{$this_round}}) {

							if ($tb_info{$tb_id}{"chair"} eq "chair") {
								next if $scores{"chair"}{$score} < 1;
							} elsif ($tb_info{$tb_id}{"chair"} eq "nonchair") {
								next if $scores{"chair"}{$score} > 0;
							}

							if ($scores{"tag"}{$score} eq "point") {
								my $points = Math::Round::nearest(1, 100 * $scores{"value"}{$score});
								push @{$student_points{$scores{'student'}{$score}}{"scores"}}, $points;
								$got_one++;

								my $judge = $scores{"judge"}{$score};
								$judge_totals{$judge}{total} += $points;
								$judge_totals{$judge}{count}++;
							}
						}

						foreach my $judge (keys %judge_totals) {
							if ($judge_totals{$judge}{"count"} > 0) {
								my $average = Math::Round::nearest(1, ($judge_totals{$judge}{total} / $judge_totals{$judge}{count}));
								$round_average{$entry}{$this_round} += $average;
							}
						}

						$rounds_with_scores++ if $got_one;

					}

					next ENTRY unless $rounds_with_scores;
					my $tourn_total;
					my $tourn_count;

					foreach my $student_id (keys %student_points) {

						if ($student_points{$student_id}{"scores"}) {
							foreach my $value (@{$student_points{$student_id}{"scores"}}) {
								$tourn_total += $value;
								$tourn_count++;
								$student_points{$student_id}{"total"} += $value;
								$student_points{$student_id}{"count"}++;
							}
						}

						push @student_ids, $student_id;

						if ($student_points{$student_id}{"count"}) {

							$student_points{$student_id}{"average"} =
								Math::Round::nearest(
									.01,
									($student_points{$student_id}{"total"} / $student_points{$student_id}{"count"})
								);
						}
					}

					foreach my $this_round (@rounds) {

						$num_rounds++;
						$max_score = $max_score_count{"point"}{$this_round};

						if ($byes_on_team_basis && $entries{"round_panel_bye"}{$this_round}{$entry}) {
							$bye++;
						} elsif ($entries{"round_panel_bye"}{$this_round}{$entry}) {
							$bye += $max_score_count{"point"}{$this_round};
						}

						if ($entries{"round_panel_bye"}{$this_round}{$entry}
							&& $this_round_sequence != 1
						) {
							next;
						}

						my $round_count;
						my $round_score;
						my %judge_points = ();
						my %done_students = ();

						if ($event_settings{"team_points"}) {

							if ($round_average{$entry}{$this_round}) {
								$round_score += $round_average{$entry}{$this_round};
								$round_count++;
								$count++ unless $byes_on_team_basis;
							}

							foreach my $score (@{$entries{"round_scores"}{$entry}{$this_round}}) {

								if ($tb_info{$tb_id}{"chair"} eq "chair") {
									next if $scores{"chair"}{$score} < 1;
								} elsif ($tb_info{$tb_id}{"chair"} eq "nonchair") {
									next if $scores{"chair"}{$score} > 0;
								}

								if (
									$scores{"tag"}{$score} eq "point"
									|| $scores{"tag"}{$score} eq "refute"
								) {

									my $points = Math::Round::nearest(1, 100 * $scores{"value"}{$score});
									$judge_points{$this_round}{$scores{"judge"}{$score}} += $points;
									$done_students{$scores{"student"}{$score}}++;
								}
							}

						} else {

							foreach my $score (@{$entries{"round_scores"}{$entry}{$this_round}}) {

								if ($tb_info{$tb_id}{"chair"} eq "chair") {
									next if $scores{"chair"}{$score} < 1;
								} elsif ($tb_info{$tb_id}{"chair"} eq "nonchair") {
									next if $scores{"chair"}{$score} > 0;
								}

								if (
									$scores{"tag"}{$score} eq "point"
									|| $scores{"tag"}{$score} eq "refute"
								) {

									my $points = Math::Round::nearest(1, 100 * $scores{"value"}{$score});

									$count++ unless $byes_on_team_basis;
									$round_count++;

									$judge_points{$this_round}{$scores{"judge"}{$score}} += $points;
									$round_score += $points;

									$done_students{$scores{"student"}{$score}}++;

								}
							}
						}

						$count++ if $round_score && $byes_on_team_basis;
						my $average_round_count;

						if ($event_settings{"team_points"}) {


						} elsif ($event_settings{"max_entry"} > 1) {

							if ($round_count && $round_count < $max_score_count{"point"}{$this_round}) {

								# Readability is your friend
								my $max_scount = $max_score_count{"point"}{$this_round};

								if ($event_settings{"mavericks"} eq "double" || $event_settings{"mavericks"} eq "double_rank") {

									if ($round_count > 0) {

										my $factor = ($round_score / $round_count);
										my $missing = $max_scount - $round_count;

										foreach (1 .. $missing) {
											$count++;
											$round_count++;

											foreach my $judgekey (keys %{$judge_points{$this_round}}) {
												$judge_points{$this_round}{$judgekey} += $factor;
											}

											$round_score += $factor;
										}
									}

								} elsif ($event_settings{"mavericks"} eq "own_average") {

									# Missing speaker's average
									foreach my $student_id (keys %student_points) {

										next if $done_students{$student_id};
										my $missing = $max_scount - $round_count;

										foreach (1 .. $missing) {

											$round_score += $student_points{$student_id}{"average"};
											$round_count++;
											$count++;

											foreach my $judgekey (keys %{$judge_points{$this_round}}) {
												$judge_points{$this_round}{$judgekey} += $student_points{$student_id}{"average"};
											}
										}
									}

									$count += ($max_scount / $round_count) - 1;
									$averages += ($max_scount / $round_count) - 1;

								} elsif ($event_settings{"mavericks"} eq "average") {

									#Tournament wide average
									unless ($event_settings{"average_points"}) {
										my $point_totals;
										my $point_count;

										foreach my $test_round (@rounds) {
											foreach my $panel (@{$rounds{$test_round}{"panels"}}) {
												foreach my $entry (@{$panels{$panel}{"entries"}}) {
													foreach my $score (@{$entries{"round_scores"}{$entry}{$test_round}}) {

														if ($tb_info{$tb_id}{"chair"} eq "chair") {
															next if $scores{"chair"}{$score} < 1;
														} elsif ($tb_info{$tb_id}{"chair"} eq "nonchair") {
															next if $scores{"chair"}{$score} > 0;
														}

														next unless $scores{"tag"}{$score} eq "point";
														$point_totals += $scores{"value"}{$score};
														$point_count++;
													}
												}
											}
										}
										$event_settings{"average_points"} = Math::Round::nearest(1, 100 * ($point_totals / $point_count));
									}

									foreach my $student_id (keys %student_points) {

										next if $done_students{$student_id};
										my $missing = $max_scount - $round_count;

										foreach (1 .. $missing) {
											$round_score += $event_settings{"average_points"};
											$round_count++;
											$count++;

											foreach my $judgekey (keys %{$judge_points{$this_round}}) {
												$judge_points{$this_round}{$judgekey} += $event_settings{"average_points"};
											}
										}
									}

									$count += ($max_scount / $round_count) - 1;
									$averages += ($max_scount / $round_count) - 1;

								} elsif ($event_settings{"mavericks"} eq "nothing") {

									foreach my $student_id (keys %student_points) {
										next if $done_students{$student_id};
										my $missing = $max_scount - $round_count;

										foreach (1 .. $missing) {
											$round_count++;
											$count++;
											foreach my $judgekey (keys %{$judge_points{$this_round}}) {
												$judge_points{$this_round}{$judgekey} += 0;
											}
										}
									}
								}
							}
						}

						if ($round_count) {

							unless (defined $round_score) {
								if (
									$entries{"round_bye"}{$this_round}{$entry}
									|| $entries{"round_forfeit"}{$this_round}{$entry}
								) {
									$bye += $round_count;
								}
							}

						} elsif ($event_type eq "debate") {

							unless (defined $round_score) {
								if ($byes_on_team_basis) {
									if (
										$entries{"round_bye"}{$this_round}{$entry}
										|| $entries{"round_forfeit"}{$this_round}{$entry}
									) {
										$bye++;
									}
								} else {
									$bye += $max_score_count{"point"}{$this_round}
										if $entries{"round_bye"}{$this_round}{$entry};

									$bye += $max_score_count{"point"}{$this_round}
										if $entries{"round_forfeit"}{$this_round}{$entry};
								}
							}

							unless ($bye) {

								if ($byes_on_team_basis) {

									$average_round_count++;
									$count++;
									$averages++;

								} else {

									$average_round_count += $max_score_count{"point"}{$this_round};
									$count += $max_score_count{"point"}{$this_round};
									$averages += $max_score_count{"point"}{$this_round};

								}
							}
						}

						# This judgekey thing deals with multi judge prelims
						foreach my $judgekey (keys %{$judge_points{$this_round}}) {

							my $points = $judge_points{$this_round}{$judgekey};

							if ($tb_highlow) {

								if (
									$tb_highlow == 1
									|| $tb_highlow == 2
									|| $tb_highlow == 3
								) {

									if (scalar @drop_best < $tb_highlow_count) {
										push @drop_best, $points;
									} else {
										my $least_best = shift @drop_best;
										push @drop_best, $least_best if $least_best >= $points;
										push @drop_best, $points if $least_best < $points;
									}

									@drop_best = sort {$a <=> $b} @drop_best;
								}

								#drop the worst

								if (
									$tb_highlow == 1
									|| $tb_highlow == 2
									|| $tb_highlow == 4
								) {

									if (scalar @drop_worst < $tb_highlow_count) {

										push @drop_worst, $points;

									} else {

										my $least_worst = shift @drop_worst;
										push @drop_worst, $least_worst if $least_worst <= $points;
										push @drop_worst, $points if $least_worst > $points;

									}

									@drop_worst = sort {$b <=> $a} @drop_worst;
								}
							}
						}

						$total += $round_score;

						# Used for whole round averages when powering round 1
						$entries{"round_points"}{$this_round}{$entry} = $round_score
							unless $entries{"round_points"}{$this_round}{$entry};

						if (
							((not defined $total) || $total == 0)
							&& $this_round_sequence == 1
						) {
							$entries{"round_averages"}{$entry}{$this_round}++;
							$event_settings{"round_averages"}++;
							$round_averages++;
						}

						next if $bye && not defined $round_score;
						$points_have_bye{$round_score} = $average_round_count;
					}

					$bye = $bye - ($bye_min * $max_score) if $event_settings{"round_robin"};

					my $average;

					if ($bye) {
						$average = $total / $count if $count;
						$total += Math::Round::nearest(1, $average * $bye);
						$count += $bye;
					}

					if ($averages) {
						$entries{"tb_digits"}{$key} = 2;

						if ($count && ($count - $averages) > 0) {
							$average = $total / ($count - $averages);
						}

						$total += Math::Round::nearest(1, $average * $averages);
						$count += $averages;
					}

					my $how_many  = $count / (scalar @rounds) if scalar @rounds;

					if ($tb_highlow) {
						if ($tb_highlow == 1 || $tb_highlow == 2) {
							$how_many -= 2 * $tb_highlow_count;
						} else {
							$how_many -= $tb_highlow_count;
						}
					}

					if (
						(not defined $tb_highlow_threshold)
						|| $tb_highlow_threshold <= $count
					) {
						foreach my $points (@drop_best, @drop_worst) {
							next unless $tb_highlow;
							$total -= Math::Round::nearest(1, $points);
							$total -= Math::Round::nearest(1, $average * $points_have_bye{$points});
							$total = 0 if $total < 0;
							$count--;
						}
					}


					if ($count) {
						#Used for opp wins, opp points
						$entries{"point"}{$entry} += ($total / $count);
					}


				# BALLOT COUNT BALLOTS
				} elsif ( $name eq "ballots") {

					my $bye;
					my $entry_bye_count;
					my $ballot_score;
					my $ballot_round_count;

					foreach my $this_round (@rounds) {

						foreach my $score (@{$entries{"round_scores"}{$entry}{$this_round}}) {

							if ($tb_info{$tb_id}{"chair"} eq "chair") {
								next if $scores{"chair"}{$score} < 1;
							} elsif ($tb_info{$tb_id}{"chair"} eq "nonchair") {
								next if $scores{"chair"}{$score} > 0;
							}

							if ($scores{"tag"}{$score} eq "winloss") {
								$ballot_score++ if $scores{"value"}{$score} == 1;
							}
						}

						if ($entries{"round_bye"}{$this_round}{$entry}
							|| $entries{"round_panel_bye"}{$this_round}{$entry}
						) {

							if ($event_settings{"round_robin"}) {
								if ($entry_bye_count++ >= $bye_min) {
									$bye += $max_score_count{"winloss"}{$this_round};
								}
							} else {
								$bye += $max_score_count{"winloss"}{$this_round};
							}
						} else {
							$ballot_round_count++;
						}
					}


					if ($bye) {

						if ($event_settings{"bye_ballot_count"} > 0) {

							$ballot_score += $event_settings{"bye_ballot_count"};

						} elsif ($event_settings{"wsdc_bye_win_average"} && $ballot_round_count) {

							my $ballot_average = ($ballot_score / $ballot_round_count);
							$ballot_average = Math::Round::nearest(1, $ballot_average);
							$ballot_score += $ballot_average;

						} else {

							$ballot_score += $bye;
						}
					}

					$total += Math::Round::nearest(1, 100 * $ballot_score);

				# CONGRESS SPEECH POINTS
				} elsif ($name eq "congress_speech") {

					my @points;

					ROUND:
					foreach my $this_round (@rounds) {

						my %score_total;
						my $presided;

						foreach my $score (@{$entries{"round_scores"}{$entry}{$this_round}}) {

							if ($tb_info{$tb_id}{"chair"} eq "chair") {
								next if $scores{"chair"}{$score} < 1;
							} elsif ($tb_info{$tb_id}{"chair"} eq "nonchair") {
								next if $scores{"chair"}{$score} > 0;
							}
							$presided++ if $scores{"tag"}{$score} eq "po";
							last if $presided;
						}

						my $base_count = scalar @points;

						unless ($presided) {

							foreach my $judge_id (
								sort {
									$a <=> $b
								} keys %{$entries{"judge_scores"}{$entry}{$this_round}}
							) {

								my $counter = $base_count + 1;

								foreach my $score_id  (
									sort {
										$scores{"speech"}{$a} <=> $scores{"speech"}{$b}
									} @{$entries{'judge_scores'}{$entry}{$this_round}{$judge_id}}
								) {

									if ($tb_info{$tb_id}{"chair"} eq "chair") {
										next if $scores{"chair"}{$score_id} < 1;
									} elsif ($tb_info{$tb_id}{"chair"} eq "nonchair") {
										next if $scores{"chair"}{$score_id} > 0;
									}

									if ($scores{"tag"}{$score_id} eq "speech") {
										$score_total{$counter++} += $scores{"value"}{$score_id};
									}
								}
							}
						}

						foreach my $key (sort keys %score_total) {
							push @points, Math::Round::nearest(1, 100 * $score_total{$key});
						}

						@points = sort {$a <=> $b} @points;
					}

					if ($tb_highlow) {

						my $count = $tb_highlow_count;

						#drop the best
						if ($tb_highlow == 1 || $tb_highlow == 2 || $tb_highlow == 3) {
							while ($count-- > 0) {
								shift @points;
							}
						}

						$count = $tb_highlow_count;

						#drop the worst
						if ( $tb_highlow == 1 || $tb_highlow == 2 || $tb_highlow == 4) {
							while ($count-- > 0) {
								pop @points;
							}
						}

						#count only the best
						if ($tb_highlow == 5) {
							while ((scalar @points) > $tb_highlow_count ) {
								shift @points;
							}
						}
					}

					foreach my $point (@points) {
						$total += $point;
					}

				# POINTS WHILE PRESIDING OFFICER
				} elsif ($name eq "po_points") {

					ROUND:
					foreach my $this_round (@rounds) {

						my $presided;

						foreach my $score (@{$entries{"round_scores"}{$entry}{$this_round}}) {
							if ($tb_info{$tb_id}{"chair"} eq "chair") {
								next if $scores{"chair"}{$score} < 1;
							} elsif ($tb_info{$tb_id}{"chair"} eq "nonchair") {
								next if $scores{"chair"}{$score} > 0;
							}
							$presided++ if $scores{"tag"}{$score} eq "po";
							last if $presided;
						}

						my @points;

						if ($presided) {
							foreach my $score (@{$entries{"round_scores"}{$entry}{$this_round}}) {
								if ($tb_info{$tb_id}{"chair"} eq "chair") {
									next if $scores{"chair"}{$score} < 1;
								} elsif ($tb_info{$tb_id}{"chair"} eq "nonchair") {
									next if $scores{"chair"}{$score} > 0;
								}
								if ($scores{"tag"}{$score} eq "speech") {
									push @points, Math::Round::nearest(1, 100 * $scores{"value"}{$score});
								}
							}
						}

						@points = sort {$a <=> $b} @points;

						if ($tb_highlow) {

							my $count = $tb_highlow_count;

							#drop the best
							if ($tb_highlow == 1 || $tb_highlow == 2 || $tb_highlow == 3) {
								while ($count-- > 0) {
									shift @points;
								}
							}

							$count = $tb_highlow_count;

							#drop the worst
							if ( $tb_highlow == 1 || $tb_highlow == 2 || $tb_highlow == 4) {
								while ($count-- > 0) {
									pop @points;
								}
							}

							#count only the best
							if ($tb_highlow == 5) {
								while ((scalar @points) > $tb_highlow_count ) {
									pop @points;
								}
							}
						}

						foreach my $point (@points) {
							$total += $point;
						}
					}

				# POINT SPREADS POINT DIFFERENTIALS
				} elsif ($name eq "point_diff") {

					my @spreads;

					ROUND:
					foreach my $round_id (@rounds) {

						my $section_id = $entries{"round_panel"}{$entry}{$round_id};
						my $mine;
						my $my_count;

						my $theirs;
						my $their_count;

						foreach my $other (@{$panels{$section_id}{"entries"}}) {
							foreach my $score_id (@{$entries{"round_scores"}{$other}{$round_id}}) {

								if ($tb_info{$tb_id}{"chair"} eq "chair") {
									next if $scores{"chair"}{$score_id} < 1;
								} elsif ($tb_info{$tb_id}{"chair"} eq "nonchair") {
									next if $scores{"chair"}{$score_id} > 0;
								}

								next unless $scores{"tag"}{$score_id} eq "point";

								if ($other == $entry) {
									$mine += Math::Round::nearest(1, 100 * $scores{"value"}{$score_id});
									$my_count++;
								} else {
									$theirs += Math::Round::nearest(1, 100 * $scores{"value"}{$score_id});
									$their_count++;
								}
							}
						}

						if ($their_count && $my_count) {

							if ($their_count > $my_count) {
								$mine = $mine * ($their_count / $my_count)
							} elsif ($their_count < $my_count) {
								$theirs = $theirs * ($my_count / $their_count)
							}

							if (defined $mine && defined $theirs) {
								push @spreads, ($mine - $theirs);
							}
						}
					}

					if ($tb_highlow) {

						my $count = $tb_highlow_count;

						#drop the best
						if ($tb_highlow == 1 || $tb_highlow == 2 || $tb_highlow == 3) {
							while ($count-- > 0) {
								shift @spreads;
							}
						}

						$count = $tb_highlow_count;

						#drop the worst
						if ( $tb_highlow == 1 || $tb_highlow == 2 || $tb_highlow == 4) {
							while ($count-- > 0) {
								pop @spreads;
							}
						}
					}

					my $sum;
					my $count;

					foreach my $spread (@spreads) {
						$sum += $spread;
						$count++;
					}

					if ($count) {
						$total += Math::Round::nearest(1, ($sum / $count));
					}

				# ROUNDS DEBATED IN
				} elsif ( $name eq "rounds") {

					my $num_rounds = scalar (keys %{$entries{"rounds"}{$entry}});
					$total += Math::Round::nearest(1, 100 * $num_rounds);

				# COINFLIP RANDOM

				} elsif ( $name eq "coinflip") {

					# This is only semi random; product of the date epoch and
					# the random entry ID's last four digits.  But it will be
					# the same every time this function is run and random
					# enough in that it cannot be pre-guessed easily.

					my $random_seed = $entry * $seed;
					$total = substr($random_seed, -8, -5);

				# THREE WAY BOUNCE FOR JUDGES PREFERENCE ON RECIPS

				} elsif ( $name eq "three_way_recip" || $name eq "3way_rcp_worst") {

					my $chosen_panel;
					my @chosen_entries;

					foreach my $this_round (@rounds) {

						# Only counts in the current round;

						PANEL:
						foreach my $panel (@{$rounds{$this_round}{"panels"}}) {
							my @entries = eval {
								return @{$panels{$panel}{"entries"}};
							};
							next PANEL unless scalar @entries > 0;
							next PANEL unless grep {$_ == $entry} @entries;
							$chosen_panel = $panel;
							@chosen_entries = @entries;
						}

						my %beseen = ();
						@chosen_entries = grep { ! $beseen{$_} ++ } @chosen_entries;

						my $entry_string;

						foreach my $okey (sort keys %tb_tiers) {
							next if $key == $okey;
							$entry_string .= "-" if $entry_string;
							$entry_string .= $entries{"tbs"}{$entry}{$okey};
						}

						my @ties;

						foreach my $oentry (@chosen_entries) {

							my $test_string;

							foreach my $okey (sort keys %tb_tiers) {
								next if $key == $okey;
								$test_string .= "-" if $test_string;
								$test_string .= $entries{"tbs"}{$oentry}{$okey};
							}

							push(@ties, $oentry) if $test_string eq $entry_string;
						}

						if (scalar @ties == 3) {

							my %tie_scores;

							foreach my $tie (@ties) {

								# Take an average so you don't have to mess around with byes

								my $recips;
								my $count;

								foreach my $tie_round (@rounds) {
									foreach my $score (@{$entries{"round_scores"}{$tie}{$tie_round}}) {

										if ($tb_info{$tb_id}{"chair"} eq "chair") {
											next if $scores{"chair"}{$score} < 1;
										} elsif ($tb_info{$tb_id}{"chair"} eq "nonchair") {
											next if $scores{"chair"}{$score} > 0;
										}

										if ($scores{"tag"}{$score} eq "rank") {
											$recips += Math::Round::nearest(1, 100 * (1 / $scores{"value"}{$score}));
											$count++;
										}
									}
								}
								$tie_scores{$tie} = Math::Round::nearest(1, ($recips / $count)) if $count;
								$tie_scores{$tie} = 0 unless $count;
							}

							my $min_score;

							# Minimum score is the worst score for reciprocals
							foreach my $tie (@ties) {
								$min_score = $tie_scores{$tie} unless $min_score;
								$min_score = $tie_scores{$tie} if $tie_scores{$tie} < $min_score;
							}

							if ($name eq "three_way_recip") {
								$total += 100 if $min_score == $tie_scores{$entry};
							} else {
								$total += 100 if $min_score != $tie_scores{$entry};
							}

						}
					}

				# THREE WAY BOUNCE FOR JUDGES PREFERENCE ON POINTS

				} elsif ( $name eq "three_way_point" || $name eq "3way_pts_worst") {

					my $chosen_panel;
					my @chosen_entries;

					foreach my $this_round (@rounds) {

						# Only counts in the current round;

						PANEL:
						foreach my $panel (@{$rounds{$this_round}{"panels"}}) {
							my @entries = eval {
								return @{$panels{$panel}{"entries"}};
							};
							next PANEL unless grep {$_ == $entry} @entries;
							$chosen_panel = $panel;
							@chosen_entries = @entries;
						}

						my %beseen = ();
						@chosen_entries = grep { ! $beseen{$_} ++ } @chosen_entries;

						my $entry_string;

						foreach my $okey (sort keys %tb_tiers) {
							next if $key == $okey;
							$entry_string .= "-" if $entry_string;
							$entry_string .= $entries{"tbs"}{$entry}{$okey};
						}

						my @ties;

						foreach my $oentry (@chosen_entries) {
							my $test_string;

							foreach my $okey (sort keys %tb_tiers) {
								next if $key == $okey;
								$test_string .= "-" if $test_string;
								$test_string .= $entries{"tbs"}{$oentry}{$okey};
							}

							push(@ties, $oentry) if $test_string eq $entry_string;
						}

						if (scalar @ties == 3) {

							my %tie_scores;

							foreach my $tie (@ties) {

								# Take an average so you don't have to mess around with byes
								my $points;
								my $count;

								foreach my $tie_round (@rounds) {
									foreach my $score (@{$entries{"round_scores"}{$tie}{$tie_round}}) {

										if ($tb_info{$tb_id}{"chair"} eq "chair") {
											next if $scores{"chair"}{$score} < 1;
										} elsif ($tb_info{$tb_id}{"chair"} eq "nonchair") {
											next if $scores{"chair"}{$score} > 0;
										}

										if ($scores{"tag"}{$score} eq "point") {
											$points += Math::Round::nearest(1, 100 * $scores{"value"}{$score});
											$count++;
										}
									}
								}

								$tie_scores{$tie} = Math::Round::nearest(1, ($points / $count)) if $count;
								$tie_scores{$tie} = 0 unless $count;
							}

							my $max_score;

							foreach my $tie (@ties) {
								$max_score = $tie_scores{$tie} if $tie_scores{$tie} > $max_score;
							}

							if ($name eq "three_way_point") {
								$total += 100 if $max_score == $tie_scores{$entry};
							} else {
								$total += 100 if $max_score != $tie_scores{$entry};
							}

						}
					}

				# JUDGEPREF
				} elsif ( $name eq "judgepref") {

					my $chosen_panel;
					my @chosen_entries;
					my @all_entries;


					foreach my $this_round (@rounds) {

						# Only counts in the current round;

						PANEL:
						foreach my $panel (@{$rounds{$this_round}{"panels"}}) {
							my @entries = eval {
								return @{$panels{$panel}{"entries"}};
							};
							push @all_entries, @entries;
							next PANEL unless grep {$_ == $entry} @entries;
							$chosen_panel = $panel;
							@chosen_entries = @entries;
						}

						my $entry_string;
						foreach my $okey (sort keys %tb_tiers) {
							next if $key == $okey;
							$entry_string .= "-" if $entry_string;
							$entry_string .= $entries{"tbs"}{$entry}{$okey};
						}

						# NSDA Nats only applies judge preference as a TB if
						# there is an overall 2 way tie, otherwise skips.

						if ($tourn_settings{"nsda_nats"} && $event_type ne "congress") {

							my @nats_ties;

							foreach my $oentry (@all_entries) {

								next if $oentry == $entry;
								my $test_string;

								foreach my $okey (sort keys %tb_tiers) {
									next if $key == $okey;
									$test_string .= "-" if $test_string;
									$test_string .= $entries{"tbs"}{$oentry}{$okey};
								}

								push(@nats_ties, $oentry) if $test_string eq $entry_string;
							}

							if (scalar @nats_ties != 1) {
								next TB;
							}
						}

						my %beseen = ();
						@chosen_entries = grep { ! $beseen{$_} ++ } @chosen_entries;

						my @ties;

						foreach my $oentry (@chosen_entries) {

							next if $oentry == $entry;
							my $test_string;

							foreach my $okey (sort keys %tb_tiers) {
								next if $key == $okey;
								$test_string .= "-" if $test_string;
								$test_string .= $entries{"tbs"}{$oentry}{$okey};
							}

							push(@ties, $oentry) if $test_string eq $entry_string;
						}

						if (scalar @ties == 1) {

							my $tie_id = shift @ties;
							my %judge_score = ();

							if ($chosen_panel && $entry) {

								my %done;

								foreach my $score (@{$entries{"scores"}{$entry}}) {

									next if $done{$score}++;

									if ($tb_info{$tb_id}{"chair"} eq "chair") {
										next if $scores{"chair"}{$score} < 1;
									} elsif ($tb_info{$tb_id}{"chair"} eq "nonchair") {
										next if $scores{"chair"}{$score} > 0;
									}

									next unless $scores{"tag"}{$score} eq "rank";
									next unless $scores{"panel"}{$score} == $chosen_panel;

									my $judge_id = $scores{"judge"}{$score};

									$judge_score{$chosen_panel}{$judge_id} = $scores{"value"}{$score};
									$judge_score{$chosen_panel}{$judge_id} = $tb_info{$tb_id}{"truncate"}
										if $tb_info{$tb_id}{"truncate"}
										&& $judge_score{$scores{"judge"}{$score}};

								}

								# If my rank is better (lower) than the tie's
								# rank, I get a JP point

								foreach my $tie_score (@{$entries{"scores"}{$tie_id}}) {

									next if $done{$tie_score}++;
									next unless $scores{"tag"}{$tie_score} eq "rank";
									next unless $scores{"panel"}{$tie_score} == $chosen_panel;

									$total += 100 if $scores{"value"}{$tie_score} >
											$judge_score{$chosen_panel}{$scores{"judge"}{$tie_score}};

								}
							}
						}
					}

				} elsif ( $name eq "preponderance") {

					my $current_panel = $entries{"round_panel"}{$entry}{$this_round_id};

					my $count_ones;
					my $count_not_ones;

					my %done;
					foreach my $score (@{$entries{"scores"}{$entry}}) {

						next if $done{$score}++;

						if ($tb_info{$tb_id}{"chair"} eq "chair") {
							next if $scores{"chair"}{$score} < 1;
						} elsif ($tb_info{$tb_id}{"chair"} eq "nonchair") {
							next if $scores{"chair"}{$score} > 0;
						}

						next unless $scores{"tag"}{$score} eq "rank";
						next unless $scores{"panel"}{$score} == $current_panel;

						if ($scores{"value"}{$score} == 1) {
							$count_ones++;
						} else {
							$count_not_ones++;
						}
					}

					$total += 100 if $count_ones > $count_not_ones;

				} elsif ( $name eq "headtohead") {

					my @test_entries = @entries;
					my $entry_string;

					foreach my $okey (sort keys %tb_tiers) {
						next if $key == $okey;
						$entry_string .= "-" if $entry_string;
						$entry_string .= $entries{"tbs"}{$entry}{$okey};
					}

					my @ties;

					foreach my $oentry (@test_entries) {

						next if $oentry == $entry;

						if ($event_settings{"round_robin"} && $entries{'pod'}{$entry}) {
							next unless $entries{"pod"}{$oentry} == $entries{'pod'}{$entry};
						}

						my $test_string;
						foreach my $okey (sort keys %tb_tiers) {
							next if $key == $okey;
							$test_string .= "-" if $test_string;
							$test_string .= $entries{"tbs"}{$oentry}{$okey};
						}

						push(@ties, $oentry) if $test_string eq $entry_string;
					}

					if (scalar @ties == 1) {

						my $tie_id = shift @ties;
						my %panel_ballots = ();
						my %done;

						foreach my $this_round (@rounds) {

							next unless $entries{"round_panel"}{$entry}{$this_round} == $entries{"round_panel"}{$tie_id}{$this_round};

							my $entry_count;
							my $tie_count;

							foreach my $score (@{$entries{"round_scores"}{$entry}{$this_round}}) {

								next unless $scores{"tag"}{$score} eq "winloss";

								if ($tb_info{$tb_id}{"chair"} eq "chair") {
									next if $scores{"chair"}{$score} < 1;
								} elsif ($tb_info{$tb_id}{"chair"} eq "nonchair") {
									next if $scores{"chair"}{$score} > 0;
								}

								$entry_count += $scores{"value"}{$score};
							}

							foreach my $score (@{$entries{"round_scores"}{$tie_id}{$this_round}}) {
								next unless $scores{"tag"}{$score} eq "winloss";

								if ($tb_info{$tb_id}{"chair"} eq "chair") {
									next if $scores{"chair"}{$score} < 1;
								} elsif ($tb_info{$tb_id}{"chair"} eq "nonchair") {
									next if $scores{"chair"}{$score} > 0;
								}

								$tie_count += $scores{"value"}{$score};
							}

							$total += 100 if $entry_count > $tie_count;
						}
					}

				} elsif ( $name eq "opp_wins") {

					my $count;
					my $sub_total;


					PANEL:
					foreach my $panel (@{$entries{"panels"}{$entry}}) {

						next unless $panels{$panel}{"roundname"};
						next if $panels{$panel}{"roundname"} > $this_round_name;

						foreach my $other (@{$panels{$panel}{"entries"}}) {

							next if $other == $entry;

							if ($tb_info{$tb_id}{"result"}) {
								unless (
									$opp_results{$entry}{"by_entry"}{$other} eq $tb_info{$tb_id}{"result"}
								) {
									next PANEL;
								}
							}

							$sub_total += $entries{"tb_wins"}{$tb_id}{$other};
							$count++;
						}
					}

					if ($count) {
						$total += Math::Round::nearest(1, 100 * $sub_total/$count);
					}

				} elsif ( $name eq "opp_ballots") {

					my $count;
					my $sub_total;

					PANEL:
					foreach my $panel (@{$entries{"panels"}{$entry}}) {

						my $check_round = $panels{$panel}{"round"};
						my $check_round_name = $panels{$panel}{"roundname"};

						next if $check_round_name > $this_round_name;

						my %did_em;

						foreach my $other (@{$panels{$panel}{"entries"}}) {

							next if $did_em{$other}++;
							next if $other == $entry;

							if ($tb_info{$tb_id}{"result"}) {
								unless (
									$opp_results{$entry}{"by_entry"}{$other} eq $tb_info{$tb_id}{"result"}
								) {
									next PANEL;
								}
							}

							foreach my $other_panel (@{$entries{"panels"}{$other}}) {

								my $other_round = $panels{$other_panel}{"round"};
								my $other_round_name = $panels{$other_panel}{"roundname"};

								next if $other_round_name > $this_round_name;

								$count++;

								if (
									$entries{"round_bye"}{$other_round}{$other}
									|| $entries{"round_panel_bye"}{$other_round}{$other}
								) {

									$sub_total += $max_score_count{"winloss"}{$other_round};

								} else {

									foreach my $score (@{$entries{"round_scores"}{$other}{$other_round}}) {
										if ($scores{"tag"}{$score} eq "winloss") {

											if ($tb_info{$tb_id}{"chair"} eq "chair") {
												next if $scores{"chair"}{$score} < 1;
											} elsif ($tb_info{$tb_id}{"chair"} eq "nonchair") {
												next if $scores{"chair"}{$score} > 0;
											}

											$sub_total++ if $scores{"value"}{$score} == 1;
										}
									}
								}
							}
						}
					}

					if ($count) {
						$total += Math::Round::nearest(1, 100 * $sub_total/$count);
					}

				} elsif ( $name eq "opp_points") {

					my $count;
					my $sub_total;

					PANEL:
					foreach my $panel (@{$entries{"panels"}{$entry}}) {

						next if $panels{$panel}{"roundname"} > $this_round_name;

						foreach my $other (@{$panels{$panel}{"entries"}}) {
							next if $other == $entry;

							if ($tb_info{$tb_id}{"result"}) {
								unless (
									$opp_results{$entry}{"by_entry"}{$other} eq $tb_info{$tb_id}{"result"}
								) {
									next PANEL;
								}
							}
							$sub_total += $entries{"point"}{$other};
							$count++;
						}
					}

					if ($count) {
						$total += Math::Round::nearest(1, ($sub_total/$count));
					}

				} elsif ( $name eq "opp_ranks") {

					my $count;
					my $sub_total;

					PANEL:
					foreach my $panel (@{$entries{"panels"}{$entry}}) {

						next if $panels{$panel}{"roundname"} > $this_round_name;

						foreach my $other (@{$panels{$panel}{"entries"}}) {
							next if $other == $entry;

							if ($tb_info{$tb_id}{"result"}) {
								unless (
									$opp_results{$entry}{"by_entry"}{$other} eq $tb_info{$tb_id}{"result"}
								) {
									next PANEL;
								}
							}

							$sub_total += $entries{"ranks"}{$other};
							$count++;
						}
					}

					if ($count) {
						$total += Math::Round::nearest(1, ($sub_total/$count));
					}

				} elsif ( $name eq "seed") {

					$seed_done++;
					$total += Math::Round::nearest(1, 100 * $entries{"seed"}{$entry});

				} elsif ( $name eq "opp_seed") {

					$opp_seed_done++;
					my $count;
					my $sub_total;

					PANEL:
					foreach my $panel (@{$entries{"panels"}{$entry}}) {

						next if $panels{$panel}{"roundname"} > $this_round_name;
						foreach my $other (@{$panels{$panel}{"entries"}}) {
							next if $other == $entry;

							if ($tb_info{$tb_id}{"result"}) {
								unless (
									$opp_results{$entry}{"by_entry"}{$other} eq $tb_info{$tb_id}{"result"}
								) {
									next PANEL;
								}
							}

							$sub_total += $entries{"seed"}{$other};
							$count++;
						}
					}

					if ($count) {
						$total += Math::Round::nearest(1, 100 * ($sub_total/$count));
					}

				} elsif ( $name eq "judgevar") {

					my $sub_total;
					my $sub_count;
					my $sub_byes;

					foreach my $this_round (@rounds) {
						foreach my $score (@{$entries{"round_scores"}{$entry}{$this_round}}) {
							# No rebuttal points here either
							next unless $scores{"tag"}{$score} eq "point";

							if ($tb_info{$tb_id}{"chair"} eq "chair") {
								next if $scores{"chair"}{$score} < 1;
							} elsif ($tb_info{$tb_id}{"chair"} eq "nonchair") {
								next if $scores{"chair"}{$score} > 0;
							}

							my $judge_avg  = ${$judge_avg_ref}{$scores{"judge"}{$score}};
							my $judge_stddev  = ${$judge_stddev_ref}{$scores{"judge"}{$score}};

							next unless $judge_stddev > 0;

							$sub_total += (
								( ($scores{"value"}{$score} - $judge_avg) / $judge_stddev) * $total_std)
								+ $total_avg;
							$sub_count++;
						}
					}

					my $average = ($sub_total / $sub_count) if $sub_count;

					$total += Math::Round::nearest(1, (100 * $average * $this_round_sequence * ($event_settings{"max_entry"} || 1)));

				} elsif ($name eq "judgevar2") {

					my $sub_total;
					my $sub_count;
					my $sub_byes;

					foreach my $this_round (@rounds) {

						foreach my $score (@{$entries{"round_scores"}{$entry}{$this_round}}) {

							next unless $scores{"tag"}{$score} eq "point";

							if ($tb_info{$tb_id}{"chair"} eq "chair") {
								next if $scores{"chair"}{$score} < 1;
							} elsif ($tb_info{$tb_id}{"chair"} eq "nonchair") {
								next if $scores{"chair"}{$score} > 0;
							}

                            my $judge_avg  = ${$judge_avg_ref}{$scores{"judge"}{$score}};
                            my $judge_stddev  = ${$judge_stddev_ref}{$scores{"judge"}{$score}};

                            # These sample only the schools/stddevs for the
                            # debaters the judge has judged, not all debaters.

                            my $judge_sample_avg  = ${$judge_z2_avg_ref}{$scores{"judge"}{$score}};
                            my $judge_sample_stddev  = ${$judge_z2_stddev_ref}{$scores{"judge"}{$score}};

                            next unless $judge_stddev > 0;

                            $sub_total += (
								( ($scores{"value"}{$score} - $judge_avg) / $judge_stddev) * $judge_sample_stddev )
								+ $judge_sample_avg;
							$sub_count++;
						}
					}

					my $average = ($sub_total / $sub_count) if $sub_count;
					$total += Math::Round::nearest(1, 100 * $average * $this_round_sequence * ($event_settings{"max_entry"} || 1));
				}

				$tier_total += $total * $tb_info{$tb_id}{"multiplier"};
			}

			if ($round_averages) {
				$entries{"averages"}{$entry}{$key}++;
			}

			$entries{"tbs"}{$entry}{$key} = $tier_total;
			$entries{"tiebreak"}{$key}{$entry} = $tier_total;

		}
	}

	if ($needs{"opp_points"} || $needs{"opp_ranks"}) {

		my $err;

		if ($needs{"opp_points"} &! $needs{'points'}) {
			$err .= " Danger Will Robinson!<br /> You have defined Opp Points as ";
			$err .= " a tiebreaker without first defining Points.  That cannot work";
			$err .= " both technically and philosophically.  Fix please! <br /><br />";
		}

		if ($needs{"opp_ranks"} &! $needs{'ranks'}) {
			$err .= " Danger Will Robinson!<br />You have defined Opp Ranks as a ";
			$err .= " tiebreaker without first defining Ranks.  That cannot work both";
			$err .= " technically and philosophically.  Fix please!";
		}


		if ($never_redirect || $ARGS{"return"}) {
			return;
		}

		$m->redirect("/setup/rules/tiebreaks.mhtml?protocol_id=".$protocol->id."&err=$err")
			if $err;
	}

	my $round_average;

	if ($event_settings{"round_averages"}) {

		my $round_total;
		my $round_count;

		foreach my $entry (@entries) {
			next unless $entries{"round_points"}{$this_round_id}{$entry} > 0;
			$round_total += $entries{"round_points"}{$this_round_id}{$entry};
			$round_count++;
		}

		$round_average = $round_total / $round_count if $round_count;
	}

	ENTRY:
	foreach my $entry (@entries) {

		next if $entries{"dq"}{$entry}
			&& (not defined $tourn_settings{"nsda_district"})
			&& (not defined $tourn_settings{"nsda_nats"});

		next unless $entries{"panels"}{$entry} && @{$entries{"panels"}{$entry}};

		foreach my $key (sort {$a <=> $b} keys %tb_tiers) {

			if ($entries{"averages"}{$entry}{$key}) {

				$entries{"tbs"}{$entry}{$key}
					+= $round_average;

				$entries{"tiebreak"}{$key}{$entry}
					+= $round_average;
			}
		}
	}

	foreach my $key (reverse sort {$a <=> $b} keys %tb_tiers) {
		@entries = sort {
			$entries{"tbs"}{$a}{$key} <=> $entries{"tbs"}{$b}{$key}
		} @entries if $tier_dir{$key} eq "up";

		@entries = sort {
				$entries{"tbs"}{$b}{$key} <=> $entries{"tbs"}{$a}{$key}
		} @entries if $tier_dir{$key} eq "down";
	}

	$protocol_settings{"equal_elims"}++ if $ARGS{"section_rank"};

	if ($protocol_settings{'equal_elims'}) {

		my $doubledown++ if $ARGS{"doubledown"};

		$doubledown++
			if $composite_set
			&& $tourn_settings{"nsda_speech_method"} eq "doubledown";

		foreach my $panel (@{$rounds{$this_round_id}{"panels"}}) {

			next unless $panels{$panel}{"entries"};

			my @pan_entries = eval {
				return @{$panels{$panel}{"entries"}};
			};

			foreach my $key (reverse (sort {$a <=> $b} keys %tb_tiers)) {

				@pan_entries =
					sort { $entries{"tbs"}{$a}{$key} <=> $entries{"tbs"}{$b}{$key}  }
					@pan_entries
					if $tier_dir{$key} eq "up";

				@pan_entries =
					sort { $entries{"tbs"}{$b}{$key} <=> $entries{"tbs"}{$a}{$key} }
					@pan_entries
					if $tier_dir{$key} eq "down";
			}

			my %already;
			my $count;
			my $delayed_count = 0;
			my $last_count;
			my $last_string;

			my $second_count;
			my $second_delayed_count;
			my $second_last_count;
			my $second_last_string;

			foreach my $panel_entry (@pan_entries) {

				my $tier_string = tier_string($panel_entry, \%tb_tiers, \%entries);

				my $second_tier_string;

				if ($tourn_settings{"nsda_speech_method"} eq "doubledown") {

					my @keys = sort keys %tb_tiers;
					my $key = shift @keys;
					my %second_tiers;

					$second_tiers{$key} = $tb_tiers{$key};
					$second_tier_string = tier_string($panel_entry, \%second_tiers, \%entries);

				}

				if ($second_tier_string eq $second_last_string) {
					$second_delayed_count++
				} else {
					$second_count++;
					$second_count += $second_delayed_count;
					$second_last_string = $second_tier_string;
					undef $second_delayed_count;

				}

				if ($tier_string eq $last_string) {
					$delayed_count++;
				} else {
					$count++;
					$count += $delayed_count;
					$last_string = $tier_string;
					$delayed_count = 0;
				}

				next if $already{$panel_entry}++;
				next if
					(not defined $tourn_settings{"nsda_district"})
					&& (not defined $tourn_settings{"nsda_nats"})
					&& $entries{"dq"}{$panel_entry};

				if ($panel_entry) {
					push @{$entries{"second_panel_order"}{$panel}{$second_count}}, $panel_entry
						if $second_count;

					push @{$entries{"panel_order"}{$panel}{$count}}, $panel_entry;
				}

				$entries{"section_rank"}{$panel_entry} = $count;
				$entries{"section_ub_rank"}{$panel_entry} = $second_count;
				$entries{"section"}{$panel_entry} = $panels{$panel}{"section"};
				$entries{"section_id"}{$panel_entry} = $panel;
				$entries{"panel"}{$panel_entry} = $panel;
				$entries{"by_section"}{$panel}{$panel_entry}++;
			}

			if (
				$tourn_settings{"nsda_district"}
				|| $tourn_settings{"nsda_nats"}
				|| ($protocol->setting("tie_middle_rank"))
				|| ($parent_set && $parent_set->setting("tie_middle_rank"))
			) {

				# At NSDA districts, three way ties should get the MIDDLE ranking.

				foreach my $place (sort keys %{$entries{"panel_order"}{$panel}}) {

					if (
						(scalar @{$entries{"panel_order"}{$panel}{$place}} == 3)
						|| (scalar @{$entries{"panel_order"}{$panel}{$place}} == 4)
					) {

						@{$entries{"panel_order"}{$panel}{($place + 1)}}
							= @{$entries{"panel_order"}{$panel}{$place}};

						@{$entries{"panel_order"}{$panel}{$place}} = ();

						delete $entries{"panel_order"}{$panel}{$place};

					}
				}

				foreach my $place (keys %{$entries{"panel_order"}{$panel}}) {
					foreach my $panel_entry (@{$entries{"panel_order"}{$panel}{$place}}) {
						$entries{"section_rank"}{$panel_entry} = $place;
					}
				}

				foreach my $place (sort keys %{$entries{"second_panel_order"}{$panel}}) {

					if (
						(scalar @{$entries{"second_panel_order"}{$panel}{$place}} == 3)
						|| (scalar @{$entries{"second_panel_order"}{$panel}{$place}} == 4)
					) {

						@{$entries{"second_panel_order"}{$panel}{($place + 1)}}
							= @{$entries{"second_panel_order"}{$panel}{$place}};

						@{$entries{"second_panel_order"}{$panel}{$place}} = ();
						delete $entries{"second_panel_order"}{$panel}{$place};
					}
				}

				foreach my $place (keys %{$entries{"second_panel_order"}{$panel}}) {
					foreach my $panel_entry (@{$entries{"second_panel_order"}{$panel}{$place}}) {
						$entries{"section_ub_rank"}{$panel_entry} = $place;
					}
				}
			}
		}

		@entries =
			sort { $entries{"section"}{$a} cmp $entries{"section"}{$b} }
			@entries;

		@entries =
			sort { length($entries{"section"}{$a}) <=> length($entries{"section"}{$b}) }
			@entries;

		@entries =
			sort { $entries{"section_rank"}{$a} <=> $entries{"section_rank"}{$b} }
			@entries;

	} elsif ($event_settings{"round_robin"}) {

		foreach my $pod (keys %pods) {

			my @pod_entries = @{$pods{$pod}};

			foreach my $key (reverse sort {$a <=> $b} keys %tb_tiers) {

				@pod_entries =
					sort { $entries{"tbs"}{$a}{$key} <=> $entries{"tbs"}{$b}{$key}  }
					@pod_entries
					if $tier_dir{$key} eq "up";

				@pod_entries =
					sort { $entries{"tbs"}{$b}{$key} <=> $entries{"tbs"}{$a}{$key} }
					@pod_entries
					if $tier_dir{$key} eq "down";
			}

			my $count = 1;

			my %already;

			foreach my $pe (@pod_entries) {
				next if $already{$pe};
				next if $entries{"dq"}{$pe}
					&& (not defined $tourn_settings{"nsda_district"})
					&& (not defined $tourn_settings{"nsda_nats"});
				$already{$pe}++;
				$entries{"pod_rank"}{$pe} = $count++;
				$entries{"section_rank"}{$pe} = $entries{"pod_rank"}{$pe};
				$entries{"pod"}{$pe} = $pod;
			}
		}

		@entries =
			sort { $entries{"pod_rank"}{$a} <=> $entries{"pod_rank"}{$b} }
			@entries;

		foreach my $panel (@{$rounds{$this_round_id}{"panels"}}) {
			if ($panels{$panel}{"entries"}) {
				foreach my $entry (@{$panels{$panel}{"entries"}}) {
					$entries{"section"}{$entry} = $panel;
					$entries{"section_id"}{$entry} = $panel;
					$entries{"panel"}{$entry} = $panel;
				}
			}
		}

	} else {

		foreach my $panel (@{$rounds{$this_round_id}{"panels"}}) {
			if ($panels{$panel}{"entries"}) {
				foreach my $pe (@{$panels{$panel}{"entries"} }) {
					$entries{"section"}{$pe} = $panels{$panel}{"section"};
					$entries{"section_id"}{$pe} = $panel;
					$entries{"panel"}{$pe} = $panel;
				}
			}
		}
	}

	@entries =
		sort { $entries{"forfeit"}{$a} <=> $entries{"forfeit"}{$b} } @entries
		if $forfeits_never_break;

	@entries =
		sort { $entries{"dq"}{$a} <=> $entries{"dq"}{$b} } @entries
		if $tourn_settings{"nsda_district"}
		|| $tourn_settings{"nsda_nats"};

	my $count;

	my $last_string;
	my $delayed_count = 0;

	my %ok;

	foreach my $entry (@entries) {

		next if $entries{"dq"}{$entry}
			&& (not defined $tourn_settings{"nsda_district"})
			&& (not defined $tourn_settings{"nsda_nats"});

		# Removed the entry active limit above and put this here because
		# otherwise it was promoting entries that took last in a round against
		# a dropped entry b/c it was not raising the threshold of the maximum
		# rank == number of kids in the round.

		next unless $entries{"panels"}{$entry} && @{$entries{"panels"}{$entry}};

		next if $breakout && not defined $eligible{$entry};
		next if $entries{"dropped"}{$entry};

		$ok{$entry}++;

		my $tier_string = tier_string($entry, \%tb_tiers, \%entries);

		if ($protocol_settings{'equal_elims'}) {
			$tier_string .= "-".$entries{"section_rank"}{$entry};
			$tier_string .= "-".$entries{"letter"}{$entry};
		}

		if ($tier_string eq $last_string) {
			$delayed_count++;
		} else {
			$count++;
			$count += $delayed_count;
			$delayed_count = 0;
		}

		$last_string = $tier_string;

		push (@{$entries{"by_place"}{$count}}, $entry);
		$entries{"seed"}{$entry} = $count;
		@{$entries{"by_place"}{$count}} = sort @{$entries{"by_place"}{$count}};

		# Normalize the 100x back to actual values

		foreach my $key (sort {$a <=> $b} keys %tb_tiers) {

			$entries{"tbs"}{$entry}{$key}
				= $entries{"tbs"}{$entry}{$key} / 100;

			my $rounder = 1 / (10 ** $entries{"tb_digits"}{$key});

			$entries{"tbs"}{$entry}{$key}
				= Math::Round::nearest($rounder, $entries{"tbs"}{$entry}{$key});

			$entries{"tiebreak"}{$key}{$entry}
				= $entries{"tiebreak"}{$key}{$entry} / 100;

			$entries{"tiebreak"}{$key}{$entry}
				= Math::Round::nearest($rounder, $entries{"tiebreak"}{$key}{$entry});
		}
	}

	foreach my $entry (@entries) {
		next if $ok{$entry};

		delete $entries{"seed"}{$entry};
		delete $entries{"panel"}{$entry};
		delete $entries{"bye"}{$entry};

		foreach my $key (sort {$a <=> $b} keys %tb_tiers) {
			delete $entries{"tbs"}{$entry};
			delete $entries{"tiebreak"}{$key}{$entry};
		}
	}

	$entries{"tb_info"} = \%tb_info;
	$entries{"tb_tiers"} = \%tb_tiers;
	$entries{"tier_direction"} = \%tier_dir;
	$entries{"tier_description"} = \%tier_descs;
	$entries{"tier_long_description"} = \%tier_long_descs;

	;

	return (
		$entries{"by_place"},
		$entries{"tbs"},
		$entries{"tier_description"},
		$entries{"forfeit"},
		$entries{"tier_direction"},
		$entries{"section_rank"},
		$entries{"letter"},
		$entries{"tier_long_description"},
		$entries{"code"},
		$entries{"bye"},
		$entries{"panel"},
		\%entries			# <-- Hope to gradually replace all the above with just this.
	);

	sub tier_string {

		my ($entry, $tb_tiers_ref, $entries_ref) = @_;
		my $tier_string;

		foreach my $key (sort {$a <=> $b} keys %{$tb_tiers_ref}) {
			my $value = Math::Round::nearest(1, $entries_ref->{"tbs"}{$entry}{$key}) / 100;
			$tier_string .= "-" if $tier_string;
			$tier_string .= $value;
		}

		return $tier_string;
	}

</%init>
