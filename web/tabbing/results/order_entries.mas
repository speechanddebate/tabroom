<%args>
	$round
	$section        => undef
	$nsda           => undef
	$seed_skip      => undef
	$skip_wins      => undef
	$breakout       => undef
	$opp_wins_only  => undef
	$composite_set  => undef
	$parent_set     => undef
	$tiebreak_set   => undef
	$section_rank   => undef
	$all_entries    => undef
	$never_redirect => undef
</%args>
<%init>

	return unless $round;

	use POSIX; 
	use Math::Round;
	use feature qw(switch);

	#fucking Perl
	no warnings 'experimental::smartmatch';

	my $event = $round->event;
	my $event_type = $event->type;
	my $byes_on_team_basis++ if $event_type eq "wsdc";

	$event_type = "debate" 
		if $event_type eq "pf"
		|| $event_type eq "ld"
		|| $event_type eq "policy"
		|| $event_type eq "parli"
		|| $event_type eq "wsdc"
		|| $event_type eq "wudc";

	my $tourn = $event->tourn;
	my $seed = $tourn->start->epoch;

	my $this_round_name = $round->name;
	my $this_round_id = $round->id;

	if ($composite_set) {

		# Check against composites of composites

		foreach my $tiebreak ($composite_set->tiebreaks) { 

			if ($tiebreak->child > 0) { 
				$m->print('<div class="main">');
				$m->print("<h3>No, not gonna do it</h3>");
				$m->print('<p class="strong redtext">You have a composite rank based on other composite ranks. </p>');
				$m->print('<p>That can lead to excessively long computation times and bring down the Tabroom server.</p>');
				$m->print('<p>Thus, they are not permitted.  Please reconfigure your tiebreakers</p>');
				$m->abort();
			}
		}

		$tiebreak_set = $composite_set;

	} elsif (not defined $tiebreak_set) { 
		$tiebreak_set = $round->tiebreak_set;
	}

	unless ($tiebreak_set) {  
		return if $nsda;
		$m->abort() if $never_redirect;
		my $err = "Round ".$round->realname." does not have a tiebreaker set applied to it.";
		$err .= "Please pick one and try again";
		$m->redirect("/setup/schedule/event.mhtml?event_id=".$event->id."&err=$err");
	}

	my %tb_settings = $tiebreak_set->all_settings;
	my %event_settings = $event->all_settings;
	my %tourn_settings = $tourn->all_settings;

	my $districts++ if $tourn_settings{"nsda_district"};

	if ($districts && $nsda && $event_type eq "speech") { 

		$tiebreak_set = Tab::TiebreakSet->search(
			tourn => $tourn,
			name  => "IE Prelim Composite"
		)->first;
		
	}

	#Deduplicate Ballots
	$m->comp(
		"/funclib/event_dedupe.mas", 
		event => $event
	);

	#Settings
	my $mfl_time_violation = $tb_settings{"mfl_time_violation"};

	my $maverick_method = $event_settings{"mavericks"};
	$maverick_method = "double" unless $maverick_method;

	my $truncate = $tb_settings{"truncate_ranks_to"} 
		if $tb_settings{"truncate_ranks_to"};

	my $truncate_to_smallest = $tb_settings{"truncate_to_smallest"};
	my $truncate_prelims     = $tb_settings{"truncate_prelims"};
	my $truncate_elims       = $tb_settings{"truncate_elims"};
	my $truncate_finals      = $tb_settings{"truncate_finals"};

	# This is for the purpose of determining NSDA points for posting

	if ($nsda) { 
		undef $truncate;
		undef $truncate_to_smallest;
		undef $truncate_prelims;
		undef $truncate_elims;
		undef $truncate_finals;
	}

	my $forfeits_never_break = $tb_settings{"forfeits_never_break"};

	my $wsdc_byes = $event_settings{"wsdc_bye_win_average"};

	$section_rank++ if $tb_settings{"equal_elims"};
	my $round_robin++ if $event_settings{"round_robin"};
	my $team_points++ if $event_settings{"team_points"};

	# Rounds by things
	my @event_rounds = ($round);
	foreach my $round ($event->rounds) { 
		push @event_rounds, $round unless $round->type eq "runoff";
	}
	@event_rounds = sort {$a->name <=> $b->name } @event_rounds;
	my $roff = $round->runoff;
	while ($roff) { 
		push @event_rounds, $roff;
		if ($roff->runoff) { 
			$roff = $roff->runoff;
		} else { 
			undef $roff;
		}
	}

	my %rounds = ();
	%{$rounds{"type"}} = map {$_->id => $_->type} @event_rounds;
	%{$rounds{"name"}} = map {$_->id => $_->name} @event_rounds;
	%{$rounds{"by_name"}} = map {$_->name => $_} @event_rounds;
	%{$rounds{"by_id"}} = map {$_->id => $_} @event_rounds;


	# Redundant and harmful
	undef $team_points if $event_type eq "congress"; 
	undef $team_points if $event_type eq "speech"; 

	undef $round_robin 
		if $round->type eq "elim" 
		|| $round->type eq "final"
		|| $round->type eq "runoff";


	my %tb_tiers = ();
	my %tb_count = ();
	my %tb_round = ();

	TB:
	foreach my $tb ($tiebreak_set->tiebreaks) { 

		$tb_count{$tb->id} = $tb->count;

		#This will only aggregate the present round for Points purposes.
		$tb_count{$tb->id} = "previous" if $nsda;

		if ($tb_count{$tb->id} eq "specific") { 
			if ($rounds{"by_id"}{$tb->count_round}) { 
				$tb_round{$tb->id} = $rounds{"by_id"}{$tb->count_round};
			} elsif ($rounds{"by_name"}{$tb->count_round}) {
				$tb_round{$tb->id} = $rounds{"by_name"}{$tb->count_round};
			} else { 
				next TB;
			}
		}

		if ($nsda 
			&& $round->type ne "elim" 
			&& $round->type ne "final"
			&& $round->type ne "runoff"
		) { 

			# If we're doing autopoints post on a prelim we have to not drop
			# scores or all will be tied.

			$tb->highlow("");
			$tb->highlow_count("");
		}

		$truncate_to_smallest++ if $tb->truncate_smallest; 
		push @{$tb_tiers{$tb->priority}}, $tb;

	}   

	# Get the data you'll need for Teh Sortingz.
	my $dbh = Tab::DBI->db_Main();

	my %pods = ();
	my %scores = ();
	my %panels = ();
	my %entries = ();

	foreach my $round (@event_rounds) { 
		$rounds{"type"}{$round} = "prelim" 
			if $rounds{"type"}{$round} eq "preset" 
			|| $rounds{"type"}{$round} eq "highhigh" 
			|| $rounds{"type"}{$round} eq "highlow" 
			|| $rounds{"type"}{$round} eq "random" 
			|| $rounds{"type"}{$round} eq "power";
	}

	my @entries;

	my $dropped_limit = " and entry.active = 1 ";
	undef $dropped_limit if $nsda;
	undef $dropped_limit if $districts;

	my $round_limit;
	my $section_limit;
	$section_limit = "and panel.letter = ".$section->letter if $section;

	my $sth = $dbh->prepare("
		select 
			entry.id, entry.code, entry.name, entry.dropped, entry.dq, entry.school,
			round.type, round.name, round.id,
			score.id, score.tag, score.value, score.student,
			ballot.id, ballot.judge, ballot.forfeit, ballot.bye, ballot.tv, ballot.chair,
			panel.id, panel.bye, panel.letter

		from (ballot, panel, round, entry)
		left join score on score.ballot = ballot.id
		where ballot.panel = panel.id
		and panel.round = round.id
		$section_limit

		and not exists ( 
			select round_setting.id 
			from round_setting 
			where round_setting.tag = 'ignore_results' 
			and round_setting.round = round.id
		)

		and round.event = ?
		and ballot.entry = entry.id
		$dropped_limit
		and entry.waitlist != 1
		and entry.unconfirmed != 1
		group by score.id, ballot.id
		order by round.event, round.name
	");

	$sth->execute($event->id);

	my %already = ();

	while (my (
		$entry_id, $entry_code, $entry_name, $entry_dropped, $entry_dq, $entry_school_id,
		$round_type, $round_name, $round_id,
		$score_id, $score_tag, $score_value, $score_student,
		$ballot_id, $ballot_judge, $ballot_forfeit, $ballot_bye, $ballot_tv, $ballot_chair,
		$panel_id, $panel_bye, $panel_letter
		)  = $sth->fetchrow_array()
	) {

		push @{$rounds{"panels"}{$round_id}}, $panel_id;

		if ($all_entries) { 
			push @entries, $entry_id unless $already{$entry_id}++;
		} elsif ($round_id == $this_round_id) { 
			push @entries, $entry_id unless $already{$entry_id}++;
		}
			
		$entries{"rounds"}{$entry_id}{$round_id}++;
		push @{$entries{"panels"}{$entry_id}}, $panel_id;
		push @{$entries{"students"}}, $score_student;

		$entries{"code"}{$entry_id} = $entry_code;
		$entries{"name"}{$entry_id} = $entry_name;
		$entries{"school_id"}{$entry_id} = $entry_school_id;

		$entries{"dq"}{$entry_id} = $entry_dq if $entry_dq;
		$entries{"dropped"}{$entry_id} = $entry_dropped if $entry_dropped;
		$entries{"letter"}{$entry_id} = $panel_letter if $round_id == $this_round_id;

		$entries{"forfeit"}{$entry_id}++ if $ballot_forfeit;
		$entries{"round_forfeit"}{$round_id}{$entry_id}++ if $ballot_forfeit;
		$entries{"round_bye"}{$round_id}{$entry_id}++ if $ballot_bye;
		$entries{"round_panel_bye"}{$round_id}{$entry_id} = 1 if $panel_bye;

		$entries{"bye"}{$entry_id}++ if $panel_bye;

		if ($score_id) { 

			unless ($entries{"round_panel"}{$entry_id}{$round_id}) { 
				$entries{"round_panel"}{$entry_id}{$round_id} = $panel_id;
				push @{$panels{"entries"}{$panel_id}}, $entry_id;
			}

			push @{$entries{"scores"}{$entry_id}}, $score_id;
			push @{$entries{"round_scores"}{$entry_id}{$round_id}}, $score_id;

			$scores{"tag"}{$score_id}      = $score_tag;
			$scores{"value"}{$score_id}    = $score_value;
			$scores{"panel"}{$score_id}    = $panel_id;
			$scores{"judge"}{$score_id}    = $ballot_judge;
			$scores{"round"}{$score_id}    = $round_name;
			$scores{"round_id"}{$score_id} = $round_id;
			$scores{"chair"}{$score_id}++ if $ballot_chair;
			$scores{"tv"}{$score_id}      = $ballot_tv;
			$scores{"student"}{$score_id} = $score_student;

		}

		$panels{"section"}{$panel_id} = $panel_letter;
		$panels{"roundname"}{$panel_id} = $round_name 
			unless $round_type eq "runoff";
	}

	my %eseen = (); 
	@entries = grep { ! $eseen{$_} ++ } @entries;

	if ($event_settings{"show_panel_average"}) { 

		$byes_on_team_basis++;

		foreach my $entry_id (@entries) { 

			my %panel_scores;
			my %done_scores;

			foreach my $score_id (@{$entries{"scores"}{$entry_id}}) { 

				next if $done_scores{$score_id}++;

				next unless $scores{"tag"}{$score_id} eq "rank" 
					|| $scores{"tag"}{$score_id} eq "points";

				my $panel_id = $scores{"panel"}{$score_id};
				push @{$panel_scores{$panel_id}}, $score_id;

			}

			my @new_scores;
			my %done_panel;

			foreach my $panel_id (@{$entries{"panels"}{$entry_id}}) { 

				next if $done_panel{$panel_id}++;

				my %points_total;
				my %points_count;

				my %ranks_total;
				my %ranks_count;

				my %points_id;
				my %ranks_id;

				my $round_id;
				my $judge_id;
				
				foreach my $score_id (@{$panel_scores{$panel_id}}) { 

					my $student_id = $scores{"student"}{$score_id};
					$student_id = 0 unless $student_id;

					if ($scores{"tag"}{$score_id} eq "rank") { 

						$ranks_id{$student_id} = $score_id unless $ranks_id{$student_id};
						$ranks_total{$student_id} += $scores{"value"}{$score_id};
						$ranks_count{$student_id}++;

					} elsif ($scores{"tag"}{$score_id} eq "points") { 

						$points_id{$student_id} = $score_id unless $points_id{$student_id};
						$points_total{$student_id} += $scores{"value"}{$score_id};
						$points_count{$student_id}++;
					}
						
					$round_id = $scores{"round_id"}{$score_id};
					$judge_id = $scores{"judge"}{$score_id};
				}

				undef @{$entries{"round_scores"}{$entry_id}{$round_id}};

				if (keys %ranks_id) { 

					foreach my $student_id (keys %ranks_total) { 

						my $ranks_average = nearest(.01, $ranks_total{$student_id} / $ranks_count{$student_id});
						my $ranks_id = $ranks_id{$student_id};

						push @{$entries{"round_scores"}{$entry_id}{$round_id}}, $ranks_id;

						$scores{"tag"}{$ranks_id}      = "rank";
						$scores{"value"}{$ranks_id}    = $ranks_average;
						$scores{"panel"}{$ranks_id}    = $panel_id;
						$scores{"judge"}{$ranks_id}    = $judge_id;
						$scores{"round_id"}{$ranks_id} = $round_id;
					}
				}

				if (keys %points_id) { 

					foreach my $student_id (keys %points_total) { 

						my $points_average = nearest(.01, $points_total{$student_id} / $points_count{$student_id});
						my $points_id = $points_id{$student_id};

						push @{$entries{"round_scores"}{$entry_id}{$round_id}}, $points_id;

						$scores{"tag"}{$points_id}      = "points";
						$scores{"value"}{$points_id}    = $points_average;
						$scores{"panel"}{$points_id}    = $panel_id;
						$scores{"judge"}{$points_id}    = $judge_id;
						$scores{"round_id"}{$points_id} = $round_id;

					}
				}
			}
		}
	}

	my %eligible = ();

	if ($breakout) { 

		my @breakout_settings = $m->comp(
			"/funclib/event_entry_settings.mas", 
			event => $event,
			tag   => "breakout_".$breakout
		);

		foreach my $bs (@breakout_settings) { 
			$eligible{$bs->entry->id}++;
		}

		if ($event_settings{"breakout_".$breakout."_exclude_elims"}) { 

			my @in_elims = $m->comp("/funclib/event_entries.mas", 
				event    => $event,
				in_elims => "yessiree!"
			);

			foreach my $in_elim (@in_elims) { 
				undef $eligible{$in_elim->id};
			}
		}

	}

	my @all_rounds;

	foreach my $all_round (@event_rounds) { 
		
		next if $rounds{"done"}{$all_round}++;

		# Do not measure the future.  the Doctor will get angry at us.
		next if $rounds{"name"}{$all_round} > $this_round_name;  

		push @all_rounds, $all_round->id;

		# Uniq the panels so there's no double counting

		my %pseen = (); 

		@{$rounds{"panels"}{$all_round}} = 
			grep { ! $pseen{$_}++ } 
			@{$rounds{"panels"}{$all_round}};

		foreach my $panel (@{$rounds{"panels"}{$all_round}}) {   

			# Uniq the panel entries so there's no double counting;
			my %eseen = (); 

			@{$panels{"entries"}{$panel}} = 
				grep { ! $eseen{$_} ++ } 
				@{$panels{"entries"}{$panel}};
		}
	}

	my %dq_panel_threshold = ();

	unless ($districts) { 

		my @keys = keys %{$entries{"dq"}};

		foreach my $entry (keys %{$entries{"dq"}}) { 

			next unless $entries{"dq"}{$entry};

			foreach my $score (@{$entries{"scores"}{$entry}}) { 

				next unless $scores{"tag"}{$score} eq "rank";

				$dq_panel_threshold{$scores{"panel"}{$score}}{$scores{"judge"}{$score}} 
					= $scores{"value"}{$score};
			}
		}
	}

	if ($truncate_to_smallest) { 

		foreach my $round (@all_rounds) { 

			# Upper limit is the hard cap, if any
			$rounds{"truncate"}{$round} = $truncate 
				if $truncate > 0; 

			foreach my $panel (@{$rounds{"panels"}{$round}}) { 

				my $size = scalar @{$panels{"entries"}{$panel}} 
					if $panels{"entries"}{$panel};

				next unless $size > 0;

				$rounds{"truncate"}{$round} = $size 
					unless $rounds{"truncate"}{$round};

				$rounds{"truncate"}{$round} = $size 
					if $rounds{"truncate"}{$round} > $size;
			}
		}
	}

	my %max_score_count;

	if (
		$round 
		&& ( $round->type eq "elim" 
			|| $round->type eq "final"
		)
	) { 

		# Eliminate everyone who has not advanced to the elim round in question.

		my @counted;
		my %last_round;
		my %done;

		foreach my $entry (@entries) { 

			next if $done{$entry}++;

			my @panels = @{$entries{"panels"}{$entry}};

			foreach my $panel (@{$entries{"panels"}{$entry}}) { 
				$last_round{$entry} = $panels{"roundname"}{$panel} 
					if $last_round{$entry} < $panels{"roundname"}{$panel};
			}

			next if $last_round{$entry} < $this_round_name;
			push @counted, $entry;
		}

		@entries = @counted;

	} 
	
	if ($event_type eq "debate" || $team_points) { 
	
		my $prep_stuff = $dbh->prepare("
			update score, ballot, round, panel
			set score.student = null 
			where score.student = 0 
				and score.tag = 'ballot' 
				and score.ballot = ballot.id 
				and ballot.panel = panel.id 
				and panel.round = round.id 
				and round.event = ?
		");

		$prep_stuff->execute($event->id);
			
		my $limit;
		$limit = ", ballot.judge" if $event_settings{"show_panel_average"};

		my $round_max = $dbh->prepare("
			select distinct(round.id), score.tag, count(score.id)
				from round, panel, ballot, score

				where round.event = ?
				and round.id = panel.round
				and panel.id = ballot.panel
				and ballot.id = score.ballot
				and score.tag in ('ballot', 'rank', 'points')
				group by round.id, score.tag, ballot.entry $limit
		");

		$round_max->execute($event->id);

		while (
			my ($round_id, $tag, $count) = $round_max->fetchrow_array()
		) { 

			$max_score_count{$tag}{$round_id}  = $count
				if $count > $max_score_count{$tag}{$round_id};
		}

	} elsif ($team_points) {

		foreach my $round (@all_rounds) {
			$max_score_count{"rank"}{$rounds{"name"}{$round}} = 1;
			$max_score_count{"points"}{$rounds{"name"}{$round}} = 1;
		}
	}

	my %tb_info = ();
	my %tier_descs = ();
	my %tier_long_descs = ();
	my %tier_dir = ();

	my %needs = ();
	my %composite_rounds;

	$needs{"win_loss"}++ if $opp_wins_only;

	foreach my $key (sort {$a <=> $b} keys %tb_tiers) { 

		TB:
		foreach my $tb (sort {$a <=> $b} @{$tb_tiers{$key}}) { 
		
			if ($tb_count{$tb->id} eq "specific") { 
				if ($rounds{"by_id"}{$tb->count_round}) { 
				} elsif ($rounds{"by_name"}{$tb->count_round}) {
				} else { 
					next TB;
				}
			}

			$needs{"ranks"}++ if $tb->name eq "ranks";
			$needs{"ranks"}++ if $tb->name eq "reciprocals";
			$needs{"ranks"}++ if $tb->name eq "chair_ranks";
			$needs{"ranks"}++ if $tb->name eq "non_chair_ranks";

			$needs{"points"}++ if $tb->name eq "points";
			$needs{"points"}++ if $tb->name eq "po_points";

			$needs{"seed"}++ if $tb->name eq "opp_seed";
			$needs{"seed"}++ if $tb->name eq "seed";

			$needs{"win_loss"}++ if $tb->name eq "winloss";
			$needs{"win_loss"}++ if $tb->name eq "opp_wins";
			$needs{"win_loss"}++ if $tb->name eq "ballots";

			$needs{"judgevar"}++ if $tb->name eq "judgevar";
			$needs{"judgevar"}++ if $tb->name eq "judgevar2";

			$needs{"losses"}++ if $tb->name eq "losses";
			$needs{"nsda_points"}++ if $tb->name eq "nsda_points";
	
			$needs{"opp_ranks"}++ if $tb->name eq "opp_ranks";
			$needs{"opp_points"}++ if $tb->name eq "opp_points";

			if ($tb->child > 0) { 

				foreach my $round (@all_rounds) { 

					if ($rounds{"type"}{$round} eq "prelim") { 
					
						push @{$composite_rounds{$tb->id}}, $round 
							if $rounds{"type"}{$round} eq "prelim";

						push @{$composite_rounds{$tb->id}}, $round 
							if $rounds{"type"}{$round} eq "highhigh";

						push @{$composite_rounds{$tb->id}}, $round 
							if $rounds{"type"}{$round} eq "highlow";

					} elsif ($rounds{"type"}{$round} eq $tb_count{$tb->id}) { 

						push @{$composite_rounds{$tb->id}}, $round;

					} elsif ($tb_count{$tb->id} eq "all") { 

						push @{$composite_rounds{$tb->id}}, $round;

					}
				}
			}

			if ($needs{'win_loss'}) {

				if ($tb_count{$tb->id} eq "previous") { 

					%{$entries{"tb_wins"}{$tb->id}} = 
						$m->comp(
							"/funclib/entry_wins.mas", 
							event => $event,
							round => $round,
							last  => 1
						);

				} elsif ($tb_count{$tb->id} eq "specific") { 

					%{$entries{"tb_wins"}{$tb->id}} = 
						$m->comp(
							"/funclib/entry_wins.mas", 
							event => $event,
							round => $tb_round{$tb->id},
							last  => 1
						);

				} elsif ($tb_count{$tb->id} eq "all") { 

					%{$entries{"tb_wins"}{$tb->id}} 
						= $m->comp(
							"/funclib/entry_wins.mas", 
							event => $event,
							round => $round
						);

				} else { 

					%{$entries{"tb_wins"}{$tb->id}} 
						= $m->comp("/funclib/entry_wins.mas", 
							event => $event,
							round => $round,
							type  => $tb_count{$tb->id}
						);
				}
			}

			if ($needs{"losses"}) { 

				if ($tb_count{$tb->id} eq "previous") { 

					%{$entries{"tb_losses"}{$tb->id}} = 
						$m->comp("/funclib/entry_losses.mas", 
							event => $event,
							round => $round,
							last  => 1
						);

				} elsif ($tb_count{$tb->id} eq "specific") { 

					%{$entries{"tb_wins"}{$tb->id}} = 
						$m->comp(
							"/funclib/entry_losses.mas", 
							event => $event,
							round => $tb_round{$tb->id},
							last  => 1
						);

				} elsif ($tb_count{$tb->id} eq "all") { 

					%{$entries{"tb_losses"}{$tb->id}} 
						= $m->comp("/funclib/entry_losses.mas", 
							event => $event,
							round => $round,
							all   => 1
						);

				} else { 

					%{$entries{"tb_losses"}{$tb->id}} 
						= $m->comp("/funclib/entry_losses.mas", 
							event => $event,
							round => $round,
							type  => $tb_count{$tb->id}
						);
				}
			}
		}
	}

	# Add in a runoff as a pseudo composite rank
	my $runoff;
	$runoff = $round->runoff if $round->runoff && $round->runoff->panels;

	my $runoff_tb;
	my $current_parent = $tiebreak_set->id;

	while ($runoff) { 

		$runoff_tb = Tab::Tiebreak->search({
			name         => "ranks",
			count        => "specific",
			count_round  => $runoff->id,
			multiplier   => 1,
			tiebreak_set => $tiebreak_set->id
		})->first;

		unless ($runoff_tb) { 

			my @keys = sort {$b <=> $a} keys %tb_tiers;
			my $max_key = $keys[0];
			$max_key++;

			$runoff_tb = Tab::Tiebreak->create({
				name         => "ranks",
				count        => "specific",
				priority     => $max_key,
				count_round  => $runoff->id,
				multiplier   => 1,
				tiebreak_set => $tiebreak_set->id
			});
		
			$tb_info{$runoff_tb}{"name"} = "ranks";
			push @{$tb_info{$runoff_tb}{"rounds"}}, $round;
			push @{$tb_tiers{$max_key}}, $runoff_tb;
		}
		
		$tb_info{$runoff_tb}{"runoff"} = $runoff;
		$tb_info{$runoff_tb}{"child"} = $runoff->tiebreak_set;

		push @{$composite_rounds{$runoff_tb->id}}, $runoff;

		if ($runoff->runoff) { 
			$current_parent = $runoff->tiebreak_set;
			$runoff = $runoff->runoff;
		} else { 
			undef $runoff;
		}

	}

	# The factors that going into calculating jvar and jvar2 (aka z scores)

	my ($judge_avg_ref,
		$judge_ballot_count_ref,
		$judge_total_ref,
		$judge_stddev_ref,
		$total_avg,
		$total_std, 
		$judge_z2_avg_ref,
		$judge_z2_ballot_count_ref,
		$judge_z2_total_ref,
		$judge_z2_stddev_ref
	) 
		= $m->comp(
			"/funclib/judge_points_average.mas", 
				event => $event
		) if $needs{"judgevar"};

	# Calculate the composite ranks if that's a thing:

	foreach my $key (sort {$a <=> $b} keys %tb_tiers) { 

		foreach my $tb (sort {$a <=> $b} @{$tb_tiers{$key}}) { 

			#Avoid recursion
			next if $tb->child && $tb->child == $tiebreak_set;

			my %comp_seen = (); 

			my @comp_rounds =  @{$composite_rounds{$tb->id}} if $composite_rounds{$tb->id};

			@comp_rounds = grep { ! $comp_seen{$_} ++ } @comp_rounds;

			next unless @comp_rounds;

			foreach my $round_id (@comp_rounds) { 

				my $rank_round = Tab::Round->retrieve(int($round_id));

				my $doubledown++ 
					if $tourn_settings{"nsda_speech_method"} eq "doubledown";

				my @results = $m->comp(
					"/tabbing/results/order_entries.mas", 
					round         => $rank_round,
					composite_set => $tb->child,
					parent_set    => $tiebreak_set,
					section_rank  => 1,
					doubledown    => $doubledown
				);

				my $full_entries_ref = pop @results;

				foreach my $panel (@{$rounds{"panels"}{$rank_round}}) { 

					foreach my $entry (@{$panels{"entries"}{$panel}}) { 

						my $rank = $full_entries_ref->{"section_rank"}{$entry};
						my $unbroken_rank = $full_entries_ref->{"section_ub_rank"}{$entry};

						$entries{"unbroken_rank"}{$entry}{$rank_round} = $unbroken_rank;
						$entries{"composite_rank"}{$entry}{$rank_round} = $rank;
						$entries{"composite_rank_count"}{$panel}{$rank}++;

					} 
				}
			}
		}
	}

	my $student_vote;

	if ($event_type eq "debate") {

		ENTRY:
		foreach my $entry (@entries) { 

			foreach my $this_round (@all_rounds) { 

				next if $rounds{"type"}{$this_round} eq "elim";
				next if $rounds{"type"}{$this_round} eq "runoff";
				next if $rounds{"type"}{$this_round} eq "final";

				next if $entries{"round_bye"}{$this_round}{$entry};
				next if $entries{"round_panel_bye"}{$this_round}{$entry};

				my %erseen = ();  

				@{$entries{"round_scores"}{$entry}{$this_round}} = 
					grep { ! $erseen{$_}++ } 
					@{$entries{"round_scores"}{$entry}{$this_round}};

				unless (
					scalar @{$entries{"round_scores"}{$entry}{$this_round}} > 0
				) { 
					$entries{"forfeit"}{$entry}++;
					next ENTRY;
				}
			}
		}
	}

	my $bye_min;

	if ($round_robin) { 
		
		my @pods = $m->comp("/funclib/event_entry_settings.mas", 
			tag   => "pod",
			event => $event
		);

		%{$entries{"pod"}} = map {$_->entry->id => $_->value} @pods;

		foreach my $entry (sort {$entries{"bye"}{$b} <=> $entries{"bye"}{$a}} @entries) { 

			push @{$pods{$entries{"pod"}{$entry}}}, $entry;

			$bye_min = $entries{"bye"}{$entry} 
				if $entries{"bye"}{$entry} 
				&& not defined $bye_min;

			$bye_min = $entries{"bye"}{$entry} 
				if $entries{"bye"}{$entry} < $bye_min;
		}
	}

	my $test_round;
	my $seed_skipper++;

	if ($needs{"seed"}) { 

		$test_round = $round if (
			$round->type ne "elim" 
			&& $round->type ne "final"
			&& $round->type ne "runoff"
		);

		unless ($test_round) { 

			my $test_round_id;

			# Rounds are in order by name so this will yield the last prelim round. 

			foreach my $round (@all_rounds) { 
				$test_round_id = $round if $rounds{"type"}{$round} eq "prelim";
			}

			$test_round = Tab::Round->retrieve($test_round_id);
			undef $seed_skipper;
		}

		unless ($seed_skip) { 

			my ($entries_ref, @others) = $m->comp(
				"/tabbing/results/order_entries.mas", 
				round     => $test_round,
				seed_skip => $seed_skipper
			);

			foreach my $key (sort {$a <=> $b} keys %{$entries_ref}) {
				foreach my $entry (@{${$entries_ref}{$key}}) {
					$entries{"seed"}{$entry} = $key;
				}
			}
		}
	}

	if ($needs{"nsda_points"}) { 

		my $round_one = Tab::Round->search(
			event => $event->id,
			name => 1
		)->first;

		my $round_one_start = eval { 
			my $start = $round_one->timeslot->start->set_time_zone($tourn->tz);
			$start->set_time_zone("UTC");
			return $start;
		};

		unless ($round_one_start) { 

			my $message = "You have NSDA Points as a tiebreaker, which are searched based on the start of the first round.  However you have no Round 1 labeled with a timeslot!  Fix this by going to Settings -> Schedule, selecting the event at right, and then saving the schedule to re-number the rounds.";

			$m->comp("/funclib/abort.mas", message => $message);
		}

		my $start_timestamp = DateTime::Format::MySQL->format_datetime($round_one_start);

		my $dbh = Tab::DBI->db_Main();
	
		my $sth = $dbh->prepare("
			select entry.id, sum(point.points)
			from tabroom.entry entry, points.NEW_POINTS point, points.NEW_USERS nsda_person,
				tabroom.entry_student entry_student, tabroom.student student
			where entry.event = ? 
				and entry.id = entry_student.entry
				and entry_student.student = student.id
				and student.nsda = nsda_person.user_id
				and nsda_person.ualt_id = point.student_id
				and point.tstamp < ? 
			group by entry.id
		");

		$sth->execute($event->id, $start_timestamp);

		while (
			my ($entry_id, $nsda_points) = $sth->fetchrow_array()
		) { 

			$entries{"nsda_points"}{$entry_id} = $nsda_points;
		}

	}

	my $seed_done;
	my $opp_seed_done;
	my $opp_wins_done;

	foreach my $key (sort keys %tb_tiers) { 

		my $tier_desc;
		my $tier_long_desc;

		next if $seed_done && $seed_skip;
		next if $opp_seed_done && $seed_skip;
		next if $opp_wins_done && $opp_wins_only;

		foreach my $tb (sort {$a <=> $b} @{$tb_tiers{$key}}) { 

			my $tb_name = $tb->name;

			# Tiebreakers where high values are better
			
			$tier_dir{$key} = "down" if (
				$tb_name eq "winloss" 
				|| $tb_name eq "reciprocals" 
				|| $tb_name eq "points" 
				|| $tb_name eq "po_points" 
				|| $tb_name eq "ballots" 
				|| $tb_name eq "rounds" 
				|| $tb_name eq "judgepref" 
				|| $tb_name eq "three_way_point" 
				|| $tb_name eq "three_way_recip" 
				|| $tb_name eq "headtohead" 
				|| $tb_name eq "opp_points" 
				|| $tb_name eq "opp_wins" 
				|| $tb_name eq "judgevar" 
				|| $tb_name eq "recipinround" 
				|| $tb_name eq "judgevar2"
				|| $tb_name eq "preponderance"
				|| $tb_name eq "nsda_points"
				|| $tb_name eq "student_ballot"
			);

			# Tiebreakers where low values are better

			$tier_dir{$key} = "up" if (
				$tb_name eq "ranks" 
				|| $tb_name eq "opp_seed" 
				|| $tb_name eq "seed" 
				|| $tb_name eq "opp_ranks" 
				|| $tb_name eq "chair_ranks" 
				|| $tb_name eq "non_chair_ranks" 
				|| $tb_name eq "rankinround" 
				|| $tb_name eq "downs" 
				|| $tb_name eq "runoff" 
				|| $tb_name eq "losses" 
				|| $tb_name eq "coinflip"
				|| $tb_name eq "student_rank"
			);

			$tier_desc .= "+" if $tier_desc;
			$tier_long_desc .= "+" if $tier_long_desc;
			$tier_desc .= "F" if $tb_count{$tb->id} eq "final";
			$tier_desc .= "E" if $tb_count{$tb->id} eq "elim";
			$tier_desc .= "P" if $tb_count{$tb->id} eq "prelim";

			my $digits = 0; 

			given ($tb_name) { 

				when ('ranks') { 
					$tier_desc .= "Rk"; 
					$tier_long_desc .= "Ranks";
					$digits = 2 if $digits < 2; 
				}

				when ("reciprocals") {
					$tier_desc .= "Rcp";
					$tier_long_desc .= "Reciprocals";
					$digits = 2 if $digits < 2; 
				}

				when ("points") {
					$tier_desc .= "Pts";
					$tier_long_desc .= " Entry" if $team_points;
					$tier_long_desc .= " Points";

					if ($event_settings{"point_increments"} eq "tenths" 
						|| $event_settings{"point_increments"} eq "half"
					) { 
						$digits = 1 if $digits < 1; 
					} elsif ($event_settings{"point_increments"} eq "fourths") { 
						$digits = 2 if $digits < 2; 
					}
				}

				when ("po_points") {
					$tier_desc .= "PO Pt";
					$tier_long_desc .= " Points while Presiding";
				}

				when ("judgepref") {
					$tier_desc .= "JP";
					$tier_long_desc .= "Judge Preferences";
				}

				when ("three_way_point") {
					$tier_desc .= "3WP";
					$tier_long_desc .= "Points if 3-Way Tie";
					$digits = 2 if $digits < 2; 
				}

				when ("three_way_recip") {
					$tier_desc .= "3WR";
					$tier_long_desc .= "Reciprocals if 3-Way Tie";
					$digits = 2 if $digits < 2; 
				}

				when ("preponderance") {
					$tier_desc .= "PRE";
					$tier_long_desc .= "Preponderance: Majority of Judges vote 1";
				}

				when ("headtohead") {
					$tier_desc .= "H2H";
					$tier_long_desc .= "Head to Head Ballots";
				}

				when ("coinflip") {
					$tier_desc .= "Rand";
					$tier_long_desc .= "Random";
					$digits = 2 if $digits < 2; 
				}

				when ("opp_ranks") {
					$tier_desc .= "ORk";
					$tier_long_desc .= "Opponents' ranks";
					$digits = 2 if $digits < 2; 
				}

				when ("chair_ranks") {
					$tier_desc .= "PRk";
					$tier_long_desc .= "Parliamentarian rank";
				}

				when ("student_rank") {
					$tier_desc .= "SV"; 
					$tier_long_desc .= "Student Vote";
					$student_vote++;
				}

				when ("student_ballot") {
					$tier_desc .= "SB"; 
					$tier_long_desc .= "Student Nominated";
					$student_vote++;
				}

				when ("non_chair_ranks") {
					$tier_desc .= "NParlRk";
					$tier_long_desc .= "Non-parliamentarian rank";
				}

				when ("winloss") {
					$tier_desc .= "Prev " if $tb_count{$tb->id} eq "previous";
					$tier_desc .= "R".$tb_round{$tb->id} if $tb_count{$tb->id} eq "specific";
					$tier_desc .= "Win";
					$tier_long_desc .= "Wins";
				}

				when ("losses") {
					$tier_desc .= "Prev " if $tb_count{$tb->id} eq "previous";
					$tier_desc .= "R".$tb_round{$tb->id} if $tb_count{$tb->id} eq "specific";
					$tier_desc .= "Loss";
					$tier_long_desc .= "Losses";
				}

				when ("downs") {
					$tier_desc .= "Dwn";
					$tier_long_desc .= "Ranked Down (Bottom Half of Room)";
				}

				when ("seed") {
					$tier_desc .= "Sd";
					$tier_long_desc .= "Prelim seed";
				}

				when ("opp_seed") {
					$tier_desc .= "OSd";
					$tier_long_desc .= "Opponents' average seed";
					$digits = 2 if $digits < 2; 
				}

				when ("opp_wins") {
					$tier_desc .= "OpW";
					$tier_long_desc .= "Opponent Wins";
					$digits = 2 if $digits < 2; 
				}

				when ("opp_points") {
					$tier_desc .= "OPt";
					$tier_long_desc .= "Opponent Points";
					$digits = 2 if $digits < 2; 
				}

				when ("judgevar") {
					$tier_desc .= "Z1";
					$tier_long_desc .= "ZScore1: Judge Points Variance";
					$digits = 2 if $digits < 2; 
				}

				when ("judgevar2") {
					$tier_desc .= "Z2";
					$tier_long_desc .= "ZScore2: Sample Judge Points Variance";
					$digits = 2 if $digits < 2; 
				}

				when ("ballots") {
					$tier_desc .= "Bal";
					$tier_long_desc .= "Ballot Total";
				}

				when ("nsda_points") {
					$tier_desc .= "NSDA";
					$tier_long_desc .= "NSDA Merit Points at Tournament Start";
				}

				when ("rounds") {
					$tier_desc .= "Rnds";
					$tier_long_desc .= "Rounds Debated In";
				}

				default {
				}
			}
					
			$entries{"tb_digits"}{$key} = $digits;

			my $tb_highlow = $tb->highlow;

			if ($tb_highlow) {

				$tier_desc .= " -".$tb->highlow_count;
				$tier_long_desc .= " dropping ".$tb->highlow_count;

				if ($tb_highlow == 1 || $tb_highlow == 2) { 
					$tier_desc .= "HL";
					$tier_long_desc .= " best & worst";
				}

				if ($tb_highlow == 3) { 
					$tier_desc .= "H";
					$tier_long_desc .= " best";
				}

				if ($tb_highlow == 4) { 
					$tier_desc .= "L";
					$tier_long_desc .= " worst";
				}
			}

			if ($tb->child > 0 ) { 
				$tier_desc = "C".$tier_desc;
				$tier_long_desc .= " Composite based on ".$tb->child->name;
			}

			$tier_long_desc .= " in ".ucfirst($tb_count{$tb->id})." round" 
				if $tb_count{$tb->id};

			if ($tb_count{$tb->id} eq "specific") { 
				$tier_long_desc .= " (R".$tb->count_round.")";
			}

			$tier_long_desc .= " Rounds" 
				if $tb_count{$tb->id} 
				&& ($tb_count{$tb->id} eq "all");

			$tier_long_desc .= "s" 
				if $tb_count{$tb->id} 
				&& ($tb_count{$tb->id} eq "prelim" 
					|| $tb_count{$tb->id} eq "elim"
				);

			$tier_long_desc .= " multplied by ".$tb->multiplier 
				if $tb->multiplier != 1;

			$tier_desc .= " x".$tb->multiplier if $tb->multiplier != 1;

			if ($opp_wins_only) { 
				$tier_desc = "OpW";
				$tier_long_desc = "Opponent Wins";
			}
		}

		my %student_vote;

		if ($student_vote) { 
			
			Tab::StudentBallot->columns(TEMP => "entryid");

			Tab::StudentBallot->set_sql( vote => "
				select student_ballot.*, ballot.entry as entryid
				from student_ballot, panel
				where panel.round = ? 
				and panel.id = student_ballot.panel
			");

			foreach my $sv (Tab::StudentBallot->search_vote($this_round_id)) { 
				if ($sv->tag eq "ballot") { 
					$student_vote{$sv->entryid}{"ballot"} = 1;
				} else { 
					$student_vote{$sv->entryid}{"rank"} = $sv->value;
				}
			}
		}

		$tier_desc = "SOP" if $tier_desc eq "Sd+OSd";
		$tier_desc = "SOP" if $tier_desc eq "OSd+Sd";

		$tier_descs{$key} = $tier_desc;
		$tier_long_descs{$key} = $tier_long_desc;

		foreach my $tb (@{$tb_tiers{$key}}) { 

			$tb_info{$tb->id}{"name"}              = $tb->name;
			$tb_info{$tb->id}{"child"}             = $tb->child->id if $tb->child;
			$tb_info{$tb->id}{"highlow"}           = $tb->highlow;
			$tb_info{$tb->id}{"truncate"}          = $tb->truncate;
			$tb_info{$tb->id}{"truncate_smallest"} = $tb->truncate_smallest;
			$tb_info{$tb->id}{"multiplier"}        = $tb->multiplier;
			$tb_info{$tb->id}{"highlow_count"}     = $tb->highlow_count;

			if ($tb_count{$tb->id} eq "specific") { 

				push (@{$tb_info{$tb->id}{"rounds"}}, $tb_round{$tb->id});

			} else { 

				foreach my $oround (@all_rounds) { 

					if ($rounds{"type"}{$oround} eq $tb_count{$tb->id}) { 
						push (@{$tb_info{$tb->id}{"rounds"}}, $oround);
					}

					if ($tb_count{$tb->id} eq "all") { 
						push (@{$tb_info{$tb->id}{"rounds"}}, $oround);
					}

					if ($tb_count{$tb->id} eq "previous" 
						&& $rounds{"name"}{$oround} == $round->name
					) { 
						push (@{$tb_info{$tb->id}{"rounds"}}, $oround);
					}

				}

			}
		}
		
		ENTRY:
		foreach my $entry (@entries) { 

			my %seen = (); 
			@{$entries{"panels"}{$entry}} = 
				grep { ! $seen{$_} ++ } 
				@{$entries{"panels"}{$entry}};

			my $tier_total;
			my $round_averages;

			foreach my $tbo (@{$tb_tiers{$key}}) { 

				my $tb = $tbo->id;

				my $name = $tb_info{$tb}{"name"};
				next unless $tb_info{$tb}{"rounds"};
				my @rounds = @{$tb_info{$tb}{"rounds"}};
				my $tb_highlow = $tb_info{$tb}{"highlow"};
				my $tb_highlow_count = $tb_info{$tb}{"highlow_count"};

				if ($opp_wins_only) { 
					$name = "opp_wins";
					$opp_wins_done++;
					undef @rounds;
					undef $tb_highlow;

					foreach my $oround (@all_rounds) { 
						push (@rounds, $oround) 
							if $rounds{"type"}{$oround} ne "elim" 
							&& $rounds{"type"}{$oround} ne "final"
							&& $rounds{"type"}{$oround} ne "runoff";
					}
				}

				my $total; 

				# WINS WINLOSS 

				if ($name eq "winloss") { 

					$total += sprintf("%d", 100 * $entries{"tb_wins"}{$tb}{$entry}) 
						unless $skip_wins;

				# LOSSES 

				} elsif ($name eq "losses") { 

					$total += sprintf("%d", 100 * $entries{"tb_losses"}{$tb}{$entry}) 
						unless $skip_wins;

				# RANKS RANKINGS RECIPS RECIPROCALS ONES TWOS

				} elsif (
					$name eq "ranks" 
					|| $name eq "reciprocals" 
					|| $name eq "chair_ranks"
					|| $name eq "non_chair_ranks"
				) { 

					my @drop_best;
					my @drop_worst;

					my $count;
					my $bye;

					my $local_truncate = $tb_info{$tb}{"truncate"};

					my $max_score;
				
					foreach my $this_round (@rounds) { 

						if ($tb_info{$tb}{"runoff"}) { 
		
							my $runoff = $tb_info{$tb}{"runoff"};
		
							$tier_descs{$key} = "RO ".$runoff->name." Rk";
							$entries{"tb_digits"}{$key} = 0;
							$tier_long_descs{$key} = "Ranking from Runoff ".$runoff->label." ".$runoff->name;

							if ($tourn_settings{"nsda_speech_method"} eq "doubledown") { 
								$total += $entries{"unbroken_rank"}{$entry}{$runoff};
								$entries{"used_composite"}{$entry}{$this_round} = 
									$entries{"unbroken_rank"}{$entry}{$runoff};
							} else { 
								$total += $entries{"composite_rank"}{$entry}{$runoff};
								$entries{"used_composite"}{$entry}{$this_round} = 
									$entries{"composite_rank"}{$entry}{$runoff};
							}
							$total = sprintf("%d", 100 * $total);

						} else { 

							$max_score = $max_score_count{"rank"}{$this_round};

							$bye += $max_score_count{"rank"}{$this_round}
								if $entries{"round_panel_bye"}{$this_round}{$entry};

							$bye += $max_score_count{"rank"}{$this_round}
								if $entries{"round_bye"}{$this_round}{$entry} 
								&& not defined $entries{"round_scores"}{$entry}{$this_round};

							$bye += $max_score_count{"rank"}{$this_round}
								if $entries{"round_forfeit"}{$this_round}{$entry} 
								&& not defined $entries{"round_scores"}{$entry}{$this_round};

							next if $entries{"round_panel_bye"}{$this_round}{$entry};

							next if $entries{"round_bye"}{$this_round}{$entry} 
								&& not defined $entries{"round_scores"}{$entry}{$this_round};

							next if $entries{"round_forfeit"}{$this_round}{$entry} 
								&& not defined $entries{"round_scores"}{$entry}{$this_round};

							my %used_scores;
							my $round_count;
							my $round_score;
							my %round_done;

							foreach my $score (@{$entries{"round_scores"}{$entry}{$this_round}}) { 

								next if $round_done{$entry}{$this_round};

								if ($scores{"tag"}{$score} eq "rank") { 

									my $rank;

									if ($tb_info{$tb}{"child"}) { 

										if ($tourn_settings{"nsda_speech_method"} eq "doubledown") { 
											$rank = $entries{"unbroken_rank"}{$entry}{$this_round};
											$entries{"used_composite"}{$entry}{$this_round} = $rank;
										} else { 
											$rank = $entries{"composite_rank"}{$entry}{$this_round};
											$entries{"used_composite"}{$entry}{$this_round} = $rank;
										}

										if ($local_truncate) { 
											#Tiebreaker specific truncation limit
											$rank = $local_truncate if $rank > $local_truncate;
										}

										if ($truncate_to_smallest || $tb_info{$tb}{"truncate_smallest"}) {
											$rank = $rounds{"truncate"}{$this_round} 
												if $rank > $rounds{"truncate"}{$this_round};
										}

										$round_done{$entry}{$this_round}++;

									} else {

										next if $name eq "chair_ranks" 
											&& $scores{"chair"}{$score} < 1;

										next if $name eq "non_chair_ranks" 
											&& $scores{"chair"}{$score} > 0;

										next if $used_scores{$score}++;

										$round_count++;
									
										$rank = $scores{"value"}{$score};
										my $this_panel = $scores{"panel"}{$score};
										my $this_judge = $scores{"judge"}{$score};
								
										if ($dq_panel_threshold{$this_panel}{$this_judge}) { 
											$rank-- 
												if $dq_panel_threshold{$this_panel}{$this_judge} < $rank;
										}

										# Bump the rank up if it's a time
										# violation.  Truncation below will
										# correct if this makes it bigger (ie
										# if the TV was last place);

										$rank++ if $scores{"tv"}{$score} && $mfl_time_violation;

										if (
											(	$rounds{"type"}{$this_round} eq "prelim" 
												&& defined $truncate_prelims
											) || (
												$rounds{"type"}{$this_round} eq "final" 
												&& defined $truncate_finals
											) || (
												$rounds{"type"}{$this_round} eq "elim" 
												&& defined $truncate_elims) 
											) { 

											# Promote anyone over the hard cap for truncation
											$rank = $truncate if $truncate && $rank > $truncate;

											# Promote anyone over the per-round floating cap for truncation
											$rank = $rounds{"truncate"}{$this_round} 
												if $truncate_to_smallest 
												&& $rank > $rounds{"truncate"}{$this_round};
										
										}

										if ($tb_info{$tb}{"truncate_smallest"})  { 
											$rank = $rounds{"truncate"}{$this_round} 
												if $rank > $rounds{"truncate"}{$this_round};
										}

										if ($local_truncate) { 
											#Tiebreaker specific truncation limit
											$rank = $local_truncate if $rank > $local_truncate;
										}

										#Rank cannot be greater than the size of the round
										my $panel_id = $entries{"round_panel"}{$entry}{$this_round};

										$rank = scalar @{$panels{"entries"}{$panel_id}} 
											if $rank > scalar @{$panels{"entries"}{$panel_id}}
											&& $event_type ne "debate";

									}

									$round_score += sprintf("%d", 100 * $rank) 
										if $name eq "ranks" 
										|| $name eq "chair_ranks"
										|| $name eq "non_chair_ranks";

									$total += sprintf("%d", 100 * ( 1 / $rank )) 
										if $rank > 0 
										&& $name eq "reciprocals";

									$count++ if $name eq "ranks";

									if ($tb_highlow) {  

										#drop the best

										if ($tb_highlow == 1 || $tb_highlow == 2 || $tb_highlow == 3) {

											if (scalar @drop_best < $tb_highlow_count) {
												push @drop_best, $rank;
											} else {
												my $least_best = pop @drop_best;

												if ($least_best <= $rank) { 
													push @drop_best, $least_best;
												} else { 
													push @drop_best, $rank;
												}
											}

											@drop_best = sort {$a <=> $b} @drop_best;
										}

										#drop the worst

										if (
											$tb_highlow == 1 || $tb_highlow == 2 || $tb_highlow == 4
										) {

											if (scalar @drop_worst < $tb_highlow_count) {

												push @drop_worst, $rank;

											} else {

												my $least_worst = pop @drop_worst;

												push @drop_worst, $least_worst 
													if $least_worst >= $rank;

												push @drop_worst, $rank 
													if $least_worst < $rank;

											}

											@drop_worst = sort {$b <=> $a} @drop_worst;
										}
									}
								}
							}

							if ($name eq "ranks" 
								|| $name eq "chair_ranks" 
								|| $name eq "non_chair_ranks"
							) {

								if ($maverick_method eq "double") { 

									if ($round_count 
										&& $round_count < $max_score_count{"rank"}{$this_round}
									) {
										$round_score = $round_score 
											* $max_score_count{"rank"}{$this_round} 
											/ $round_count;

										$count +=  
											($max_score_count{"rank"}{$this_round} / $round_count) 
											- 1;
									}

								} else { 

									if ($round_count 
										&& $round_count < $max_score_count{"rank"}{$this_round}
									) {

										my $missing = $max_score_count{"rank"}{$this_round} - $round_count;
										#400 because we're 100x to avoid floats
										$round_score += 400 * $missing;  
										$count +=  ($max_score_count{"rank"}{$this_round} / $round_count) - 1;
									}
								}
							}

							$total += sprintf("%d", $round_score) 
								if $name eq "ranks" 
								|| $name eq "chair_ranks"
								|| $name eq "non_chair_ranks";
						}
					}

					$bye = $bye - ($bye_min * $max_score) if $round_robin;

					my $average;

					if ($bye) { 
						$average = $total / $count if $count;
						$total += sprintf("%d", ($average * $bye));
						$entries{"tb_digits"}{$key} = 2 if $entries{"tb_digits"}{$key} < 2;
					}

                    foreach my $rank (@drop_best, @drop_worst) { 

                        $total -= sprintf("%d", 100 * $rank) 
							if $name eq "ranks" 
							|| $name eq "chair_ranks"
							|| $name eq "non_chair_ranks";

                        $total -= sprintf("%d", 100 * (1 / $rank)) 
							if $rank 
							&& $name eq "reciprocals";

						$count-- if $name eq "ranks";
						$total = 0 if $total < 0;
                    }

					$entries{"ranks"}{$entry} = $total / $count if $count;

				# STUDENT VOTE
				} elsif ($name eq "student_ballot") { 

					if ($student_vote{$entry}{"ballot"}) { 
						$total = 100;
					} else { 
						$total = 0;
					}

				} elsif ($name eq "student_rank") { 

					$total = ($student_vote{$entry}{"rank"} * 100);

				# DOWNS DOUBLEDOWN DROPS DOUBLEDROPS

				} elsif ($name eq "downs") { 

					foreach my $this_round (@rounds) { 

						my $panel_id   = $entries{"round_panel"}{$entry}{$this_round};
						my $rank       = $entries{"composite_rank"}{$entry}{$this_round};
						my $rank_count = $entries{"composite_rank_count"}{$panel_id}{$rank};

						$entries{"used_composite"}{$entry}{$this_round} = $rank;

						my $size_of_panel = 
							scalar @{$panels{"entries"}{$panel_id}}
							if $panels{"entries"}{$panel_id};

						my $first_limit = floor($size_of_panel / 2);
						my $absolute_limit = ceil($size_of_panel / 2);

						$absolute_limit++ if $first_limit == $absolute_limit;

						# The NSDA.  Where formulas take a backseat to lists. 

						if ($districts) { 

							given ($size_of_panel) { 

								when (4) { 
									$first_limit    = 2;
									$absolute_limit = 4;
								}

								when (5) { 
									$first_limit    = 3;
									$absolute_limit = 4;
								}

								when (6) { 
									$first_limit    = 3;
									$absolute_limit = 4;
								}

								when (7) { 
									$first_limit    = 3;
									$absolute_limit = 4;
								}
							}
						}

						my $rank_position = $rank + ($rank_count - 1);

						if ($rank_count > 1) { 
							$total++ if $rank_position > $absolute_limit;
						} else { 
							$total++ if $rank_position > $first_limit;
						}

					}

					$total = $total * 100;

				# SPEAKS SPEAKER POINTS

				} elsif ($name eq "points") { 

					my $bye;
					my $count;
					my $averages;
					my $num_rounds;
					my @student_ids;

					my @drop_best;
					my @drop_worst;
					my %points_have_bye;

					my $max_score;
					my %student_scores = ();

					foreach my $this_round (@rounds) { 
						foreach my $score (@{$entries{"round_scores"}{$entry}{$this_round}}) { 
							if ($scores{"tag"}{$score} eq "points") { 
								my $points = sprintf("%d", 100 * $scores{"value"}{$score});
								push @{$student_scores{$scores{'student'}{$score}}{"scores"}}, $points;
							}
						}
					}

					foreach my $student_id (keys %student_scores) { 

						my $total;
						my $counter;

						if ($student_scores{$student_id}{"scores"}) { 
							foreach my $value (@{$student_scores{$student_id}{"scores"}}) { 
								$total += $value;
								$counter++;
							}
						}

						push @student_ids, $student_id;

						my $average = sprintf("%d", ($total / $counter) ) 
							if $counter > 0;

						$student_scores{$student_id}{"average"} = $average;
						$student_scores{$student_id}{"total"} = $total;
						$student_scores{$student_id}{"count"} = $counter;
					}

					foreach my $this_round (@rounds) { 

						$num_rounds++;
						$max_score = $max_score_count{"points"}{$this_round};
	
						if ($byes_on_team_basis) { 
							$bye++ if $entries{"round_panel_bye"}{$this_round}{$entry};
						} else { 
							$bye += $max_score_count{"points"}{$this_round}  
								if $entries{"round_panel_bye"}{$this_round}{$entry};
						}
						
						next if $entries{"round_panel_bye"}{$this_round}{$entry}
							&& $this_round_name != 1;

						my $round_count;
						my $round_score;
						my %judge_points = ();
						my %done_students = ();

						foreach my $score (@{$entries{"round_scores"}{$entry}{$this_round}}) { 

							if (
								$scores{"tag"}{$score} eq "points" 
								|| $scores{"tag"}{$score} eq "rebuttal_points"
							) { 

								my $points = sprintf("%d", 100 * $scores{"value"}{$score});
								$count++ unless $byes_on_team_basis;
								$round_count++;

								$judge_points{$this_round}{$scores{"judge"}{$score}} 
									+= sprintf("%d", 100 *$scores{"value"}{$score});

								$round_score += $points;
								$done_students{$scores{"student"}{$score}}++;

							}
						}

						$count++ if $round_score && $byes_on_team_basis;
						my $average_round_count;

						unless ($team_points) {

							if ($maverick_method eq "double" || $maverick_method eq "double_rank") { 

								if ($round_count 
									&& $round_count < $max_score_count{"points"}{$this_round}
								) {

									$count +=  
										($max_score_count{"points"}{$this_round} / $round_count) 
										- 1;

									$round_score = $round_score 
										* ($max_score_count{"points"}{$this_round} / $round_count);
								}

							} elsif ($maverick_method eq "average") { 

								if ($round_count 
									&& $round_count < $max_score_count{"points"}{$this_round}
								) {

									foreach my $student_id (keys %student_scores) { 

										next if $done_students{$student_id};

										my $missing = $max_score_count{"points"}{$this_round} - $round_count;

										foreach (1 .. $missing) { 

											$round_score += $student_scores{$student_id}{"average"};
											$round_count++;
											$count++;
						
											foreach my $judgekey (keys %{$judge_points{$this_round}}) { 
												$judge_points{$this_round}{$judgekey} 
													+= $student_scores{$student_id}{"average"};
											}
										}
									} 
								} 

								if ($round_count 
									&& $round_count < $max_score_count{"points"}{$this_round}
								) {

									$average_round_count++;

									$count +=  
										($max_score_count{"points"}{$this_round} / $round_count) 
										- 1;

									$averages += 
										($max_score_count{"points"}{$this_round} / $round_count) 
										- 1;

								}
							}
						}

						if ($round_count) { 
							unless ($round_score) { 

								if (
									$entries{"round_bye"}{$this_round}{$entry}
									|| $entries{"round_forfeit"}{$this_round}{$entry} 
								) { 
									$bye += $round_count;
								}
							}

						} elsif ($event_type eq "debate") { 

							unless (defined $round_score) { 

								if ($byes_on_team_basis) { 

									if (
										$entries{"round_bye"}{$this_round}{$entry}
										|| $entries{"round_forfeit"}{$this_round}{$entry} 
									) { 
										$bye++;
									}

								} else { 

									$bye += $max_score_count{"points"}{$this_round} 
										if $entries{"round_bye"}{$this_round}{$entry};

									$bye += $max_score_count{"points"}{$this_round} 
										if $entries{"round_forfeit"}{$this_round}{$entry};
								}
							}

							unless ($bye) { 

								if ($byes_on_team_basis) { 

									$average_round_count++;
									$count++;
									$averages++;

								} else {
						
									$average_round_count += $max_score_count{"points"}{$this_round};
									$count += $max_score_count{"points"}{$this_round};
									$averages += $max_score_count{"points"}{$this_round};

								}
							}
						}

						# This judgekey thing deals with multi judge prelims

						foreach my $judgekey (keys %{$judge_points{$this_round}}) { 
							
							my $points = $judge_points{$this_round}{$judgekey};

							if ($tb_highlow) { 			

								if (
									$tb_highlow == 1 
									|| $tb_highlow == 2 
									|| $tb_highlow == 3
								) {

									if (scalar @drop_best < $tb_highlow_count) {

										push @drop_best, $points;

									} else {

										my $least_best = shift @drop_best;

										push @drop_best, $least_best 
											if $least_best >= $points;

										push @drop_best, $points 
											if $least_best < $points;

									}

									@drop_best = sort {$a <=> $b} @drop_best;
								}

								#drop the worst

								if (
									$tb_highlow == 1 
									|| $tb_highlow == 2 
									|| $tb_highlow == 4
								) {

									if (scalar @drop_worst < $tb_highlow_count) {

										push @drop_worst, $points;

									} else {

										my $least_worst = shift @drop_worst;

										push @drop_worst, $least_worst 
											if $least_worst <= $points;

										push @drop_worst, $points 
											if $least_worst > $points;

									}

									@drop_worst = sort {$b <=> $a} @drop_worst;
								}
							}
						}

						$total += $round_score;

						# Used for whole round averages when powering round 1
						$entries{"round_points"}{$this_round}{$entry} = $round_score
							unless $entries{"round_points"}{$this_round}{$entry};

						if ( 
							((not defined $total) || $total == 0)
							&& $this_round_name == 1
						) { 

							$entries{"round_averages"}{$entry}{$this_round}++;
							$event_settings{"round_averages"}++;
							$round_averages++;
						}

						next if $bye && not defined $round_score;
						$points_have_bye{$round_score} = $average_round_count;

					}

					$bye = $bye - ($bye_min * $max_score) if $round_robin;
					my $average;

					if ($bye) { 
						$average = $total / $count if $count;
						$total += sprintf("%d", $average * $bye);
						$count += $bye;
					}

					if ($averages) { 
						$entries{"tb_digits"}{$key} = 2;
						$average = $total / ($count - $averages) 
							if $count && ($count - $averages) > 0;

						$total += sprintf("%d", $average * $averages);
						$count += $averages;
					}

					my $how_many  = $count / (scalar @rounds) if scalar @rounds;

					if ($tb_highlow) { 
						if ($tb_highlow == 1 || $tb_highlow == 2) { 
							$how_many -= 2 * $tb_highlow_count;
						} else { 
							$how_many -= $tb_highlow_count;
						}
					}

                    foreach my $points (@drop_best, @drop_worst) {
						next unless $tb_highlow;
                        $total -= sprintf("%d", $points);
						$total -= sprintf("%d", $average * $points_have_bye{$points});
						$total = 0 if $total < 0;
						$count--;
                    }

					if ($team_points) { 
						my %seen = ();
						@student_ids = grep { ! $seen{$_} ++ } @student_ids;
						$how_many = scalar @student_ids;
						$total = sprintf("%d", $total / $how_many) 
							if $how_many;
					}

					if ($count) { 
						#Used for opp wins, opp points
						$entries{"points"}{$entry} += ($total / $count);
					}

				# BALLOT COUNT BALLOTS

				} elsif ( $name eq "ballots") { 

					my $bye;
					my $ballot_score;
					my $ballot_round_count;

					foreach my $this_round (@rounds) { 

						foreach my $score (@{$entries{"round_scores"}{$entry}{$this_round}}) { 
							if ($scores{"tag"}{$score} eq "ballot") { 
								$ballot_score++ if $scores{"value"}{$score} == 1;
							}
						}
			
						if ($entries{"round_bye"}{$this_round}{$entry} 
							|| $entries{"round_panel_bye"}{$this_round}{$entry}) {

							$bye += $max_score_count{"ballot"}{$this_round};

						} else { 
							$ballot_round_count++;
						}

					}

					$bye = $bye - $bye_min if $round_robin;

					if ($bye) { 

						if ($wsdc_byes && $ballot_round_count) { 
					
							my $ballot_average = ($ballot_score / $ballot_round_count);
							$ballot_average = nearest(1, $ballot_average);
							$ballot_score += $ballot_average;

						} else {

							$ballot_score += $bye;

						}
					}

					$total += sprintf("%d", 100 * $ballot_score);

				# POINTS WHILE PRESIDING OFFICER

				} elsif ($name eq "po_points") { 

					ROUND:
					foreach my $this_round (@rounds) { 

						my $presided;

						foreach my $score (@{$entries{"round_scores"}{$entry}{$this_round}}) { 
							$presided++ if $scores{"tag"}{$score} eq "presiding_officer";
						}

						if ($presided) { 

							foreach my $score (@{$entries{"round_scores"}{$entry}{$this_round}}) { 

								if ($scores{"tag"}{$score} eq "congress_speech") { 
									$total += sprintf("%d", 100 * $scores{"value"}{$score});
								}
							}
						}
					}

				# ROUNDS DEBATED IN

				} elsif ( $name eq "rounds") {

					my $num_rounds = scalar (keys %{$entries{"rounds"}{$entry}});
					$total += sprintf("%d", 100 * $num_rounds);
					
				# COINFLIP RANDOM

				} elsif ( $name eq "coinflip") { 

					# This is only semi random; product of the date epoch and
					# the random entry ID's last four digits.  But it will be
					# the same every time this function is run and random
					# enough in that it cannot be pre-guessed easily.

					my $random_seed = $entry * $seed;
					$total = substr($random_seed, -8, -5);

				# THREE WAY BOUNCE FOR JUDGES PREFERENCE ON RECIPS
				} elsif ( $name eq "three_way_recip") { 

					my $chosen_panel;
					my @chosen_entries;
					my $local_truncate = $tb_info{$tb}{"truncate"};

					foreach my $this_round (@rounds) { 

						# Only counts in the current round;

						PANEL:
						foreach my $panel (@{$rounds{"panels"}{$this_round}}) {    
							my @entries = @{$panels{"entries"}{$panel}};
							next PANEL unless grep {$_ == $entry} @entries;
							$chosen_panel = $panel;
							@chosen_entries = @entries;
						} 

						my %beseen = (); 
						@chosen_entries = grep { ! $beseen{$_} ++ } @chosen_entries;

						my $entry_string;

						foreach my $okey (sort keys %tb_tiers) { 
							next if $key == $okey;
							$entry_string .= "-" if $entry_string;
							$entry_string .= $entries{"tbs"}{$entry}{$okey};
						}

						my @ties;

						foreach my $oentry (@chosen_entries) { 
							my $test_string;

							foreach my $okey (sort keys %tb_tiers) { 
								next if $key == $okey;
								$test_string .= "-" if $test_string;
								$test_string .= $entries{"tbs"}{$oentry}{$okey};
							}

							push(@ties, $oentry) if $test_string eq $entry_string;
						}

						if (scalar @ties == 3) { 

							my %tie_scores;

							foreach my $tie (@ties) { 
	
								# Take an average so you don't have to fuck around with byes
								my $recips;
								my $count;
						
								foreach my $tie_round (@rounds) { 
									foreach my $score (@{$entries{"round_scores"}{$tie}{$tie_round}}) { 
										if ($scores{"tag"}{$score} eq "rank") { 
											$recips += sprintf("%d", 100 * (1 / $scores{"value"}{$score}));
											$count++;
										}
									}
								}

								$tie_scores{$tie} = sprintf("%d", ($recips / $count)) if $count;
								$tie_scores{$tie} = 0 unless $count;
							}

							my $max_score;

							foreach my $tie (@ties) { 
								$max_score = $tie_scores{$tie} 
									if $tie_scores{$tie} > $max_score;
							}

							$total += 100 if $max_score == $tie_scores{$entry};

						}
					}

				# THREE WAY BOUNCE FOR JUDGES PREFERENCE ON POINTS
				} elsif ( $name eq "three_way_point") { 

					my $chosen_panel;
					my @chosen_entries;
					my $local_truncate = $tb_info{$tb}{"truncate"};

					foreach my $this_round (@rounds) { 

						# Only counts in the current round;

						PANEL:
						foreach my $panel (@{$rounds{"panels"}{$this_round}}) {    
							my @entries = @{$panels{"entries"}{$panel}};
							next PANEL unless grep {$_ == $entry} @entries;
							$chosen_panel = $panel;
							@chosen_entries = @entries;
						} 

						my %beseen = (); 
						@chosen_entries = grep { ! $beseen{$_} ++ } @chosen_entries;

						my $entry_string;

						foreach my $okey (sort keys %tb_tiers) { 
							next if $key == $okey;
							$entry_string .= "-" if $entry_string;
							$entry_string .= $entries{"tbs"}{$entry}{$okey};
						}

						my @ties;

						foreach my $oentry (@chosen_entries) { 
							my $test_string;

							foreach my $okey (sort keys %tb_tiers) { 
								next if $key == $okey;
								$test_string .= "-" if $test_string;
								$test_string .= $entries{"tbs"}{$oentry}{$okey};
							}

							push(@ties, $oentry) if $test_string eq $entry_string;
						}

						if (scalar @ties == 3) { 

							my %tie_scores;

							foreach my $tie (@ties) { 
	
								# Take an average so you don't have to fuck around with byes
								my $points;
								my $count;
						
								foreach my $tie_round (@rounds) { 
									foreach my $score (@{$entries{"round_scores"}{$tie}{$tie_round}}) { 
										if ($scores{"tag"}{$score} eq "points") { 
											$points += sprintf("%d", 100 * $scores{"value"}{$score});
											$count++;
										}
									}
								}

								$tie_scores{$tie} = sprintf("%d", ($points / $count)) if $count;
								$tie_scores{$tie} = 0 unless $count;
							}

							my $max_score;

							foreach my $tie (@ties) { 
								$max_score = $tie_scores{$tie} if $tie_scores{$tie} > $max_score;
							}

							$total += 100 if $max_score == $tie_scores{$entry};

						}
					}

				# JUDGEPREF
				} elsif ( $name eq "judgepref") { 

					my $chosen_panel;
					my @chosen_entries;

					my $local_truncate = $tb_info{$tb}{"truncate"};

					foreach my $this_round (@rounds) { 

						# Only counts in the current round;

						PANEL:
						foreach my $panel (@{$rounds{"panels"}{$this_round}}) {    
							my @entries = @{$panels{"entries"}{$panel}};
							next PANEL unless grep {$_ == $entry} @entries;
							$chosen_panel = $panel;
							@chosen_entries = @entries;
						} 

						my %beseen = (); 
						@chosen_entries = grep { ! $beseen{$_} ++ } @chosen_entries;

						my $entry_string;

						foreach my $okey (sort keys %tb_tiers) { 
							next if $key == $okey;
							$entry_string .= "-" if $entry_string;
							$entry_string .= $entries{"tbs"}{$entry}{$okey};
						}

						my @ties;

						foreach my $oentry (@chosen_entries) { 

							next if $oentry == $entry;
							my $test_string;

							foreach my $okey (sort keys %tb_tiers) { 
								next if $key == $okey;
								$test_string .= "-" if $test_string;
								$test_string .= $entries{"tbs"}{$oentry}{$okey};
							}

							push(@ties, $oentry) if $test_string eq $entry_string;
						}

						if (scalar @ties == 1) { 

							my $tie_id = shift @ties;

							my %judge_score = ();

							if ($chosen_panel && $entry) { 

								my %done;

								foreach my $score (@{$entries{"scores"}{$entry}}) { 
								
									next if $done{$score}++;
									next unless $scores{"tag"}{$score} eq "rank";
									next unless $scores{"panel"}{$score} == $chosen_panel;
		
									my $judge_id = $scores{"judge"}{$score};

									$judge_score{$chosen_panel}{$judge_id} = $scores{"value"}{$score};
									$judge_score{$chosen_panel}{$judge_id} = $local_truncate 
										if $local_truncate 
										&& $judge_score{$scores{"judge"}{$score}};

								}

								# If my rank is better (lower) than the tie's
								# rank, I get a JP point

								foreach my $tie_score (@{$entries{"scores"}{$tie_id}}) {

									next if $done{$tie_score}++;
									next unless $scores{"tag"}{$tie_score} eq "rank";
									next unless $scores{"panel"}{$tie_score} == $chosen_panel;

									$total += 100 if $scores{"value"}{$tie_score} > 
											$judge_score{$chosen_panel}{$scores{"judge"}{$tie_score}}; 

								}
							}
						}
					}

				} elsif ( $name eq "preponderance") { 

					my $current_panel = $entries{"round_panel"}{$entry}{$this_round_id};

					my $count_ones;
					my $count_not_ones;

					my %done;
					foreach my $score (@{$entries{"scores"}{$entry}}) { 
					
						next if $done{$score}++;
						next unless $scores{"tag"}{$score} eq "rank";
						next unless $scores{"panel"}{$score} == $current_panel;

						if ($scores{"value"}{$score} == 1) { 
							$count_ones++;
						} else { 
							$count_not_ones++;
						}
					}

					$total += 100 if $count_ones > $count_not_ones;

				} elsif ( $name eq "headtohead") { 

					my @test_entries;

					# Only counts in the current round;

					PANEL:
					foreach my $panel (@{$rounds{"panels"}{$this_round_id}}) {    
						push @test_entries, @{$panels{"entries"}{$panel}};
					} 

					my %beseen = (); 
					@test_entries = grep { ! $beseen{$_} ++ } @test_entries;

					my $entry_string;

					foreach my $okey (sort keys %tb_tiers) { 
						next if $key == $okey;
						$entry_string .= "-" if $entry_string;
						$entry_string .= $entries{"tbs"}{$entry}{$okey};
					}

					my @ties;

					foreach my $oentry (@test_entries) { 
						next if $oentry == $entry;
						my $test_string;
						foreach my $okey (sort keys %tb_tiers) { 
							next if $key == $okey;
							$test_string .= "-" if $test_string;
							$test_string .= $entries{"tbs"}{$oentry}{$okey};
						}

						push(@ties, $oentry) if $test_string eq $entry_string;
					}

					if (scalar @ties == 1) { 

						my $tie_id = shift @ties;
						my %panel_ballots = ();
						my %done;

						foreach my $this_round (@rounds) { 

							next unless 
								$entries{"round_panel"}{$entry}{$this_round}
								== $entries{"round_panel"}{$tie_id}{$this_round};

							my $entry_count;
							my $tie_count;

							foreach my $score (@{$entries{"round_scores"}{$entry}{$this_round}}) { 
								next unless $scores{"tag"}{$score} eq "ballot";
								$entry_count += $scores{"value"}{$score};
							}

							foreach my $score (@{$entries{"round_scores"}{$tie_id}{$this_round}}) { 
								next unless $scores{"tag"}{$score} eq "ballot";
								$tie_count += $scores{"value"}{$score};
							}

							$total += 100 if $entry_count > $tie_count;
						}
					}

				} elsif ( $name eq "opp_wins") { 

					my $count;
					my $sub_total;

					foreach my $panel (@{$entries{"panels"}{$entry}}) { 

						next if $panels{"roundname"}{$panel} > $this_round_name;

						foreach my $other (@{$panels{"entries"}{$panel}}) { 

							next if $other == $entry;
							$sub_total += $entries{"tb_wins"}{$tb}{$other};
							$count++;

						}
					}

					$total += sprintf "%.2d", 100 * $sub_total/$count if $count;

				} elsif ( $name eq "opp_points") { 

					my $count;
					my $sub_total;

					foreach my $panel (@{$entries{"panels"}{$entry}}) { 

						next if $panels{"roundname"}{$panel} > $this_round_name;

						foreach my $other (@{$panels{"entries"}{$panel}}) { 
							next if $other == $entry;

							$sub_total += $entries{"points"}{$other};
							$count++;
						}
					}

					$total += sprintf "%d", $sub_total / $count if $count;

				} elsif ( $name eq "opp_ranks") { 

					my $count;
					my $sub_total;

					foreach my $panel (@{$entries{"panels"}{$entry}}) { 

						next if $panels{"roundname"}{$panel} > $this_round_name;

						foreach my $other (@{$panels{"entries"}{$panel}}) { 
							next if $other == $entry;
							$sub_total += $entries{"ranks"}{$other};
							$count++;
						}
					}

					$total += sprintf "%d", $sub_total / $count if $count;

				} elsif ( $name eq "nsda_points") { 

					$total += sprintf "%d", 100 * $entries{"nsda_points"}{$entry};

				} elsif ( $name eq "seed") { 

					$seed_done++;
					$total += sprintf "%d", 100 * $entries{"seed"}{$entry};

				} elsif ( $name eq "opp_seed") { 

					$opp_seed_done++;
					my $count;
					my $sub_total;

					foreach my $panel (@{$entries{"panels"}{$entry}}) { 

						next if $panels{"roundname"}{$panel} > $this_round_name;
						foreach my $other (@{$panels{"entries"}{$panel}}) { 
							next if $other == $entry;
							$sub_total += $entries{"seed"}{$other};
							$count++;
						}
					}

					$total += sprintf "%d", 100 * $sub_total / $count if $count;

				} elsif ( $name eq "judgevar") { 

					my $sub_total;
					my $sub_count;
					my $sub_byes;

					foreach my $this_round (@rounds) { 

						my $round_done;

						foreach my $score (@{$entries{"round_scores"}{$entry}{$this_round}}) { 
							# No rebuttal points here either
							next unless $scores{"tag"}{$score} eq "points";   

							my $judge_avg  = ${$judge_avg_ref}{$scores{"judge"}{$score}};
							my $judge_stddev  = ${$judge_stddev_ref}{$scores{"judge"}{$score}};

							next unless $judge_stddev > 0;

							$sub_total += ( 
								( ($scores{"value"}{$score} - $judge_avg) / $judge_stddev) * $total_std) 
								+ $total_avg;
							$sub_count++;
							$round_done++;
						}

						$sub_byes++ unless $round_done;
					}

					my $average = ($sub_total / $sub_count) if $sub_count;
					$total += sprintf "%d", 100 * $average * $this_round_name * $event_settings{"max_entry"};

				} elsif ($name eq "judgevar2") { 

					my $sub_total;
					my $sub_count;
					my $sub_byes;

					foreach my $this_round (@rounds) { 

						my $round_done;

						foreach my $score (@{$entries{"round_scores"}{$entry}{$this_round}}) { 
							next unless $scores{"tag"}{$score} eq "points";

                            my $judge_avg  = ${$judge_avg_ref}{$scores{"judge"}{$score}};
                            my $judge_stddev  = ${$judge_stddev_ref}{$scores{"judge"}{$score}};

                            # These sample only the schools/stddevs for the
                            # debaters the judge has judged, not all debaters.

                            my $judge_sample_avg  = ${$judge_z2_avg_ref}{$scores{"judge"}{$score}};
                            my $judge_sample_stddev  = ${$judge_z2_stddev_ref}{$scores{"judge"}{$score}};

                            next unless $judge_stddev > 0; 

                            $sub_total += 
								( 
									(
										($scores{"value"}{$score} - $judge_avg) 
										/ $judge_stddev
									) 
									* $judge_sample_stddev
								) + $judge_sample_avg;


							$sub_count++;
							$round_done++;

						}
						$sub_byes++ unless $round_done;
					}

					my $average = ($sub_total / $sub_count) if $sub_count;
					$total += sprintf "%d", 100 * $average * $sub_byes if $sub_byes;
					$total += sprintf "%d", 100 * $sub_total;

				}

				$tier_total += $total * $tb_info{$tb}{"multiplier"} if $tb_info{$tb}{"multiplier"};
			}

			if ($round_averages) { 
				$entries{"averages"}{$entry}{$key}++;
			}

			$entries{"tbs"}{$entry}{$key} = $tier_total;
			$entries{"tiebreak"}{$key}{$entry} = $tier_total;
			
		}
	}

	if ($needs{"opp_points"} || $needs{"opp_ranks"}) { 
		
		my $err;

		if ($needs{"opp_points"} &! $needs{'points'}) { 
			$err .= " Danger Will Robinson!<br /> You have defined Opp Points as ";
			$err .= " a tiebreaker without first defining Points.  That cannot work";
			$err .= " both technically and philosophically.  Fix please! <br /><br />";
		}

		if ($needs{"opp_ranks"} &! $needs{'ranks'}) { 
			$err .= " Danger Will Robinson!<br />You have defined Opp Ranks as a ";
			$err .= " tiebreaker without first defining Ranks.  That cannot work both";
			$err .= " technically and philosophically.  Fix please!";
		}

		$m->abort() if $never_redirect;

		$m->redirect("/setup/rules/tiebreaks.mhtml?tiebreak_set_id=".$tiebreak_set->id."&err=$err") 
			if $err;
	}

	my $round_average;

	if ($event_settings{"round_averages"}) { 

		my $round_total;
		my $round_count;

		foreach my $entry (@entries) { 
			next unless $entries{"round_points"}{$this_round_id}{$entry} > 0;
			$round_total += $entries{"round_points"}{$this_round_id}{$entry};
			$round_count++;
		}

		$round_average = $round_total / $round_count if $round_count;
	}

	ENTRY:
	foreach my $entry (@entries) { 

		next if $entries{"dq"}{$entry} && not defined ($districts);
			
		next unless $entries{"panels"}{$entry} && @{$entries{"panels"}{$entry}};

		foreach my $key (sort {$a <=> $b} keys %tb_tiers) { 
		
			if ($entries{"averages"}{$entry}{$key}) { 

				$entries{"tbs"}{$entry}{$key} 
					+= $round_average;
			
				$entries{"tiebreak"}{$key}{$entry} 
					+= $round_average;
			}
		}
	}

	foreach my $key (reverse sort {$a <=> $b} keys %tb_tiers) { 

		@entries = sort { 
			$entries{"tbs"}{$a}{$key} <=> $entries{"tbs"}{$b}{$key} 
		} @entries 
		if $tier_dir{$key} eq "up";

		@entries = 
			sort { 
				$entries{"tbs"}{$b}{$key} <=> $entries{"tbs"}{$a}{$key} 
		} @entries 
		if $tier_dir{$key} eq "down";

	}

	if ($section_rank) { 

		my $doubledown++ if $ARGS{"doubledown"};

		$doubledown++ 
			if $composite_set 
			&& $tourn_settings{"nsda_speech_method"} eq "doubledown";

		foreach my $panel (@{$rounds{"panels"}{$this_round_id}}) { 

			my @pan_entries = @{$panels{"entries"}{$panel}};

			foreach my $key (reverse (sort {$a <=> $b} keys %tb_tiers)) { 

				@pan_entries = 
					sort { $entries{"tbs"}{$a}{$key} <=> $entries{"tbs"}{$b}{$key}  } 
					@pan_entries 
					if $tier_dir{$key} eq "up";

				@pan_entries = 
					sort { $entries{"tbs"}{$b}{$key} <=> $entries{"tbs"}{$a}{$key} } 
					@pan_entries 
					if $tier_dir{$key} eq "down";
			}

			my %already; 
			my $count;
			my $delayed_count;
			my $last_count;
			my $last_string;

			my $second_count;
			my $second_delayed_count;
			my $second_last_count;
			my $second_last_string;

			foreach my $panel_entry (@pan_entries) { 

				my $tier_string = tier_string($panel_entry, \%tb_tiers, \%entries);

				my $second_tier_string;
			
				if ($tourn_settings{"nsda_speech_method"} eq "doubledown") { 

					my @keys = sort keys %tb_tiers;
					my $key = shift @keys;
					my %second_tiers;

					$second_tiers{$key} = $tb_tiers{$key};
					$second_tier_string = tier_string($panel_entry, \%second_tiers, \%entries);

				}

				if ($second_tier_string eq $second_last_string) { 
					$second_delayed_count++
				} else { 
					$second_count++;
					$second_count += $second_delayed_count;
					$second_last_string = $second_tier_string;
					undef $second_delayed_count;

				}

				if ($tier_string eq $last_string) { 
					$delayed_count++;
				} else {
					$count++;
					$count += $delayed_count;
					$last_string = $tier_string;
					undef $delayed_count;
				}

				next if $already{$panel_entry}++;
				next if (not defined $districts) && $entries{"dq"}{$panel_entry};

				if ($panel_entry) { 
					push @{$entries{"second_panel_order"}{$panel}{$second_count}}, $panel_entry 
						if $second_count;

					push @{$entries{"panel_order"}{$panel}{$count}}, $panel_entry;
				}

				$entries{"section_rank"}{$panel_entry} = $count;
				$entries{"section_ub_rank"}{$panel_entry} = $second_count;

				$entries{"section"}{$panel_entry} = $panels{"section"}{$panel};
				$entries{"section_id"}{$panel_entry} = $panel;

				$entries{"panel"}{$panel_entry} = $panel;

			}

			if (
				$districts
				|| ($tiebreak_set->setting("tie_middle_rank"))
				|| ($parent_set && $parent_set->setting("tie_middle_rank"))
			) { 

				# At NSDA districts, three way ties should get the MIDDLE ranking.

				foreach my $place (sort keys %{$entries{"panel_order"}{$panel}}) { 

					if (
						(scalar @{$entries{"panel_order"}{$panel}{$place}} == 3) 
						|| (scalar @{$entries{"panel_order"}{$panel}{$place}} == 4) 
					) {
					
						@{$entries{"panel_order"}{$panel}{($place + 1)}} 
							= @{$entries{"panel_order"}{$panel}{$place}};

						@{$entries{"panel_order"}{$panel}{$place}} = ();

						delete $entries{"panel_order"}{$panel}{$place};

					}
				}

				foreach my $place (keys %{$entries{"panel_order"}{$panel}}) { 
					foreach my $panel_entry (@{$entries{"panel_order"}{$panel}{$place}}) { 
						$entries{"section_rank"}{$panel_entry} = $place;
					}
				}

				foreach my $place (sort keys %{$entries{"second_panel_order"}{$panel}}) { 

					if (
						(scalar @{$entries{"second_panel_order"}{$panel}{$place}} == 3) 
						|| (scalar @{$entries{"second_panel_order"}{$panel}{$place}} == 4) 
					) {
					
						@{$entries{"second_panel_order"}{$panel}{($place + 1)}} 
							= @{$entries{"second_panel_order"}{$panel}{$place}};

						@{$entries{"second_panel_order"}{$panel}{$place}} = ();

						delete $entries{"second_panel_order"}{$panel}{$place};

					}
				}

				foreach my $place (keys %{$entries{"second_panel_order"}{$panel}}) { 
					foreach my $panel_entry (@{$entries{"second_panel_order"}{$panel}{$place}}) { 
						$entries{"section_ub_rank"}{$panel_entry} = $place;
					}
				}
			}
		}
	
		@entries = 
			sort { $entries{"section"}{$a} cmp $entries{"section"}{$b} } 
			@entries;

		@entries = 
			sort { length($entries{"section"}{$a}) <=> length($entries{"section"}{$b}) } 
			@entries;

		@entries = 
			sort { $entries{"section_rank"}{$a} <=> $entries{"section_rank"}{$b} } 
			@entries;

	} elsif ($round_robin) { 

		foreach my $pod (keys %pods) { 

			my @pod_entries = @{$pods{$pod}};

			foreach my $key (reverse sort {$a <=> $b} keys %tb_tiers) { 

				@pod_entries = 
					sort { $entries{"tbs"}{$a}{$key} <=> $entries{"tbs"}{$b}{$key}  } 
					@pod_entries 
					if $tier_dir{$key} eq "up";

				@pod_entries = 
					sort { $entries{"tbs"}{$b}{$key} <=> $entries{"tbs"}{$a}{$key} } 
					@pod_entries 
					if $tier_dir{$key} eq "down";
			}

			my $count = 1;

			my %already; 

			foreach my $pe (@pod_entries) { 
				next if $already{$pe};
				next if $entries{"dq"}{$pe} && (not defined $districts);
				$already{$pe}++;
				$entries{"pod_rank"}{$pe} = $count++;
				$entries{"section_rank"}{$pe} = $entries{"pod_rank"}{$pe};
				$entries{"pod"}{$pe} = $pod;
			}
		}
	
		@entries = 
			sort { $entries{"pod_rank"}{$a} <=> $entries{"pod_rank"}{$b} } 
			@entries;

		foreach my $panel (@{$rounds{"panels"}{$this_round_id}}) { 
			foreach my $entry (@{$panels{"entries"}{$panel}}) { 
				$entries{"section"}{$entry} = $panel;
				$entries{"section_id"}{$entry} = $panel;
				$entries{"panel"}{$entry} = $panel;
			}
		}

	} else { 

		foreach my $panel (@{$rounds{"panels"}{$this_round_id}}) { 
			foreach my $pe (@{$panels{"entries"}{$panel}}) { 
				$entries{"section"}{$pe} = $panels{"section"}{$panel};
				$entries{"section_id"}{$pe} = $panel;
				$entries{"panel"}{$pe} = $panel;
			}
		}
	}

	@entries = 
		sort { $entries{"forfeit"}{$a} <=> $entries{"forfeit"}{$b} } @entries 
		if $forfeits_never_break;

	@entries = 
		sort { $entries{"dq"}{$a} <=> $entries{"dq"}{$b} } @entries 
		if $districts;

	my $count;
	
	my $last_string;
	my $delayed_count;
	my $three_way;

	foreach my $entry (@entries) { 

		next if $entries{"dq"}{$entry} && (not defined $districts);
			
		next unless $entries{"panels"}{$entry} 
			&& @{$entries{"panels"}{$entry}};

		next if $breakout && not defined $eligible{$entry};

		my $tier_string = tier_string($entry, \%tb_tiers, \%entries);

		if ($section_rank) { 
			$tier_string .= "-".$entries{"section_rank"}{$entry};
			$tier_string .= "-".$entries{"letter"}{$entry};
		}

		if ($tier_string eq $last_string) { 
			$delayed_count++;
		} else {
			$count++;
			$count += $delayed_count;
			undef $delayed_count;
		}

		$last_string = $tier_string;

		push (@{$entries{"by_place"}{$count}}, $entry);

		$entries{"seed"}{$entry} = $count;

		@{$entries{"by_place"}{$count}} = sort @{$entries{"by_place"}{$count}};
			
		#Normalize the 100x back to actual values
		foreach my $key (sort {$a <=> $b} keys %tb_tiers) { 
		
			$entries{"tbs"}{$entry}{$key} 
				= $entries{"tbs"}{$entry}{$key} / 100;

			my $rounder = 1 / (10 ** $entries{"tb_digits"}{$key});

			$entries{"tbs"}{$entry}{$key} 
				= nearest($rounder, $entries{"tbs"}{$entry}{$key});

			$entries{"tiebreak"}{$key}{$entry} 
				= $entries{"tiebreak"}{$key}{$entry} / 100;

			$entries{"tiebreak"}{$key}{$entry}
				= nearest($rounder, $entries{"tiebreak"}{$key}{$entry});
		}
	}

	$entries{"tb_info"} = \%tb_info;
	$entries{"tier_direction"} = \%tier_dir;
	$entries{"tier_description"} = \%tier_descs;
	$entries{"tier_long_description"} = \%tier_long_descs;

	return (
		$entries{"by_place"},
		$entries{"tbs"},
		\%tier_descs,
		$entries{"forfeit"},
		\%tier_dir,
		$entries{"section_rank"},
		$entries{"letter"},
		\%tier_long_descs,
		$entries{"code"},
		$entries{"bye"},
		$entries{"panel"},
		\%entries
	);  # <-- Hope to gradually replace all the above with just this. 

	sub tier_string { 

		my ($entry, $tb_tiers_ref, $entries_ref) = @_;
		my $tier_string;

		foreach my $key (sort {$a <=> $b} keys %{$tb_tiers_ref}) { 
			my $value = nearest(1, $entries_ref->{"tbs"}{$entry}{$key}) / 100;
			$tier_string .= "-" if $tier_string;
			$tier_string .= $value;
		}

		return $tier_string;
	}

</%init>
