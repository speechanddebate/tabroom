<%args>
	$round
	$nsda          => undef
	$seed_skip     => undef
	$skip_wins     => undef
	$breakout      => undef
	$long_names    => undef
	$opp_wins_only => undef
</%args>
<%init>

	return unless $round;
	use POSIX;

	my $event = $round->event;
	my $event_type = $event->type;
	my $tourn = $event->tourn;
	my $seed = $tourn->start->epoch;

	my $this_round_name = $round->name;

	my $tb_set = $round->tb_set if $round->tb_set;

	unless ($tb_set) {  
		my $err = "Round ".$round->realname." does not have a tiebreaker set applied to it.";
		$err .= "Please pick one and try again";
		$m->redirect("/setup/schedule/event.mhtml?event_id=".$event->id."&err=$err");
	}

	#Deduplicate Ballots
	$m->comp("/funclib/event_dedupe.mas", event => $event);

	#Settings
	my $mfl_time_violation = $tb_set->setting("mfl_time_violation");
	my $truncate = $tb_set->setting("truncate_ranks_to") if $tb_set->setting("truncate_ranks_to");
	my $truncate_to_smallest = $tb_set->setting("truncate_to_smallest");
	my $truncate_prelims = $tb_set->setting("truncate_prelims");
	my $truncate_elims = $tb_set->setting("truncate_elims");
	my $truncate_finals = $tb_set->setting("truncate_finals");

	if ($nsda) { 
		undef $truncate;
		undef $truncate_to_smallest;
		undef $truncate_prelims;
		undef $truncate_elims;
		undef $truncate_finals;
	}

	my $forfeits_never_break = $tb_set->setting("forfeits_never_break");
	my $equal_elims++ if $tb_set->setting("equal_elims");

	my $round_robin++ if $event->setting("round_robin");
	my $team_points++ if $event->setting("team_points");

	undef $team_points if $event_type eq "congress"; # Redundant and harmful
	undef $team_points if $event_type eq "speech"; # Redundant and harmful

	undef $round_robin if $round->type eq "elim" || $round->type eq "final";

	my %used_tier = (); 
	my $all;
	my $elim;

	my %tb_tiers = ();
	my %tbid_tiers = ();

	foreach my $tb ($tb_set->tiebreaks) { 
		my $count = $tb->count;

		#This will only aggregate the present round for Points purposes.
		$count = "last_elim" if $nsda; 

		$used_tier{$count}++;
		$all++ if $count eq "all";
		$elim++ if $count eq "elim";

		if ($nsda && $round->type ne "elim" && $round->type ne "final") { 

			# If we're doing autopoints post on a prelim we have to not drop
			# scores or all will be tied.

			$tb->highlow("");
			$tb->highlow_count("");
		}
		push @{$tb_tiers{$tb->priority}}, $tb;
		push @{$tbid_tiers{$tb->priority}}, $tb->id;
	}   


	# Get the data you'll need for Teh Sortingz.
	my $dbh = Tab::DBI->db_Main();

    my %entry_wins;

    my %entry_scores;
    my %entry_panels;
	my %entry_round_scores;
    my %entry_school;
    my %entry_event;
    my %entry_code;
    my %entry_dq;
    my %entry_forfeit;
	my %entry_bye;
	my %entry_round_bye;
	my %entry_round_fft;
	my %entry_round_panel_bye;

	my %entry_ranks;  		#For opp_ranks calculation
	my %entry_points;		#For opp_points calculation

    my %score_entry;
    my %score_tag;
    my %score_value;
    my %score_panel;
    my %score_judge;
    my %score_event;
	my %score_round;
	my %score_chair;
	my %score_tv;

	my %round_panels;
	my %pods;

	my %panel_letter;
	my %panel_roundname;
	my %panel_entries;

	my @rounds = $event->rounds;
	my %round_type = map {$_->id => $_->type} @rounds;
	my %round_name = map {$_->id => $_->name} @rounds;

	foreach my $round (@rounds) { 
		$round_type{$round} = "prelim" if $round_type{$round} eq "preset" || $round_type{$round} eq "highhigh" || $round_type{$round} eq "highlow" || $round_type{$round} eq "random" || $round_type{$round} eq "power";
	}

	my @scores;
	my @entries;

	my $last_elim_wins;

	my $dropped_limit = " and entry.dropped != 1 ";
	undef $dropped_limit if $nsda;

	if ($all) { 

		my $sth = $dbh->prepare("
			select value.id, entry.id, entry.code, entry.dq,  round.type, round.name, round.id, value.tag, value.value, event.id, panel.id, 
			ballot.judge, ballot.forfeit, ballot.tv, panel.letter, entry.school, ballot.chair, ballot.bye, panel.bye
			from score value, ballot, panel, round, event, entry, entry_student, student
			where value.ballot = ballot.id
			and ballot.panel = panel.id
			and panel.round = round.id
			and round.event = event.id
			and not exists ( select round_setting.id from round_setting where round_setting.tag = 'ignore_results' and round_setting.round = round.id)
			and event.id = ".$event->id."
			and ballot.entry = entry.id
			$dropped_limit
			and entry.waitlist != 1
			
			and entry.id = entry_student.entry
			and entry_student.student = student.id
			group by value.id
			order by event.id, round.name
		");

		$sth->execute();

		while (my ($id, $entry, $code, $dq, $type, $roundname, $round, $tag, $value, $event, $panel, $judge, $forfeit, $tv, $letter,  $school, $chair, $bye, $pbye)  = $sth->fetchrow_array() ) {

			push @{$round_panels{$round}}, $panel;

			push @entries, $entry;
			push @{$entry_scores{$entry}}, $id;
			push @{$entry_panels{$entry}}, $panel; 
			push @{$entry_round_scores{$entry."-".$round}}, $id;

			$entry_school{$entry} = $school;
			$entry_event{$entry} = $event;
			$entry_code{$entry} = $code;
			$entry_dq{$entry} = $dq if $dq;
			$entry_forfeit{$entry}++ if $forfeit;

			$entry_round_bye{$round."-".$entry} = $bye;
			$entry_round_fft{$round."-".$entry} = $forfeit;

			$entry_round_panel_bye{$round."-".$entry} = 1 if $pbye;
			$entry_bye{$entry}++ if $pbye;

			push @scores, $id;
			$score_tag{$id} = $tag;
			$score_entry{$id} = $entry;
			$score_value{$id} = $value;
			$score_panel{$id} = $panel;
			$score_judge{$id} = $judge;
			$score_event{$id} = $event;
			$score_round{$id} = $roundname;
			$score_chair{$id}++ if $chair;
			$score_tv{$id} = $tv if $tv;

			$panel_letter{$panel} = $letter;
			$panel_roundname{$panel} = $roundname;
			push @{$panel_entries{$panel}}, $entry;

		}

		my $bye_sth = $dbh->prepare("
			select ballot.entry, entry.code, panel.id, panel.round, round.name, panel.letter
			from panel, ballot, round, entry
			where round.event = ".$event->id."
			and panel.round = round.id
			and not exists ( select round_setting.id from round_setting where round_setting.tag = 'ignore_results' and round_setting.round = round.id)
			and ballot.panel = panel.id
			and ballot.entry = entry.id
			$dropped_limit
			and entry.waitlist != 1
			
			and panel.bye = 1
			and not exists ( 
				select score.id
				from score
				where score.ballot = ballot.id
			)
			group by ballot.entry
			order by round.name
		");

		$bye_sth->execute();

		while (my ($entry, $code, $panel, $round, $roundname, $letter)  = $bye_sth->fetchrow_array() ) {

			$entry_round_panel_bye{$round."-".$entry} = 1;
		
			$entry_bye{$entry}++;
			push @entries, $entry;
			push @rounds, $round;
			push @{$entry_panels{$entry}}, $panel;
			push @{$panel_entries{$panel}}, $entry;
			push @{$round_panels{$round}}, $panel;
			$entry_code{$entry} = $code;
			$panel_roundname{$panel} = $roundname;
			$panel_letter{$panel} = $letter;
		}

		my $other_bye_sth = $dbh->prepare("
			select ballot.entry, entry.code, panel.id, panel.round, round.name, ballot.bye, ballot.forfeit, panel.bye, panel.letter
			from panel, ballot, round, entry
			where round.event = ".$event->id."
			and panel.round = round.id
			and not exists ( select round_setting.id from round_setting where round_setting.tag = 'ignore_results' and round_setting.round = round.id)
			and ballot.panel = panel.id
			$dropped_limit
			and entry.waitlist != 1
			
			and ballot.entry = entry.id
			and not exists ( 
				select score.id
				from score
				where score.ballot = ballot.id
			)
			group by ballot.id
			order by round.name
		");

		$other_bye_sth->execute();

		while (my ($entry, $code, $panel, $round, $roundname, $bye, $forfeit, $skip, $letter)  = $other_bye_sth->fetchrow_array() ) {

			next if $skip > 0;

			if ($bye) { 
				$entry_round_bye{$round."-".$entry} = 1;
				$entry_bye{$entry}++;
			} elsif ($forfeit) { 
				$entry_round_fft{$round."-".$entry} = 1;
				$entry_forfeit{$entry}++;
			}

			$entry_code{$entry} = $code;
			push @entries, $entry;
			push @rounds, $round;
			push @{$entry_panels{$entry}}, $panel;
			push @{$panel_entries{$panel}}, $entry;
			push @{$round_panels{$round}}, $panel;
			$panel_roundname{$panel} = $roundname;
			$panel_letter{$panel} = $letter;

		}

	} else { 

		foreach my $key (keys %used_tier) { 

			if ($key eq "last elim" || $key eq "last_elim") { 

				%entry_wins = $m->comp("/funclib/entry_wins.mas", event => $event, round => $round, last => 1);

				$last_elim_wins++;

				my $sth = $dbh->prepare("
					select value.id, entry.id, entry.code, entry.dq, round.type, round.name, round.id, value.tag, value.value, event.id, panel.id, 
					ballot.judge, ballot.forfeit, ballot.tv, panel.letter, entry.school, ballot.chair, ballot.bye, panel.bye
					from score value, ballot, panel, round, event, entry, entry_student, student
					where value.ballot = ballot.id
					and ballot.panel = panel.id
					and panel.round = round.id
					and not exists ( select round_setting.id from round_setting where  round_setting.tag = 'ignore_results' and round_setting.round = round.id)
					and round.event = event.id
					and round.id = ".$round->id."
					and ballot.entry = entry.id
					$dropped_limit
					and entry.waitlist != 1
					
					and entry.id = entry_student.entry
					and entry_student.student = student.id
					group by value.id
					order by event.id, round.name
				");

				$sth->execute();

				while (my ($id, $entry, $code, $dq,  $type, $roundname, $round, $tag, $value, $event, $panel, $judge, $forfeit, $tv, $letter,  $school, $chair, $bye, $pbye)  = $sth->fetchrow_array() ) {

					push @{$round_panels{$round}}, $panel;

					push @entries, $entry;
					push @{$entry_scores{$entry}}, $id;
					push @{$entry_panels{$entry}},$panel;
					push @{$entry_round_scores{$entry."-".$round}}, $id;

					$entry_school{$entry} = $school;
					$entry_event{$entry} = $event;
					$entry_code{$entry} = $code;
					$entry_dq{$entry} = $dq if $dq;
					$entry_forfeit{$entry}++ if $forfeit;

					$entry_round_bye{$round."-".$entry} = $bye;
					$entry_round_fft{$round."-".$entry} = $forfeit;

					$entry_round_panel_bye{$round."-".$entry} = 1 if $pbye;
					$entry_bye{$entry}++ if $pbye;

					push @scores, $id;
					$score_tag{$id} = $tag;
					$score_entry{$id} = $entry;
					$score_value{$id} = $value;
					$score_panel{$id} = $panel;
					$score_judge{$id} = $judge;
					$score_event{$id} = $event;
					$score_round{$id} = $roundname;
					$score_chair{$id}++ if $chair;
					$score_tv{$id} = $tv;

					$panel_letter{$panel} = $letter;
					$panel_roundname{$panel} = $roundname;
					push @{$panel_entries{$panel}}, $entry;
				}

				my $bye_sth = $dbh->prepare("
					select ballot.entry, entry.code, panel.id, panel.round, round.name, panel.letter, panel.bye, ballot.forfeit, ballot.bye
					from panel, ballot, round, entry
					where round.event = ".$event->id."
					and round.id = ".$round->id."
					and panel.round = round.id
					and not exists ( select round_setting.id from round_setting where  round_setting.tag = 'ignore_results' and round_setting.round = round.id)
					and ballot.panel = panel.id
					and ballot.entry = entry.id
					$dropped_limit
					and entry.waitlist != 1
					
					and not exists ( 
						select score.id
						from score
						where score.ballot = ballot.id
					)
					group by ballot.entry
					order by round.name
				");

				$bye_sth->execute();

				while (my ($entry, $code, $panel, $round, $roundname, $letter, $pbye, $forfeit, $ballot_bye)  = $bye_sth->fetchrow_array() ) {

					next unless $ballot_bye || $pbye || $forfeit;

				 	if ($ballot_bye) { 
						$entry_round_bye{$round."-".$entry} = 1;
					} elsif ($forfeit) { 
						$entry_round_fft{$round."-".$entry} = 1;
					} elsif ($pbye) { 
						$entry_round_panel_bye{$round."-".$entry} = 1;
					}

					push @entries, $entry;
					push @{$entry_panels{$entry}}, $panel;
					push @{$panel_entries{$panel}}, $entry;
					push @{$round_panels{$round}}, $panel;
					$entry_code{$entry} = $code;
					$panel_roundname{$panel} = $roundname;
					$panel_letter{$panel} = $letter;
				}

			} else {

				my $sth = $dbh->prepare("
					select value.id, entry.id, entry.code, entry.dq, round.type, round.name, round.id, 
					value.tag, value.value, event.id, panel.id, ballot.judge, ballot.forfeit, ballot.tv, panel.letter, 
					entry.school, ballot.chair, ballot.bye, panel.bye 
					from score value, ballot, panel, round, event, entry, entry_student, student
					where value.ballot = ballot.id
					and ballot.panel = panel.id
					and not exists ( select round_setting.id from round_setting where  round_setting.tag = 'ignore_results' and round_setting.round = round.id)
					and panel.round = round.id
					and round.event = event.id
					and event.id = ".$event->id."
					and round.name <= ".$this_round_name."
					and ballot.entry = entry.id
					$dropped_limit
					and entry.waitlist != 1
					
					and entry.id = entry_student.entry
					and entry_student.student = student.id
					group by value.id
					order by event.id, round.name
				");

				$sth->execute();

				while (my ($id, $entry, $code, $dq, $type, $roundname, $round, $tag, $value, $event, $panel, $judge, $forfeit, $tv, $letter,  $school, $chair, $bye, $pbye)  = $sth->fetchrow_array() ) {

					push @{$round_panels{$round}}, $panel;

					push @entries, $entry;
					push @{$entry_scores{$entry}}, $id;
					push @{$entry_panels{$entry}},$panel;
					push @{$entry_round_scores{$entry."-".$round}}, $id;

					$entry_school{$entry} = $school;
					$entry_event{$entry} = $event;
					$entry_code{$entry} = $code;
					$entry_dq{$entry} = $dq if $dq;
					$entry_forfeit{$entry}++ if $forfeit;

					$entry_round_bye{$round."-".$entry} = $bye;
					$entry_round_fft{$round."-".$entry} = $forfeit;

					$entry_round_panel_bye{$round."-".$entry} = 1 if $pbye;
					$entry_bye{$entry}++ if $pbye;

					push @scores, $id;
					$score_tag{$id} = $tag;
					$score_entry{$id} = $entry;
					$score_value{$id} = $value;
					$score_panel{$id} = $panel;
					$score_judge{$id} = $judge;
					$score_event{$id} = $event;
					$score_round{$id} = $roundname;
					$score_chair{$id}++ if $chair;
					$score_tv{$id} = $tv;

					$panel_letter{$panel} = $letter;
					$panel_roundname{$panel} = $roundname;
					push @{$panel_entries{$panel}}, $entry;

				}

				my $bye_sth = $dbh->prepare("
					select ballot.entry, entry.code, panel.id, panel.round, round.name, panel.letter
					from panel, ballot, round, entry
					where round.event = ".$event->id."
					and round.name <= ".$this_round_name."
					and panel.round = round.id
					and not exists ( select round_setting.id from round_setting where  round_setting.tag = 'ignore_results' and round_setting.round = round.id)
					and ballot.panel = panel.id
					and ballot.entry = entry.id
					$dropped_limit
					and entry.waitlist != 1
					
					and panel.bye = 1
					and not exists ( 
						select score.id
						from score
						where score.ballot = ballot.id
					)
					group by ballot.entry
					order by round.name
				");

				$bye_sth->execute();

				while (my ($entry, $code, $panel, $round, $roundname, $letter)  = $bye_sth->fetchrow_array() ) {

					$entry_bye{$entry}++;
				
					$entry_round_panel_bye{$round."-".$entry} = 1;
					push @entries, $entry;
					push @{$entry_panels{$entry}}, $panel;
					push @{$panel_entries{$panel}}, $entry;
					push @{$round_panels{$round}}, $panel;
					$entry_code{$entry} = $code;
					$panel_roundname{$panel} = $roundname;
					$panel_letter{$panel} = $letter;
				}

				my $other_bye_sth = $dbh->prepare("
					select ballot.entry, entry.code, panel.id, panel.round, round.name, ballot.bye, ballot.forfeit, panel.bye, panel.letter
					from panel, ballot, round, entry
					where round.event = ".$event->id."
					and round.name <= ".$this_round_name."
					and panel.round = round.id
					and not exists ( select round_setting.id from round_setting where  round_setting.tag = 'ignore_results' and round_setting.round = round.id)
					and ballot.panel = panel.id
					$dropped_limit
					and entry.waitlist != 1
					
					and ballot.entry = entry.id
					and not exists ( 
						select score.id
						from score
						where score.ballot = ballot.id
					)
					order by round.name
				");

				$other_bye_sth->execute();

				while (my ($entry, $code, $panel, $round, $roundname, $bye, $forfeit, $skip, $letter)  = $other_bye_sth->fetchrow_array() ) {
					next if $skip > 0;
					$entry_round_panel_bye{$round."-".$entry} = 1 if $bye;
					$entry_round_fft{$round."-".$entry} = 1 if $forfeit;
					$entry_code{$entry} = $code;
					push @entries, $entry;
					push @{$entry_panels{$entry}}, $panel;
					push @{$panel_entries{$panel}}, $entry;
					push @{$round_panels{$round}}, $panel;
					$panel_roundname{$panel} = $roundname;
					$panel_letter{$panel} = $letter;
				}
			}
		}
	}

	my %rseen = (); 
	@rounds = grep { ! $rseen{$_}++ } @rounds;

	my %eligible = ();

	if ($breakout) { 

		my @breakout_settings = $m->comp("/funclib/event_entry_settings.mas", event => $event, tag => "breakout_".$breakout);

		foreach my $bs (@breakout_settings) { 
			$eligible{$bs->entry->id}++;
		}

		if ($event->setting("breakout_".$breakout."_exclude_elims")) { 
			my @in_elims = $m->comp("/funclib/event_entries.mas", event => $event, in_elims => "yessiree!");
			foreach my $in_elim (@in_elims) { 
				undef $eligible{$in_elim->id};
			}
		}

	}

	my @all_rounds;

	my %round_done;

	foreach my $all_round (@rounds) { 

		next if $round_name{$all_round} > $this_round_name;  # Do not measure the future

		push @all_rounds, $all_round;

		# Uniq the panels so there's no double counting

		my %pseen = (); 
		@{$round_panels{$all_round}} = grep { ! $pseen{$_}++ } @{$round_panels{$all_round}};

		foreach my $panel (@{$round_panels{$all_round}}) {   

			# Uniq the panel entries so there's no double counting;
			my %eseen = (); 
			@{$panel_entries{$panel}} = grep { ! $eseen{$_} ++ } @{$panel_entries{$panel}};
		}
	}

	my %dq_panel_threshold = ();
	my @keys = keys %entry_dq;

	foreach my $entry (keys %entry_dq) { 

		next unless $entry_dq{$entry};

		foreach my $score (@{$entry_scores{$entry}}) { 
			next unless $score_tag{$score} eq "rank";
			$dq_panel_threshold{$score_panel{$score}."-".$score_judge{$score}} = $score_value{$score};
		}

	}

	my %round_truncate = ();

	if ($truncate_to_smallest) { 

		foreach my $round (@all_rounds) { 

			next if $round_type{$round} eq "elim" && not defined $truncate_elims;
			next if $round_type{$round} eq "final" && not defined $truncate_finals;
			next if $round_type{$round} eq "prelim" && not defined $truncate_prelims;

			$round_truncate{$round} = $truncate if $truncate > 0; # Upper limit is the hard cap, if any

			foreach my $panel (@{$round_panels{$round}}) { 
				my $size = scalar @{$panel_entries{$panel}} if $panel_entries{$panel};
				next unless $size > 0;
				$round_truncate{$round} = $size unless $round_truncate{$round};
				$round_truncate{$round} = $size if $round_truncate{$round} > $size;
			}

		}
	}

	my %eseen = (); 
	@entries = grep { ! $eseen{$_} ++ } @entries;

	my %entry_score_count;
	my %max_score_count;

	if ($round && ($round->type eq "elim" || $round->type eq "final")) { 

		#Eliminate everyone who has not advanced to the elim round in question.

		my @counted;
		my %last_round;
		my %done;

		foreach my $entry (@entries) { 

			next if $done{$entry}++;

			my @panels = @{$entry_panels{$entry}};

			foreach my $panel (@{$entry_panels{$entry}}) { 
				$last_round{$entry} = $panel_roundname{$panel} if $last_round{$entry} < $panel_roundname{$panel};
			}

			next if $last_round{$entry} < $this_round_name;
			push @counted, $entry;
		}

		@entries = @counted;

	} elsif ($event_type ne "congress" || $event_type ne "speech" || $team_points) { 

		# Balance scores for mavericks

		foreach my $entry (@entries) { 

			foreach my $score (@{$entry_scores{$entry}}) { 
				next if $score_round{$score} > $this_round_name;
				$entry_score_count{$entry."-".$score_tag{$score}."-".$score_round{$score}}++ if $score_value{$score} > 0;
			}

			foreach my $score (@{$entry_scores{$entry}}) { 
				$max_score_count{$score_tag{$score}} = $entry_score_count{$entry."-".$score_tag{$score}."-".$score_round{$score}}
					if $entry_score_count{$entry."-".$score_tag{$score}."-".$score_round{$score}} > $max_score_count{$score_tag{$score}};
			}
		}

	} elsif ($team_points) {
		$max_score_count{"rank"} = 1;
		$max_score_count{"points"} = 1;
	}

	my $maverick_method = $event->setting("mavericks");
	$maverick_method = "average" unless $maverick_method;

	my %entry_tbs = ();
	my %tier_descs = ();
	my %tier_long_descs = ();
	my %tier_dir = ();

	my $win_loss;
	my $judge_var;

	my @rinr_rounds;

	my $opp_seed;
	my $own_seed;

	$win_loss++ if $opp_wins_only;

	foreach my $key (sort {$a <=> $b} keys %tb_tiers) { 

		foreach my $tb (sort {$a <=> $b} @{$tb_tiers{$key}}) { 

			$opp_seed++ if $tb->name eq "opp_seed";
			$own_seed++ if $tb->name eq "seed";

			$win_loss++ if $tb->name eq "winloss";
			$win_loss++ if $tb->name eq "opp_wins";
			$win_loss++ if $tb->name eq "ballots";
			$judge_var++ if $tb->name eq "judgevar";
			$judge_var++ if $tb->name eq "judgevar2";

			if ($tb->name eq "rankinround") { 
				foreach my $round (@all_rounds) { 
					if ($round_type{$round} eq $tb->count) { 
						push @rinr_rounds, $round;
					} elsif ($tb->count eq "all") { 
						push @rinr_rounds, $round;
					}
				}
			}
		}
	}

	%entry_wins = $m->comp("/funclib/entry_wins.mas", event => $event, round => $round) 
		if $win_loss && not defined $last_elim_wins;

	my ($judge_avg_ref, $judge_ballot_count_ref, $judge_total_ref, $judge_stddev_ref, $total_avg, $total_std, $judge_z2_avg_ref, $judge_z2_ballot_count_ref, $judge_z2_total_ref, $judge_z2_stddev_ref) = $m->comp("/funclib/judge_points_average.mas", event => $event) if $judge_var;

	my %entry_rankinround = ();
	my %entry_recipinround = ();

	my %rinr_seen = (); 
	@rinr_rounds = grep { ! $rinr_seen{$_} ++ } @rinr_rounds;

	my $warn_rank_in_round;

	foreach my $rank_round_id (@rinr_rounds) { 
		$warn_rank_in_round++ if $rank_round_id == $round->id;
	}

	unless ($warn_rank_in_round) { 

		foreach my $round_id (@rinr_rounds) { 

			my $rank_round = Tab::Round->retrieve(int($round_id));

			my ($entries_ref, @others) = $m->comp("/tabbing/results/order_entries.mas", round => $rank_round);

			my %absolute_rank;

			foreach my $key (sort {$a <=> $b} keys %{$entries_ref}) {
				foreach my $entry (@{${$entries_ref}{$key}}) {
					$absolute_rank{$entry} = $key;
				}
			}

			foreach my $panel (@{$round_panels{$rank_round}}) { 
				my $rank = 1;

				foreach my $entry (sort {$absolute_rank{$a} <=> $absolute_rank{$b}} @{$panel_entries{$panel}}) { 
					$entry_rankinround{$entry."-".$rank_round} = $rank;
					$entry_recipinround{$entry."-".$rank_round} = sprintf("%2f", (1 / $rank)  );
					$rank++;

				}
			}
		}
	}

	my $opp_ranks;
	my $opp_points;
	my $ranks;
	my $points;

	unless ($event_type eq "congress" || $event_type eq "speech") { 

		ENTRY:
		foreach my $entry (@entries) { 

			foreach my $this_round (@all_rounds) { 

				next if $round_type{$this_round} eq "elim" || $round_type{$this_round} eq "final";
				next if $entry_round_panel_bye{$this_round."-".$entry};
				next if $entry_round_bye{$this_round."-".$entry};

				my %erseen = ();  
				@{$entry_round_scores{$entry."-".$this_round}} = grep { ! $erseen{$_}++ } @{$entry_round_scores{$entry."-".$this_round}};

				unless (scalar @{$entry_round_scores{$entry."-".$this_round}} > 0) { 
					$entry_forfeit{$entry}++;
					next ENTRY;
				}

			}
		}
	}

	my $bye_min;

	if ($round_robin) { 
		
		my @pods = $m->comp("/funclib/event_entry_settings.mas", tag => "pod", event => $event);
		my %entry_pod = map {$_->entry->id => $_->value} @pods;

		foreach my $entry (sort {$entry_bye{$b} <=> $entry_bye{$a}} @entries) { 
			push @{$pods{$entry_pod{$entry}}}, $entry;
			$bye_min = $entry_bye{$entry} if $entry_bye{$entry} && not defined $bye_min;
			$bye_min = $entry_bye{$entry} if $entry_bye{$entry} < $bye_min;
		}
	}

	my %entry_seed;
	my %opp_entry_seed;

	my $test_round;
	my $seed_skipper++;

	if ($opp_seed || $own_seed) { 

		$test_round = $round if ($round->type ne "elim" && $round->type ne "final");

		unless ($test_round) { 

			my $test_round_id;

			foreach my $round (@all_rounds) { 
				$test_round_id = $round->id if $round_type{$round} eq "prelim";
			}
			$test_round = Tab::Round->retrieve($test_round_id);
			undef $seed_skipper;
		}
	}

	if ($opp_seed && not defined $seed_skip) { 
		
		my ($entries_ref, @others) = $m->comp("/tabbing/results/order_entries.mas", round => $test_round, seed_skip => $seed_skipper);

		foreach my $key (sort {$a <=> $b} keys %{$entries_ref}) {
			foreach my $entry (@{${$entries_ref}{$key}}) {
				$opp_entry_seed{$entry} = $key;
			}
		}

	}

	if ($own_seed && not defined $seed_skip) { 

		my ($entries_ref, @others) = $m->comp("/tabbing/results/order_entries.mas", round => $test_round, seed_skip => $seed_skipper);

		foreach my $key (sort {$a <=> $b} keys %{$entries_ref}) {
			foreach my $entry (@{${$entries_ref}{$key}}) {
				$entry_seed{$entry} = $key;
			}
		}
	}

	my $seed_done;
	my $opp_seed_done;
	my $opp_wins_done;

	foreach my $key (sort keys %tb_tiers) { 

		my $tier_desc;
		my $tier_long_desc;

		next if $seed_done && $seed_skip;
		next if $opp_seed_done && $seed_skip;
		next if $opp_wins_done && $opp_wins_only;

		foreach my $tb (sort {$a <=> $b} @{$tb_tiers{$key}}) { 

			my $tb_name = $tb->name;
			
			$tier_dir{$key} = "down" if (
				$tb_name eq "winloss" ||
				$tb_name eq "reciprocals" ||
				$tb_name eq "points" ||
				$tb_name eq "ballots" ||
				$tb_name eq "judgepref" ||
				$tb_name eq "headtohead" ||
				$tb_name eq "opp_points" ||
				$tb_name eq "opp_wins" ||
				$tb_name eq "judgevar" || 
				$tb_name eq "recipinround" ||
				$tb_name eq "judgevar2");

			$tier_dir{$key} = "up" if (
				$tb_name eq "ranks" ||
				$tb_name eq "opp_seed" ||
				$tb_name eq "seed" ||
				$tb_name eq "opp_ranks" ||
				$tb_name eq "chair_ranks" ||
				$tb_name eq "rankinround" ||
				$tb_name eq "coinflip");

			$tier_desc .= "+" if $tier_desc;
			$tier_long_desc .= "+" if $tier_long_desc;

			$tier_desc .= "Rk" if $tb_name eq "ranks";
			$tier_long_desc .= "Ranks" if $tb_name eq "ranks";

			$tier_desc .= "Pts" if $tb_name eq "points";
			$tier_long_desc .= "Team Points" if $tb_name eq "points" && $team_points;
			$tier_long_desc .= "Speaker Points" if $tb_name eq "points" &! $team_points;

			$tier_desc .= "Rcp" if $tb_name eq "reciprocals";
			$tier_long_desc .= "Reciprocals" if $tb_name eq "reciprocals";

			$tier_desc .= "JP" if $tb_name eq "judgepref";
			$tier_long_desc .= "Judge Preferences" if $tb_name eq "judgepref";

			$tier_desc .= "H2H" if $tb_name eq "headtohead";
			$tier_long_desc .= "Head to Head Ballots" if $tb_name eq "headtohead";

			$tier_desc .= "Rand" if $tb_name eq "coinflip";
			$tier_long_desc .= "Random" if $tb_name eq "coinflip";

			$tier_desc .= "ORk" if $tb_name eq "opp_ranks";
			$tier_long_desc .= "Opponents Ranks" if $tb_name eq "opp_ranks";

			$tier_desc .= "CRk" if $tb_name eq "chair_ranks";
			$tier_long_desc .= "Chair Judge Ranks" if $tb_name eq "chair_ranks";

			$tier_desc .= "SRk" if $tb_name eq "rankinround";
			$tier_long_desc .= "Rank within Section" if $tb_name eq "rankinround";
			$tier_long_desc .= "\n(Skipped. This tiebreaker cannot be calculated for a round it includes)" if $warn_rank_in_round;

			$tier_desc .= "SRcp" if $tb_name eq "recipinround";
			$tier_long_desc .= "Reciprocal Rank within Section" if $tb_name eq "recipinround";
			$tier_long_desc .= "\n(Skipped. This tiebreaker cannot be calculated for a round it includes)" if $warn_rank_in_round;

			$tier_desc .= "Win" if $tb_name eq "winloss";
			$tier_long_desc .= "Wins" if $tb_name eq "winloss";

			$tier_desc .= "Sd" if $tb_name eq "seed";
			$tier_long_desc .= "Prelim Seed Position" if $tb_name eq "seed";

			$tier_desc .= "OSd" if $tb_name eq "opp_seed";
			$tier_long_desc .= "Opponent Seed Position" if $tb_name eq "opp_seed";

			$tier_desc .= "OpW" if $tb_name eq "opp_wins";
			$tier_long_desc .= "Opponent Wins" if $tb_name eq "opp_wins";

			$tier_desc .= "OPt" if $tb_name eq "opp_points";
			$tier_long_desc .= "Opponent Points" if $tb_name eq "opp_points";

			$tier_desc .= "Z1" if $tb_name eq "judgevar";
			$tier_long_desc .= "ZScore1: Judge Points Variance" if $tb_name eq "judgevar";

			$tier_desc .= "Z2" if $tb_name eq "judgevar2";
			$tier_long_desc .= "ZScore2: Sample Judge Points Variance" if $tb_name eq "judgevar2";

			$tier_desc .= "Bal" if $tb_name eq "ballots";
			$tier_long_desc .= "Ballot Total" if $tb_name eq "ballots";

			$points++ if $tb_name eq "points";
			$ranks++ if $tb_name eq "ranks";

			$opp_seed++ if $tb_name eq "opp_seed";
			$own_seed++ if $tb_name eq "seed";
			$opp_ranks++ if $tb_name eq "opp_ranks" && not defined $ranks;
			$opp_points++ if $tb_name eq "opp_points" && not defined $points;

			my $tb_highlow = $tb->highlow;

			if ($tb_highlow) {

				$tier_desc .= " -".$tb->highlow_count;
				$tier_long_desc .= " -".$tb->highlow_count;

				$tier_desc .= "HL" if $tb_highlow == 1 || $tb_highlow == 2;
				$tier_long_desc .= " Best & Worst" if $tb_highlow == 1 || $tb_highlow == 2;

				$tier_desc .= "H" if $tb_highlow == 3;
				$tier_long_desc .= " Best" if $tb_highlow == 3;

				$tier_desc .= "L" if $tb_highlow == 4;
				$tier_long_desc .= " Worst" if $tb_highlow == 4;
			}

			$tier_long_desc .= " in ".ucfirst($tb->count) if $tb->count;
			$tier_long_desc .= " Rounds" if $tb->count && ($tb->count eq "all");
			$tier_long_desc .= "s" if $tb->count && ($tb->count eq "prelim" || $tb->count eq "elim");
			$tier_long_desc .= " multplied by ".$tb->multiplier if $tb->multiplier != 1;
			$tier_desc .= " x".$tb->multiplier if $tb->multiplier != 1;

			if ($opp_wins_only) { 
				$tier_desc = "OpW";
				$tier_long_desc = "Opponent Wins";
			}

			$points++ if $opp_points;
			$opp_ranks++ if $opp_ranks;

		}

		$tier_desc = "SOP" if $tier_desc eq "Sd+OSd";
		$tier_desc = "SOP" if $tier_desc eq "OSd+Sd";

		$tier_descs{$key} = $tier_desc;
		$tier_long_descs{$key} = $tier_long_desc;

		my %tb_name;
		my %tb_rounds;
		my %tb_highlow;
		my %tb_highlow_count;
		my %tb_multiplier;

		foreach my $tb (@{$tb_tiers{$key}}) { 

			$tb_name{$tb->id} = $tb->name;
			$tb_highlow{$tb->id} = $tb->highlow;
			$tb_highlow_count{$tb->id} = $tb->highlow_count;
			$tb_multiplier{$tb->id} = $tb->multiplier;

			foreach my $oround (@all_rounds) { 
				push (@{$tb_rounds{$tb->id}}, $oround) if $round_type{$oround} eq $tb->count;
				push (@{$tb_rounds{$tb->id}}, $oround) if $tb->count eq "all";
				push (@{$tb_rounds{$tb->id}}, $oround) if ($round_type{$oround} eq "elim" || $round_type{$oround} eq "final") && ($tb->count eq "last elim" || $tb->count eq "last_elim") && $round_name{$oround} == $round->name;
			}

		}

		ENTRY:
		foreach my $entry (@entries) { 

			my %seen = (); 
			@{$entry_panels{$entry}} = grep { ! $seen{$_} ++ } @{$entry_panels{$entry}};

			my $tier_total;

			foreach my $tb (@{$tbid_tiers{$key}}) { 

				my $name = $tb_name{$tb};
				next unless $tb_rounds{$tb};
				my @rounds = @{$tb_rounds{$tb}};

				my $tb_highlow = $tb_highlow{$tb};
				my $tb_highlow_count = $tb_highlow_count{$tb};

				if ($opp_wins_only) { 
					$name = "opp_wins";
					$opp_wins_done++;
					undef @rounds;
					undef $tb_highlow;

					foreach my $oround (@all_rounds) { 
						push (@rounds, $oround) if $round_type{$oround} ne "elim" && $round_type{$oround} ne "final";
					}
				}

				my $total; 

				if ($name eq "winloss") { 

					$total += sprintf("%d", 100 * $entry_wins{$entry}) unless $skip_wins;

				# RANK RANKS RANKINGS
				} elsif ($name eq "ranks" || $name eq "reciprocals" || $name eq "chair_ranks") { 

					my @drop_best;
					my @drop_worst;

					my $count;
					my $bye;

					foreach my $this_round (@rounds) { 

						$bye += $max_score_count{"rank"} if $entry_round_panel_bye{$this_round."-".$entry};

						$bye += $max_score_count{"rank"} if $entry_round_bye{$this_round."-".$entry} && not defined $entry_round_scores{$entry."-".$this_round};
						$bye += $max_score_count{"rank"} if $entry_round_fft{$this_round."-".$entry} && not defined $entry_round_scores{$entry."-".$this_round};


						next if $entry_round_panel_bye{$this_round."-".$entry};
						next if $entry_round_bye{$this_round."-".$entry} && not defined $entry_round_scores{$entry."-".$this_round};
						next if $entry_round_fft{$this_round."-".$entry} && not defined $entry_round_scores{$entry."-".$this_round};

						my %used_scores;
						my $round_count;
						my $round_score;

						foreach my $score (@{$entry_round_scores{$entry."-".$this_round}}) { 

							if ($score_tag{$score} eq "rank") { 

								next if $name eq "chair_ranks" && $score_chair{$score} < 1;
								next if $used_scores{$score}++;

								$round_count++;
							
								my $rank = $score_value{$score};
						
								if ($dq_panel_threshold{$score_panel{$score}."-".$score_judge{$score}}) { 
									$rank-- if $dq_panel_threshold{$score_panel{$score}."-".$score_judge{$score}} < $rank;
								}

								# Bump the rank up if it's a time violation.
								# Truncation below will correct if this makes
								# it bigger (ie if the TV was last place);

								$rank++ if $score_tv{$score} && $mfl_time_violation;

								if (
									($round_type{$this_round} eq "prelim" && defined $truncate_prelims)  ||
									($round_type{$this_round} eq "final" && defined $truncate_finals) ||
									($round_type{$this_round} eq "elim" && defined $truncate_elims) ) { 

									# Promote anyone over the hard cap for truncation
									$rank = $truncate if $truncate && $rank > $truncate;

									# Promote anyone over the per-round floating cap for truncation
									$rank = $round_truncate{$this_round} if $truncate_to_smallest && $rank > $round_truncate{$this_round};
								
								}

								#Rank cannot be greater than the size of the round
								$rank = scalar @{$panel_entries{$score_panel{$score}}} 
									if $rank > scalar @{$panel_entries{$score_panel{$score}}} 
										&& ($event_type eq "speech" || $event_type eq "congress");

								$round_score += sprintf("%d", 100 * $rank) if $name eq "ranks" || $name eq "chair_ranks";
								$total += sprintf("%d", 100 * ( 1 / $rank )) if $rank && $name eq "reciprocals";
								$count++ if $name eq "ranks";

								if ($tb_highlow) {  

									#drop the best

									if ($tb_highlow == 1 || $tb_highlow == 2 || $tb_highlow == 3) {

										if (scalar @drop_best < $tb_highlow_count) {
											push @drop_best, $rank;
										} else {
											my $least_best = pop @drop_best;
											push @drop_best, $least_best if $least_best <= $rank;
											push @drop_best, $rank if $least_best > $rank;
										}

										@drop_best = sort {$b <=> $a} @drop_best;
									}

									#drop the worst

									if ($tb_highlow == 1 || $tb_highlow == 2 || $tb_highlow == 4) {

										if (scalar @drop_worst < $tb_highlow_count) {
											push @drop_worst, $rank;
										} else {
											my $least_worst = pop @drop_worst;
											push @drop_worst, $least_worst if $least_worst >= $rank;
											push @drop_worst, $rank if $least_worst < $rank;
										}

										@drop_worst = sort {$a <=> $b} @drop_worst;
									}
								}
							}
						}

						if ($name eq "ranks" || $name eq "chair_ranks") {
							if ($maverick_method eq "double") { 
								if ($round_count && $round_count < $max_score_count{"rank"}) {
									$round_score = $round_score * $max_score_count{"rank"} / $round_count;
									$count +=  ($max_score_count{"rank"} / $round_count) - 1;
								}
							}

							if ($maverick_method eq "average") { 
								if ($round_count && $round_count < $max_score_count{"rank"}) {
									$round_score += 4;
									$count +=  ($max_score_count{"rank"} / $round_count) - 1;
								}
							}
						}

						$total += sprintf("%d", $round_score) if $name eq "ranks" || $name eq "chair_ranks";

					}

					$bye = $bye - ($bye_min * $max_score_count{"rank"}) if $round_robin;

					my $average;

					if ($bye) { 
						$average = $total / $count if $count;
						$total += sprintf("%d", ($average * $bye));
					}

                    foreach my $rank (@drop_best, @drop_worst) {
                        $total -= sprintf("%d", 100 * $rank) if $name eq "ranks" || $name eq "chair_ranks";
                        $total -= sprintf("%d", 100 * (1 / $rank)) if $rank && $name eq "reciprocals";
						$count-- if $name eq "ranks";
						$total = 0 if $total < 0;
                    }

					$entry_ranks{$entry} = $total / $count if $count;
	
				# SPEAKS SPEAKER POINTS
				} elsif ($name eq "points") { 

					my $bye;
					my $count;
					my $averages;
					my $num_rounds;

					my @drop_best;
					my @drop_worst;
					my %points_have_bye;

					foreach my $this_round (@rounds) { 

						$num_rounds++;

						$bye += $max_score_count{"points"}  if $entry_round_panel_bye{$this_round."-".$entry};
						
						next if $entry_round_panel_bye{$this_round."-".$entry};

						my $round_count;
						my $round_score;
						my %judge_points;

						foreach my $score (@{$entry_round_scores{$entry."-".$this_round}}) { 

							if ($score_tag{$score} eq "points" || $score_tag{$score} eq "rebuttal_points") { 

								my $points = sprintf("%d", 100 * $score_value{$score});
						
								if ($score_tag{$score} eq "points") {		
									# Do not count WSDC rebuttals in jvar or mavericks.
									$count++;
									$round_count++;
									$judge_points{$this_round."-".$score_judge{$score}} += sprintf("%d", 100 *$score_value{$score});
								}

								$round_score += $points;
							}

						}

						my $average_round_count;

						unless ($team_points) {

							if ($maverick_method eq "double") { 

								if ($round_count && $round_count < $max_score_count{"points"}) {
									$count +=  ($max_score_count{"points"} / $round_count) - 1;
									$round_score = $round_score * $max_score_count{"points"} / $round_count;
								}

							} elsif ($maverick_method eq "average") { 

								if ($round_count && $round_count < $max_score_count{"points"}) {
									$average_round_count++;
									$count +=  ($max_score_count{"points"} / $round_count) - 1;
									$averages += ($max_score_count{"points"} / $round_count) - 1;
								}
							}
						}

						if ($round_count) { 

							unless ($round_score) { 
								$bye += $round_count if $entry_round_bye{$this_round."-".$entry};
								$bye += $round_count if $entry_round_fft{$this_round."-".$entry};
							}

						} elsif ($event->type ne "speech" && $event->type ne "congress") { 

							unless ($round_score) { 
								$bye += $max_score_count{"points"} if $entry_round_bye{$this_round."-".$entry};
								$bye += $max_score_count{"points"} if $entry_round_fft{$this_round."-".$entry};
							}

							unless ($bye) { 
								$average_round_count += $max_score_count{"points"};
								$count += $max_score_count{"points"};
								$averages += $max_score_count{"points"};
							}

						}

						# This judgekey thing deals with multi judge prelims

						foreach my $judgekey (keys %judge_points) { 
							
							my $points = $judge_points{$judgekey};

							if ($tb_highlow) { 			

								if ($tb_highlow == 1 || $tb_highlow == 2 || $tb_highlow == 3) {

									if (scalar @drop_best < $tb_highlow_count) {
										push @drop_best, $points;
									} else {
										my $least_best = shift @drop_best;
										push @drop_best, $least_best if $least_best >= $points;
										push @drop_best, $points if $least_best < $points;
									}

									@drop_best = sort {$a <=> $b} @drop_best;
								}

								#drop the worst

								if ($tb_highlow == 1 || $tb_highlow == 2 || $tb_highlow == 4) {

									if (scalar @drop_worst < $tb_highlow_count) {
										push @drop_worst, $points;
									} else {
										my $least_worst = shift @drop_worst;
										push @drop_worst, $least_worst if $least_worst <= $points;
										push @drop_worst, $points if $least_worst > $points;
									}

									@drop_worst = sort {$b <=> $a} @drop_worst;
								}
							}
						}

						$total += $round_score;
						next if $bye && not defined $round_score;
						$points_have_bye{$round_score} = $average_round_count;

					}

					$bye = $bye - ($bye_min * $max_score_count{"points"}) if $round_robin;

					my $average;

					if ($bye) { 
						$average = $total / $count if $count;
						$total += sprintf("%d", $average * $bye);
						$count += $bye;
					}

					if ($averages) { 
						$average = $total / ($count - $averages) if $count && ($count - $averages) > 0;
						$total += sprintf("%d", $average * $averages);
						$count += $averages;
					}

					my $how_many  = $count / (scalar @rounds) if scalar @rounds;

					if ($tb_highlow) { 
						if ($tb_highlow == 1 || $tb_highlow == 2) { 
							$how_many -= 2 * $tb_highlow_count;
						} else { 
							$how_many -= $tb_highlow_count;
						}
					}

                    foreach my $points (@drop_best, @drop_worst) {
					
						next unless $tb_highlow;
                        $total -= sprintf("%d", $points);
						$total -= sprintf("%d", $average * $points_have_bye{$points});
						$total = 0 if $total < 0;
						$count--;
                    }

					$total = sprintf("%d", $total / $how_many) if $team_points && $how_many;

					Tab::debuglog("How many is $how_many for a total of $total for highlow $tb_highlow") if $entry == 1033262;

					$entry_points{$entry} += ($total / $count) if $count; #used for opp wins and opp points.

				# BALLOT COUNT BALLOTS
				} elsif ( $name eq "ballots") { 

					my $bye;

					foreach my $this_round (@rounds) { 

						foreach my $score (@{$entry_round_scores{$entry."-".$this_round}}) { 
							if ($score_tag{$score} eq "ballot") { 
								$total += 100 if $score_value{$score} == 1;
							}
						}
			
						if ($entry_round_bye{$this_round."-".$entry} || $entry_round_panel_bye{$this_round."-".$entry}) {
							$bye++;
						}

					}

					$bye = $bye - $bye_min if $round_robin;

					if ($bye) { 
						$total += sprintf("%d", 100 * $max_score_count{"ballot"} * $bye);
					}
					
				# COINFLIP RANDOM
				} elsif ( $name eq "coinflip") { 

					# This is only semi random; product of the date epoch and
					# the random entry ID's last four digits.  But it will be
					# the same every time this function is run and random
					# enough in that it cannot be pre-guessed easily.

					my $random_seed = $entry * $seed;
					$total = substr($random_seed, -8, -5);

				#JUDGEPREF
				} elsif ( $name eq "judgepref") { 

					my $chosen_panel;
					my @chosen_entries;

					foreach my $this_round (@rounds) { 

						PANEL:
						foreach my $panel (@{$round_panels{$this_round}}) {    #Only counts in the current round;
							my @entries = @{$panel_entries{$panel}};
							next PANEL unless grep {$_ == $entry} @entries;
							$chosen_panel = $panel;
							@chosen_entries = @entries;
						} 

						my %beseen = (); 
						@chosen_entries = grep { ! $beseen{$_} ++ } @chosen_entries;

						my $entry_string;

						foreach my $okey (sort keys %tb_tiers) { 
							next if $key == $okey;
							$entry_string .= "-" if $entry_string;
							$entry_string .= $entry_tbs{$entry."-".$okey};
						}

						my @ties;

						foreach my $oentry (@chosen_entries) { 
							next if $oentry == $entry;
							my $test_string;
							foreach my $okey (sort keys %tb_tiers) { 
								next if $key == $okey;
								$test_string .= "-" if $test_string;
								$test_string .= $entry_tbs{$oentry."-".$okey};
							}
							push(@ties, $oentry) if $test_string eq $entry_string;
						}

						if (scalar @ties == 1) { 

							my $tie_id = shift @ties;

							my %judge_score = ();

							if ($chosen_panel && $entry) { 

								my %done;
								foreach my $score (@{$entry_scores{$entry}}) { 
									next if $done{$score}++;
									next unless $score_tag{$score} eq "rank";
									next unless $score_panel{$score} == $chosen_panel;
									$judge_score{$score_judge{$score}} = $score_value{$score};
								}

								foreach my $tie_score (@{$entry_scores{$tie_id}}) {
									next if $done{$tie_score}++;
									next unless $score_tag{$tie_score} eq "rank";
									next unless $score_panel{$tie_score} == $chosen_panel;
									$total += 100 if $score_value{$tie_score} > $judge_score{$score_judge{$tie_score}}; 
									#If my rank is better (lower) than the tie's rank, I get a JP point
								}
							}
						}
					}

				} elsif ( $name eq "headtohead") { 

					my $chosen_panel;
					my @chosen_entries;

					foreach my $this_round (@rounds) { 

						PANEL:
						foreach my $panel (@{$round_panels{$this_round}}) {    #Only counts in the current round;
							my @entries = @{$panel_entries{$panel}};
							next PANEL unless grep {$_ == $entry} @entries;
							$chosen_panel = $panel;
							@chosen_entries = @entries;
						} 

						my %beseen = (); 
						@chosen_entries = grep { ! $beseen{$_} ++ } @chosen_entries;

						my $entry_string;

						foreach my $okey (sort keys %tb_tiers) { 
							next if $key == $okey;
							$entry_string .= "-" if $entry_string;
							$entry_string .= $entry_tbs{$entry."-".$okey};
						}

						my @ties;

						foreach my $oentry (@chosen_entries) { 
							next if $oentry == $entry;
							my $test_string;
							foreach my $okey (sort keys %tb_tiers) { 
								next if $key == $okey;
								$test_string .= "-" if $test_string;
								$test_string .= $entry_tbs{$oentry."-".$okey};
							}
							push(@ties, $oentry) if $test_string eq $entry_string;
						}

						if (scalar @ties == 1) { 

							my $tie_id = shift @ties;
							my %panel_ballots = ();

							if ($chosen_panel && $entry) { 

								my %done;
								foreach my $score (@{$entry_scores{$entry}}) { 
									next if $done{$score}++;
									next unless $score_tag{$score} eq "ballot";
									next unless $score_panel{$score} == $chosen_panel;
									$panel_ballots{$chosen_panel} += $score_value{$score};
									$total += 100 if $score_value{$score} > 0;
								}
							}
						}
					}

				} elsif ( $name eq "rankinround") { 

					foreach my $this_round (@rounds) { 
						$total += sprintf("%d", 100 * $entry_rankinround{$entry."-".$this_round});
					}

				} elsif ( $name eq "recipinround") { 

					foreach my $this_round (@rounds) { 
						$total += sprintf("%d", 100 * $entry_recipinround{$entry."-".$this_round});
					}

				} elsif ( $name eq "opp_wins") { 

					my $count;
					my $sub_total;

					foreach my $panel (@{$entry_panels{$entry}}) { 

						next if $panel_roundname{$panel} > $this_round_name;

						foreach my $other (@{$panel_entries{$panel}}) { 
							next if $other == $entry;
							$sub_total += $entry_wins{$other};
							$count++;
						}
					}

					$total += sprintf "%.2d", 100 * $sub_total/$count if $count;

				} elsif ( $name eq "opp_points") { 

					my $count;
					my $sub_total;

					foreach my $panel (@{$entry_panels{$entry}}) { 

						next if $panel_roundname{$panel} > $this_round_name;

						foreach my $other (@{$panel_entries{$panel}}) { 
							next if $other == $entry;

							$sub_total += $entry_points{$other};
							$count++;
						}
					}

					$total += sprintf "%d", $sub_total / $count if $count;

				} elsif ( $name eq "opp_ranks") { 

					my $count;
					my $sub_total;

					foreach my $panel (@{$entry_panels{$entry}}) { 

						next if $panel_roundname{$panel} > $this_round_name;

						foreach my $other (@{$panel_entries{$panel}}) { 
							next if $other == $entry;
							$sub_total += $entry_ranks{$other};
							$count++;
						}
					}

					$total += sprintf "%d", $sub_total / $count if $count;

				} elsif ( $name eq "seed") { 

					$seed_done++;
					$total += sprintf "%d", 100 * $entry_seed{$entry};

				} elsif ( $name eq "opp_seed") { 

					$opp_seed_done++;
					my $count;
					my $sub_total;

					foreach my $panel (@{$entry_panels{$entry}}) { 

						next if $panel_roundname{$panel} > $this_round_name;

						foreach my $other (@{$panel_entries{$panel}}) { 
							next if $other == $entry;
							$sub_total += $opp_entry_seed{$other};
							$count++;
						}
					}

					$total += sprintf "%d", 100 * $sub_total / $count if $count;

				} elsif ( $name eq "judgevar") { 

					my $sub_total;
					my $sub_count;
					my $sub_byes;

					foreach my $this_round (@rounds) { 

						my $round_done;

						foreach my $score (@{$entry_round_scores{$entry."-".$this_round}}) { 
							next unless $score_tag{$score} eq "points";   #No rebuttal points here either
							my $judge_avg  = ${$judge_avg_ref}{$score_judge{$score}};
							my $judge_stddev  = ${$judge_stddev_ref}{$score_judge{$score}};
							next unless $judge_stddev > 0;
							$sub_total += ( (  ($score_value{$score} - $judge_avg) / $judge_stddev) * $total_std) + $total_avg;
							$sub_count++;
							$round_done++;
						}

						$sub_byes++ unless $round_done;
					}

					my $average = ($sub_total / $sub_count) if $sub_count;
					$total += sprintf "%d", 100 * $average * $sub_byes if $sub_byes;
					$total += sprintf "%d", 100 * $sub_total;

				} elsif ($name eq "judgevar2") { 

					my $sub_total;
					my $sub_count;
					my $sub_byes;

					foreach my $this_round (@rounds) { 

						my $round_done;

						foreach my $score (@{$entry_round_scores{$entry."-".$this_round}}) { 
							next unless $score_tag{$score} eq "points";

                            my $judge_avg  = ${$judge_avg_ref}{$score_judge{$score}};
                            my $judge_stddev  = ${$judge_stddev_ref}{$score_judge{$score}};

                            # These sample only the schools/stddevs for the
                            # debaters the judge has judged, not all debaters.

                            my $judge_sample_avg  = ${$judge_z2_avg_ref}{$score_judge{$score}};
                            my $judge_sample_stddev  = ${$judge_z2_stddev_ref}{$score_judge{$score}};

                            next unless $judge_stddev > 0; 

                            $sub_total += ( (  ($score_value{$score} - $judge_avg) / $judge_stddev) * $judge_sample_stddev) + $judge_sample_avg;
							$sub_count++;
							$round_done++;
						}

						$sub_byes++ unless $round_done;
					}

					my $average = ($sub_total / $sub_count) if $sub_count;
					$total += sprintf "%d", 100 * $average * $sub_byes if $sub_byes;
					$total += sprintf "%d", 100 * $sub_total;

				}

				$tier_total += $total * $tb_multiplier{$tb} if $tb_multiplier{$tb};

			}

			$entry_tbs{$entry."-".$key} = $tier_total;

		}

	}

	if ($opp_points || $opp_ranks) { 
		
		my $err;
		$err .= "Danger Will Robinson!<br />You have defined Opp Points as a tiebreaker without first defining Points.  That cannot work both technically and philosophically.  Fix please! <br /><br />" if $opp_points;
		$err .= "Danger Will Robinson!<br />You have defined Opp Ranks as a tiebreaker without first defining Ranks.  That cannot work both technically and philosophically.  Fix please!" if $opp_ranks;
		$m->redirect("/setup/rules/tiebreaks.mhtml?tb_set_id=".$tb_set->id."&err=$err");

	}

	foreach my $key (reverse sort {$a <=> $b} keys %tb_tiers) { 

		@entries = sort { $entry_tbs{$a."-".$key} <=> $entry_tbs{$b."-".$key} } @entries if $tier_dir{$key} eq "up";
		@entries = sort { $entry_tbs{$b."-".$key} <=> $entry_tbs{$a."-".$key} } @entries if $tier_dir{$key} eq "down";

	}

	my %panel_rank = ();
	my %entry_letter = ();

	if ($equal_elims) { 

		foreach my $panel (@{$round_panels{$round->id}}) { 

			my @pan_entries = @{$panel_entries{$panel}};

			foreach my $key (reverse sort keys %tb_tiers) { 
				@pan_entries = sort { $entry_tbs{$a."-".$key} <=> $entry_tbs{$b."-".$key}  } @pan_entries if $tier_dir{$key} eq "up";
				@pan_entries = sort { $entry_tbs{$b."-".$key} <=> $entry_tbs{$a."-".$key} } @pan_entries if $tier_dir{$key} eq "down";
			}

			my $count = 1;

			my %already; 

			foreach my $pe (@pan_entries) { 
				next if $already{$pe};
				next if $entry_dq{$pe};
				$already{$pe}++;
				$panel_rank{$pe} = $count++;
				$entry_letter{$pe} = $panel_letter{$panel};
			}
		}
	
		@entries = sort { $entry_letter{$a} cmp $entry_letter{$b} } @entries;
		@entries = sort { length($entry_letter{$a}) <=> length($entry_letter{$b}) } @entries;
		@entries = sort { $panel_rank{$a} <=> $panel_rank{$b} } @entries;

	} elsif ($round_robin) { 

		foreach my $seed (keys %pods) { 

			my @pod_entries = @{$pods{$seed}};

			foreach my $key (reverse sort {$a <=> $b} keys %tb_tiers) { 
				@pod_entries = sort { $entry_tbs{$a."-".$key} <=> $entry_tbs{$b."-".$key}  } @pod_entries if $tier_dir{$key} eq "up";
				@pod_entries = sort { $entry_tbs{$b."-".$key} <=> $entry_tbs{$a."-".$key} } @pod_entries if $tier_dir{$key} eq "down";
			}

			my $count = 1;

			my %already; 

			foreach my $pe (@pod_entries) { 
				next if $already{$pe};
				next if $entry_dq{$pe};
				$already{$pe}++;
				$panel_rank{$pe} = $count++;
				$entry_letter{$pe} = $seed;
			}
		}
	
		@entries = sort { $entry_letter{$a} cmp $entry_letter{$b} } @entries;
		@entries = sort { length($entry_letter{$a}) <=> length($entry_letter{$b}) } @entries;
		@entries = sort { $panel_rank{$a} <=> $panel_rank{$b} } @entries;

	} else { 

		foreach my $panel (@{$round_panels{$round->id}}) { 
			foreach my $pe (@{$panel_entries{$panel}}) { 
				$entry_letter{$pe} = $panel_letter{$panel};
			}
		}
	}

	@entries = sort { $entry_forfeit{$a} <=> $entry_forfeit{$b} } @entries if $forfeits_never_break;

	my $count;
	my %entry_by_place = ();
	
	my $last_string;
	my $delayed_count;

	foreach my $entry (@entries) { 

		next if $entry_dq{$entry};
		next if $breakout && not defined $eligible{$entry};

		my $tier_string;

		foreach my $key (sort {$a <=> $b} keys %tb_tiers) { 

			$entry_tbs{$entry."-".$key} = $entry_tbs{$entry."-".$key} / 100;

			$tier_string .= "-" if $tier_string;
			$tier_string .= $entry_tbs{$entry."-".$key};
		}

		if ($tier_string eq $last_string) { 
			$delayed_count++;
		} else {
			$count++;
			$count += $delayed_count;
			undef $delayed_count;
		}

		$last_string = $tier_string;
		push (@{$entry_by_place{$count}}, $entry);
		@{$entry_by_place{$count}} = sort @{$entry_by_place{$count}};

	}

	return (\%entry_by_place, \%entry_tbs, \%tier_descs, \%entry_forfeit, \%tier_dir, \%panel_rank, \%entry_letter, \%tier_long_descs, \%entry_code, \%entry_bye);

</%init>
