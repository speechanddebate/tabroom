<%args>
	$round
</%args>
<%init>

	return unless $round;

	my $event = $round->event;
	my $tourn = $event->tourn;

	#Settings
	my $noshows_never_break = $tourn->setting("noshows_never_break");

	my $tb_set_id = $round->event->setting("speaker_tbset");
	my $tb_set = Tab::TiebreakSet->retrieve($tb_set_id);

	unless ($tb_set) {  
		my $err = "That event does not have a speaker points tiebreaker set applied to it.  Please pick one and try again";
		$m->redirect("/setup/schedule/event.mhtml?event_id=".$round->event->id."&err=$err");
	}

	my %students_by_entry = (); 

	my @panels;
	my @ballots;
	my @entries;
	my @students;
	my @values;
	my @judges;

	my %used = (); 
	my $all;
	my $elim;

	my %tb_tiers = ();

	foreach my $tb ($tb_set->tiebreaks) { 
		$used{$tb->count}++;
		$all++ if $tb->count eq "all";
		$elim++ if $tb->count eq "elim";
		push @{$tb_tiers{$tb->priority}}, $tb;

		if ($tb->count eq "prelim") { 
			$used{"highhigh"}++;
			$used{"highlow"}++;
			$used{"preset"}++;
		}
	}   

	# Get the data you'll need for Teh Sortingz.

	if ($all) { 

		Tab::Ballot->set_sql( get_all => "
			select distinct ballot.*
			from ballot, panel, round
			where ballot.panel = panel.id
			and panel.round = round.id
			and round.name <= ?
			and round.event = ?
		");

		@ballots = Tab::Ballot->search_get_all( $round->name, $event->id );

		Tab::Panel->set_sql( get_all => "
			select distinct panel.*
			from panel, round
			where panel.round = round.id
			and round.name <= ?
			and round.event = ?
		");

		@panels = Tab::Panel->search_get_all( $round->name, $event->id );

		Tab::Entry->set_sql( get_all => "
			select distinct entry.*
			from ballot, panel, round, entry
			where entry.id = ballot.entry
			and entry.dropped = 0
			and entry.unconfirmed = 0
			and entry.waitlist = 0
			and ballot.panel = panel.id
			and panel.round = round.id
			and round.name <= ?
			and round.event = ?
		");

		@entries = Tab::Entry->search_get_all( $round->name, $event->id );

		# Get the data you'll need for Teh Sortingz.
		Tab::Student->set_sql( get_all_event => "
			select distinct student.* 
			from student, entry, entry_student, ballot, panel, round
			where entry.event = ? 
			and entry.id = entry_student.entry
			and entry_student.student = student.id
			and entry.dropped = 0
			and entry.unconfirmed = 0
			and entry.waitlist = 0
			and ballot.entry = entry.id
			and ballot.panel = panel.id
			and panel.round = round.id
			and round.name <= ?
			order by entry.dropped, student.last
		");

		my @all_students = Tab::Student->search_get_all_event($round->event->id, $round->name);
		my %students_by_id = map {$_->id => $_} @all_students;

		Tab::EntryStudent->set_sql( get_all_event => "
			select distinct entry_student.*
			from entry, entry_student, ballot, panel, round
			where entry.id = entry_student.entry
			and entry.event = ? 
			and entry.dropped = 0
			and entry.unconfirmed = 0
			and entry.waitlist = 0
			and ballot.entry = entry.id
			and ballot.panel = panel.id
			and panel.round = round.id
			and round.name <= ?
		");

		my @all_es = Tab::EntryStudent->search_get_all_event($round->event->id, $round->name);

		foreach my $es (@all_es) { 
			push (@{$students_by_entry{$es->entry->id}}, $students_by_id{$es->student->id});
		}   

		Tab::BallotValue->set_sql( get_all => "
			select distinct ballot_value.*
			from ballot, panel, round, ballot_value
			where ballot_value.ballot = ballot.id
			and ballot.panel = panel.id
			and panel.round = round.id
			and round.name <= ?
			and round.event = ?
			order by ballot.entry
		");

		@values = Tab::BallotValue->search_get_all( $round->name, $event->id );

		Tab::Judge->set_sql( get_all => "
			select distinct judge.*
			from ballot, panel, round, judge
			where judge.id = ballot.judge
			and ballot.panel = panel.id
			and panel.round = round.id
			and round.name <= ?
			and round.event = ?
		");

		@judges = Tab::Judge->search_get_all( $round->name, $event->id );

	} else { 

		foreach my $key (keys %used) { 

			if ($key eq "last elim" || $key eq "last_elim") { 

				push @ballots, $m->comp('/funclib/round_ballots.mas', round => $round);
				push @panels, $round->panels;
				push @entries, $m->comp('/funclib/round_entries.mas', round => $round);
				push @students, $m->comp('/funclib/round_students.mas', round => $round);
				push @judges, $m->comp('/funclib/round_judges.mas', round => $round);
				push @values, $m->comp('/funclib/round_values.mas', round => $round);

				my %students_by_id = map {$_->id => $_} @students;

				Tab::EntryStudent->set_sql( get_all_event => "
					select distinct entry_student.*
					from entry, entry_student, ballot, panel
					where entry.id = entry_student.entry
					and entry.event = ? 
					and entry.dropped = 0
					and entry.unconfirmed = 0
					and entry.waitlist = 0
					and ballot.entry = entry.id
					and ballot.panel = panel.id
					and panel.round = ?
				");

				my @all_es = Tab::EntryStudent->search_get_all_event($round->event->id);

				foreach my $es (@all_es) { 
					push (@{$students_by_entry{$es->entry->id}}, $students_by_id{$es->student->id});
				}   

			} else {

				Tab::Ballot->set_sql( get_all => "
					select distinct ballot.*
					from ballot, panel, round
					where ballot.panel = panel.id
					and panel.round = round.id
					and round.name <= ?
					and round.type = ?
					and round.event = ?
				");

				push (@ballots,Tab::Ballot->search_get_all( $round->name, $key, $event->id ));

				Tab::Panel->set_sql( get_all => "
					select distinct panel.*
					from panel, round
					where panel.round = round.id
					and round.name <= ?
					and round.type = ?
					and round.event = ?
				");

				push (@panels, Tab::Panel->search_get_all( $round->name, $key, $event->id ));

				Tab::Entry->set_sql( get_all => "
					select distinct entry.*
					from ballot, panel, round, entry
					where entry.id = ballot.entry
					and entry.dropped = 0
					and entry.unconfirmed = 0
					and entry.waitlist = 0
					and ballot.panel = panel.id
					and panel.round = round.id
					and round.name <= ?
					and round.type = ?
					and round.event = ?
				");

				push (@entries, Tab::Entry->search_get_all( $round->name, $key, $event->id ));

				Tab::Student->set_sql( get_all => "
					select distinct student.*
					from ballot, panel, round, entry, entry_student, student
					where entry.id = ballot.entry
					and entry.dropped = 0
					and entry.unconfirmed = 0
					and entry.waitlist = 0
					and entry.id = entry_student.entry
					and entry_student.student = student.id
					and ballot.panel = panel.id
					and panel.round = round.id
					and round.name <= ?
					and round.type = ?
					and round.event = ?
				");

				push (@students, Tab::Student->search_get_all( $round->name, $key, $event->id ));

				my %students_by_id = map {$_->id => $_} @students;

				Tab::EntryStudent->set_sql( get_all_event => "
					select distinct entry_student.*
					from entry, entry_student, ballot, panel, round
					where entry.id = entry_student.entry
					and entry.dropped = 0
					and entry.unconfirmed = 0
					and entry.waitlist = 0
					and ballot.entry = entry.id
					and ballot.panel = panel.id
					and panel.round = round.id
					and round.name <= ?
					and round.type = ?
					and round.event = ?
				");

				my @all_es = Tab::EntryStudent->search_get_all_event($round->name, $key, $event->id);

				foreach my $es (@all_es) { 
					push (@{$students_by_entry{$es->entry->id}}, $students_by_id{$es->student->id});
				}   

				Tab::BallotValue->set_sql( get_all => "
					select distinct ballot_value.*
					from ballot, panel, round, ballot_value
					where ballot_value.ballot = ballot.id
					and ballot.panel = panel.id
					and panel.round = round.id
					and round.name <= ?
					and round.type = ?
					and round.event = ?
				");

				push (@values, Tab::BallotValue->search_get_all( $round->name, $key, $event->id ));

				Tab::Judge->set_sql( get_all => "
					select distinct judge.*
					from ballot, panel, round, judge
					where judge.id = ballot.judge
					and ballot.panel = panel.id
					and panel.round = round.id
					and round.name <= ?
					and round.type = ?
					and round.event = ?
				");

				push (@judges, Tab::Judge->search_get_all( $round->name, $key, $event->id ));

			}
		}
	}

	my %judge_variances = $m->comp("/funclib/judge_points_average.mas", event => $event);
	my %entry_wins = $m->comp("/funclib/entry_wins.mas", event => $event);

	#Dedupe
	my %jseen = (); 
	@judges = grep { ! $jseen{$_->id} ++ } @judges;

	my %bseen = (); 
	@ballots = grep { ! $bseen{$_->id} ++ } @ballots;

	my %pseen = (); 
	@panels = grep { ! $pseen{$_->id} ++ } @panels;

	my %vseen = (); 
	@values = grep { ! $vseen{$_->id} ++ } @values;

	my %sseen = (); 
	@students = grep { ! $sseen{$_->id} ++ } @students;

	my @all_rounds;
	my %round_by_id = ();

	foreach my $oround ($event->rounds) { 
		next if $oround->name > $round->name;  # Do not measure the future
		$round_by_id{$oround->id} = $oround;
		push (@all_rounds, $oround);
	}

	@all_rounds = sort {$b->name <=> $a->name} @all_rounds;

	my %values_by_ballot = ();
	foreach my $value (@values) { 
		push @{$values_by_ballot{$value->ballot->id}}, $value;
	}

	my %judge_by_id = ();
	foreach my $judge (@judges) { 
		$judge_by_id{$judge->id} = $judge;
	}

	my %panels_by_round = ();
	my %panel_by_id = ();
	my %round_panel = ();

	foreach my $panel (@panels) { 
		push @{$panels_by_round{$panel->round->id}}, $panel->id;
		$panel_by_id{$panel->id} = $panel;
		$round_panel{$panel->id} = $panel->round->name;
	}

	my %ballots_by_panel = ();
	my %ballots_by_entry = ();
	my %ballots_by_judge = ();
	my %ballots_by_entry_panel = ();
	my %ballots_by_judge_panel = ();
	my %entry_ids_by_panel = ();
	my %judge_ids_by_panel = ();
	my %last_round = ();
	my %noshows = ();

	my %panel_ids_by_entry = ();

	foreach my $ballot (@ballots) { 
		next unless $ballot->entry;
		push @{$ballots_by_panel{$ballot->panel->id}}, $ballot;
		push @{$ballots_by_entry{$ballot->entry->id}}, $ballot;
		push @{$ballots_by_entry_panel{$ballot->entry->id."-".$ballot->panel->id}}, $ballot;
		push @{$ballots_by_judge_panel{$ballot->judge->id."-".$ballot->panel->id}}, $ballot;
		push @{$entry_ids_by_panel{$ballot->panel->id}}, $ballot->entry->id;
		push @{$judge_ids_by_panel{$ballot->panel->id}}, $ballot->judge->id;
		push @{$panel_ids_by_entry{$ballot->entry->id}}, $ballot->panel->id;
		$last_round{$ballot->entry->id} = $round_panel{$ballot->panel->id} if $last_round{$ballot->entry->id} < $round_panel{$ballot->panel->id};
	}

	if ($round && ($round->type eq "elim" || $round->type eq "final")) { 
		my @counted;
		foreach my $entry (@entries) { 
			next if $last_round{$entry->id} < $round->name;
			push (@counted, $entry);
		}
		@entries = @counted;
	}

	my %eseen = (); 
	@entries = grep { ! $eseen{$_->id} ++ } @entries;

	my %student_tbs = ();
	my %tier_descs = ();
	my %tier_dir = ();

	foreach my $key (sort keys %tb_tiers) { 

		my $tier_desc;

		foreach my $tb (sort {$a <=> $b} @{$tb_tiers{$key}}) { 

			$tier_dir{$key} = "down" if $tb->name eq "reciprocals" || $tb->name eq "judgepref" || $tb->name eq "points" || $tb->name eq "winloss" || $tb->name eq "opp_wins" || $tb->name eq "opp_points" || $tb->name eq "judgevar" || $tb->name eq "ballots";
			$tier_dir{$key} = "up" if $tb->name eq "ranks" || $tb->name eq "coinflip" || $tb->name eq "competition" || $tb->name eq "rankinround";
			
			$tier_desc .= "+"   if $tier_desc;
			$tier_desc .= "Rks" if $tb->name eq "ranks";
			$tier_desc .= "Pts" if $tb->name eq "points";
			$tier_desc .= "Rcp" if $tb->name eq "reciprocals";
			$tier_desc .= "JPr" if $tb->name eq "judgepref";
			$tier_desc .= "Rnd" if $tb->name eq "coinflip";
			$tier_desc .= "QC"  if $tb->name eq "competition";
			$tier_desc .= "RRk" if $tb->name eq "rankinround";
			$tier_desc .= "Win" if $tb->name eq "winloss";
			$tier_desc .= "Bal" if $tb->name eq "ballots";
			$tier_desc .= "OWn" if $tb->name eq "opp_wins";
			$tier_desc .= "OPt" if $tb->name eq "opp_points";
			$tier_desc .= "JVr" if $tb->name eq "judgevar";

			if ($tb->highlow) {
				$tier_desc .= " -".$tb->highlow_count;
				$tier_desc .= "H/L" if $tb->highlow == 1 || $tb->highlow == 2;
				$tier_desc .= "H" if $tb->highlow == 3;
				$tier_desc .= "L" if $tb->highlow == 4;
			}
		}

		$tier_descs{$key} = $tier_desc;

		foreach my $entry (@entries) { 

			my $entry_id = $entry->id;

			my $tier_total;

			my @students = @{$students_by_entry{$entry->id}} if $students_by_entry{$entry->id};
			next unless @students;

			my %used = ();

			foreach my $student (@students) { 
			
				my $student_id = $student->id;

				next if $used{$student_id};
				$used{$student_id}++;

				foreach my $tb (@{$tb_tiers{$key}}) { 

					my $name = $tb->name;
					my @rounds;

					my $total;

					foreach my $oround (@all_rounds) { 

						next if $oround->name > $round->name; #Avoid the future
		
						if ($tb->count eq "prelim") { 

							push (@rounds, $oround) if $oround->type eq "prelim";
							push (@rounds, $oround) if $oround->type eq "preset";
							push (@rounds, $oround) if $oround->type eq "highlow";
							push (@rounds, $oround) if $oround->type eq "highhigh";

						} elsif ($tb->count eq "last_elim" || $tb->count eq "last elim") { 

							push (@rounds, $oround) if $oround->type eq "elim" &! @rounds;

						} elsif ($tb->count eq "all") {  

							push (@rounds, $oround);

						} else { 

							push (@rounds, $oround) if $oround->type eq $tb->count;

						}

					}

					if ($name eq "winloss") { 

						$total += $entry_wins{$entry_id};

					} elsif ($name eq "ballots") { 

						foreach my $this_round (@rounds) { 

							foreach my $panel (@{$panels_by_round{$this_round->id}}) { 

								foreach my $ballot (@{$ballots_by_entry_panel{$entry_id."-".$panel}}) { 

									$noshows{$student_id}++ if $ballot->noshow;

									foreach my $value (@{$values_by_ballot{$ballot->id}}) { 
										$total++ if $value->value > 0 && $value->tag eq "ballot";
									}
								}
							}
						}

					} elsif ($name eq "opp_wins") { 

						my @opponents;
						my @panels;

						foreach my $this_round (@rounds) { 

							foreach my $panel (@{$panels_by_round{$this_round->id}}) { 

								my $yup;

								foreach my $other (@{$entry_ids_by_panel{$panel}}) { 
									$yup++ if $other == $entry_id;
								}

								if ($yup) { 

									foreach my $other (@{$entry_ids_by_panel{$panel}}) { 
										push (@opponents, $other) unless $other == $entry_id;
									}

								}
							}
						}

						foreach my $opp (@opponents) { 
							$total += $entry_wins{$opp};
						}


					} elsif ($name eq "opp_points") { 

						my $other_count;
						my $opp_points_total;

						foreach my $this_round (@rounds) { 

							foreach my $panel (@{$panels_by_round{$this_round->id}}) { 

								foreach my $other (@{$entry_ids_by_panel{$panel}}) { 

									next if $other == $entry_id;

									my @drop_best;
									my @drop_worst;

									foreach my $this_round (@rounds) { 

										foreach my $panel (@{$panels_by_round{$this_round->id}}) { 
											
											foreach my $ballot (@{$ballots_by_entry_panel{$other."-".$panel}}) { 

												my $points;
												
												foreach my $value (@{$values_by_ballot{$ballot->id}}) { 
													$points += $value->value > 0 if $value->tag eq "ballot";
												}
													
												$opp_points_total += $points;
												$other_count++;

												if ($tb->highlow) { 

													#drop the best

													if ($tb->highlow == 1 || $tb->highlow == 2 || $tb->highlow == 3) { 

														if (scalar @drop_best < $tb->highlow_count) { 
															push @drop_best, $points;
														} else { 
															my $least_best = pop @drop_best;
															push @drop_best, $least_best if $least_best >= $points;
															push @drop_best, $points if $least_best < $points;
														}

														@drop_best = sort {$b <=> $a} @drop_best;
													}

													#drop the worst

													if ($tb->highlow == 1 || $tb->highlow == 2 || $tb->highlow == 4) { 

														if (scalar @drop_worst < $tb->highlow_count) { 
															push @drop_worst, $points;
														} else { 
															my $least_worst = pop @drop_worst;
															push @drop_worst, $least_worst if $least_worst <= $points;
															push @drop_worst, $points if $least_worst > $points;
														}

														@drop_worst = sort {$a <=> $b} @drop_worst;
													}
												}
											}
										}
									}

									foreach my $point (@drop_best, @drop_worst) { 
										$opp_points_total -= $point;
										$other_count--;
									}
								}
							}
						}

						$total += Math::Round::nearest(.01, ($opp_points_total / $other_count)); 

					} elsif ($name eq "ranks") { 

						my @drop_best;
						my @drop_worst;

						foreach my $this_round (@rounds) { 

							my %panel_ranks = ();
						
							foreach my $panel (@{$panels_by_round{$this_round->id}}) { 

								foreach my $ballot (@{$ballots_by_entry_panel{$entry_id."-".$panel}}) { 

									my $rank;

									$noshows{$entry_id}++ if $ballot->noshow;
								
									foreach my $value (@{$values_by_ballot{$ballot->id}}) { 
										$rank += $value->value if $value->tag eq "rank";
									}

									$total += $rank;

									if ($tb->highlow) { 

										#drop the best

										if ($tb->highlow == 1 || $tb->highlow == 2 || $tb->highlow == 3) { 

											if (scalar @drop_best < $tb->highlow_count) { 
												push @drop_best, $rank;
											} else { 
												my $least_best = pop @drop_best;
												push @drop_best, $least_best if $least_best <= $rank;
												push @drop_best, $rank if $least_best > $rank;
											}

											@drop_best = sort {$a <=> $b} @drop_best;
										}

										#drop the worst

										if ($tb->highlow == 1 || $tb->highlow == 2 || $tb->highlow == 4) { 

											if (scalar @drop_worst < $tb->highlow_count) { 
												push @drop_worst, $rank;
											} else { 
												my $least_worst = pop @drop_worst;
												push @drop_worst, $least_worst if $least_worst >= $rank;
												push @drop_worst, $rank if $least_worst < $rank;
											}

											@drop_worst = sort {$b <=> $a} @drop_worst;
										}
									}
								}
							}
						}

						foreach my $rank (@drop_best, @drop_worst) { 
							$total -= $rank;
						}
									
					} elsif ($name eq "reciprocals") { 

						my @drop_best;
						my @drop_worst;
						
						foreach my $this_round (@rounds) { 

							foreach my $panel (@{$panels_by_round{$this_round->id}}) { 

								foreach my $ballot (@{$ballots_by_entry_panel{$entry_id."-".$panel}}) { 

									my $rank;
								
									foreach my $value (@{$values_by_ballot{$ballot->id}}) { 
										$rank += $value->value if $value->tag eq "rank";
									}

									$total += (1/$rank) if $rank;

									if ($tb->highlow) { 

										#drop the best

										if ($tb->highlow == 1 || $tb->highlow == 2 || $tb->highlow == 3) { 

											if (scalar @drop_best < $tb->highlow_count) { 
												push @drop_best, $rank;
											} else { 
												my $least_best = pop @drop_best;
												push @drop_best, $least_best if $least_best <= $rank;
												push @drop_best, $rank if $least_best > $rank;
											}

											@drop_best = sort {$a <=> $b} @drop_best;
										}

										#drop the worst

										if ($tb->highlow == 1 || $tb->highlow == 2 || $tb->highlow == 4) { 

											if (scalar @drop_worst < $tb->highlow_count) { 
												push @drop_worst, $rank;
											} else { 
												my $least_worst = pop @drop_worst;
												push @drop_worst, $least_worst if $least_worst >= $rank;
												push @drop_worst, $rank if $least_worst < $rank;
											}

											@drop_worst = sort {$b <=> $a} @drop_worst;
										}
									}
								}
							}
						}

						foreach my $rank (@drop_best, @drop_worst) { 
							$total -= (1/$rank);
						}

						$total = sprintf "%.2f", $total;  #round to 2 decimal places;

					} elsif ( $name eq "judgevar") { 

						my $count;
						my $avg;

						foreach my $this_round (@rounds) { 

							foreach my $panel (@{$panels_by_round{$this_round->id}}) { 

								foreach my $ballot (@{$ballots_by_entry_panel{$entry_id."-".$panel}}) { 

									my $average = $judge_variances{$ballot->judge->id};

									foreach my $value (@{$values_by_ballot{$ballot->id}}) { 
										next unless $value->tag eq "points";
										$avg +=  ($value->value - $average);
										$count++;
									}

								}
							}
						}

						$avg = Math::Round::nearest(.01, ($avg / $count));
						$total += $avg;

					} elsif ( $name eq "points") { 

						my $count;
						my $byes;

						my @drop_best;
						my @drop_worst;

						foreach my $this_round (@rounds) { 

							foreach my $panel (@{$panels_by_round{$this_round->id}}) { 

								foreach my $ballot (@{$ballots_by_entry_panel{$entry_id."-".$panel}}) { 

									my $points;
						
									unless ($ballot->bye > 0) { 
										foreach my $value (@{$values_by_ballot{$ballot->id}}) { 
											$points += $value->value if $value->student && 
												$value->student->id == $student->id && $value->tag eq "points";
										}
									}

									if ($ballot->bye > 0 || $points < 0) { 

										$byes++;

									} else { 

										$total += $points;
										$count++;

										if ($tb->highlow) { 

											if ($tb->highlow == 1 || $tb->highlow == 2 || $tb->highlow == 3) { 

												if (scalar @drop_best < $tb->highlow_count) { 
													push @drop_best, $points;
												} else { 
													my $least_best = pop @drop_best;
													push @drop_best, $least_best if $least_best >= $points;
													push @drop_best, $points if $least_best < $points;
												}

												@drop_best = sort {$b <=> $a} @drop_best;

											}

											if ($tb->highlow == 1 || $tb->highlow == 2 || $tb->highlow == 4) { 

												if (scalar @drop_worst < $tb->highlow_count) { 
													push @drop_worst, $points;
												} else { 
													my $least_worst = pop @drop_worst;
													push @drop_worst, $least_worst if $least_worst <= $points;
													push @drop_worst, $points if $least_worst > $points;
												}

												@drop_worst = sort {$a <=> $b} @drop_worst;

											}
										}
									}
								}
							}
						}

						my $average = sprintf("%.2f", $total / $count) if $count;
						$total += ($byes * $average) if $byes;

						foreach my $point (@drop_best, @drop_worst) { 
							$total -= $point;
						}
				
					} elsif ( $name eq "coinflip") { 

						# This is only semi random; product of the date epoch and
						# the random entry ID's last four digits.  But it will be
						# the same every time this function is run.

						my $random_seed = $student->id * $tourn->start->epoch;
						$total = substr($random_seed, -8, -3);

					} 

					if ($tb->multiplier > 0) { 
						$tier_total += $total * $tb->multiplier;
					} else { 
						$tier_total += $total;
					}
				
				}

				$student_tbs{$student->id."-".$key} = $tier_total;

			}

		}

	}

	foreach my $key (reverse sort keys %tb_tiers) { 
		@students = sort { $student_tbs{$a->id."-".$key} <=> $student_tbs{$b->id."-".$key}  } @students if $tier_dir{$key} eq "up";
		@students = sort { $student_tbs{$b->id."-".$key} <=> $student_tbs{$a->id."-".$key}  } @students if $tier_dir{$key} eq "down";
	}

	@students = sort { $noshows{$a->id} <=> $noshows{$b->id} } @entries if $noshows_never_break;

	my $count;
	my %student_by_place = ();
	
	my $last_string;
	my $delayed_count;

	foreach my $student (@students) { 

		my $tier_string;

		foreach my $key (sort keys %tb_tiers) { 
			$tier_string .= "-" if $tier_string;
			$tier_string .= $student_tbs{$student->id."-".$key};
		}

		if ($tier_string eq $last_string) { 
			$delayed_count++;
		} else {
			$count++;
			$count += $delayed_count;
			undef $delayed_count;
		}

		$last_string = $tier_string;
		push (@{$student_by_place{$count}}, $student);

	}

	return (\%student_by_place, \%student_tbs, \%tier_descs, \%noshows, \%tier_dir);

</%init>
