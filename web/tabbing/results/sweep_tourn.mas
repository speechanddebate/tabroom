<%args>
	$tourn
	$sweep_set
</%args>
<%init>

	my $novice_only;
	my %skip_round;
	my $prelim_seeds;

	return unless $sweep_set && $sweep_set->id;

	Tab::debuglog("Doing sweep set ".$sweep_set->name);

	my @rules = $sweep_set->rules;

	foreach my $rule (@rules) {

		$novice_only++
			if $rule->tag eq "novice_only"
			&& $rule->value == 1;

		$skip_round{$rule->value}++
			if $rule->tag eq "ignore_round";

		$prelim_seeds++ if $rule->tag eq "prelim_seed";
	}

	my @all_events = $sweep_set->events;
	return unless @all_events;

	my @events;
	my %used;

	foreach my $event (@all_events) {
		next unless $event && $event->id;
		next if $used{$event}++;
		push @events, $event;
	}

	my %event_include = map {$_->id => $_} @events;

	my @entries;
	my %entries;

	my %entry_code;
	my %entry_event;
	my %entry_school;
	my %entry_manual;

	my %event_count;

	my $dbh = Tab::DBI->db_Main();

	my $entry_sth = $dbh->prepare("
		select entry.id, entry.code, entry.name, entry.event, entry.school,
			school.name as schoolname, chapter.state as state, chapter.nsda as nsda,
			district.id as districtid, district.name as districtname
		from (entry, event)
		left join school on entry.school = school.id
		left join chapter on chapter.id = school.chapter
		left join district on district.id = school.district
		where entry.event = event.id
		and event.tourn  = ?
		and entry.unconfirmed = 0

		and not exists (
			select entry_setting.id
			from entry_setting
			where entry_setting.entry = entry.id
			and entry_setting.tag = 'exclude_from_sweeps'
			and entry_setting.value > 0
		)

		order by entry.code
	");

    $entry_sth->execute($tourn->id);

    while (
		my ($id, $code, $name, $event, $school, $schoolname, $state, $nsda, $districtid, $districtname)
		= $entry_sth->fetchrow_array()
	) {

		next unless $event_include{$event};

		push @entries, $id;

		$entries{$id}{"code"} = $code;
		$entries{$id}{"name"} = $name;
		$entries{$id}{"event"} = $event;
		$entries{$id}{"school"} = $school;
		$entries{$id}{"schoolname"} = $schoolname;
		$entries{$id}{"state"} = $state;
		$entries{$id}{"districtid"} = $districtid;
		$entries{$id}{"nsda_school_id"} = $nsda;
		$entries{$id}{"districtname"} = $districtname;

		$entry_event{$id}  = $event;
		$entry_school{$id} = $school;
		$entry_code{$id}   = $code;
		$event_count{$event}++;
	}

	foreach my $event (@events) {

		next unless $event;

		my @manual_sweeps = $m->comp(
			"/funclib/event_entry_settings.mas",
				event => $event,
				tag   => "sweeps"
			);

		foreach my $manual (@manual_sweeps) {
			$entry_manual{$manual->entry->id} = $manual->value;
		}
	}


	my $sth = $dbh->prepare("
		select score.id, entry.id, event.id,
			round.type, round.id,
			score.tag, score.value,
			panel.id,
			student.id, student.ualt_id, student.nsda, student.novice

		from score, ballot, panel, round, event, entry, entry_student, student
		where score.ballot = ballot.id
		and ballot.panel = panel.id
		and panel.round = round.id
		and round.event = event.id
		and event.tourn = ?
		and ballot.entry = entry.id
		and entry.active = 1
		and entry.dq != 1

		and not exists (
			select entry_setting.id
			from entry_setting
			where entry_setting.entry = entry.id
			and entry_setting.tag = 'exclude_from_sweeps'
			and entry_setting.value > 0
		)

		and entry.id = entry_student.entry
		and entry_student.student = student.id
		group by score.id
		order by event.id, round.name
	");

    $sth->execute($tourn->id);

	my %event_scores;
	my %entry_scores;
	my %entry_panels;
	my %entry_round_panel;

	my %score_entry;
	my %score_type;
	my %score_tag;
	my %score_value;
	my %score_panel;
	my %score_round;
	my %score_event;
	my %score_novice;
	my %entry_novice;

	my @scores;

    while (
		my ($id, $entry, $event, $type, $round, $tag, $value, $panel, $student, $ualt_id, $nsda, $novice)
		= $sth->fetchrow_array()
	) {

		next if $type eq "runoff";

		next unless $event_include{$event};
		next if $skip_round{$round};

		$entry_novice{$entry} = $novice;
		next if $novice_only && $novice < 1;

		$entries{$entry}{"students"}{$student}{"ualt_id"} = $ualt_id if $ualt_id;
		$entries{$entry}{"students"}{$student}{"nsda"} = $nsda if $nsda;

		$entries{$entry}{"students"}{$student}{"novice"} = $novice;
		$entries{$entry}{"rounds"}{$round}++;

		push @scores, $id;
		push @{$event_scores{$event}}, $id;
		push @{$entry_scores{$entry}}, $id;
		push @{$entry_panels{$entry}},$panel;

		$entry_round_panel{$entry."-".$round} = $panel;

		$score_tag{$id} = $tag;

		$type = "prelim"
			if $type eq "preset"
			|| $type eq "highhigh"
			|| $type eq "highlow";

		$score_type{$id} = $type;

		$score_entry{$id} = $entry;
		$score_value{$id} = $value;
		$score_panel{$id} = $panel;
		$score_round{$id} = $round;
		$score_event{$id} = $event;
		$score_novice{$id} = $novice;

	}

	my $bye_sth = $dbh->prepare("
		select entry.id, event.id, round.type, round.id, panel.id, panel.bye, ballot.bye
		from panel, round, event, entry, ballot
		where ballot.panel = panel.id
		and panel.round = round.id
		and round.event = event.id
		and event.tourn = ?
		and ballot.entry = entry.id
		and entry.active = 1
		and entry.dq != 1

		and not exists (
			select entry_setting.id
			from entry_setting
			where entry_setting.entry = entry.id
			and entry_setting.tag = 'exclude_from_sweeps'
			and entry_setting.value > 0
		)

		group by ballot.id
		order by event.id, round.name
	");

    $bye_sth->execute($tourn->id);

	my %entry_byes;
	my %entry_byes_by_type;

    while (
		my ($entry, $event, $type, $round, $panel, $panel_bye, $ballot_bye)
		= $bye_sth->fetchrow_array()
	) {

		next if $skip_round{$round};
		next unless $event_include{$event};
		next unless $panel_bye || $ballot_bye;

		next if $novice_only && $entry_novice{$entry};

		$entry_byes{$entry}++;

		$type = "prelim"
			if $type eq "preset"
			|| $type eq "highhigh"
			|| $type eq "highlow";

		$entry_byes_by_type{$entry}{$type}++;

		push @{$entry_panels{$entry}}, $panel;
		$entry_round_panel{$entry."-".$round} = $panel;

	}

	my %seen = ();
	@entries = grep { ! $seen{$_} ++ } @entries;

	my %entry_points;
	my %entry_placement;
	my %entry_placement_event;

	my %places = ();
	my $placement_done;

	foreach my $rule (@rules) {
		$places{$rule->place} = $rule->value
			if $rule->place && $rule->tag ne "cume";
	}

	my %prelim_seeding = ();

	if ($prelim_seeds) {

		foreach my $event (@events) {

			my $last_prelim;

			foreach my $round ($event->rounds) {
				next if $round->type eq "elim";
				next if $round->type eq "final";
				$last_prelim = $round if (not defined $last_prelim);
				$last_prelim = $round if $round->name > $last_prelim->name;
			}

			my (@results) = $m->comp(
				"/tabbing/results/order_entries.mas",
				round => $last_prelim
			);

			my $fullref = pop @results if @results;

			$prelim_seeding{$event->id} = $fullref->{"by_place"};

		}
	}

	foreach my $rule (@rules) {

		if ($rule->tag eq "points_per") {

			my $points = $rule->value;
			my $count = $rule->count;

			foreach my $entry (@entries) {

				my @panels;

				SCORE:
				foreach my $score (@{$entry_scores{$entry}}) {

					unless ( (not defined $count) || $count eq "all") {
						next if $score_type{$score} eq "prelim" && $count ne "prelim";
						next if $score_type{$score} eq "elim" && $count ne "elim";
						next if $score_type{$score} eq "final" && $count ne "final";
					}

					next if $novice_only && not defined $score_novice{$score};
					push @panels, $score_panel{$score};
				}

				my %pseen = ();
				@panels = grep { ! $pseen{$_} ++ } @panels;
				$entries{$entry}{$rule->id} += ($points * (scalar @panels));
			}
		}

		if ($rule->tag eq "points_per_rank") {

			my $points = $rule->value;
			my $place = $rule->place;
			my $count = $rule->count;

			foreach my $entry (@entries) {

				my %used;

				SCORE:
				foreach my $score (@{$entry_scores{$entry}}) {

					next if $used{$score}++;
					next unless $score_tag{$score} eq "rank";

					if ($count && $count ne "all") {
						next SCORE if $score_type{$score} ne $count;
					}

					next if $novice_only && not defined $score_novice{$score};

					$entries{$entry}{$rule->id} += $points if $score_value{$score} == $place;
				}
			}
		}

		if ($rule->tag eq "points_per_elim") {

			my $points = $rule->value;

			foreach my $entry (@entries) {

				my @panels;

				foreach my $score (@{$entry_scores{$entry}}) {

					next if $score_type{$score} ne "elim";
					next if $novice_only && not defined $score_novice{$score};
					push @panels, $score_panel{$score};
				}

				my %pseen = ();
				@panels = grep { ! $pseen{$_} ++ } @panels;
				$entries{$entry}{$rule->id} += ($points * (scalar @panels));
			}
		}

		if ($rule->tag eq "points_per_final" ) {

			my $points = $rule->value;

			foreach my $entry (@entries) {

				my @panels;

				foreach my $score (@{$entry_scores{$entry}}) {
					next if $score_type{$score} ne "final";
					next if $novice_only && not defined $score_novice{$score};
					push @panels, $score_panel{$score};
				}

				my %pseen = ();
				@panels = grep { ! $pseen{$_} ++ } @panels;
				$entries{$entry}{$rule->id} += ($points * (scalar @panels));
			}
		}

		if ($rule->tag eq "rev_per_rank" || $rule->tag eq "rev_per_rank_sansworst" ) {

			my $dropworst++ if $rule->tag eq "rev_per_rank_sansworst";
			my $points = $rule->value;
			my %entry_worst;

			my $count = $rule->count;

			SCORE:
			foreach my $score (@scores) {

				my $entry = $score_entry{$score};

				unless (not defined $count || $count eq "all") {
					next SCORE if $score_type{$score} ne $count;
				}

				next if $novice_only && not defined $score_novice{$score};
				next unless $score_tag{$score} eq "rank";

				my $points;

				if ($dropworst && $entry_worst{$entry} < $score_value{$score}) {

					if ($entry_worst{$entry}) {
						$points = 6 - $entry_worst{$entry};
						$points = 1 if $points < 1;
						$entry_worst{$entry} = $score_value{$score};
					} else {
						$points = 6 - $score_value{$score};
						$points = 1 if $points < 1;
					}

				} else {
					$points = 6 - $score_value{$score};
					$points = 1 if $points < 1;
				}

				$entries{$entry}{$rule->id} += $points;
			}
		}

		if ($rule->tag eq "cume") {

			my $points = $rule->value;
			my $place = $rule->place;

			my %entry_cume;

			foreach my $score (@scores) {
				next if $novice_only && not defined $score_novice{$score};
				next unless $score_tag{$score} eq "rank";
				next if $score_type{$score} eq "elim";
				next if $score_type{$score} eq "final";
				$entry_cume{$score_entry{$score}} += $score_value{$score};
			}

			foreach my $entry (@entries) {
				$entries{$entry}{$rule->id} += $points
					if $entry_cume{$entry} == $place;
			}

		}

		if ($rule->tag eq "prelim_seed") {

			my $limit = $rule->place;
			my $points = $rule->value;
			my %done;

			foreach my $event (@events) {

				next unless $event && $event->id;

				foreach my $place (
					sort {$a <=> $b}
					keys %{$prelim_seeding{$event->id} }
				)  {

					next if $place > $limit;

					foreach my $entry_id (@{$prelim_seeding{$event->id}{$place}}) {

						next if $done{$entry_id}++;

						$entries{$entry_id}{$rule->id} += $points;

					}
				}
			}
		}

		if ($rule->tag eq "rev_per_place") {

			my $type = $rule->count;

			foreach my $event (@events) {

				next unless $event && $event->id;

				foreach my $round ($event->rounds) {

					next if $skip_round{$round->id};
					next unless $round->type eq $type;


					my ($entries_ref, $tbs_ref, $desc_ref, $forfeit_ref)
						= $m->comp("/tabbing/results/order_entries.mas",
						round => $round
					);

					my %panel_place;

					foreach my $key (sort {$a <=> $b} keys %{$entries_ref}) {

						foreach my $entry (@{${$entries_ref}{$key}}) {

							next if $novice_only && not defined $entry_novice{$entry};

							my $panel = $entry_round_panel{$entry."-".$round->id};
							$panel_place{$panel}++;

							my $points = 6 - $panel_place{$panel};
							$points = 1 if $points < 1;

							$entries{$entry}{$rule->id} += $points;
						}

					}
				}
			}
		}

		if ($rule->tag eq "points_per_composite_rank") {

			my $type = $rule->count;

			foreach my $event (@events) {

				next unless $event && $event->id;

				foreach my $round ($event->rounds) {

					next if $skip_round{$round->id};
					next unless $round->type eq $type;

					my ($entries_ref, $tbs_ref, $desc_ref, $forfeit_ref)
						= $m->comp("/tabbing/results/order_entries.mas",
							round         => $round,
							composite_set => $rule->tiebreak_set
					);

					my %panel_place;

					foreach my $key (sort {$a <=> $b} keys %{$entries_ref}) {

						foreach my $entry (@{${$entries_ref}{$key}}) {

							next if $novice_only && not defined $entry_novice{$entry};

							my $panel = $entry_round_panel{$entry."-".$round->id};
							$panel_place{$panel}++;

							my $points = $rule->value
								if $panel_place{$panel} == $rule->place;

							$points = 0 if $points < 1;

							$entries{$entry}{$rule->id} += $points;
						}
					}
				}
			}
		}

		if ($rule->tag eq "rev_composite" && $rule->tiebreak_set) {

			my $type = $rule->count;
			my $tiebreak_set = $rule->tiebreak_set;

			foreach my $event (@events) {

				next unless $event && $event->id;

				foreach my $round ($event->rounds) {

					next if $skip_round{$round->id};

					next unless ($round->type eq $type)
						|| $type eq "all";

					my @results = $m->comp(
						"/tabbing/results/order_entries.mas",
							round        => $round,
							tiebreak_set => $tiebreak_set,
							section_rank => 1
					);

					my $entries_ref = pop @results;

					my %panel_place;

					foreach my $entry_id (sort {$a <=> $b} keys %{$entries_ref->{"section_rank"}}) {

						my $rank = $entries_ref->{"section_rank"}{$entry_id};

						next unless $rank;

						my $points = 6 - $rank;
						$points = 1 if $points < 1;

						$entries{$entry_id}{$rule->id} += $points;

					}
				}
			}
		}



		if (
			$rule->tag eq "rev_overall"
			|| $rule->tag eq "place"
			|| $rule->tag eq "place_above"
			|| $rule->tag eq "rev_per_overall_place"
			|| $rule->tag eq "nsda_place"
		) {

			my $type = $rule->count;
			my $tiebreak_set = $rule->tiebreak_set;

			my $districts = $tourn->setting("nsda_district");

			unless ($placement_done eq $type."-".$tiebreak_set) {

				foreach my $event (@events) {

					my $pilot++ if $tourn->setting("nsda_pilot_".$event->type);

					next unless $event && $event->id;

					my @rounds = sort {$b->name <=> $a->name} $event->rounds();
					next unless @rounds;

					if ($districts && ($event->type eq "speech" || $event->type eq "debate")) {
						my $final;
						foreach my $round (@rounds) {
							$final = $round if $round->type eq "final";
							last if $final;
						}
						$tiebreak_set = $final->tiebreak_set if $final;
					}

					my $did_stuff;

					foreach my $round (@rounds) {

						next if $skip_round{$round->id};
						next unless ($round->type eq $type) || ($type eq "all");

						if ($pilot && $round->type ne "final" && $round->type ne "elim") {
							$tiebreak_set = $rule->tiebreak_set;
						}

						my @results = $m->comp(
							"/tabbing/results/order_entries.mas",
								round        => $round,
								tiebreak_set => $tiebreak_set
						);

						my $entries_ref = pop @results;
						my $counter;

						foreach my $key (sort {$a <=> $b} keys %{${$entries_ref}{"by_place"}}) {
							foreach my $entry_id (@{${${$entries_ref}{"by_place"}}{$key}}) {
								next if $entry_placement{$entry_id};
								$entry_placement{$entry_id} = $key;
								$entry_placement_event{$event->id}{$entry_id} = $key;
								$counter++;
							}
						}

						if ($counter) {
							last if $round->type eq "prelim";
							last if $round->type eq "highhigh";
							last if $round->type eq "highlow";
						}
					}
				}

				Tab::debuglog("Entry 173 placement is ".$entry_placement{2259136});
				Tab::debuglog("Entry 158 placement is ".$entry_placement{2267314});

				$placement_done = $type."-".$tiebreak_set;
			}
		}


		if ($rule->tag eq "rev_overall" && $rule->tiebreak_set) {

			foreach my $event (@events) {

				next unless $event && $event->id;

				# The +1 is so the DFL entry doesn't get zero points and
				# therefore aren't told yet again how much THEY SUCK.

				# Because kindness matters or something -- CLP

				my $num_entries = scalar (keys %{$entry_placement{$event->id}}) + 1;

				my $multiplier = $rule->value;
				$multiplier = 1 unless $multiplier;

				foreach my $entry_id (keys %{$entry_placement_event{$event->id}{$event->id}}) {

					my $placement_points
						= ($num_entries - $entry_placement_event{$event->id}{$entry_id}) * $multiplier;

					$placement_points = 0 if $placement_points < 0;
					$entries{$entry_id}{$rule->id} = $placement_points;
				}
			}
		}

		if ($rule->tag eq "percentage" && $rule->tiebreak_set) {

			my $type = $rule->count;

			my $tiebreak_set = $rule->tiebreak_set;

			my $points = $rule->value;

			foreach my $event (@events) {

				next unless $event && $event->id;

				my @rounds;

				if ($type eq "all") {

					foreach my $round ($event->rounds) {
						next if $skip_round{$round->id};
						push @rounds, $round;
					}

				} elsif ($type eq "prelim") {

					foreach my $round ($event->rounds) {
						next if $skip_round{$round->id};
						push @rounds, $round if (
							$round->type ne "elim"
							&& $round->type ne "final"
						);
					}

				} elsif ($type eq "elim") {

					foreach my $round ($event->rounds) {
						next if $skip_round{$round->id};

						push @rounds, $round
							if $round->type eq "elim";
					}

				} elsif ($type eq "final") {

					foreach my $round ($event->rounds) {
						next if $skip_round{$round->id};
						push @rounds, $round
							if $round->type eq "final";
					}

				} elsif ($type eq "last_prelim") {

					my $last_prelim;

					foreach my $round ($event->rounds) {

						next if $skip_round{$round->id};
						next if $round->type eq "elim";
						next if $round->type eq "final";

						$last_prelim = $round
							if (not defined $last_prelim);

						$last_prelim = $round
							if $last_prelim
							&& $last_prelim->name < $round->name;
					}

					push @rounds, $last_prelim;

				}

				foreach my $round (@rounds) {

					my @results = $m->comp(
						"/tabbing/results/order_entries.mas",
							round        => $round,
							tiebreak_set => $tiebreak_set
					);

					my $entries_ref = pop @results;

					my $entries_count = scalar( keys %{$entries_ref->{"by_place"}} );

					my $threshold = ceil($rule->place * .01 * $entries_count);

					foreach my $place (
						sort {$a <=> $b} keys %{$entries_ref->{"by_place"}}
					) {

						next if $place > $threshold;

						if ($entries_ref->{"by_place"}{$place}) {

							foreach my $entry_id (@{$entries_ref->{"by_place"}{$place}}) {

								$entries{$entry_id}{$rule->id} += $points;
							}

						}

					}

				}

			}

		}

		if ($rule->tag eq "rev_per_overall_place") {
			foreach my $entry (@entries) {
				next unless $entry_placement{$entry};
				my $points = 6 - $entry_placement{$entry};
				$points = 0 unless $points;
				$entries{$entry}{$rule->id} += $points;
			}
		}

		if ($rule->tag eq "place_above") {
			foreach my $entry (@entries) {
				next unless $entry_placement{$entry};
				next if $entry_placement{$entry} > $rule->place;
				$entries{$entry}{$rule->id} += $places{$entry_placement{$entry}};
			}
		}

		if ($rule->tag eq "place") {
			foreach my $entry (@entries) {

				next unless $entry_placement{$entry};
				next if $entry_placement{$entry} != $rule->place;
				$entries{$entry}{$rule->id} += $places{$entry_placement{$entry}};
			}
		}

		if ($rule->tag eq "nsda_place") {

			my %eseen = ();
			@entries = grep { ! $eseen{$_} ++ } @entries;

			foreach my $entry (@entries) {

				next unless $entry_placement{$entry};
				next unless $entry_placement{$entry} < 7;

				my $event = $event_include{$entry_event{$entry}};

				my $baseline_score = 10;

				$baseline_score-- if $event->type eq "speech";
				$baseline_score-- if $event->type eq "congress";

				my $field_size = $event_count{$event};

				if ($event->setting("max_entry") > 1) {

					$baseline_score-- if $field_size < 50;
					$baseline_score-- if $field_size < 30;

				} else {

					$baseline_score-- if $field_size < 58;
					$baseline_score-- if $field_size < 38;
				}

				my $points = 0;

				if (
					($entry_placement{$entry} < 7)
					&& ($entry_placement{$entry} > 0)
				) {

					$points = $baseline_score - $entry_placement{$entry};
				}

				$entries{$entry}{$rule->id} += $points;
			}

		}

		if ($rule->tag eq "debate_win" || $rule->tag eq "debate_loss" ) {

			my $winner++ if $rule->tag eq "debate_win";
			my $points = $rule->value;
			my $count = $rule->count;

			SCORE:
			foreach my $score (@scores) {

				if ($count && $count ne "all") {
					next SCORE if $score_type{$score} ne $count;
				}

				my $entry = $score_entry{$score};

				next if $novice_only && not defined $score_novice{$score};

				next unless $score_tag{$score} eq "ballot";

				if ($rule->tag eq "debate_win") {

					$entries{$entry}{$rule->id} += $points
						if $score_value{$score} == 1;
				}

				if ($rule->tag eq "debate_loss") {
					$entries{$entry}{$rule->id} += $points
						if $score_value{$score} == 0;
				}
			}

		}

		if ($rule->tag eq "debate_round_win" || $rule->tag eq "debate_round_loss" ) {

			my $winner++ if $rule->tag eq "debate_round_win";

			my $points = $rule->value;
			my $count = $rule->count;

			my @round_keys;
			my @entries;
			my %round_ballots_won;
			my %round_ballots_lost;

			SCORE:
			foreach my $score (@scores) {

				if ($count && $count ne "all") {
					next SCORE if $score_type{$score} ne $count;
				}

				my $entry = $score_entry{$score};
				my $round = $score_round{$score};

				next if $novice_only && not defined $score_novice{$score};
				next unless $score_tag{$score} eq "ballot";

				$round_ballots_won{$entry}{$round}++
					if $score_value{$score} == 1;

				$round_ballots_lost{$entry}{$round}++
					if $score_value{$score} == 0;

				push @round_keys, $round
					if exists $score_value{$score};

				push @entries, $entry
					if exists $score_value{$score};
			}

			my %seen = ();
			@round_keys = grep { ! $seen{$_} ++ } @round_keys;

			my %eseen = ();
			@entries = grep { ! $eseen{$_} ++ } @entries;

			foreach my $key (@round_keys) {

				foreach my $entry (@entries) {

					if ($rule->tag eq "debate_round_win") {

						$entries{$entry}{$rule->id} += $points
							if $round_ballots_won{$entry}{$key} > $round_ballots_lost{$entry}{$key};

					} elsif ($rule->tag eq "debate_round_loss") {

						$entries{$entry}{$rule->id} += $points
							if $round_ballots_won{$entry}{$key} < $round_ballots_lost{$entry}{$key};
					}

				}
			}
		}

		if ($rule->tag eq "debate_round_bye") {

			my $points = $rule->value;
			my $count = $rule->count;

			foreach my $entry (@entries) {

				if ($count && $count ne "all") {
					$entries{$entry}{$rule->id} += $entry_byes_by_type{$entry}{$count} * $points;
				} else {
					$entries{$entry}{$rule->id} += $entry_byes{$entry} * $points;
				}
			}
		}

		if ($rule->tag eq "points_per_po_round") {

			my $points = $rule->value;
			my $count = $rule->count;

			foreach my $entry (@entries) {

				my %rounds;

				SCORE:
				foreach my $score (@{$entry_scores{$entry}}) {

					next unless $score_tag{$score} eq "presiding_officer";

					unless ( (not defined $count) || $count eq "all") {

						next if $score_type{$score} eq "prelim" && $count ne "prelim";
						next if $score_type{$score} eq "elim" && $count ne "elim";
						next if $score_type{$score} eq "final" && $count ne "final";

					}
					next if $novice_only && not defined $score_novice{$score};
					$rounds{$score_round{$score}}++;
				}
				$entries{$entry}{$rule->id} += ($points * (scalar (keys %rounds)));
			}
		}

		if ($rule->tag eq "manual") {
			foreach my $entry (@entries) {
				$entries{$entry}{$rule->id} += $entry_manual{$entry};
			}
		}

		push @{$entries{"rules"}}, $rule->id;

		$entries{"tag"}{$rule->id} = $rule->tag;

		$entries{"tag"}{$rule->id} =~ s/points_per_po_round/Elected PO/g;
		$entries{"tag"}{$rule->id} =~ s/points_per/In a round/g;
		$entries{"tag"}{$rule->id} =~ s/place_above/Placed above/g;
		$entries{"tag"}{$rule->id} =~ s/_/ /g;

		$entries{"tag"}{$rule->id} .= "  ".Lingua::EN::Numbers::Ordinate::ordinate($rule->place) if $rule->place;

		if ($rule->count && $rule->count ne "all") {
			$entries{"tag"}{$rule->id} .= " ".$rule->count;
			$entries{"tag"}{$rule->id} =~ s/round//g;
		}

		foreach my $entry (@entries) {
			$entry_points{$entry} += $entries{$entry}{$rule->id};
			$entries{$entry}{"points"} += $entries{$entry}{$rule->id};
		}
	}

	@{$entries{"entries"}} = @entries;

	return \%entry_points, \@entries, \%entry_school, \%entry_event, \%entry_code, \%entries;

</%init>
