<%args>
	$person
	$panel_id => undef
	$judge_id => undef
</%args>
<%init>

	my $now = DateTime->now;

    my $panel = Tab::Panel->retrieve($panel_id);
    my $judge = Tab::Judge->retrieve($judge_id);

    unless ($panel && $judge) { 
        my $err = "No ballots found for that judge and that panel.";
        $m->redirect("../index.mhtml?err=$err");
    }   

	my $round = $panel->round;
	my $event = $round->event;
	my $category = $event->category;
    my $tourn = $category->tourn;

	my %event_settings = $event->all_settings();

	my $no_lpw++ if $event_settings{"no_lpw"};

    my %max_points;
    my %min_points;

    my @score_types = ("Style", "Content", "Strategy", "POI");

    foreach my $key (@score_types) { 

        $min_points{$key} = $event_settings{"min_".$key."_points"};

        $max_points{$key} = $event_settings{"max_".$key."_points"};
    
        $min_points{"total"} += $min_points{$key} 
			unless $key eq "POI";

        $max_points{"total"} += $max_points{$key} 
			unless $key eq "POI";

    }   

	$min_points{"total"} = $event_settings{'min_points'} 
		unless $min_points{'total'};

	$max_points{"total"} = $event_settings{'max_points'} 
		unless $max_points{'total'};

    my $pts = $event_settings{'point_increments'};
    my $point_increments = $event_settings{"point_increments"};

    my $point_ties = $event_settings{"point_ties"};

	my %tb_types = $m->comp(
		"/funclib/tiebreak_types.mas", 
		round => $round
	);

    my @ballots = Tab::Ballot->search( 
		judge => $judge->id, 
		panel => $panel->id
	);

	my @scores = $m->comp(
		"/funclib/panel_scores.mas", 
		panel => $panel, 
		judge => $judge
	);

	my $errs;

	my %student_rank;
	my %student_points;
	my %student_position;
	my %student_categories;

	my %team_points;
	my %team_ranks;
	my %team_bye;
	my %team_forfeit;

	my %rank_points;
	my $winner;

	my %used_team_points;

	foreach my $ballot (@ballots) { 

		my $entry = $ballot->entry();
		my @students = $entry->students();

		my %students_by_id = map {$_->id => $_} @students;

		$team_bye{$entry->id}++ if $ARGS{"bye_".$ballot->id};
		$team_forfeit{$entry->id}++ if $ARGS{"forfeit_".$ballot->id};

		if ($team_bye{$entry->id} && $team_forfeit{$entry->id}) { 
			$errs = "Error type: HYC+EI2.  (Have Your Cake And Eat It Too).<br/>";
			$errs .= "You assigned ".$entry->code." a bye and a forfeit. One or the other, plz.";
		}

		my %used;
		my $team_total;

		POSITION:
		foreach my $position (1 .. 4) { 

			my $student_id = $ARGS{"speaker_".$position."_".$ballot->id};

			my $student = $students_by_id{$student_id};

			$student_position{$student_id} = $position if $position < 4;

			unless ($student && $student->id) { 
				$errs .= "<p>Speaker missing in position $position.  Key is speaker_".$position."_".$ballot->id;
				next POSITION;
			}

			if ($used{"student_".$student_id} && $position < 4) { 
				$errs .= "<p>Speaker ".$student->first." ".$student->last;
				$errs .= " is listed in two speaker positions</p>";
			}

			if (($position > 3) &! $used{"student_".$student_id}) { 
				$errs .= "<p>Speaker ".$student->first." ".$student->last." on ".$entry->code;
				$errs .= " is listed in reply but did not otherwise speak</p>";
			}

			if (($position > 3) && ($used{"student_".$student_id} == 3)) { 
				$errs .= "<p>Speaker ".$student->first." ".$student->last." on ".$entry->code;
				$errs .= " is listed in reply but spoke 3rd</p>";
			}

			$used{"student_".$student_id} = $position;

			next unless $student;

			my $ballot_points;
			my $ballot_rank;

			if ($tb_types{"points"}) { 

				$ballot_points = $ARGS{"points_".$position."_".$ballot->id};

				if ($ballot_points > 0) { 

					$ballot_points = int($ballot_points + 0.5) 
						if $point_increments eq "whole";

					if ($point_increments eq "tenths") { 
						$ballot_points = $ballot_points * 10;
						$ballot_points = int($ballot_points + 0.5);
						$ballot_points = $ballot_points / 10;
					}

					if ($point_increments eq "half") { 
						$ballot_points = $ballot_points * 2;
						$ballot_points = int($ballot_points + 0.5);
						$ballot_points = $ballot_points / 2;
					}
				}
						
				$errs .= "<p>Points missing</p>" 
					if not defined $ballot_points 
					&! $team_bye{$entry->id} 
					&! $team_forfeit{$entry->id};

				if ($ballot_points) { 

					$team_total += $ballot_points;

					$errs .= "<p>$ballot_points Points must be a number</p>" 
						unless (
							$ballot_points == 0 
							|| $ballot_points eq $ballot_points + 0
						);

					if ($position < 4) { 

						$errs .= "<p>Points $ballot_points are outside of range</p>" 
							if $ballot_points < $min_points{"total"} 
							|| $ballot_points > $max_points{"total"};

					} else { 

						$errs .= "<p>Points $ballot_points are outside of range for reply</p>" 
							if ($ballot_points < ($min_points{"total"} / 2))
							|| ($ballot_points > ($max_points{'total'} / 2));

					}

				}

				if ($event_settings{"wsdc_subtotal_ballot"}) { 

					my $subtotal_check;
					my $replyfirst;
		
					foreach my $key (@score_types) { 

						my $category = $ARGS{$key."_".$position."_".$ballot->id};

						$student_categories{$student_id} .= ", " 
							if $student_categories{$student_id};

						$student_categories{$student_id} .= " \n\n REPLY: " 
							if $position == 4 
							&& not defined $replyfirst;

						$replyfirst++;

						$student_categories{$student_id} .= "$key: $category" 
							if $category != 0;

						$subtotal_check += $category;

					}

					$errs .= "<p>Points were sent as $ballot_points but your subtotals add to $subtotal_check</p>"
						if $ballot_points != $subtotal_check;

				}

			}

			if ($tb_types{"ranks"}) { 

				$ballot_rank = $ARGS{"ranks_".$position."_".$ballot->id};

				$ballot_rank = int($ballot_rank + 0.5);

				$errs .= "<p>$ballot_rank Ranks must be a number</p>" 
					unless $ballot_rank == 0 
						|| ($ballot_rank eq $ballot_rank + 0);

				$errs .= "<p>Points $ballot_points are outside of range</p>" 
					if $ballot_points < $min_points{"total"} 
					|| $ballot_points > $max_points{"total"};

				$errs .= "<p>Ranks missing</p>" 
					if not defined $ballot_rank 
					&& not defined $team_bye{$entry->id} 
					&& not defined $team_forfeit{$entry->id};

				if ($ballot_rank) { 

					$errs .= "<p>Rank $ballot_rank is outside of range</p>" 
						if $ballot_rank < 1 
						|| $ballot_rank > 6;

					$errs .= "<p>Rank $ballot_rank is repeated</p>" 
						if $used{"rank_".$ballot_rank}++;

					if ($tb_types{"points"}) { 
						
						#check that ranks agree with points
						foreach my $rank (keys %rank_points) { 

							if ($rank_points{$rank} > $ballot_points && $rank > $ballot_rank) { 
								$errs .= "<p>Speaker ranked $rank has better points ($rank_points{$rank})";
								$errs .= " than rank $ballot_rank ($ballot_points)</p>";
							}

							if ($rank_points{$rank} < $ballot_points && $rank < $ballot_rank) { 
								$errs .= "<p>Speaker ranked $ballot_rank has better points ($ballot_points) ";
								$errs .= " than rank $rank ($rank_points{$rank})</p>";
							}

						}

					}

				}

			} 

			if ($position > 3) { 

				$student_points{$student_id."_rebuttal"} = $ballot_points;
						
				$errs .= "<p>Points $ballot_points are outside of range for reply</p>" 
					if ($ballot_points < ($min_points{"total"} / 2))
					|| ($ballot_points > ($max_points{'total'} / 2));

			} else {

				$student_points{$student_id} = $ballot_points;
				$student_rank{$student_id} = $ballot_rank;

			}

			$team_points{$entry->id} += $ballot_points;
			$team_ranks{$entry->id} += $ballot_rank;

		}

		unless ($point_ties) { 

			my $points = $team_points{$entry->id};

			$errs .= "<p>Team points were tied.  Please try again</p>" 
				if $used_team_points{$points}++; 
		}

		$winner = $ballot 
			if $tb_types{"winloss"} 
			&& $ballot->id == $ARGS{"winner"};

		if ($winner && $tb_types{"points"} && $no_lpw) { 

			my $winner_points = $team_points{$winner->entry->id};

			foreach my $team (keys %team_points) { 
				next if $team == $winner->entry->id;
				$errs .= "<p>Low point wins are not allowed by this tournament</p>" 
					if $winner_points < $team_points{$team};
			}
		}

	}

	unless ($winner) { 
		$errs .= "<p class='strong redtext'>You did not have a winner marked.";
		$errs .= " There are no ties in debate, though there are sometimes tears.";
		$errs .= " Be strong.</p>";
	}

	#Remove any duplicate ballots and judges
	$m->comp("/funclib/panel_dedupe.mas", panel => $panel);

	my $ballot_err;

	my $status;

	if ($errs) { 
		$m->redirect("../index.mhtml?timeslot_id=".$round->timeslot->id."&judge_id=$judge_id&flight=".$panel->flight."&errs=$errs&err=Trouble in Paradise!");

	} else { 

		my $audit_method = $category->setting("audit_method");

		$audit_method = "twice" unless $audit_method;

		$status = 1 if $audit_method eq "none";

		if ($audit_method eq "twice") { 

			#Check existing values to see if they match.

			foreach my $ballot (@ballots) { 

				my @bvs = $ballot->scores;

				foreach my $bv ($ballot->scores) { 

					if ($bv->tag eq "points") { 

						my $student = $bv->student;
						$ballot_err .= "Points for ".$student->first." ".$student->last." differ (".$bv->value." vs ".$student_points{$student->id}.") <br />" if $bv->value != $student_points{$student->id};

					} elsif ($bv->tag eq "rank") { 

						my $student = $bv->student;
						$ballot_err .= "Rank for ".$student->first." ".$student->last." differ (".$bv->value." vs ".$student_rank{$student->id}.") <br />" if $bv->value != $student_rank{$student->id}; 

					} elsif ($bv->tag eq "rebuttal_points") { 

						my $student = $bv->student;
						$ballot_err .= "Reply Points for ".$student->first." ".$student->last." differ (".$bv->value." vs ".$student_points{$student->id."_rebuttal"}.") <br />" if $bv->value != $student_points{$student->id."_rebuttal"};

					} elsif ($bv->tag eq "ballot") { 

						$status++;
						if ($winner && $bv->value == 1 && $winner->id != $ballot->id) { 
							$ballot_err .= "Winner was different!";
						}
					}
				}

				if ($ballot->bye) {
					$ballot_err .= "Bye marked last round was not marked" 
						unless $team_bye{$ballot->entry->id};
				} 

				if ($ballot->forfeit) {
					$ballot_err .= "Forfeit marked last round was not marked" 
						unless $team_forfeit{$ballot->entry->id};
				}

			}

			undef $status if $ballot_err;

			foreach my $ballot (@ballots) { 
				undef $status if $team_forfeit{$ballot->entry->id} &! $ballot->forfeit;
				undef $status if $team_bye{$ballot->entry->id} &! $ballot->bye;
			}

		}

		if ($status && $audit_method ne "none") {
				
			foreach my $ballot (@ballots) { 
				$ballot->audit(1);
				$ballot->update;
			}

		} else {

			Tab::Score->set_sql( clear_cruft => "
				delete score.*
				from score, ballot
				where ballot.panel = ?
				and ballot.judge = ? 
				and (score.tag = 'categories' 
						or score.tag = 'rank' 
						or score.tag = 'points' 
						or score.tag = 'categories' 
						or score.tag = 'rebuttal_points' 
						or score.tag = 'ballot') 
				and ballot.id = score.ballot");

			Tab::Score->sql_clear_cruft->execute($panel->id, $judge->id);

			foreach my $ballot (@ballots) { 
					
				my $tigers_blood = 0;
				$tigers_blood++ if $winner && $winner->id == $ballot->id;

				eval { 
					Tab::Score->create({
						ballot   => $ballot->id,
						value    => $tigers_blood,
						tag      => "ballot",
						tiebreak => 2,
						student  => 0
					});
				};

				foreach my $student ($ballot->entry->students) { 

					if ($student_points{$student->id}) { 

						eval { 
							Tab::Score->create({
								ballot   => $ballot->id,
								student  => $student->id,
								position => $student_position{$student->id},
								tag      => "points",
								tiebreak => 3,
								value    => $student_points{$student->id}
							});
						};

					}

					if ($student_points{$student->id."_rebuttal"}) { 

						eval { 
							Tab::Score->create({
								ballot   => $ballot->id,
								student  => $student->id,
								position => 4,
								tag      => "rebuttal_points",
								tiebreak => 6,
								value    => $student_points{$student->id."_rebuttal"}
							});
						};

					}

					if ($student_rank{$student->id}) { 

						eval { 
							Tab::Score->create({
								ballot   => $ballot->id,
								student  => $student->id,
								position => $student_position{$student->id},
								tag      => "rank",
								tiebreak => 1,
								value    => $student_rank{$student->id}
							});
						};

					}

					if ($student_categories{$student->id}) { 

						eval { 
							Tab::Score->create({ 
								ballot   => $ballot->id,
								student  => $student->id,
								position => $student_position{$student->id},
								tag      => "categories",
								tiebreak => 8,
								content  => $student_categories{$student->id}
							});
						};

					}

				}

				$ballot->audit(0);
				$ballot->audit(1) if $audit_method eq "none";
				$ballot->bye($team_bye{$ballot->entry->id});
				$ballot->forfeit($team_forfeit{$ballot->entry->id});
				$ballot->entered_by($person->id);

				$ballot->update();

			}

			$panel->started($now) unless $panel->started;
			$panel->confirmed($now) unless $panel->confirmed;
			$panel->update();

		}

		foreach my $ballot (@ballots) { 

			foreach my $value ($ballot->values(tag => "")) { 

				# This bug is driving me up the F#%)(*&#%(@*%&! wall.  for now
				# check for it and fix it on the fly.  NOTE:  This is an
				# incredibly ugly hack.  I hate it.  I hate the bug more
				# though.

				$value->tag("rank") if $value->tiebreak == 1;
				$value->tag("ballot") if $value->tiebreak == 2;
				$value->tag("points") if $value->tiebreak == 3;
				$value->tag("rebuttal_points") if $value->tiebreak == 6;
				$value->update;
			}

		}

		my $yellowmsg;
		my $greenmsg;
		my $err;

		if ($ballot_err) { 
			$err = "Trouble in paradise!";
		} elsif ($status) { 
			$greenmsg = "Ballot entry complete." if $status > 1;
		} else {
			$yellowmsg = "Ballot first entry complete.  Pass to someone to enter for a doublecheck.";
		}

		$m->comp("/funclib/round_done.mas", round => $round);

		my $limit = "and event.category = ".$category->id if $category;

		my @unentered = $m->comp(
			"/funclib/timeslot_judges.mas", 
			timeslot => $round->timeslot,
			status   => "full",
			limit    => $limit,
			flight   => $panel->flight
		);

		my @half_entered = $m->comp(
			"/funclib/timeslot_judges.mas", 
			timeslot => $round->timeslot,
			status   => "half",
			limit    => $limit,
			flight   => $panel->flight
		); 
		
		my $style = "codes";
		$style = "names" if $category->setting("no_codes");

		push @unentered, @half_entered; 

		@unentered = 
			sort {$a->last cmp $b->last} @unentered;

		@unentered = 
			sort {$a->code <=> $b->code} @unentered 
			unless $style eq "names";

		my $next_one;

		NEXT:
		foreach my $next (@unentered) { 

			if ($next_one) {
				next NEXT if $next->id == $judge->id;
				$next_one = $next->id;
			} else { 
				last NEXT;
			}

		}

		$m->redirect("../index.mhtml?timeslot_id=".$round->timeslot->id."&judge_id=$judge_id&err=$err&ballot_err=$ballot_err") if $ballot_err;

		$m->redirect("../index.mhtml?timeslot_id=".$round->timeslot->id."&judge_id=$next_one&greenmsg=$greenmsg&yellowmsg=$yellowmsg&err=$err");

	}

</%init>
