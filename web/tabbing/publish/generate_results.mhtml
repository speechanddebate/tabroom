<%args>
	$tourn
	$tourn_settings
	$result_type
	$event_id     => undef
	$event        => undef
	$session      => undef
	$publish      => 0
	$mailbids     => undef
	$limit        => undef
	$circuit_id   => undef
</%args>
<%init>

	my @events;
	my $msg;

	my $tz = $tourn->tz;
	$tz = "UTC" unless $tz;

	my $now = DateTime->now( time_zone => $tz);

	if ($event_id eq "all") {

		@events = $tourn->events;

	} elsif ($event_id =~ /type/) {

		my $type = $event_id;
		$type =~ s/type_//g;

		@events = Tab::Event->search(
			tourn => $tourn->id,
			type  => $type
		);

	} elsif ($event) {
		push @events, $event;
	} else {
		push @events, Tab::Event->retrieve($event_id);
	}

	my $breakout;
	my $breakout_label;
	my %limit_entries = ();
	my %limit_students = ();

	my %es;

	foreach my $event (@events) {

		unless ($es{$event} && keys %{$es{$event}}) {
			%{$es{$event}} = $event->all_settings();
		}

		my $event_settings = $es{$event->id};

		foreach my $key (1 .. $event_settings->{"breakouts"}) {

			next unless $ARGS{"breakout_".$event->id."-".$key};
			next if $event_settings->{"breakout_".$key."_delete"};
			my $label =  $event_settings->{"breakout_".$key."_label"};

			$breakout_label .= " and " if $breakout_label;
			$breakout_label = " (" unless $breakout_label;
			$breakout_label .= $label;

			$breakout = $key;

			my $flagged_students = JSON::decode_json($event_settings->{'breakout_'.$key.'_students'})
				if $event_settings->{'breakout_'.$key."_students"};

			my @entries = $m->comp(
				"/funclib/event_entries.mas",
				event    => $event,
				breakout => $key
			);

			foreach my $entry (@entries) {
				$limit_entries{$entry->id}++;
			}

			foreach my $student_id (keys %{$flagged_students}) {
				$limit_students{$student_id}++;
			}
		}
	}

	$breakout_label .= ") " if $breakout_label;

	if ($result_type eq "ndca") {

		foreach my $event (@events) {

			my $event_settings = $es{$event->id};

			if ($event_settings->{"baker"}
				|| $event_settings->{"dukesandbailey"}
				|| $event_settings->{"ndca_public_forum"}
			) {

				$m->comp("/tabbing/report/ndca/points.mhtml",
					event_id => $event->id,
					publish  => $publish,
					generate => 1,
					tourn    => $tourn);

				$msg .= "NDCA points generated for ".$event->abbr." <br />";
			}
		}

	} elsif ($result_type eq "toc") {

		foreach my $event (@events) {

			my $event_settings = $es{$event->id};

			if ($event_settings->{"bid_round"}) {

				$msg .= $m->comp("/tabbing/report/toc/post_bids.mhtml",
					event_id       => $event->id,
					publish        => $publish,
					generate       => 1,
					mailbids       => $mailbids,
					tourn          => $tourn,
					tourn_settings => $tourn_settings,
					session        => $session);
			}
		}

	} elsif ($result_type eq "bracket") {

		foreach my $event (@events) {

			my $event_settings = $es{$event->id};

			my $bracket = $m->comp("generate_bracket.mas", 
				event    => $event,
				breakout => $breakout,
				label    => "Bracket ".$breakout_label
			);

			$bracket->published($publish);
			$bracket->update;
			$msg .= "Bracket for ".$event->abbr." regenerated";
		}

	} else {

		my $label = "Prelim Seeds" if ($result_type eq "prelim_seed");
		$label = "Final Places" if ($result_type eq "final");
		$label = "Speaker Awards" if ($result_type eq "speakers");
		$label = "Cume Sheet" if ($result_type eq "cumesheet");

		$label .= $breakout if $breakout;

		Tab::ResultValue->set_sql( rm_label => "
			delete result_value.*
			from result, result_value, result_set
			where result_value.result = result.id
			and result.result_set = result_set.id
			and result_set.event = ?
			and result_set.label = ?
		");

		Tab::Result->set_sql( rm_label => "
			delete result.*
			from result, result_set
			where result.result_set = result_set.id
			and result_set.event = ?
			and result_set.label = ?
		");

		Tab::ResultSet->set_sql( rm_label => "
			delete from result_set
			where event = ?
			and label = ?
		");

		foreach my $event (@events) {

			my $event_settings = $es{$event->id};
			my $novice++ if $event_settings->{"top_novice"};
			my $honmen++ if $event_settings->{"honorable_mentions"};
			my $event_type = $event->type;

			my @rounds = sort {$b->name <=> $a->name}
				$m->comp("/funclib/event_rounds.mas",
					event => $event,
					done => "yes"
				);

			my $top_novice = $m->comp(
				"/tabbing/results/top_novice.mas",
				event => $event
			) if $novice;

			my %used;
			my $final;
			my @elims;
			my $last_prelim;

			foreach my $round (@rounds) {

				$final = $round if $round->type eq "final";
				push (@elims, $round) if $round->type eq "elim";

				$last_prelim = $round if $round->type ne "elim"
					&& $round->type ne "final"
					&& not defined $last_prelim;
			}

			my $rank = 1;

			Tab::ResultValue->sql_rm_label->execute( $event->id, $label );
			Tab::Result->sql_rm_label->execute( $event->id, $label );
			Tab::ResultSet->sql_rm_label->execute( $event->id, $label );

			my $set = Tab::ResultSet->create({
				tourn     => $tourn->id,
				event     => $event->id,
				label     => $label,
				generated => $now,
				published => $publish
			});

			my %keys = map {$_->tag => $_} $set->result_keys();

			my %prelim_seed;

			if ($result_type eq "speakers") {

				my %student_ballots = ();

				my $tiebreak_set_id = $event_settings->{"speaker_tbset"};

				my $tiebreak_set = Tab::TiebreakSet->retrieve($tiebreak_set_id)
					if $tiebreak_set_id;

				unless ($tiebreak_set) {

					my $err = "Event ".$event->name." does not have a speaker ";
					$err .= "awards tiebreaker set applied to it.  Please pick one ";
					$err .= "and try again";

					return $err if $ARGS{"return"};
					$m->redirect("/setup/events/tabbing.mhtml?event_id=".$event->id."&err=$err");

				}

				if ($last_prelim) {

					my %tiebreak_types = $m->comp(
						"/funclib/tiebreak_types.mas",
						tiebreak_set => $tiebreak_set,
						round        => $last_prelim
					);

					my $type = $event->type;

					my $dbh = Tab::DBI->db_Main();

					my $sth = $dbh->prepare("

						select score.id, score.tag, score.value, score.student,
							student.id, ballot.entry, ballot.judge,
							panel.bye, ballot.bye, ballot.forfeit, ballot.chair,
							round.name

						from (ballot, panel, round, entry_student, student)

						left join score on score.ballot = ballot.id
							and (
									score.tag    = 'winloss'
									or score.tag = 'rank'
									or score.tag = 'point'
								)

						where ballot.panel = panel.id
							and panel.round = round.id
							and round.name <= ?
							and round.event = ?
							and ballot.entry = entry_student.entry
							and entry_student.student = student.id

							and not exists (
								select round_setting.id from round_setting
								where round_setting.tag = 'ignore_results'
								and round_setting.round = round.id
							)
						order by round.name, ballot.entry, ballot.chair, ballot.judge,
							CASE score.tag
								WHEN 'winloss' 	then 1
								when 'rank' 	then 2
								when 'point' 	then 3
								when 'refute' 	then 4
							end
					");

					$sth->execute($last_prelim->name, $event->id);

					my %student_round;

					while (
						my (
							$id, $tag, $value, $value_student, $student,
							$entryid, $judge, $pbye, $bye, $fft, $chair, $roundname
						) = $sth->fetchrow_array()
					) {

						next if $tag eq "categories";
						next if $tag eq "rfd";
						next if $tag eq "comments";

						next unless $tiebreak_types{$tag};

						next if $tag ne "winloss" && $value_student != $student;
						next if $breakout && not defined $limit_students{$student};

						if ($student_round{$student}
							&& $student_ballots{$student}
							&& $roundname != $student_round{$student}) {
							$student_ballots{$student} .= " &nbsp; ";
						}

						unless ($tag) {
							if ($pbye || $bye) {
								$student_ballots{$student} .= " B ";
								$student_ballots{$student} .= "&nbsp;" if $tiebreak_types{"point"};
								$student_ballots{$student} .= "&nbsp;" if $tiebreak_types{"rank"};
							} elsif ($fft) {
								$student_ballots{$student} .= " F ";
								$student_ballots{$student} .= "&nbsp;" if $tiebreak_types{"point"};
								$student_ballots{$student} .= "&nbsp;" if $tiebreak_types{"rank"};
							}

						} elsif ($tag eq "winloss") {
							if ($pbye || $bye) {
								$student_ballots{$student} .= " B ";
								$student_ballots{$student} .= "&nbsp;" if $tiebreak_types{"point"};
								$student_ballots{$student} .= "&nbsp;" if $tiebreak_types{"rank"};
							} elsif ($fft) {
								$student_ballots{$student} .= " F ";
								$student_ballots{$student} .= "&nbsp;" if $tiebreak_types{"point"};
								$student_ballots{$student} .= "&nbsp;" if $tiebreak_types{"rank"};
							} else {
								$student_ballots{$student} .= " W " if $value > 0;
								$student_ballots{$student} .= " L " if $value < 1;
							}
						} else {
							$student_ballots{$student} .= $value." ";
						}

						$student_round{$student} = $roundname;

					}

					my (
						$students_ref, $tbs_ref, $desc_ref, $forfeit_ref,
						$tier_dir, $long_desc_ref, $novice_ref, $name_ref,
						$code_ref, $school_ref, $entry_ref
					) = $m->comp("/tabbing/results/order_speakers.mas", round => $last_prelim);

					my $counter = 1;

					foreach my $key (sort {$a <=> $b} keys %{$students_ref}) {

						next if $limit && $counter > $limit;

						my @students;

						if ($breakout) {
							foreach my $student (@{${$students_ref}{$key}}) {
								push @students, $student if $limit_students{$student};
							}
						} else {
							@students = @{${$students_ref}{$key}};
						}

						my $park;
						my $tie++ if scalar @students > 1;

						my $key_value = $rank;
						$key_value .= "-T" if $tie;

						foreach my $student (@students) {

							$prelim_seed{$student} = $rank;
							$park++;

							my $result = Tab::Result->create({
								student    => $student,
								entry      => ${$entry_ref}{$student},
								rank       => $rank,
								result_set => $set->id,
								place      => $key_value
							});

							foreach my $key (sort {$a <=> $b} keys %{$desc_ref}) {

								my $tag = ${$desc_ref}{$key};
								my $description = ${$long_desc_ref}{$key};

								my $sort_desc = 0;
								$sort_desc = 1 if ${$tier_dir}{$key} eq "down";

								my $value = ${$tbs_ref}{$student."-".$key};
								$value = sprintf("%.2f", $value);

								unless ($keys{$tag}) {
									$keys{$tag} = Tab::ResultKey->create({
										result_set  => $set->id,
										tag         => $tag,
										description => $description,
										sort_desc   => $sort_desc
									});
								}

								Tab::ResultValue->create({
									result       => $result->id,
									value        => $value,
									result_key   => $keys{$tag},
									priority     => $key,
									tiebreak_set => $tiebreak_set
								});
							}

							unless ($keys{"Ballots"}) {
								$keys{"Ballots"} = Tab::ResultKey->create({
									result_set  => $set->id,
									tag         => "Ballots",
									description => "Unadjusted Raw Scores",
									no_sort     => 1
								});
							}

							Tab::ResultValue->create({
								result       => $result->id,
								value        => $student_ballots{$student},
								result_key   => $keys{"Ballots"},
								priority     => 999,
								tiebreak_set => $tiebreak_set
							});

						}

						$counter += scalar @students if $park;
						$rank += $park;
					}
				}

			} elsif ($last_prelim) {

				my (
					$entries_ref, $tbs_ref, $desc_ref, $forfeit_ref,
					$tier_dir, $panrank_ref, $panletter_ref, $long_desc_ref
				) = $m->comp("/tabbing/results/order_entries.mas", round => $last_prelim);

				my $tiebreak_set = $last_prelim->tiebreak_set;

				my %entry_ballots = $m->comp(
					"/funclib/round_ballot_strings.mas",
					round => $last_prelim);

				my $counter = 1;

				foreach my $key (sort {$a <=> $b} keys %{$entries_ref}) {

					next if $limit && $counter > $limit;

					my @entries;

					if ($breakout) {
						foreach my $entry ( @{${$entries_ref}{$key}} ) {
							push @entries, $entry if $limit_entries{$entry};
						}
					} else {
						@entries = @{${$entries_ref}{$key}};
					}

					my $tie++ if scalar @entries > 1;

					my $park;

					foreach my $entry (@entries) {

						$prelim_seed{$entry} = $rank;
						next unless $result_type eq "prelim_seed";
						next if $used{$entry}++;

						$park++;

						my $key_value = $counter;
						$key_value .= "-T" if $tie;

						my $result = Tab::Result->create({
							entry      => $entry,
							rank       => $rank,
							result_set => $set->id,
							place      => $key_value
						});

						foreach my $key (sort {$a <=> $b} keys %{$desc_ref}) {

							my $tag = ${$desc_ref}{$key};
							my $description = ${$long_desc_ref}{$key};

							my $sort_desc = 0;
							$sort_desc = 1 if ${$tier_dir}{$key} eq "down";

							my $value = ${$tbs_ref}{$entry}{$key};
							$value = sprintf("%.2f", $value);

							unless ($keys{$tag}) {
								$keys{$tag} = Tab::ResultKey->create({
									result_set  => $set->id,
									tag         => $tag,
									description => $description,
									sort_desc   => $sort_desc
								});
							}

							Tab::ResultValue->create({
								result       => $result->id,
								value        => $value,
								priority     => $key,
								result_key   => $keys{$tag},
								tiebreak_set => $tiebreak_set
							});
						}

						unless ($keys{"Ballots"}) {
							$keys{"Ballots"} = Tab::ResultKey->create({
								result_set  => $set->id,
								tag         => "Ballots",
								description => "Unadjusted Raw Scores",
								no_sort     => 1
							});
						}

						Tab::ResultValue->create({
							result_key   => $keys{"Ballots"},
							result       => $result->id,
							value        => $entry_ballots{$entry},
							tiebreak_set => $tiebreak_set,
							priority     => 999
						});

					}

					$counter += scalar @entries if $park;
					$rank += $park;
				}

				if ($result_type eq "final") {

					undef $rank;

					foreach my $round ($final, @elims, $last_prelim) {

						next unless $round;
						my $type = $round->type;
						my $label = substr($round->label, 0, 8);

						my ($entries_ref, $tbs_ref, $desc_ref, $forfeit_ref,
							$tier_dir, $panrank_ref, $panletter_ref, $long_desc_ref
						) = $m->comp("/tabbing/results/order_entries.mas", round => $round);

						my $tiebreak_set = $round->tiebreak_set;

						my %entry_ballots = $m->comp(
							"/funclib/round_ballot_strings.mas",
							round => $round
						);

						foreach my $key (sort {$a <=> $b} keys %{$entries_ref}) {

							my $tie++ if scalar @{${$entries_ref}{$key}} > 1;

							@{${$entries_ref}{$key}} =
								sort {
									$prelim_seed{$a} <=> $prelim_seed{$b}
								} @{${$entries_ref}{$key}};

							foreach my $entry (@{${$entries_ref}{$key}}) {

								next if $breakout && not defined $limit_entries{$entry};
								next if $used{$entry}++;

								$rank++;
								my $key_value = Lingua::EN::Numbers::Ordinate::ordinate($key)
									if $type eq "final";

								$key_value .= "-T" if $tie && $type eq "final";

								if ($key_value eq "1st-T") {
									$key_value = "Co-Champion"
								}

								$key_value = $label if $type eq "elim";
								$key_value = "Prelim" if $type ne "elim" && $type ne "final";

								my $result = Tab::Result->create({
									entry      => $entry,
									rank       => $rank,
									round      => $round,
									result_set => $set->id,
									place      => $key_value
								});

								foreach my $key (sort {$a <=> $b} keys %{$desc_ref}) {

									if (
										($type eq "elim" || $type eq "final")
										&& $event_type ne "speech"
										&& $event_type ne "congress"
									) {

										my $tag = "Round";
										my $description = "Last round competed in";
										my $sort_desc = 0;

										my $value = $round->realname;

										unless ($keys{$tag}) {
											$keys{$tag} = Tab::ResultKey->create({
												result_set  => $set->id,
												tag         => $tag,
												description => $description,
												sort_desc   => $sort_desc
											});
										}

										Tab::ResultValue->create({
											result       => $result->id,
											value        => $value,
											priority     => $key,
											result_key   => $keys{$tag},
											tiebreak_set => $tiebreak_set
										});

									} else {

										my $tag = ${$desc_ref}{$key};
										my $description = ${$long_desc_ref}{$key};
										my $sort_desc = 0;
										$sort_desc = 1 if ${$tier_dir}{$key} eq "down";

										unless ($keys{$tag}) {
											$keys{$tag} = Tab::ResultKey->create({
												result_set  => $set->id,
												tag         => $tag,
												description => $description,
												sort_desc   => $sort_desc
											});
										}

										Tab::ResultValue->create({
											result       => $result->id,
											value        => ${$tbs_ref}{$entry}{$key},
											priority     => $key,
											result_key   => $keys{$tag},
											tiebreak_set => $tiebreak_set
										});
									}
								}

								unless ($keys{"Ballots"}) {
									$keys{"Ballots"} = Tab::ResultKey->create({
										result_set  => $set->id,
										tag         => "Ballots",
										description => "Unadjusted Raw Scores",
										no_sort     => 1
									});
								}

								Tab::ResultValue->create({
									result       => $result->id,
									value        => $entry_ballots{$entry},
									result_key   => $keys{"Ballots"},
									priority     => 999,
									tiebreak_set => $tiebreak_set
								});

								# Mark the tournament champion if we have one
								if ($type eq "final") {

									Tab::Result->set_sql( delete_final => "
										delete result.*
										from (result_set, result)
										where result.result_set = result_set.id
										and result_set.id = ?
										and result.round = ?
										and result.entry = ?
										and result_set.label = 'Final Places'
									");

									Tab::Result->sql_delete_final->execute($set->id, $entry, $round);
									my $place = Lingua::EN::Numbers::Ordinate::ordinate($key);

									if ($tie) {
										$place = "Co-Champion";
									}

									Tab::Result->create({
										result_set => $set->id,
										entry      => $entry,
										round      => $round->id,
										rank       => $key,
										place      => $place
									});
								}
							}
						}
					}
				}
			}

			Tab::Result->set_sql( update_percentile =>
				"update result set percentile = ( ( (? - rank + 1) / ? ) * 100)
				where result_set = ? ");

			Tab::Result->sql_update_percentile->execute( $rank, $rank, $set->id);

			$msg .= $event->name." results published " if $publish;
			$msg .= $event->name." results calculated " unless $publish;

		}
	}

	if ($ARGS{'return'}) {
		return $msg;
	}

	$m->redirect("/user/circuit/tourn_results.mhtml?circuit_id=$circuit_id&msg=$msg") if $circuit_id;
	$m->redirect("index.mhtml?msg=$msg");

</%init>
