<%args>
	$person_id   => undef
	$username    => undef
	$password    => undef
	$tourn_id    => undef
	$event_id    => undef
	$round_id    => undef
	$school_id   => undef
	$public      => undef
	$session_id  => undef
	$category_id => undef
</%args>
<%doc>

	This is the first exporter of tournament data from Tabroom that does the
	following things:

	1.  Is sufficiently modular that it can download the whole tournament, or a
	single judge category, a single round, one event, or a single school's
	registration.

	2. Exports a format that is close to tabroom native, and not compromised
	with various third party stuff.

	Phew.

</%doc>
<%init>

	unless ($ARGS{"file"}) {
		$m->clear_buffer();
		$r->content_type('application/json');
	}

	use JSON -convert_blessed_universally;
	use utf8;

	my $dbh = Tab::DBI->db_Main();

	my $person;
	my $tourn;
	my $session;
	my $round;
	my $event;
	my $category;

	$public = 1;

	if ($ARGS{'tourn'} && $ARGS{"tourn"}->id && $ARGS{"owner"} && $ARGS{"owner"}->id) {

		# An owner object must be an internal result of an auto backup process
		# because you cannot post an PERL object over the web.
		$person = $ARGS{"owner"};
		$tourn = $ARGS{"tourn"};
		undef $public;

		if ($ARGS{"round_id"}) {
			$round = Tab::Round->retrieve($ARGS{round_id});
		}
		if ($ARGS{"event_id"}) {
			$event = Tab::Round->retrieve($ARGS{event_id});
		}

	} elsif ($ARGS{"person"} || $ARGS{"login"}) {

		# Again objects are valid
		if ($ARGS{"person"} && $ARGS{"session"}) {
			$person = $ARGS{"person"};
			$person_id = $person->id;
			$session = $ARGS{"session"};
		} else {
			($person, $session) = $m->comp("/user/login/authenticate.mas");
		}

		unless ($session > 0) {
			$m->comp("/funclib/abort.mas",
				message => "You do not have an active login session."
			);
		}

		$session_id = $session->id;

		if ($ARGS{"tourn_id"}) {
			$tourn = Tab::Tourn->retrieve($ARGS{"tourn_id"});
		} elsif ($ARGS{'category_id'}) {
			$tourn = eval {
				$category = Tab::Category->retrieve($ARGS{"category_id"});
				return $category->tourn;
			}
		} elsif ($ARGS{'event_id'}) {
			$tourn = eval {
				$event = Tab::Event->retrieve($ARGS{"event_id"});
				return $event->tourn;
			}
		} elsif ($ARGS{'school_id'}) {
			$tourn = eval {
				my $school = Tab::School->retrieve($ARGS{"school_id"});
				return $school->tourn;
			}
		} elsif ($ARGS{'round_id'}) {
			$tourn = eval {
				my $round = Tab::Round->retrieve($ARGS{"round_id"});
				$event = $round->event;
				return $event->tourn;
			}
		}

		my %perms = $person->all_permissions($tourn);

		if ($perms{"owner"} || $perms{"tabber"}) {
			undef $public;
		}

		if ($event && $ARGS{"event"}{$event->id} eq "tabber") {
			undef $public;
		}

		if ($category && $ARGS{"category"}{$category->id} eq "tabber") {
			undef $public;
		}

	} elsif ($ARGS{"api_id"} && $ARGS{"api_key"}) {

		($person, $tourn) = $m->comp("login_api.mas",
			method    => "api_key",
			person_id => $ARGS{"api_id"},
			api_key   => $ARGS{"api_key"},
			tourn_id  => $tourn_id,
		);

		undef $public;

	} else {

		($person, $tourn, $session) = $m->comp(
			"login_api.mas",
				tourn_id   => $tourn_id,
				username   => $username,
				password   => $password,
				session_id => $session_id,
				person_id  => $person_id,
				skip_abort => 1
		);

		if ($person && $session ) {
			undef $public;
		} else {
			$public = 1;
			$tourn = Tab::Tourn->retrieve($tourn_id);
		}
	}

	if ($tourn_id && (not defined $tourn)) {
		$m->print('{ "error": true, "message": "No such tournament was found"}');
		$m->abort();
	}

	if ($round_id && (not defined $round)) {
		$m->print('{ "error": true, "message": "No such round was found"}');
		$m->abort();
	}

	if ($event_id && (not defined $event)) {
		$m->print('{ "error": true, "message": "No such event was found"}');
		$m->abort();
	}

	my $json_tourn;
	my %filter;

	if ($round_id) {
		$json_tourn->{round_only} = $round_id;
	} elsif ($school_id) {
		$json_tourn->{school_only} = $school_id;
	} elsif ($event_id) {
		$json_tourn->{event_only} = $event_id;
	} elsif ($category_id) {
		$json_tourn->{category_only} = $category_id;
	} else {
		$json_tourn->{whole} = 1;
	}

	if ($ARGS{"skip_content"}) {
		$json_tourn->{"skip_content"} = "true";
	}

	if ($public) {
		$json_tourn->{public} = 'true';
		$json_tourn->{anonymous} = "true" if $tourn->setting("anonymous_public");
	}

	my $now = DateTime->now(time_zone => "UTC");

	my @events;
	my @timeslots;

	my @categories;

	if ($event) {
		@categories = ($event->category);
	} else {
		@categories = $tourn->categories;
	}

	my %category_events;
	my $file_name;

	my %entries;
	my %schools;
	my %students;

	my $now_string = $now->datetime();

	if ($json_tourn->{public} || $json_tourn->{whole}) {

		my $tourn_sth = $dbh->prepare("
			select tourn.*
			from tourn
			where id = ?
		");

		$tourn_sth->execute($tourn->id);

		my $results = $tourn_sth->fetchall_hash();
		my $ref = shift @{$results};
		my $creator;

		if ($person) {
			$creator = $person->email;
		} else {
			$creator = "Public";
		}

		my $add_tourn = {
			name           => $ref->{name},
			city           => $ref->{city},
			state          => $ref->{state},
			country        => $ref->{country},
			webname        => $ref->{webname},
			timezone       => $ref->{tz},
			hidden         => $ref->{hidden},
			creator        => $creator
		};

	    $json_tourn = { %$json_tourn, %$add_tourn };

		$json_tourn->{start} = $ref->{start};
		$json_tourn->{end} = $ref->{end};
		$json_tourn->{reg_start} = $ref->{reg_start};
		$json_tourn->{reg_end} = $ref->{reg_end};
		$json_tourn->{backup_created} = $now_string;

	} else {

		# Just a shell for the event or school or category in question.

		my $add_tourn = {
			name           => $tourn->name,
			backup_created => $now_string,
			creator        => $person->email
		};

	    $json_tourn = { %$json_tourn, %$add_tourn };
	}


	my %schools_used;
	my %events_used;

	unless (
		$json_tourn->{school_only}
		|| $json_tourn->{category_only}
		|| $json_tourn->{event_only}
		|| $json_tourn->{round_only}
		|| $json_tourn->{public}
	) {

		# TOURN SETTINGS
		my $ts_sth = $dbh->prepare("
			select
				tourn.id, tourn_setting.id, tourn_setting.tag,
				tourn_setting.value, tourn_setting.value_date, tourn_setting.value_text
			from (tourn, tourn_setting)
			where tourn.id = ?
			and tourn.id = tourn_setting.tourn
			and tourn_setting.tag NOT IN ('nc_purchased')
		");

		$json_tourn->{settings} = raw_value($ts_sth, $tourn->id);
	}

	my $rpool_sth = $dbh->prepare("
		select
			rpool.id,
			rpool.name,
			rpool_room.room
		from (rpool)
			left join rpool_room on rpool.id = rpool_room.rpool
		where rpool.tourn = ?
	");

	my $rpool_round_sth = $dbh->prepare("
		select
			rpool_round.rpool, rpool_round.round
		from rpool_round, rpool
			where rpool_round.rpool = rpool.id
			and rpool.tourn = ?
	");

	my $event_entries_sth = $dbh->prepare("
		select entry_student.id,
			student.id, student.first, student.middle, student.last, student.grad_year,
				student.nsda, student.phonetic, student.chapter, hybrid.id,
			entry.id, entry.code, entry.name, entry.event, entry.school, school.chapter,
				entry.ada, entry.active, entry.dropped, entry.waitlist, entry.unconfirmed,
				entry.created_at, entry.registered_by
		from (entry, school)
			left join entry_student on entry_student.entry = entry.id
			left join student on student.id = entry_student.student

		left join school hybrid
			on hybrid.tourn = school.tourn
			and hybrid.chapter = student.chapter

		where entry.event = ?
			and entry.school = school.id
		group by entry.id, entry_student.student
	");

	my $quals_common = "
		select
			qual.id, qual.name, qual.result, qual.entry
			from (qualifier as qual, entry)
			where qual.entry = entry.id
	";

	my $school_quals_sth = $dbh->prepare("
		$quals_common
		and entry.school = ?
	");

	my $event_quals_sth = $dbh->prepare("
		$quals_common
		and entry.event = ?
	");

	my $school_strikes_sth = $dbh->prepare("
		select
			strike.id, strike.type,
			strike.judge, strike.entry, strike.school,
			strike.registrant, strike.conflict, strike.conflictee
		from strike
		where strike.school = ?
		and strike.type = 'school'
	");

	my $entry_strikes = "
		select
			strike.id, strike.type,
			strike.judge, strike.entry, strike.school,
			strike.registrant, strike.conflict, strike.conflictee
		from strike, entry
		where strike.entry = entry.id
	";

	my $event_strikes_sth = $dbh->prepare("
		$entry_strikes
		and entry.event = ?
	");

	my $school_entry_strikes_sth = $dbh->prepare("
		$entry_strikes
			and entry.school = ?
	");

	my $entry_ratings = "
		select
			rating.id, rating.type, rating.entry, rating.judge,
			rating.entered,
			rating.ordinal, rating.percentile,
			rating.rating_tier, rating_tier.name, rating.rating_subset,
			rating.side

		from (rating, entry)
		left join rating_tier on rating_tier.id = rating.rating_tier
		where rating.entry = entry.id
	";

	my $event_ratings_sth = $dbh->prepare("
		$entry_ratings
		and entry.event = ?
	");

	my $school_entry_ratings_sth = $dbh->prepare("
		$entry_ratings
		and entry.school = ?
	");

	my $judge_strikes = "
		select
			strike.id, strike.type, strike.start, strike.end,
			strike.judge, strike.entry, strike.event, strike.school,
			strike.region, strike.district, strike.timeslot, strike.shift,
			strike.registrant, strike.conflict, strike.conflictee
		from strike, judge
		where strike.judge = judge.id
	";

	my $category_strikes_sth = $dbh->prepare("
		$judge_strikes
		and judge.category = ?
	");

	my $school_judge_strikes_sth = $dbh->prepare("
		$judge_strikes
		and judge.school = ?
	");

	my $judge_ratings = "
		select
			rating.id, rating.type, rating.entry, rating.judge,
			rating.entered,
			rating.ordinal, rating.percentile,
			rating.rating_tier, rating_tier.name, rating.rating_subset,
			rating.side

		from (rating, judge)

		left join rating_tier on rating_tier.id = rating.rating_tier

		where rating.judge = judge.id
	";

	my $category_ratings_sth = $dbh->prepare("
		$judge_ratings
		and judge.category = ?
	");

	my $school_judge_ratings_sth = $dbh->prepare("
		$judge_ratings
		and judge.school = ?
	");

	my $es_sth = $dbh->prepare("
		select
			entry.id, entry_setting.id, entry_setting.tag,
			entry_setting.value, entry_setting.value_date, entry_setting.value_text
		from (entry, entry_setting)

		where entry.id = ?
			and entry.id = entry_setting.entry
	");

	my $sv_sth = $dbh->prepare("
		select
			sv.id, sv.panel, sv.tag, sv.value, sv.voter, sv.entry, sv.entered_by, sv.entered_at,
			round.id
			from student_vote sv, panel, round
		where sv.panel = panel.id
		and panel.round = round.id
		and round.event = ?
	");

	if ($json_tourn->{round_only}) {

		unless ($round) {
			$round = Tab::Round->retrieve($round_id);
		}

		unless ($round || $ARGS{"file"}) {
			$m->clear_buffer();
			$m->print("No round found for ID $round_id");
			$m->abort;
		}

		if ($event) {
			@events = ($event);
		} else {
			@events = ($round->event);
		}

		@timeslots = ($round->timeslot);

		if ($person_id) {
			$file_name = "AutoBackup-";
		}

		my $event_name = $events[0]->name;
		my $round_name = $round->realname;

		$event_name =~ s/[\W_]//g;
		$round_name =~ s/[\W_]//g;

		$file_name .= $event_name."-";
		$file_name .= $round_name;

	} elsif ($json_tourn->{event_only}) {

		push @events, Tab::Event->retrieve($event_id);
		unless (@events || $ARGS{"file"}) {
			$m->clear_buffer();
			$m->print("No event found for ID $event_id");
			$m->abort;
		}

		$file_name = $events[0]->name;
		$file_name =~ s/[\W_]//g;;

	} elsif ($json_tourn->{category_only}) {

		my $category = Tab::Category->retrieve($category_id);

		unless ($category || $ARGS{"file"}) {
			$m->clear_buffer();
			$m->print("No judge category found for ID $category_id");
			$m->abort;
		}

		$file_name = $category->name;
		$file_name =~ s/[\W_]//g;;

		push @events, $category->events();

	} else {
		push @events, $tourn->events;
	}

	foreach my $event (@events) {

		my $category = $event->category();
		next unless $category > 0;

		push @{$category_events{$category->id}}, $event;

		unless ($json_tourn->{round_only}) {
			push (@timeslots, $m->comp("/funclib/event_timeslots.mas", event => $event));
		}
		$events_used{$event->id} = $event;
	}

	unless (
		$json_tourn->{school_only}
		|| $ARGS{"rounds_only"}
	) {

		my %tseen = ();
		@timeslots = grep { ! $tseen{$_->id} ++ } @timeslots;

		# TIMESLOTS
		foreach my $ts (@timeslots) {

			if ($ts->start) {
				my $json_ts = {
					id    => $ts->id,
					name  => $ts->name,
					start => $ts->start->datetime(),
					end   => $ts->end->datetime()
				};

				push (@{$json_tourn->{timeslots}}, $json_ts);
			}
		}

		unless (
			$json_tourn->{round_only}
			|| $json_tourn->{event_only}
			|| $json_tourn->{category_only}
		) {

			# PATTERNS
			foreach my $pattern ($tourn->patterns) {

				my $json_pattern = {
					id      => $pattern->id,
					name    => $pattern->name,
					tag     => $pattern->type,
					max     => $pattern->max,
					exclude => $pattern->exclude
				};

				push (@{$json_tourn->{patterns}}, $json_pattern);
			}

			my $room_strike_sth = $dbh->prepare("
				select rs.id, rs.type, rs.start, rs.end, rs.room,
					rs.event, rs.tourn, rs.entry, rs.judge
				from room_strike rs, room
				where rs.room = room.id
				and room.site = ?
				and rs.tourn = ?
			");


			unless ($json_tourn->{public}) {
				# SITES AND ROOMS
				foreach my $site ($tourn->sites) {

					my $json_site = {
						id => $site->id,
						name => $site->name
					};

					push @{$json_tourn->{sites}}, $json_site;

					foreach my $room ($site->rooms(deleted => 0)) {

						my $json_room = {
							id   => $room->id,
							name => $room->name
						};

						$json_room->{rows} = $room->rowcount if $room->rowcount;
						$json_room->{seats} = $room->seats if $room->seats;
						$json_room->{inactive} = $room->inactive if $room->inactive;
						$json_room->{ada} = $room->ada if $room->ada && (not defined $json_tourn->{public});

						$json_room->{quality} = $room->quality if $room->quality;
						$json_room->{capacity} = $room->capacity if $room->capacity;
						$json_room->{notes} = $room->notes if $room->notes;
						$json_room->{url} = $room->url if $room->url;

						push (@{$json_site->{rooms}}, $json_room);
					}

					$room_strike_sth->execute($site->id, $tourn->id);

					while (
						my ($rs_id, $rs_type, $rs_start, $rs_end, $rs_room,
							$rs_event, $rs_tourn, $rs_entry, $rs_judge
						) = $room_strike_sth->fetchrow_array()
					) {

						my $room_strike = {
							id   => $rs_id,
							tag  => $rs_type,
							room => $rs_room
						};

						$room_strike->{start} = $rs_start if $rs_start;
						$room_strike->{end} = $rs_end if $rs_end;
						$room_strike->{event} = $rs_event if $rs_event;
						$room_strike->{entry} = $rs_entry if $rs_entry;
						$room_strike->{judge} = $rs_judge if $rs_judge;

						push @{$json_site->{blocks}}, $room_strike;
					}
				}

				# ROOM POOLS RPOOLS
				my %rpools;
				$rpool_sth->execute($tourn->id);

				while(
					my (
						$rpool_id,
						$rpool_name,
						$room_id
					) = $rpool_sth->fetchrow_array()
				) {

					my $json_rpool = $rpools{$rpool_id};

					unless ($json_rpool) {
						$json_rpool = {
							id     => $rpool_id,
							name   => $rpool_name
						};
						$rpools{$rpool_id} = $json_rpool;
						push @{$json_tourn->{"room_pools"}}, $json_rpool;
					}
					push @{$json_rpool->{"rooms"}}, $room_id;
				}

				$rpool_round_sth->execute($tourn->id);

				while (
					my (
						$rpool, $round
					) = $rpool_round_sth->fetchrow_array()
				) {

					my $rpool = $rpools{$rpool};

					if ($rpool) {
						push @{$rpool->{rounds}}, $round;
					}
				}
			}

			# WEEKENDS
			foreach my $weekend ($tourn->weekends) {

				my $json_weekend = {
					id              => $weekend->id,
					name            => $weekend->name,
					city            => $weekend->city,
					state           => $weekend->state,
					site            => $weekend->site->id,
					start           => $weekend->start->datetime(),
					end             => $weekend->end->datetime(),
					reg_start       => $weekend->reg_start->datetime(),
					reg_end         => $weekend->reg_end->datetime(),
					freeze_deadline => $weekend->freeze_deadline->datetime(),
					drop_deadline   => $weekend->drop_deadline->datetime(),
					judge_deadline  => $weekend->judge_deadline->datetime(),
					fine_deadline   => $weekend->fine_deadline->datetime(),
				};

				push @{$json_tourn->{weekends}}, $json_weekend;
			}
		}
	}

	my $limit;

	if ($json_tourn->{round_only}) {
		$limit = " and round.id = ".$json_tourn->{round_only};
	}

	my $score_sth = $dbh->prepare("
		select
			score.id, score.tag, score.student, score.value, score.speech,
				score.position, score.topic, score.content,
			ballot.id, ballot.panel, ballot.judge, ballot.entry, ballot.bye,
				ballot.judge_started, ballot.started_by,
				ballot.forfeit, ballot.side, ballot.speakerorder, ballot.audit, ballot.chair,
			entry.code, entry.name, judge.code, judge.last, judge.first,
			panel.id, panel.letter, panel.round, panel.room, panel.bye, panel.flight, panel.bracket,
				panel.publish,
			room.name,
			round.id, round.name, round.event, round.flighted, round.protocol, protocol.name,
				round.label, round.type, round.timeslot, round.site,
				round.published, round.post_primary, round.post_secondary, round.post_feedback, round.created_at, round.start_time,
				runoff.id

			from (round)

			left join panel on panel.round = round.id
			left join room on panel.room = room.id
			left join ballot on ballot.panel = panel.id
			left join score on score.ballot = ballot.id
			left join round runoff on runoff.id = round.runoff
			left join protocol on protocol.id = round.protocol

			left join entry on ballot.entry = entry.id
			left join judge on ballot.judge = judge.id

			where round.event = ?
			$limit
	");

	my $cs_sth = $dbh->prepare("
		select
			category_setting.category, category_setting.id, category_setting.tag,
			category_setting.value, category_setting.value_date, category_setting.value_text
		from category_setting

		where category_setting.category = ?
	");

	my $ps_sth = $dbh->prepare("
		select
			panel_setting.panel, panel_setting.id, panel_setting.tag,
			panel_setting.value, panel_setting.value_date, panel_setting.value_text
		from panel_setting

		where panel_setting.panel = ?
	");

	my $rs_sth = $dbh->prepare("
		select
			round_setting.round, round_setting.id, round_setting.tag,
			round_setting.value, round_setting.value_date, round_setting.value_text
		from round_setting

		where round_setting.round = ?
	");

	my $cj_sth = $dbh->prepare("
		select
			judge.id, judge_setting.id, judge_setting.tag,
			judge_setting.value, judge_setting.value_date, judge_setting.value_text
		from (judge, judge_setting)

		where judge.category = ?
			and judge.id = judge_setting.judge
	");

	my $sj_sth = $dbh->prepare("
		select
			judge.id, judge_setting.id, judge_setting.tag,
			judge_setting.value, judge_setting.value_date, judge_setting.value_text
		from (judge, judge_setting)

		where judge.school = ?
			and judge.id = judge_setting.judge
	");

	my $judge_sth = $dbh->prepare("
		select
			judge.id, judge.first, judge.middle, judge.last, judge.person,
			judge.code, judge.ada, judge.active, judge.obligation, judge.hired,
			judge.alt_category, judge.covers, judge.chapter_judge,
			judge.school,
			person.id, person.email, person.phone

		from judge
		left join person on person.id = judge.person

		where judge.category = ?
		group by judge.id
	");

	my $school_judge_sth = $dbh->prepare("
		select
			judge.id, judge.first, judge.middle, judge.last, judge.person,
			judge.code, judge.ada, judge.active, judge.obligation, judge.hired,
			judge.category,
			judge.alt_category, judge.covers, judge.chapter_judge,
			judge.school,
			person.id, person.email, person.phone

		from judge
		left join person on person.id = judge.person
		where judge.school = ?
	");

	my $jpool_sth = $dbh->prepare("
		select
			jpool.id,
			jpool_judge.judge,
			jpool.name, jpool.category, jpool.site, jpool.parent
		from (jpool)
			left join jpool_judge on jpool.id = jpool_judge.jpool
		where jpool.category = ?
	");

	my $jpool_setting_sth = $dbh->prepare("
		select
			setting.id, setting.tag, setting.value, setting.value_text, setting.value_date, setting.jpool
		from (jpool_setting setting, jpool)
		where jpool.category = ?
			and jpool.id = setting.jpool
	");

	my $jpool_round_sth = $dbh->prepare("
		select jpool_round.jpool
		from jpool_round, jpool
		where jpool_round.jpool = jpool.id
			and jpool.category = ?
	");

	my $results_sth = $dbh->prepare("
		select
			rv.id, rv.value, rv.result_key, rv.priority, rv.protocol,
			rk.id, rk.tag, rk.description, rk.no_sort, rk.sort_desc,
			result.id, result.rank, result.place, result.percentile,
				result.entry, result.student, result.school, result.round,
			rs.id, rs.label, rs.bracket, rs.published, rs.coach, rs.tourn, rs.event, rs.generated

			from result_set rs

			left join result on result.result_set = rs.id
			left join result_value rv on rv.result = result.id
			left join result_key rk on rv.result_key = rk.id

			where rs.event = ?
	");


	# CATEGORY CATEGORIES
	unless ($json_tourn->{school_only}) {

		foreach my $category (@categories) {

			my %judges;
			my %jpools;

			next if $json_tourn->{category_only} && ($category->id != $json_tourn->{category_only});

			my $category_id = $category->id;

			# next unless $category_events{$category_id};

			my $json_category = {
				id       => $category->id,
				name     => $category->name,
				abbr     => $category->abbr,
			};

			push (@{$json_tourn->{categories}}, $json_category);

			unless (
				$json_tourn->{event_only}
				|| $json_tourn->{round_only}
				|| $json_tourn->{public}
				|| $ARGS{"rounds_only"}
			) {

				$json_category->{settings} = raw_value($cs_sth, $category_id);

				# RATINGS PREFS RATING TIERS
				foreach my $rt ($category->rating_tiers) {
					my $json_rating = {
						id          => $rt->id,
						tag         => $rt->type,
						name        => $rt->name,
						strike      => $rt->strike,
						conflict    => $rt->conflict,
						description => $rt->description,
						min         => $rt->min,
						max         => $rt->max,
						start       => $rt->start
					};

					push @{$json_category->{'rating_tiers'}}, $json_rating;
				}

				# RATINGS PREFS RATING TIERS
				foreach my $rs ($category->rating_subsets) {
					my $json_subset = {
						id   => $rs->id,
						name => $rs->name,
					};
					push @{$json_category->{'rating_subsets'}}, $json_subset;
				}

				# JUDGES
				$judge_sth->execute($category_id);

				my %done_judge;

				while (
					my (
						$judge_id, $judge_first, $judge_middle, $judge_last,
						$judge_person, $judge_code, $judge_ada, $judge_active,
						$judge_obligation, $judge_hired,
						$judge_alt_category,
						$judge_covers, $judge_chapter_judge, $judge_school,
						$person_id, $person_email, $person_phone
					) = $judge_sth->fetchrow_array()
				) {

					next if $done_judge{$judge_id}++;

					my $json_judge = {
						id       => $judge_id,
						first    => $judge_first,
						last     => $judge_last
					};

					$schools_used{$judge_school}++ if $judge_school;
					$person_phone =~ s/[\D_]//g;

					$json_judge->{school}        = $judge_school if $judge_school;
					$json_judge->{active}        = $judge_active;
					$json_judge->{ada}           = $judge_ada unless $json_tourn->{public};
					$json_judge->{email}         = lc($person_email) if $person_email;
					$json_judge->{phone}         = $person_phone if $person_phone;
					$json_judge->{person}        = $person_id if $person_id;
					$json_judge->{obligation}    = $judge_obligation if $judge_obligation;
					$json_judge->{hired}         = $judge_hired if $judge_hired;
					$json_judge->{alt_category}  = $judge_alt_category if $judge_alt_category;
					$json_judge->{covers}        = $judge_covers if $judge_covers;
					$json_judge->{chapter_judge} = $judge_chapter_judge if $judge_chapter_judge;

					$judges{$judge_id} = $json_judge;
					push @{$json_category->{judges}}, $json_judge;
				}

				$judge_sth->finish();
				$cj_sth->execute($category_id);

				while(
					my (
						$judge_id, $js_id, $js_tag, $js_value, $js_value_date, $js_value_text
					) = $cj_sth->fetchrow_array()
				) {

					my $meta;

					if ($js_value eq "date") {
						$js_value_date =~ s/ /T/g;
						$js_value = $js_value_date;
						$meta = "date";
					} elsif ($js_value eq "text" || $js_value eq "json") {
						$meta = $js_value;
						$js_value = Tab::Utils::compress($js_value_text);
					}

					my $js_setting = {
						tag   => $js_tag,
						value => $js_value
					};

					$js_setting->{meta} = $meta if $meta;
					push @{$judges{$judge_id}->{settings}}, $js_setting;
				}

				$cj_sth->finish();

				# JUDGE POOLS JPOOLS

				$jpool_sth->execute($category_id);

				while(
					my (
						$jpool_id,
						$judge_id,
						$jpool_name, $jpool_category, $jpool_site, $jpool_parent
					) = $jpool_sth->fetchrow_array()
				) {

					my $json_jpool = $jpools{$jpool_id};

					unless ($json_jpool) {
						$json_jpool = {
							id     => $jpool_id,
							name   => $jpool_name,
							site   => $jpool_site,
							parent => $jpool_parent
						};
						$jpools{$jpool_id} = $json_jpool;
					}

					push @{$jpools{$jpool_id}->{judges}}, $judge_id;
				}

				foreach my $key (keys %jpools) {
					push @{$json_category->{jpools}}, $jpools{$key};
				}

				$jpool_setting_sth->execute($category_id);

				while (
					my (
						$setting_id, $setting_tag, $setting_value,
						$setting_value_text, $setting_value_date, $setting_jpool
					) = $jpool_setting_sth->fetchrow_array()
				) {

					my $jpool = $jpools{$setting_jpool};

					if ($jpool) {

						my $meta = "string";

						if ($setting_value eq "date") {
							$setting_value_date =~ s/ /T/g;
							$setting_value = $setting_value_date."Z";
							$meta = "date";
						} elsif ($setting_value eq "text" || $setting_value eq "json") {
							$meta = $setting_value;
							$setting_value = Tab::Utils::compress($setting_value_text);
						}

						my $jpool_setting = {
							tag   => $setting_tag,
							value => $setting_value
						};

						$jpool_setting->{meta} = $meta if $meta;
						push @{$jpool->{settings}}, $jpool_setting;
					}
				}

				# JPOOL ROUNDS
				$jpool_round_sth->execute($category->id);

				while (
					my (
						$jpool, $round
					) = $jpool_round_sth->fetchrow_array()
				) {
					my $jpool = $jpools{$jpool};
					if ($jpool) {
						push @{$jpool->{rounds}}, $round;
					}
				}
			}
			my %event_settings;

			unless (
				$json_tourn->{public}
				|| $json_tourn->{round_only}
				|| $ARGS{rounds_only}
			) {

				my $event_setting_sth = $dbh->prepare("
					select
						setting.id, setting.tag, setting.value, setting.value_text, setting.value_date, setting.event
					from (event_setting setting, event)
					where event.category = ?
						and event.id = setting.event
				");

				$event_setting_sth->execute($category_id);
				my $ess = $event_setting_sth->fetchall_hash();

				foreach my $es (@{$ess}) {

					my $meta = "string";

					if ($es->{value} eq "date") {
						$es->{value_date} =~ s/ /T/g;
						$es->{value} = $es->{value_date}."Z";
						$meta = "date";
					} elsif ($es->{value} eq "text" || $es->{value} eq "json") {
						$meta = $es->{value};
						$es->{value} = Tab::Utils::compress($es->{value_text});
					}

					my $event_setting = {
						tag   => $es->{tag},
						meta  => $meta,
						value => $es->{value}
					};

					push @{$event_settings{$es->{event}}}, $event_setting;
				}
			}

			# EVENTS
			foreach my $event (@{$category_events{$category_id}}) {

				my $json_event = {
					id   => $event->id,
					name => $event->name,
					abbr => $event->abbr,
					type => $event->type,
					fee  => $event->fee
				};

				unless ($ARGS{"rounds_only"}) {
					foreach my $key ("pattern", "rating_subset") {
						$json_event->{$key} = $event->$key if $event->$key;
					}
				}

				unless (
					$json_tourn->{public}
					|| $json_tourn->{round_only}
					|| $ARGS{rounds_only}
				) {
					$json_event->{settings} = $event_settings{$event->id};
				}

				push @{$json_category->{"events"}}, $json_event;

				# EVENT ENTRIES

				# If we are downloading only one event or category, then we
				# need the entries here as well.

				if (
					(
						$json_tourn->{event_only}
						|| $json_tourn->{category_only}
					)
					&& (not defined $ARGS{"rounds_only"})
					&& (not defined $json_tourn->{public})
				) {

					$event_entries_sth->execute($event->id);

					while (
						my (

							$entry_student_id,
							$student_id, $student_first, $student_middle, $student_last,
							$student_grad_year, $student_nsda, $student_phonetic, $student_chapter, $student_school,
							$entry_id, $entry_code, $entry_name, $entry_event, $entry_school, $entry_chapter,
							$entry_ada, $entry_active, $entry_dropped, $entry_waitlist, $entry_unconfirmed,
							$entry_created_at,
							$entry_registered_by

						) = $event_entries_sth->fetchrow_array()
					) {

						my $json_entry;

						if ($entries{$entry_id}) {

							$json_entry = $entries{$entry_id};

						} else {

							$json_entry = {
								id            => $entry_id,
								school        => $entry_school,
								event         => $entry_event,
								code          => $entry_code,
								name          => $entry_name,
								created_at    => $entry_created_at,
								registered_by => $entry_registered_by
							};

							if ($student_chapter != $entry_chapter) {
								$json_entry->{hybrid} = $student_school;
							}

							$json_entry->{ada}         = $entry_ada unless $json_tourn->{public};
							$json_entry->{active}      = $entry_active;
							$json_entry->{dropped}     = $entry_dropped;
							$json_entry->{waitlist}    = $entry_waitlist;
							$json_entry->{unconfirmed} = $entry_unconfirmed;
							$json_entry->{settings}    = raw_value($es_sth, $entry_id);
						}

						$entries{$entry_id} = $json_entry;
						push (@{$json_event->{entries}}, $json_entry);

						my $json_student = {
							id        => $student_id,
							chapter   => $student_chapter,
							first     => $student_first,
							last      => $student_last
						};

						$json_student->{nsda}      = $student_nsda if $student_nsda;
						$json_student->{grad_year} = $student_grad_year if $student_grad_year;
						$json_student->{middle}    = $student_middle if $student_middle;

						if ($student_chapter != $entry_chapter) {
							$json_student->{hybrid} = $student_school;
						}

						push @{$json_entry->{students}}, $json_student;
					}

					$event_entries_sth->finish();

					# EVENT QUALS EVENT QUALIFIERS
					# Qualifying records for this tournament.

					$event_quals_sth->execute($event_id);

					while (
						my ($qual_id, $qual_name, $qual_result, $qual_entry) = $event_quals_sth->fetchrow_array()
					) {

						my $json_qual = {
							id     => $qual_id,
							name   => $qual_name,
							result => $qual_result
						};

						push @{$entries{$qual_entry}->{qualifiers}}, $json_qual;
					}

					$event_quals_sth->finish();

				}

				unless ($json_tourn->{school_only} || $ARGS{"rounds_only"}) {

					unless ($json_tourn->{public}) {

						# STRIKES and PREFS

						if ($json_tourn->{event_only}) {

							# If we're doing only one event then the strikes and prefs are
							# stored under the ENTRY because there are no JUDGES

							$event_strikes_sth->execute($event->id);

							while (
								my (
									$strike_id, $strike_type,
									$strike_judge, $strike_entry, $strike_school,
									$strike_registrant, $strike_conflict, $strike_conflictee
								) = $event_strikes_sth->fetchrow_array()
							) {

								my $json_strike = {
									id         => $strike_id,
									tag        => $strike_type,
									conflict   => $strike_conflict,
									registrant => $strike_registrant,
									conflictee => $strike_conflictee
								};

								$json_strike->{judge} = $strike_judge if $strike_judge;
								$json_strike->{school} = $strike_school if $strike_school;

								push @{$entries{$strike_entry}{"strikes"}}, $json_strike;

							}

							$event_ratings_sth->execute($event->id);

							while (
								my (
									$rating_id, $rating_type,$rating_entry, $rating_judge,
									$rating_entered,
									$rating_ordinal, $rating_percentile,
									$rating_rating_tier, $rating_tier_name, $rating_rating_subset,
									$rating_side
								) = $event_ratings_sth->fetchrow_array()
							) {

								$rating_side = 0 unless $rating_side;
								next if $filter{$rating_entry}{$rating_judge}{$rating_side}++;

								my $json_rating = {
									id    => $rating_id,
									judge => $rating_judge
								};

								if ($rating_type eq 'coach') {
									$json_rating->{tag} = 'coach';
								}

								$json_rating->{ordinal}          = $rating_ordinal;
								$json_rating->{percentile}       = $rating_percentile;
								$json_rating->{rating_tier}      = $rating_rating_tier;
								$json_rating->{rating_tier_name} = $rating_tier_name;
								$json_rating->{rating_subset}    = $rating_rating_subset;
								$json_rating->{side}             = $rating_side;

								unless ($ARGS{"skip_content"}) {
									$json_rating->{entered} = $rating_entered;
								}

								foreach my $key (keys %{$json_rating}) {
									delete $json_rating->{$key} unless $json_rating->{$key};
								}

								push @{$entries{$rating_entry}{"ratings"}}, $json_rating;
							}

						} else {

							# Otherwise, if we're downloading a whole category
							# or tournament, just leave the ratings with the
							# JUDGES ONLY.

							$category_strikes_sth->execute($category->id);

							while (
								my (
									$strike_id, $strike_type, $strike_start, $strike_end,
									$strike_judge, $strike_entry, $strike_event, $strike_school,
									$strike_region, $strike_district, $strike_timeslot, $strike_shift,
									$strike_registrant, $strike_conflict, $strike_conflictee
								) = $category_strikes_sth->fetchrow_array()
							) {

								my $json_strike = {
									id         => $strike_id,
									tag        => $strike_type,
									conflict   => $strike_conflict,
									registrant => $strike_registrant,
									conflictee => $strike_conflictee,
								};

								$json_strike->{start} = $strike_start if $strike_start;
								$json_strike->{end} = $strike_end if $strike_end;
								$json_strike->{entry} = $strike_entry if $strike_entry;
								$json_strike->{event} = $strike_event if $strike_event;
								$json_strike->{school} = $strike_school if $strike_school;
								$json_strike->{region} = $strike_region if $strike_region;
								$json_strike->{district} = $strike_district if $strike_district;
								$json_strike->{timeslot} = $strike_timeslot if $strike_timeslot;
								$json_strike->{shift} = $strike_shift if $strike_shift;

								push @{$judges{$strike_judge}{strikes}},  $json_strike;

							}

							$category_ratings_sth->execute($category->id);

							while (
								my (
									$rating_id, $rating_type, $rating_entry, $rating_judge,
									$rating_entered,
									$rating_ordinal, $rating_percentile,
									$rating_rating_tier, $rating_tier_name, $rating_rating_subset,
									$rating_side
								) = $category_ratings_sth->fetchrow_array()
							) {

								$rating_side = 0 unless $rating_side;
								next if $filter{$rating_entry}{$rating_judge}{$rating_side}++;

								my $json_rating = {
									id    => $rating_id,
									entry => $rating_entry
								};

								if ($rating_type eq 'coach') {
									$json_rating->{tag} = 'coach';
								}

								unless ($ARGS{"skip_content"}) {
									$json_rating->{entered}     = $rating_entered;
								}
								$json_rating->{ordinal}          = $rating_ordinal;
								$json_rating->{percentile}       = $rating_percentile;
								$json_rating->{rating_tier}      = $rating_rating_tier;
								$json_rating->{rating_tier_name} = $rating_tier_name;
								$json_rating->{rating_subset}    = $rating_rating_subset;
								$json_rating->{side}             = $rating_side;

								foreach my $key (keys %{$json_rating}) {
									delete $json_rating->{$key} unless $json_rating->{$key};
								}

								push @{$judges{$rating_judge}{"ratings"}}, $json_rating;
							}
						}
					}
				}

				my %rounds;
				my %sections;
				my %ballots;

				$score_sth->execute($event->id);

				# ROUNDS BALLOTS AND SCORES
				while (
					my (
						$score_id, $score_tag, $score_student, $score_value, $score_speech,
						$score_position, $score_topic, $score_content,
						$ballot_id, $ballot_panel, $ballot_judge, $ballot_entry, $ballot_bye,
							$ballot_judge_started, $started_by,
							$ballot_forfeit, $ballot_side, $ballot_speakerorder, $ballot_audit, $ballot_chair,
						$entry_code, $entry_name, $judge_code, $judge_last, $judge_first,
						$panel_id, $panel_letter, $panel_round, $panel_room, $panel_bye, $panel_flight,
							$panel_bracket, $panel_publish,
						$room_name,
						$round_id, $round_name, $round_event, $round_flighted, $round_protocol, $round_protocol_name,
							$round_label, $round_type, $round_timeslot, $round_site,
							$round_published, $round_primary, $round_secondary, $round_feedback, $round_created, $round_start_time,
						$runoff_id
					) = $score_sth->fetchrow_array()
				) {

					next if ($json_tourn->{public}) && $round_published < 1;

					my $json_round;

					if ($rounds{$round_id}) {
						$json_round = $rounds{$round_id};
					} else {
						$json_round = {
							id             => $round_id,
							type           => $round_type,
							name           => $round_name,
							published      => $round_published,
							post_primary   => $round_primary,
							post_secondary => $round_secondary,
							post_feedback  => $round_feedback,
							timeslot       => $round_timeslot,
							created_at     => $round_created,
							start_time     => $round_start_time,
							site           => $round_site,
							protocol       => $round_protocol,
							protocol_name  => $round_protocol_name
						};

						$json_round->{label}  = $round_label if $round_label;
						$json_round->{flights} = $round_flighted if $round_flighted;
						$json_round->{runoff}  = $runoff_id if $runoff_id;

						if ($json_tourn->{public}) {

							delete $json_round->{published};
							delete $json_round->{post_primary};
							delete $json_round->{post_secondary};
							delete $json_round->{post_feedback};
							delete $json_round->{timeslot};
							delete $json_round->{created_at};
							delete $json_round->{site};
							delete $json_round->{protocol};

						} else {

							# ROUND SETTINGS
							$json_round->{settings} = raw_value($rs_sth, $round_id);
						}

						$rounds{$round_id} = $json_round;
						push @{$json_event->{rounds}}, $json_round;
					}

					# SECTIONS PANELS
					if ($panel_id) {

						my $json_section;

						if ($sections{$panel_id}) {

							$json_section = $sections{$panel_id};

						} else {

							$json_section = {
								id      => $panel_id,
								round   => $round_id,
								room    => $panel_room,
								letter  => $panel_letter
							};

							$json_section->{bye}     = 1 if $panel_bye;
							$json_section->{flight}  = $panel_flight if $panel_flight;

							if ($json_tourn->{public}) {
								if ($room_name) {
									$json_section->{room} = $room_name;
								} else {
									$json_section->{room} = "NONE";
								}
							} else {
								$json_section->{publish} = 1 if $panel_publish;
								$json_section->{bracket} = $panel_bracket if $panel_bracket;
								$json_section->{settings} = raw_value($ps_sth, $panel_id);
							}

							$sections{$panel_id} = $json_section;
							push @{$json_round->{"sections"}}, $json_section;
						}

						if ($ballot_id) {

							my $json_ballot;

							# BALLOTS
							if ($ballots{$ballot_id}) {

								$json_ballot = $ballots{$ballot_id};

							} else {

								$json_ballot = {
									id    => $ballot_id,
									panel => $panel_id,
									entry => $ballot_entry
								};

								$json_ballot->{judge_started} = $ballot_judge_started if $ballot_judge_started;
								$json_ballot->{started_by}    = $started_by if $started_by;
								$json_ballot->{side}          = $ballot_side if $ballot_side;
								$json_ballot->{speakerorder}  = $ballot_speakerorder if $ballot_speakerorder;

								if ($json_tourn->{public}) {

									if ($round_published != 2) {

										$json_ballot->{judge}      = $ballot_judge if $ballot_judge;
										$json_ballot->{judge_code} = $judge_code if $judge_code;
										$json_ballot->{chair}      = $ballot_chair if $ballot_chair;

										unless ($json_tourn->{anonymous}) {
											$json_ballot->{judge_first} = $judge_first if $judge_first;
											$json_ballot->{judge_last}  = $judge_last if $judge_last;
										}
									}

									$json_ballot->{entry_code} = $entry_code if $entry_code;

									unless ($json_tourn->{anonymous}) {
										$json_ballot->{entry_name}  = $entry_name if $entry_name;
									}

									if ($round_primary) {
										$json_ballot->{bye}     = $ballot_bye if $ballot_bye;
										$json_ballot->{forfeit} = $ballot_forfeit if $ballot_forfeit;
									}

								} else {

									$json_ballot->{judge}   = $ballot_judge if $ballot_judge;
									$json_ballot->{audit}   = $ballot_audit;
									$json_ballot->{chair}   = $ballot_chair;
									$json_ballot->{bye}     = $ballot_bye if $ballot_bye;
									$json_ballot->{forfeit} = $ballot_forfeit if $ballot_forfeit;
								}

								$ballots{$ballot_id} = $json_ballot;
								push @{$json_section->{"ballots"}}, $json_ballot;
							}

							#Public downloads get no strikes
							if (
								$json_tourn->{"public"}
								&& $score_tag eq "strike"
							) {
								next;
							}

							#Public downloads get zero results that aren't published
							if (
								$json_tourn->{"public"}
								&& $round_primary < 3
							) {
								next;
							}

							#Public downloads get no RFDs or comments
							if (
								$json_tourn->{"public"}
								&& $score_tag ne "rank"
								&& $score_tag ne "point"
								&& $score_tag ne "refute"
								&& $score_tag ne "winloss"
							) {
								next;
							}

							# Public downloads for win/loss only get only that.

							if ($event->type eq "debate" || $event->type eq "wsdc") {

								if (
									$json_tourn->{"public"}
									&& $round_secondary < 3
									&& $score_tag ne "winloss"
								) {
									next;
								}

							} else {

								if (
									$json_tourn->{"public"}
									&& $round_secondary < 3
									&& $score_tag ne "rank"
								) {
									next;
								}
							}

							# SCORES
							if ($score_id) {

								my $json_score = {
									id    => $score_id,
									tag   => $score_tag,
									value => $score_value
								};

								$json_score->{speech}  = $score_speech if $score_speech;
								$json_score->{speaker} = $score_student if $score_student;

								unless ($json_tourn->{"public"}) {
									$json_score->{topic}    = $score_topic if $score_topic;
									$json_score->{position} = $score_position if $score_position;
									$json_score->{content}  = $score_content if $score_content;
								}
								push @{$json_ballot->{"scores"}}, $json_score;
							}
						}
					}
				}

				$score_sth->finish();

				# Student Vote
				$sv_sth->execute($event->id);

				while (
					my (
						$sv_id, $sv_panel, $sv_tag, $sv_value, $sv_voter, $sv_entry, $sv_entered_by, $sv_entered_at,
						$round_id
					) = $sv_sth->fetchrow_array()
				) {

					my $json_round = $rounds{$round_id};
					my $json_section = $sections{$sv_panel};

					if ($json_round) {

						my $json_sv = {
							id         => $sv_id,
							tag        => $sv_tag,
							value      => $sv_value,
							voter      => $sv_voter,
							entry      => $sv_entry,
							entered_by => $sv_entered_by,
							entered_at => $sv_entered_at
						};

						push @{$json_section->{'student_votes'}}, $json_sv;
					}
				}

				unless ($ARGS{"skip_content"} || $json_tourn->{round_only}) {

					# RESULTS SHEETS
					$results_sth->execute($event->id);

					my %results;
					my %result_sets;
					my %done_key;

					while(
						my (
							$rv_id, $rv_value, $rv_result_key, $rv_priority, $rv_protocol,
							$rk_id, $rk_tag, $rk_description, $rk_no_sort, $rk_sort_desc,
							$result_id, $result_rank, $result_place, $result_percentile,
								$result_entry, $result_student, $result_school, $result_round,
							$rs_id, $rs_label, $rs_bracket, $rs_published, $rs_coach,
								$rs_tourn, $rs_event, $rs_generated
						) = $results_sth->fetchrow_array()
					) {

						if ($json_tourn->{"public"} && ($rs_published != 1)) {
							next;
						}

						my $json_rs;

						if ($result_sets{$rs_id}) {

							$json_rs = $result_sets{$rs_id};

						} else {

							$json_rs = {
								label     => $rs_label,
								bracket   => $rs_bracket,
								published => $rs_published,
								coach     => $rs_coach,
								generated => $rs_generated
							};

							push @{$json_event->{result_sets}}, $json_rs;
							$result_sets{$rs_id} = $json_rs;
						}

						my $json_result;

						if ($results{$result_id}) {

							$json_result = $results{$result_id};

						} else {

							$json_result = {
								rank       => $result_rank,
								place      => $result_place,
								percentile => $result_percentile,
								entry      => $result_entry,
								student    => $result_student,
								school     => $result_school,
								round      => $result_round
							};

							foreach my $key (keys %{$json_result}) {
								delete $json_result->{$key} unless $json_result->{$key};
							}

							push @{$json_rs->{results}}, $json_result;
							$results{$result_id} = $json_result;
						}

						unless ($done_key{$rk_id}++) {

							my $json_key = {
								id          => $rk_id,
								tag         => $rk_tag,
								description => $rk_description,
								no_sort     => $rk_no_sort,
								sort_desc   => $rk_sort_desc
							};

							push @{$json_rs->{result_keys}}, $json_key;

						}

						my $json_rv = {
							result_key   => $rk_id,
							value        => $rv_value,
							priority     => $rv_priority,
							protocol => $rv_protocol
						};

						foreach my $key (keys %{$json_rv}) {
							delete $json_rv->{$key} unless $json_rv->{$key};
						}

						push @{$json_result->{"values"}}, $json_rv;

					}
				}
			}
		}
	}

	my $student_sth = $dbh->prepare("
		select
			entry_student.id,
			student.id, student.first, student.middle, student.last, student.grad_year,
				student.nsda, student.phonetic, student.chapter,
			entry.id, entry.code, entry.name, entry.event,
				entry.school, entry.ada, entry.active, entry.dropped, entry.waitlist, entry.unconfirmed,
				entry.created_at,
				entry.registered_by,
			school.id, school.name, school.chapter, school.code,
				school.onsite, school.state, school.region, school.district,
			chapter.id, chapter.nsda, pairing_seed.value,
			hybrid.id, hybrid.type, hybrid.school

		from (entry, school, chapter, event)

			left join entry_student
				on entry_student.entry = entry.id

			left join student
				on student.id = entry_student.student

			left join entry_setting pairing_seed
				on pairing_seed.tag = 'pairing_seed'
				and pairing_seed.entry = entry.id

			left join strike hybrid
				on hybrid.entry = entry.id
				and hybrid.type = 'hybrid'

		where event.tourn = ?
			and event.id = entry.event
			and entry.school = school.id
			and school.chapter = chapter.id
		group by entry.id, entry_student.student

	");

	my $ss_sth = $dbh->prepare("
		select
			school.id, school_setting.id, school_setting.tag,
			school_setting.value, school_setting.value_date, school_setting.value_text
		from (school, school_setting)

		where school.id = ?
			and school.id = school_setting.school
	");

	my $purchase_sth = $dbh->prepare("
		select purchase.id, purchase.school,
			purchase.quantity, purchase.placed, purchase.fulfilled,
				purchase.concession, purchase.invoice,
			cpo.concession_option
		from (concession_purchase purchase, school)
			left join concession_purchase_option cpo on cpo.concession_purchase = purchase.id
		where purchase.school = school.id
		and school.tourn = ?
	");

	my $invoice_sth = $dbh->prepare("
		select invoice.id,
			invoice.blusynergy, invoice.blu_number,
			invoice.total, invoice.paid,
			invoice.school, invoice.details
		from (invoice, school)
		where invoice.school = school.id
		and school.tourn = ?
	");

	unless (
		$json_tourn->{category_only}
		|| $json_tourn->{event_only}
		|| $json_tourn->{round_only}
		|| $json_tourn->{public}
	) {

		$student_sth->execute($tourn->id);

		my %judges;

		my $edina_counter;

		while (
			my (
				$entry_student_id,
				$student_id, $student_first, $student_middle, $student_last, $student_grad_year,
				$student_nsda, $student_phonetic, $student_chapter,
				$entry_id, $entry_code, $entry_name, $entry_event, $entry_school,
				$entry_ada, $entry_active, $entry_dropped, $entry_waitlist, $entry_unconfirmed, $entry_created_at,
				$entry_registered_by,
				$this_school_id, $school_name, $school_chapter, $school_code, $school_onsite,
				$school_state, $school_region, $school_district,
				$chapter_id, $chapter_nsda, $entry_seed,
				$hybrid_id, $hybrid_type, $hybrid_school
			) = $student_sth->fetchrow_array()
		) {

			if ($json_tourn->{school_only}) {
				next if ($json_tourn->{school_only} != $entry_school);
				$file_name = $school_name;
				$file_name =~ s/[\W_]//g;;
			}

			my $json_school;

			# SCHOOLS CHAPTERS

			if ($schools{$entry_school}) {

				$json_school = $schools{$entry_school};

			} else {

				$json_school = {
					id      => $entry_school,
					name    => $school_name
				};

				$json_school->{code}     = $school_code if $school_code;
				$json_school->{state}    = $school_state if $school_state;
				$json_school->{chapter}  = $school_chapter if $school_chapter;
				$json_school->{onsite}   = $school_onsite if $school_onsite;
				$json_school->{nsda}     = $chapter_nsda if $chapter_nsda;
				$json_school->{region}   = $school_region if $school_region;
				$json_school->{district} = $school_district if $school_district;
				$json_school->{settings} = raw_value($ss_sth, $entry_school);

				$schools{$entry_school} = $json_school;
				push (@{$json_tourn->{schools}}, $json_school);
			}

			if ($entry_school == 706566) {
				$edina_counter++;
			}

			# SCHOOL ENTRY SCHOOL ENTRIES
			my $json_entry;

			if ($entries{$entry_id}) {

				$json_entry = $entries{$entry_id};

			} else {

				$json_entry = {
					id     => $entry_id,
					school => $entry_school,
					event  => $entry_event,
					code   => $entry_code,
					name   => $entry_name
				};

				$json_entry->{ada}           = $entry_ada;
				$json_entry->{active}        = $entry_active;
				$json_entry->{hybrid}        = $hybrid_school;
				$json_entry->{dropped}       = $entry_dropped;
				$json_entry->{waitlist}      = $entry_waitlist;
				$json_entry->{unconfirmed}   = $entry_unconfirmed;
				$json_entry->{created_at}    = $entry_created_at;
				$json_entry->{registered_by} = $entry_registered_by;
				$json_entry->{settings}      = raw_value($es_sth, $entry_id);

				$entries{$entry_id} = $json_entry;
				push (@{$json_school->{entries}}, $json_entry);
			}

			# STUDENTS COMPETITORS
			my $json_student;

			if ($student_id && $students{$student_id}) {

				$json_student = $students{$student_id};

			} elsif ($student_id) {

				$json_student = {
					id        => $student_id,
					chapter   => $student_chapter,
					first     => $student_first,
					last      => $student_last
				};

				$json_student->{nsda}      = $student_nsda if $student_nsda;
				$json_student->{grad_year} = $student_grad_year if $student_grad_year;
				$json_student->{middle}    = $student_middle if $student_middle;

				push (@{$json_school->{students}}, $json_student);
				$students{$student_id} = $json_student;
			}

			if ($student_id) {
				push @{$json_entry->{students}}, $student_id;
			}
		}

		$student_sth->finish();

		if ($json_tourn->{school_only}) {

			# The below data are only loaded into the School JSON file if this
			# is a school only download.  Otherwise, entry qual info goes under
			# the events, strikes and prefs are under the judges

			#SCHOOL QUALS SCHOOL QUALIFIERS Qualifying records for this tournament.

			$school_quals_sth->execute($json_tourn->{school_only});

			while (
				my ($qual_id, $qual_name, $qual_result, $qual_entry) = $school_quals_sth->fetchrow_array()
			) {

				my $json_qual = {
					id     => $qual_id,
					name   => $qual_name,
					result => $qual_result
				};

				push @{$entries{$qual_entry}->{qualifiers}}, $json_qual;
			}

			$school_quals_sth->finish();

			# SCHOOL STRIKES SCHOOL CONFLICTS
			# School wide strikes and conflicts

			$school_strikes_sth->execute($json_tourn->{school_only});

			while (
				my (
					$strike_id, $strike_type,
					$strike_judge, $strike_entry, $strike_school,
					$strike_registrant, $strike_conflict, $strike_conflictee
				) = $school_strikes_sth->fetchrow_array()
			) {

				my $json_strike = {
					id         => $strike_id,
					tag        => $strike_type,
					judge      => $strike_judge,
					conflict   => $strike_conflict,
					registrant => $strike_registrant,
					conflictee => $strike_conflictee
				};

				push @{$schools{$strike_school}{"strikes"}}, $json_strike;

			}

			$school_entry_strikes_sth->execute($json_tourn->{school_only});

			while (
				my (
					$strike_id, $strike_type,
					$strike_judge, $strike_entry, $strike_school,
					$strike_registrant, $strike_conflict, $strike_conflictee
				) = $school_entry_strikes_sth->fetchrow_array()
			) {

				my $json_strike = {
					id         => $strike_id,
					tag        => $strike_type,
					conflict   => $strike_conflict,
					registrant => $strike_registrant,
					conflictee => $strike_conflictee
				};

				$json_strike->{judge} = $strike_judge if $strike_judge;
				$json_strike->{school} = $strike_school if $strike_school;

				push @{$entries{$strike_entry}{"strikes"}}, $json_strike;

			}

			# If we are downloading a school only then we need to do
			# ratings/strikes for every entry AND every judge connected to the
			# school because this guards for the case that one school's reg got
			# blown away and is being restored.

			$school_entry_ratings_sth->execute($json_tourn->{school_only});

			while (
				my (
					$rating_id, $rating_type, $rating_entry, $rating_judge,
					$rating_entered,
					$rating_ordinal, $rating_percentile,
					$rating_rating_tier, $rating_tier_name, $rating_rating_subset, $rating_side
				) = $school_entry_ratings_sth->fetchrow_array()
			) {

				$rating_side = 0 unless $rating_side;
				next if $filter{$rating_entry}{$rating_judge}{$rating_side}++;

				my $json_rating = {
					id    => $rating_id,
					judge => $rating_judge
				};

				if ($rating_type == 'coach') {
					$json_rating->{tag} = 'coach';
				}

				unless ($ARGS{"skip_content"}) {
					$json_rating->{entered}     = $rating_entered;
				}

				$json_rating->{ordinal}          = $rating_ordinal;
				$json_rating->{percentile}       = $rating_percentile;
				$json_rating->{rating_tier}      = $rating_rating_tier;
				$json_rating->{rating_tier_name} = $rating_tier_name;
				$json_rating->{rating_subset}    = $rating_rating_subset;
				$json_rating->{side}             = $rating_side;

				foreach my $key (keys %{$json_rating}) {
					delete $json_rating->{$key} unless $json_rating->{$key};
				}

				push @{$entries{$rating_entry}{"ratings"}}, $json_rating;
			}

			# SCHOOL JUDGES

			$school_judge_sth->execute($json_tourn->{school_only});

			my $json_school = ${$json_tourn->{schools}}[0];
			my %done_judge;

			while (
				my (
					$judge_id, $judge_first, $judge_middle, $judge_last,
					$judge_person, $judge_code, $judge_ada, $judge_active,
					$judge_obligation, $judge_hired,
					$judge_category, $judge_alt_category,
					$judge_covers, $judge_chapter_judge, $judge_school,
					$person_id, $person_email, $person_phone

				) = $school_judge_sth->fetchrow_array()
			) {

				next if $done_judge{$judge_id}++;

				my $json_judge = {
					id       => $judge_id,
					first    => $judge_first,
					last     => $judge_last,
					category => $judge_category
				};

				$schools_used{$judge_school}++ if $judge_school;

				$person_phone =~ s/[\D_]//g;

				$json_judge->{active}       = $judge_active;
				$json_judge->{ada}          = $judge_ada;
				$json_judge->{email}        = lc($person_email) if $person_email;
				$json_judge->{phone}        = $person_phone if $person_phone;
				$json_judge->{middle}       = $judge_middle if $judge_middle;
				$json_judge->{code}         = $judge_code if $judge_code;
				$json_judge->{person}       = $person_id if $person_id;
				$json_judge->{obligation}   = $judge_obligation if $judge_obligation;
				$json_judge->{hired}        = $judge_hired if $judge_hired;
				$json_judge->{alt_category} = $judge_alt_category if $judge_alt_category;
				$json_judge->{covers}       = $judge_covers if $judge_covers;

				$judges{$judge_id} = $json_judge;

				push @{$json_school->{"judges"}}, $json_judge;
			}

			$school_judge_sth->finish();
			$sj_sth->execute($json_tourn->{school_only});

			while(
				my (
					$judge_id, $js_id, $js_tag, $js_value, $js_value_date, $js_value_text
				) = $sj_sth->fetchrow_array()
			) {

				my $meta;
				if ($js_value eq "date") {
					$js_value_date =~ s/ /T/g;
					$js_value = $js_value_date;
					$meta = "date";
				} elsif ($js_value eq "text") {
					$js_value = Tab::Utils::compress($js_value_text);
					$meta = "text";
				}

				my $js_setting = {
					tag   => $js_tag,
					value => $js_value
				};

				$js_setting->{meta} = $meta if $meta;

				push @{$judges{$judge_id}->{settings}}, $js_setting;
			}

			$sj_sth->finish();

			# SCHOOL ONLY RATINGS AND STRIKES

			$school_judge_strikes_sth->execute($json_tourn->{school_only});

			while (
				my (
					$strike_id, $strike_type, $strike_start, $strike_end,
					$strike_judge, $strike_entry, $strike_event, $strike_school,
					$strike_region, $strike_district, $strike_timeslot, $strike_shift,
					$strike_registrant, $strike_conflict, $strike_conflictee
				) = $school_judge_strikes_sth->fetchrow_array()
			) {

				my $json_strike = {
					id         => $strike_id,
					tag        => $strike_type,
					conflict   => $strike_conflict,
					registrant => $strike_registrant,
					conflictee => $strike_conflictee,
				};

				$json_strike->{start} = $strike_start if $strike_start;
				$json_strike->{end} = $strike_end if $strike_end;
				$json_strike->{entry} = $strike_entry if $strike_entry;
				$json_strike->{event} = $strike_event if $strike_event;
				$json_strike->{school} = $strike_school if $strike_school;
				$json_strike->{region} = $strike_region if $strike_region;
				$json_strike->{district} = $strike_district if $strike_district;
				$json_strike->{timeslot} = $strike_timeslot if $strike_timeslot;
				$json_strike->{shift} = $strike_shift if $strike_shift;

				push @{$judges{$strike_judge}{strikes}},  $json_strike;

			}

			$school_judge_ratings_sth->execute($json_tourn->{school_only});

			while (
				my (
					$rating_id, $rating_type, $rating_entry, $rating_judge,
					$rating_entered,
					$rating_ordinal, $rating_percentile,
					$rating_rating_tier, $rating_tier_name, $rating_rating_subset, $rating_side
				) = $school_judge_ratings_sth->fetchrow_array()
			) {

				$rating_side = 0 unless $rating_side;
				next if $filter{$rating_entry}{$rating_judge}{$rating_side}++;

				my $json_rating = {
					id    => $rating_id,
					entry => $rating_entry
				};

				if ($rating_type == 'coach') {
					$json_rating->{tag} = 'coach';
				}

				unless ($ARGS{"skip_content"}) {
					$json_rating->{entered}     = $rating_entered;
				}

				$json_rating->{ordinal}          = $rating_ordinal;
				$json_rating->{percentile}       = $rating_percentile;
				$json_rating->{rating_tier}      = $rating_rating_tier;
				$json_rating->{rating_tier_name} = $rating_tier_name;
				$json_rating->{rating_subset}    = $rating_rating_subset;
				$json_rating->{side}             = $rating_side;

				foreach my $key (keys %{$json_rating}) {
					delete $json_rating->{$key} unless $json_rating->{$key};
				}

				push @{$judges{$rating_judge}{"ratings"}}, $json_rating;
			}
		}

		unless ($ARGS{"skip_content"}) {
			$purchase_sth->execute($tourn->id);
			my %purchases;

			while (
				my (
					$purchase_id, $purchase_school,
					$purchase_quantity, $purchase_placed, $purchase_fulfilled,
					$purchase_concession, $purchase_invoice, $cpo_option
				) = $purchase_sth->fetchrow_array()
			) {

				next unless $purchase_quantity > 0;

				my $json_school = $schools{$purchase_school};

				if ($json_school) {

					my $json_purchase = $purchases{$purchase_id};

					unless ($json_purchase) {

						$json_purchase = {
							id         => $purchase_id,
							quantity   => $purchase_quantity,
							placed     => $purchase_placed,
							fulfilled  => $purchase_fulfilled,
							concession => $purchase_concession,
							invoice    => $purchase_invoice,
						};

						push @{$json_school->{purchases}}, $json_purchase;
						$purchases{$purchase_id} = $json_purchase;
					}

					push @{$json_purchase->{options}}, $cpo_option if $cpo_option;
				}
			}

			#INVOICES
			$invoice_sth->execute($tourn->id);

			while (
				my ( $invoice_id, $invoice_blusynergy, $invoice_blu_number,
					$invoice_total, $invoice_paid, $invoice_school, $invoice_details
				) = $invoice_sth->fetchrow_array()
			) {

				my $json_school = $schools{$invoice_school};

				my $json_invoice = {
					id         => $invoice_id,
					blusynergy => $invoice_blusynergy,
					blu_number => $invoice_blu_number,
					total      => $invoice_total,
					paid       => $invoice_paid,
					details    => $invoice_details
				};

				push @{$json_school->{invoices}}, $json_invoice;

			}
		}

		# Get schools with only hybrid entries

		my $hybrid_school_sth = $dbh->prepare("
			select
				student.id student_id, student.first, student.last, student.chapter,
				student.nsda, student.grad_year, student.middle,
				entry.id entry_id, entry.code,
				event.id event_id, event.abbr event_abbr,
				school.id school_id, school.name school_name, school.code school_code,
				s2.id s2_id, s2.name s2_name, s2.code s2_code, s2.state s2_state,
				s2.onsite, s2.region, s2.district,
				c2.nsda cnsda

			from (student, school, entry, entry_student es, event)

				left join chapter c2
					on student.chapter = c2.id

				left join school s2
					on s2.tourn = school.tourn
					and s2.chapter = student.chapter

			where 1=1
				and school.tourn = ?
				and school.id = entry.school
				and entry.id = es.entry
				and es.student = student.id
				and student.chapter != school.chapter
				and entry.event = event.id

			group by student.id
		");

		$hybrid_school_sth->execute($tourn->id);

		my $results = $hybrid_school_sth->fetchall_hash();

		foreach my $hybrid (@{$results}) {

			my $json_school;

			if ($schools{$hybrid->{"school"}}) {

				$json_school = $schools{$hybrid->{"school"}};

			} else {

				$json_school = {
					id   => $hybrid->{"s2_name"},
					name => $hybrid->{"s2_name"}
				};

				$json_school->{code}     = $hybrid->{s2_code} if $hybrid->{s2_code};
				$json_school->{state}    = $hybrid->{s2_state} if $hybrid->{s2_state};
				$json_school->{chapter}  = $hybrid->{chapter} if $hybrid->{chapter};
				$json_school->{onsite}   = $hybrid->{onsite} if $hybrid->{onsite};
				$json_school->{nsda}     = $hybrid->{cnsda} if $hybrid->{cnsda};
				$json_school->{region}   = $hybrid->{region} if $hybrid->{region};
				$json_school->{district} = $hybrid->{district} if $hybrid->{district};
				$json_school->{settings} = raw_value($ss_sth, $hybrid->{"s2_id"});

				$schools{$hybrid->{school}} = $json_school;
				push (@{$json_tourn->{schools}}, $json_school);
			}

			unless ($students{$hybrid->{student}}) {

				my $json_student = {
					id        => $hybrid->{student},
					chapter   => $hybrid->{chapter},
					first     => $hybrid->{first},
					last      => $hybrid->{last}
				};

				$json_student->{nsda}      = $hybrid->{nsda} if $hybrid->{nsda};
				$json_student->{grad_year} = $hybrid->{grad_year} if $hybrid->{grad_year};
				$json_student->{middle}    = $hybrid->{middle} if $hybrid->{middle};

				push (@{$json_school->{students}}, $json_student);
				$students{$hybrid->{"student"}} = $json_student;
			}
		}
	}

	unless (
		$json_tourn->{school_only}
		|| $json_tourn->{category_only}
		|| $json_tourn->{event_only}
		|| $json_tourn->{round_only}
		|| $json_tourn->{public}
	) {

		my $region_sth = $dbh->prepare("
			select region.id, region.name, region.code, region.circuit, region.tourn
			from region
				where region.tourn = ?
		");

		my $regs_sth = $dbh->prepare("
			select
				region.id, region_setting.id, region_setting.tag,
				region_setting.value, region_setting.value_date, region_setting.value_text
			from (region, region_setting)
			where region.id = ?
				and region.id = region_setting.region
		");

		$region_sth->execute($tourn->id);

		while (
			my (
				$region_id, $region_name, $region_code, $region_circuit, $region_tourn
			) = $region_sth->fetchrow_array()
		) {

			my $json_region = {
				id           => $region_id,
				name         => $region_name,
				code         => $region_code,
				circuit      => $region_circuit,
				tourn        => $region_tourn
			};

			$json_region->{settings} = raw_value($regs_sth, $region_id);
			push @{$json_tourn->{"regions"}}, $json_region;
		}
	}

	unless (
		$json_tourn->{school_only}
		|| $json_tourn->{category_only}
		|| $json_tourn->{event_only}
		|| $json_tourn->{round_only}
		|| $json_tourn->{public}
	) {

		my $tb_sth = $dbh->prepare("
			select
				tiebreak.id, tiebreak.name, tiebreak.count, tiebreak.count_round,
				tiebreak.truncate, tiebreak.truncate_smallest,
				tiebreak.multiplier, tiebreak.priority,
				tiebreak.highlow, tiebreak.highlow_count,
				tiebreak.child,
				ts.id, ts.name

			from tiebreak, protocol ts
				where ts.tourn = ?
				and ts.id = tiebreak.protocol
		");

		my $tie_sth = $dbh->prepare("
			select
				protocol.id, protocol_setting.id, protocol_setting.tag,
				protocol_setting.value, protocol_setting.value_date, protocol_setting.value_text
			from (protocol, protocol_setting)
			where protocol.id = ?
				and protocol.id = protocol_setting.protocol
		");

		my %protocols;

		$tb_sth->execute($tourn_id);

		while (
			my (
				$tiebreak_id, $tiebreak_name, $tiebreak_count, $tiebreak_count_round,
				$tiebreak_truncate, $tiebreak_truncate_smallest,
				$tiebreak_multiplier, $tiebreak_priority,
				$tiebreak_highlow, $tiebreak_highlow_count, $tiebreak_child,
				$ts_id, $ts_name
			) = $tb_sth->fetchrow_array()
		) {

			my $json_protocol;

			if ($protocols{$ts_id}) {

				$json_protocol = $protocols{$ts_id};

			} else {

				$json_protocol = {
					id   => $ts_id,
					name => $ts_name
				};

				$json_protocol->{settings} = raw_value($tie_sth, $ts_id);
				$protocols{$ts_id} = $json_protocol;
				push @{$json_tourn->{"protocols"}}, $json_protocol;

			};

			my $json_tb = {
				name     => $tiebreak_name,
				priority => $tiebreak_priority,
				count    => $tiebreak_count
			};

			$json_tb->{highlow}           = $tiebreak_highlow if $tiebreak_highlow;
			$json_tb->{highlow_count}     = $tiebreak_highlow_count if $tiebreak_highlow_count;
			$json_tb->{count_round}       = $tiebreak_count_round if $tiebreak_count_round;
			$json_tb->{truncate}          = $tiebreak_truncate if $tiebreak_truncate;
			$json_tb->{truncate_smallest} = $tiebreak_truncate_smallest if $tiebreak_truncate_smallest;
			$json_tb->{multiplier}        = $tiebreak_multiplier if $tiebreak_multiplier;
			$json_tb->{child}             = $tiebreak_child if $tiebreak_child;

			push (@{$json_protocol->{tiebreaks}}, $json_tb);
		}
	}

	unless ($json_tourn->{public}
		|| $json_tourn->{event_only}
		|| $json_tourn->{round_only}
		|| $json_tourn->{category_only}
	) {

		# FINES FEES PAYMENTS

		my $fine_sth = $dbh->prepare("
			select
				fine.id, fine.reason, fine.amount, fine.payment, fine.levied_at, fine.levied_by,
				fine.deleted, fine.deleted_at, fine.deleted_by,
				fine.tourn, fine.school, fine.region, fine.judge, fine.parent, fine.invoice
			from fine
			where fine.tourn = ?
		");

		$fine_sth->execute($tourn->id);

		while (
			my (
				$fine_id, $fine_reason, $fine_amount, $fine_payment,
				$fine_levied_at, $fine_levied_by,
				$fine_deleted, $fine_deleted_at, $fine_deleted_by,
				$fine_tourn, $fine_school, $fine_region, $fine_judge,
				$fine_parent, $fine_invoice
			) = $fine_sth->fetchrow_array()
		) {

			next if ($json_tourn->{school_only} && ($json_tourn->{school_only} != $fine_school));

			my $json_fine = {
				id         => $fine_id,
				reason     => $fine_reason,
				amount     => $fine_amount,
				payment    => $fine_payment,
				levied_by  => $fine_levied_by,
				levied_at  => $fine_levied_at,
				deleted    => $fine_deleted,
				deleted_by => $fine_deleted_by,
				deleted_at => $fine_deleted_at,
				tourn      => $fine_tourn,
				school     => $fine_school,
				region     => $fine_region,
				judge      => $fine_judge,
				parent     => $fine_parent,
				invoice    => $fine_invoice,
			};

			push @{$json_tourn->{"fines"}}, $json_fine;
		}
	}

	unless ($json_tourn->{event_only}
		|| $json_tourn->{round_only}
		|| $json_tourn->{category_only}
		|| $json_tourn->{school_only}
		|| $json_tourn->{public}
		|| $ARGS{"skip_content"}
	) {

		my $email_sth = $dbh->prepare("
			select
				email.id, email.subject, email.content, email.metadata,
				email.sent_to, email.sent_at, email.sender, email.tourn
			from email
			where email.tourn = ?
		");

		$email_sth->execute($tourn->id);

		while (
			my ($email_id, $email_subject, $email_content, $email_metadata,
				$email_sent_to, $email_sent_at, $email_sender, $email_tourn
			) = $email_sth->fetchrow_array()
		) {

			utf8::encode($email_content);
			utf8::encode($email_metadata);

			my $json_email = {
				id       => $email_id,
				subject  => $email_subject,
				content  => Tab::Utils::compress($email_content),
				metadata => Tab::Utils::compress($email_metadata),
				sent_to  => $email_sent_to,
				sent_at  => $email_sent_at,
				sender   => $email_sender,
			};

			push @{$json_tourn->{"emails"}}, $json_email;
		}

		my $webpage_sth = $dbh->prepare("
			select
				webpage.id, webpage.title, webpage.content, webpage.published,
				webpage.special, webpage.page_order,
				webpage.parent, webpage.last_editor
			from webpage
			where webpage.tourn = ?
		");

		$webpage_sth->execute($tourn->id);

		while (
			my (
				$webpage_id, $webpage_title, $webpage_content, $webpage_published,
				$webpage_special, $webpage_page_order,
				$webpage_parent, $webpage_last_editor
			) = $webpage_sth->fetchrow_array()
		) {

			utf8::encode($webpage_content);

			my $json_webpage = {
				id          => $webpage_id,
				title       => $webpage_title,
				content     => Tab::Utils::compress($webpage_content),
				published   => $webpage_published,
				special     => $webpage_special,
				page_order  => $webpage_page_order,
				parent      => $webpage_parent,
				last_editor => $webpage_last_editor,
			};

			push @{$json_tourn->{"webpages"}}, $json_webpage;
		}

		my $concession_sth = $dbh->prepare("
			select
				concession.id, concession.name, concession.price, concession.description,
				concession.deadline, concession.cap, concession.school_cap, concession.billing_code,
				type.id, type.name, type.description,
				copt.id, copt.name, copt.description, copt.disabled
			from concession

				left join concession_type type on type.concession = concession.id
				left join concession_option copt on copt.concession_type = type.id
			where concession.tourn = ?
		");

		$concession_sth->execute($tourn->id);

		my %concession_by_id;
		my %ctype_by_id;

		#CONCESSION ORDERS

		while (
			my (

				$concession_id, $concession_name, $concession_price, $concession_description,
				$concession_deadline, $concession_cap, $concession_school_cap, $concession_billing_code,
				$type_id, $type_name, $type_description,
				$option_id, $option_name, $option_description, $option_disabled
			) = $concession_sth->fetchrow_array()
		) {

			my $json_concession = $concession_by_id{$concession_id};

			unless ($json_concession) {

				$json_concession = {
					id           => $concession_id,
					name         => $concession_name,
					price        => $concession_price,
					description  => $concession_description,
					deadline     => $concession_deadline,
					cap          => $concession_cap,
					school_cap   => $concession_school_cap,
					billing_code => $concession_billing_code,
				};

				$concession_by_id{$concession_id} = $json_concession;
				push @{$json_tourn->{concessions}}, $json_concession;
			}

			if ($type_id) {

				my $json_type = $ctype_by_id{$type_id};

				unless ($json_type) {
					$json_type = {
						id          => $type_id,
						name        => $type_name,
						description => $type_description
					};

					$ctype_by_id{$type_id} = $json_type;
					push @{$json_concession->{types}}, $json_type;
				}

				if ($option_id) {

					my $json_option = {
						id          => $option_id,
						name        => $option_name,
						description => $option_description,
						disabled    => $option_disabled,
					};

					push @{$json_type->{options}}, $json_option;
				}
			}
		}
	}

	my $filename;
	my $tourn_name = $tourn->name;
	$tourn_name =~ s/[\W_]//g;

	if ($json_tourn->{public}) {
		$filename = "TabroomData-".$tourn_name;
	} elsif ($round_id) {
		$filename = "TabroomData-".$tourn_name."-R".$round->name."-".$round->event->abbr;
	} elsif ($person_id) {
		$filename = "TabroomData-".$tourn_name;
	} elsif ($file_name) {
		$filename = $file_name."-".$tourn_name;
	} else {
		$filename = "Complete-".$tourn->name;
	}

	$filename =~ s/\s+//g;
	$filename =~ s/\///g;
	$filename =~ s/\\//g;

	$filename = $filename."-".$now->ymd('-')."-at-".$now->hms('-').".json";

	my $json = JSON->new->allow_nonref->convert_blessed;

	if ($person_id || $ARGS{"file"}) {

		my $filedir = $Tab::file_root."tmp/".$tourn->id."/".$now->epoch."/";
		system "mkdir -p $filedir";
		my $filepath = $filedir.$filename;

		open my $fh, ">", $filepath;
		print $fh $json->encode($json_tourn);
		close $fh;

		# Return a reference so that the public path is not visible.
		my @return = ($filepath, $filename);
		return \@return;

	} elsif ($session) {

		my $filedir = $Tab::file_root."tmp/".$session->id."/".$now->epoch."/";
		system "mkdir -p $filedir";
		my $filepath = $filedir."/".$filename;

		open my $fh, ">", $filepath;
		print $fh $json->encode($json_tourn);
		close $fh;

		$m->redirect("/tmp/".$session->id."/".$now->epoch."/".$filename);

	} else {

		# With a public download I don't care if it's slow and do care about
		# the storage costs

		$r->headers_out->{'Content-Disposition'} = "attachment; filename=$filename";
		$m->print($json->pretty->encode( $json_tourn ));
		$m->flush_buffer();
		$m->abort();
	}

	sub raw_value {

		my ($parent_sth, $args) = @_;
		$parent_sth->execute($args);

		my @settings;

		while (
			my (
				$object_id, $setting_id, $tag, $value, $value_date, $value_text
			) = $parent_sth->fetchrow_array()
		) {

			my $meta = "string";
			utf8::encode($value_text);

			if ($value_date) {

				$value_date =~ s/ /T/g;
				$value = $value_date."Z";
				$meta = "date";

			} elsif ($value_text) {

				if ($value eq "json") {
					$meta = "json";
				} else {
					$meta = "text";
				}

				$value = Tab::Utils::compress($value_text);
				chomp $value;
			}

			my $json_setting = {
				tag   => $tag,
				value => $value,
				meta  => $meta
			};

			push @settings, $json_setting;
		}

		$parent_sth->finish;
		return \@settings;
	}

</%init>
