<%args>
	$username    => undef
	$password    => undef
	$session_id  => undef
	$tourn_id    => undef
	$event_id    => undef
	$round_id    => undef
	$school_id   => undef
	$category_id => undef
	$from        => undef
</%args>
<%init>

	use Scalar::Util "reftype";
	use utf8;

	# I hate this.
	our $no_return;
	undef $no_return;

	if ($round_id) {
		$no_return = $round_id;
	} else {
		$no_return = $from;
	}

	use JSON -convert_blessed_universally;

	my ($person, $tourn, $session, $perms) = $m->comp(
		"login_api.mas",
		tourn_id   => $tourn_id,
		username   => $username,
		password   => $password,
		session_id => $session_id
	);

	my $tz = $tourn->tz;
	$tz = "UTC" unless $tz;

	my $now       = DateTime->now(time_zone => $tz);
	my $nowstring = DateTime::Format::MySQL->format_datetime($now);
	my $req       = Apache2::Request->new($r);
	my @handles   = $r->upload;
	my $upload    = $req->upload($handles[0]);

	$m->print("<div id=\"wrapper\">");
	$m->print("<div id=\"content\">");

	my %tourn_settings = $tourn->all_settings();
	my @actual_schools;

    $m->comp("/register/data/menu.mas",
        tourn          => $tourn,
		tourn_settings => \%tourn_settings,
        person         => $person,
        whoami         => 'import_native',
	);

	my $dbh = Tab::DBI->db_Main();

	$m->print("<div class=\"main\">");
	&outlog("<h2>Uploading data</h2>");

	$m->print("<span class='nospace upload_scroll'>");
	$m->flush_buffer() unless $no_return;

	unless ($upload) {
		&errorlog("<p>No data upload sent, cannot process anything!</p>");
		$m->abort();
	}

	my $contents;
	$upload->slurp($contents);

	&outlog("<h5>Data uploaded and parsed</h5>");

	my $json = JSON->new->allow_nonref->convert_blessed;
	my %filter;

	my $jdata = eval {
		$json->pretty->decode($contents);
	};

	unless ($jdata) {
		&outlog("<h4>Data uploaded was invalid</h4>\n");
		$m->abort();
	}

	if ($jdata->{public}) {
		&outlog("<h2 class='redtext centeralign semibold martopmuchmore'>DATA FILE INVALID</h2>");
		&outlog("<p class='bigger martopmore'>This datafile contains the publicly generated data for a tournament,<p>");
		&outlog("<p>not complete data, and will therefore really mess up your tournament if you try to load it into Tabroom.</p>");
		&outlog("<p class='bigger'>Please upload only datafiles generated by an administrator-side operation, not the public interface</p>");
		$m->abort();
	}

	my $default_year = Tab::school_year();

	&outlog("<h4>Tournament: ".$tourn->name."</h4>\n");
	my $timestamp = parse_date($jdata->{backup_created});

	&outlog("<p class='specific'>Data file was created on ");
	$m->comp("/funclib/showdt.mas", dt => $timestamp);
	&outlog(" by ".$jdata->{creator}."</p>");

	# Shared Database functions

	Tab::EntryStudent->columns(TEMP => "entryid");
	Tab::EntryStudent->columns(TEMP => "studentid");

	Tab::EntryStudent->set_sql (by_school => "
		select entry_student.*, entry_student.entry entryid, entry_student.student studentid
			from entry_student, entry
		where entry_student.entry = entry.id
		and entry.school = ?
	");

	Tab::Concession->set_sql(rm_all => "
		delete from concession where school = ?
	");

	Tab::RoundSetting->set_sql(rm_all => "
		delete from round_setting where round = ?
	");

	Tab::PanelSetting->set_sql(rm_all => "
		delete panel_setting.* from panel_setting, panel where panel_setting.panel = panel.id and panel.round = ?
	");

	Tab::TournSetting->set_sql(rm_all => "
		delete from tourn_setting where tourn = ? and tag != 'nc_purchased'
	");

	Tab::RegionSetting->set_sql(rm_all => "
		delete from region_setting where region = ?
	");

	Tab::CategorySetting->set_sql(
		rm_all => "delete from category_setting where category = ?"
	);

	Tab::ProtocolSetting->set_sql(rm_all => "
		delete from protocol_setting where protocol = ?
	");

	Tab::SchoolSetting->set_sql(rm_all => "
		delete from school_setting where school = ?
	");

	Tab::EntrySetting->set_sql(rm_all => "
		delete from entry_setting where entry = ?
	");

	Tab::StudentVote->set_sql(rm_all => "
		delete from student_vote where panel = ?
	");

	my $school_entries_sth = $dbh->prepare("
		select entry.id from entry where school = ?
	");

	my $event_ratings_sth = $dbh->prepare("
		select
			rating.id, rating.entry, rating.judge, rating.ordinal, rating.rating_tier, rating.percentile
		from rating, entry
		where rating.entry = entry.id
			and entry.event = ?
	");

	my $school_ratings_sth = $dbh->prepare("
		select
			rating.id, rating.entry, rating.judge, rating.ordinal, rating.rating_tier, rating.percentile
		from rating, entry
		where rating.entry = entry.id
			and entry.school = ?
	");

	my $category_ratings_sth = $dbh->prepare("
		select
			rating.id, rating.entry, rating.judge, rating.ordinal, rating.rating_tier, rating.percentile
		from rating, judge
		where rating.judge = judge.id
			and judge.category = ?
	");

	my $school_judge_ratings_sth = $dbh->prepare("
		select
			rating.id, rating.entry, rating.judge, rating.ordinal, rating.rating_tier, rating.percentile
		from rating, judge
		where rating.judge = judge.id
			and judge.school = ?
	");

	my $update_rating_sth = $dbh->prepare("
		update rating
		set ordinal = ?, percentile = ?, rating_tier = ?, rating_subset = ?, side = ?
		where entry = ? and judge = ?
	");

	my $insert_rating_sth = $dbh->prepare("insert into rating
		(type, entered, tourn, ordinal, percentile, rating_tier, rating_subset,  side, entry, judge)
		VALUES ('entry', NOW(), ".$tourn->id.", ?, ?, ?, ?, ?, ?, ?)
	");

	my $delete_rating_sth = $dbh->prepare("delete from rating where entry = ? and judge = ? ");

	Tab::Score->set_sql(rm_all => "
		delete score.* from panel, ballot, score
		where panel.round = ?
			and panel.id = ballot.panel
			and ballot.id = score.ballot
	");

	Tab::Ballot->set_sql(rm_all => "
		delete ballot.* from panel, ballot
		where panel.round = ?
			and panel.id = ballot.panel
	");

	Tab::Panel->set_sql(rm_all => "
		delete from panel where panel.round = ?
	");

	Tab::RoomStrike->set_sql( by_site => "
		select rs.*
		from room_strike rs, room
		where rs.room = room.id
			and room.site = ?
			and rs.tourn = ?
	");

	unless (
		$jdata->{event_only}
		|| $jdata->{round_only}
		|| $jdata->{school_only}
		|| $jdata->{category_only}
	) {

		# TOURN DATA

		my $start_dt = parse_date($jdata->{start});
		my $end_dt = parse_date($jdata->{end});

		my $reg_start_dt = parse_date($jdata->{reg_start});
		my $reg_end_dt = parse_date($jdata->{reg_end});

		&outlog("<p class='action'> Updating tournament</p>");

		$tourn->name($jdata->{name}) if $jdata->{name};
		$tourn->tz($jdata->{tz}) if $jdata->{tz};
		$tourn->start($start_dt) if $start_dt;

		$tourn->end($end_dt) if $end_dt;
		$tourn->reg_start($reg_start_dt) if $reg_start_dt;
		$tourn->reg_end($reg_end_dt) if $reg_end_dt;

		my $hidden = $jdata->{hidden};
		$hidden = 0 unless $hidden;
		$tourn->hidden($hidden);

		&outlog("<p class='specific'>Loaded tournament data changes</p>");

		$tourn->update();

		my %ts_settings = &find_settings(
			"tourn",
			$tourn->id,
			" from tourn_setting setting",
			" where setting.tourn = ?",
			$dbh,
		);

		if ($jdata->{settings})  {
			# TOURN SETTINGS
			&align_settings($tourn->id, "tourn", $ts_settings{$tourn->id}, $jdata->{settings}, $dbh);
		}

	} elsif ($jdata->{round_only}) {
		&outlog("<p class='specific'>Update one round only</p>");
	} elsif ($jdata->{event_only}) {
		&outlog("<p class='specific'>Update event(s) only</p>");
	} elsif ($jdata->{school_only}) {
		&outlog("<p class='specific'>Update school(s) only</p>");
		unless ($perms->{"owner"} || $perms->{"tabber"}) {
			$m->comp("/funclib/abort.mas",
				message => "Only users with tournament wide tabber access may upload tournament wide data backups."
			);
		}
	}

	if ($jdata->{whole}) {

		unless ($perms->{"owner"} || $perms->{"tabber"}) {
			$m->comp("/funclib/abort.mas",
				message => "Only users with tournament wide tabber access may upload tournament wide data backups."
			);
		}
		&outlog("<p class='action'>Whole tournament mode active</p>");
	}

	my %translator;
	my @categories = $tourn->categories();
	my %category_by_id = map {$_->id => $_} @categories;
	my %category_by_name = map {$_->name => $_} @categories;
	my %category_by_abbr = map {$_->abbr => $_} @categories;

	my @protocols = $tourn->protocols;
	my %protocol_by_id = map {$_->id => $_} @protocols;
	my %protocol_by_name = map {$_->name => $_} @protocols;

	my $default_site;
	my @sites = $tourn->sites;
	my %site_by_id = map {$_->id => $_} @sites;
	my %site_by_name = map {$_->name => $_} @sites;

	# TIEBREAK SETS

	if ($jdata->{'tiebreak_sets'} && (not defined $jdata->{'protocols'})) {
		$jdata->{'protocols'} = $jdata->{'tiebreak_sets'};
	}

	if ($jdata->{protocols}) {

		&outlog("<p class='action'>Importing tiebreaker sets</p>");

		foreach my $protocol (@{$jdata->{protocols}}) {

			my $oprotocol;
			$oprotocol = $protocol_by_id{$protocol->{id}};

			unless ($oprotocol) {
				$oprotocol = $protocol_by_name{$protocol->{name}};
			}

			unless ($oprotocol) {
				$oprotocol = Tab::Protocol->create({
					name  => $protocol->{name},
					tourn => $tourn->id
				});
			} else {

				$oprotocol->name($protocol->{name});
				$oprotocol->update();

				# Prevent a double pump
				delete $protocol_by_id{$oprotocol->id};
			}

			$translator{protocol}{$protocol->{id}} = $oprotocol;

			&outlog("<p class='specific'>Tiebreak set ".$oprotocol->id." stored for ".$protocol->{id}." named ".$oprotocol->name."</p>");

			foreach my $tiebreak ($oprotocol->tiebreaks) {
				$tiebreak->delete();
			}

			# TIEBREAK SET SETTINGS
			Tab::ProtocolSetting->sql_rm_all->execute($oprotocol->id);

			if ($protocol->{settings})  {
				foreach my $jsetting (@{$protocol->{settings}}) {
					my @reply = parse_setting($jsetting);
					$oprotocol->setting(@reply) if @reply;
				}
			}
		}

		# TIEBREAKS

		# These are broken off to ensure that Child tiebreak sets with
		# derivative sets are available for translation.  No pruning required
		# because all tiebreakers are loaded fresh every time an import
		# happens.

		foreach my $protocol (@{$jdata->{protocols}}) {

			my $oprotocol = $translator{protocol}{$protocol->{id}};

			foreach my $tiebreak (@{$protocol->{tiebreaks}}) {

				my $child_set = $translator{protocol}{$tiebreak->{child}};

				$tiebreak->{count} = "all" unless $tiebreak->{count};
				$tiebreak->{truncate_smallest} = 0 unless $tiebreak->{truncate_smallest} > 0;

				Tab::Tiebreak->create({
					protocol          => $oprotocol->id,
					name              => $tiebreak->{name},
					priority          => $tiebreak->{priority},
					count             => $tiebreak->{count},
					highlow           => $tiebreak->{highlow},
					highlow_count     => $tiebreak->{highlow_count},
					count_round       => $tiebreak->{count_round},
					truncate          => $tiebreak->{truncate},
					truncate_smallest => $tiebreak->{truncate_smallest},
					multiplier        => $tiebreak->{multiplier},
					child             => $child_set
				});
			}
		}

		prune_unused( \%protocol_by_id, $translator{protocol}, $jdata->{protocols});

	} else {

		$translator{protocol} = \%protocol_by_id;
	}

	unless ($jdata->{round_only}) {

		# PATTERNS

		my @patterns = $tourn->patterns;
		my %pattern_by_id = map {$_->id => $_} @patterns;
		my %pattern_by_name = map {$_->name => $_} @patterns;

		if ($jdata->{patterns}) {

			foreach my $pattern (@{$jdata->{patterns}}) {

				my $opattern;
				$opattern = $pattern_by_id{$pattern->{id}};

				unless ($opattern) {
					$opattern = $pattern_by_name{$pattern->{name}};
				}

				if ($opattern) {

					$opattern->name($pattern->{name});
					$opattern->type($pattern->{tag});
					$opattern->max($pattern->{max});
					$opattern->exclude($pattern->{exclude});
					$opattern->update();
					delete $pattern_by_id{$opattern->id};

				} else {
					$opattern = Tab::Pattern->create({
						tourn   => $tourn->id,
						name    => $pattern->{name},
						type    => $pattern->{tag},
						max     => $pattern->{max},
						exclude => $pattern->{exclude}
					});
				}
				$translator{pattern}{$pattern->{id}} = $opattern;
			}

			prune_unused( \%pattern_by_id, $translator{pattern}, $jdata->{patterns});

		} else {
			$translator{pattern} = \%pattern_by_id;
		}
	}

	if ($jdata->{categories}) {

		&outlog("<p class='action'> Importing ".scalar @{$jdata->{categories}}." judge categories </p>");

		# CATEGORY CATEGORIES
		foreach my $category (@{$jdata->{categories}}) {

			my $ocategory = $category_by_id{$category->{id}};

			$ocategory = $category_by_abbr{$category->{abbr}}
				unless $ocategory || (not defined $category->{abbr});

			$ocategory = $category_by_name{$category->{name}}
				unless $ocategory || (not defined $category->{name});

			&outlog("<p class='action'> Searched for category ".$category->{name}." and found ID ".$ocategory."</p>");
			$m->flush_buffer() unless $no_return;

			my %category_settings = &find_settings(
				"category",
				$tourn->id,
				" from category_setting setting, category",
				" where category.tourn = ? and category.id = setting.category ",
				$dbh,
			);

			unless ( $jdata->{event_only} || $jdata->{round_only} ) {

				if ($perms->{"owner"} || $perms->{"tabber"} || $perms->{category}{$ocategory} eq "tabber") {

					if ($ocategory) {

						&outlog("<p class='specific'> Importing judge category ".$category->{name}." into matching category ".$ocategory->name."</p>");

						$ocategory->name($category->{name});
						$ocategory->abbr($category->{abbr});
						$ocategory->update();
						delete $category_by_id{$ocategory->id};

					} else {

						&outlog("<p class='specific'> No category found for name ".$category->{name}." Creating</p>");

						$ocategory = Tab::Category->create({
							tourn => $tourn->id,
							name  => $category->{name},
							abbr  => $category->{abbr},
						});
					}

					if ($category->{settings})  {
						&align_settings(
							$ocategory->id,
							"category",
							$category_settings{$ocategory->id},
							$category->{settings},
							$dbh
						);
					}
				}

			} elsif ($ocategory) {
				&outlog("<p class='specific'> Importing events in category ".$ocategory->name."</p>");
				$translator{category}{$category->{id}} = $ocategory;
			}

			$m->flush_buffer() unless $no_return;
			if ($perms->{"owner"} || $perms->{"tabber"} || $perms->{category}{$ocategory} eq "tabber") {

				unless ($jdata->{round_only}) {

					# PREFS AND PREF SHEETS

					my @rts;
					my %rt_by_id;
					my %rt_by_name;

					@rts = $ocategory->rating_tiers if $ocategory;
					%rt_by_id = map {$_->id => $_} @rts if @rts;
					%rt_by_name = map {$_->name => $_} @rts if @rts;

					# PREF TIERS
					if ($category->{rating_tiers}) {

						&outlog("<p class='action'> Importing ".scalar @{$category->{rating_tiers}}." pref tiers </p>");

						foreach my $rt (@{$category->{rating_tiers}}) {

							my $ort = $rt_by_id{$rt->{id}};
							$ort = $rt_by_name{$rt->{name}} unless $ort;

							foreach my $tag ("strike", "conflict", "start") {
								$rt->{$tag} = 0 unless $rt->{$tag} > 0;
							}

							unless ($ort) {
								$ort = Tab::RatingTier->create({
									category    => $ocategory->id,
									type        => $rt->{tag},
									name        => $rt->{name},
									description => $rt->{description},
									strike      => $rt->{strike},
									conflict    => $rt->{conflict},
									min         => $rt->{min},
									max         => $rt->{max},
									start       => $rt->{start},
								});

								&outlog("<p class='specific'> No rating tier found for ".$rt->{id}." ".$rt->{name}." RT $ort created</p>");

							} else {

								&outlog("<p class='specific'> Rating tier $ort found for  ".$rt->{id}." ".$rt->{name}."</p>");
								$ort->type($rt->{tag});
								$ort->name($rt->{name});
								$ort->description($rt->{description});
								$ort->strike($rt->{strike});
								$ort->conflict($rt->{conflict});
								$ort->min($rt->{min});
								$ort->max($rt->{max});
								$ort->start($rt->{start});
								$ort->update();
								delete $rt_by_id{$ort->id};
							}

							$translator{rating_tier}{$rt->{id}} = $ort;
						}

						prune_unused( \%rt_by_id, $translator{rating_tier}, $category->{rating_tiers});

					} elsif ($ocategory) {
						$translator{rating_tier} = \%rt_by_id;
						$translator{rating_tier_name}{$ocategory->id} = \%rt_by_name;
					}

					my @rss;
					my %rs_by_id;
					my %rs_by_name;

					@rss = $ocategory->rating_subsets if $ocategory;
					%rs_by_id = map {$_->id => $_} @rss if @rss;
					%rs_by_name = map {$_->name => $_} @rss if @rss;

					# RATING SUBSETS

					if ($category->{rating_subsets}) {

						foreach my $rs (@{$category->{rating_subsets}}) {

							my $ors = $rs_by_id{$rs->{id}};
							&outlog("<p class='specific'> No rating subset found for id ".$rs->{id}." Trying name ".$rs->{name}."</p>");
							$ors = $rs_by_name{$rs->{name}} unless $ors;

							unless ($ors) {
								$ors = Tab::RatingSubset->create({
									category => $ocategory->id,
									name     => $rs->{name}
								});
								&outlog("<p class='specific'> No rating subset found for ".$rs->{id}." ".$rs->{name}." RS $ors created</p>");
							} else {
								&outlog("<p class='specific'> Rating subset $ors found for  ".$rs->{id}." ".$rs->{name}."</p>");
								$ors->name($rs->{name});
								$ors->update();
							}

							$translator{rating_subset}{$rs->{id}} = $ors;
						}

						prune_unused( \%rs_by_id, $translator{rating_subset}, $category->{rating_subsets});

					} elsif ($ocategory) {
						$translator{rating_subset} = \%rs_by_id;
						$translator{rating_subset_name}{$ocategory->id} = \%rs_by_name;
					}

					$translator{category}{$category->{id}} = $ocategory;
				}
			}

			# EVENTS

			if ($ocategory
				&& $category->{events}
				&& (not defined $jdata->{round_only})
			) {

				&outlog("<p class='action'><span class='halfspacer'></span>Importing ".scalar @{$category->{events}}." events </p>");

				my @events = $ocategory->events();

				my %event_by_id = map {$_->id => $_} @events;
				my %event_by_name = map {$_->name => $_} @events;
				my %event_by_abbr = map {$_->abbr => $_} @events;

				my @tourn_events = $tourn->events();
				my %tourn_event_by_id = map {$_->id => $_} @tourn_events;
				my %tourn_event_by_name = map {$_->name => $_} @tourn_events;
				my %tourn_event_by_abbr = map {$_->abbr => $_} @tourn_events;

				my %event_settings = &find_settings(
					"event",
					$tourn->id,
					" from event_setting setting, event",
					" where event.tourn = ? and event.id = setting.event ",
					$dbh,
				);

				EVENT:
				foreach my $event (@{$category->{events}}) {

					&outlog("<p class='specific'> Importing event ".$event->{abbr}."</p>");

					unless ($event->{type}) {
						&outlog("<p class='specific'> No event type listed for ".$event->{id}." Cannot import.</p>");
						next EVENT;
					}

					my $oevent = $event_by_id{$event->{id}};

					unless (
						$perms->{"owner"}
						|| $perms->{"tabber"}
						|| $perms->{category}{$ocategory} eq "tabber"
						|| $perms->{event}{$oevent} eq "tabber"
					) {
						&outlog("<p class='specific'> You do not have permissions to affect ".$event->{id}." Cannot import.</p>");
						next EVENT;
					}

					$oevent = $event_by_abbr{$event->{abbr}} unless $oevent;

					unless ($oevent) {
						if ( $event->{abbr} eq "DX" || $event->{abbr} eq "DX") {
							$oevent = $event_by_abbr{USX};
						} elsif ($event->{abbr} eq "FX") {
							$oevent = $event_by_abbr{IX};
						} elsif ($event->{abbr} eq "BQD") {
							$oevent = $event_by_abbr{BQ};
						}
					}

					$oevent = $event_by_name{$event->{name}} unless $oevent;

					unless ($oevent) {

						$oevent = $tourn_event_by_id{$event->{id}};
						$oevent = $tourn_event_by_abbr{$event->{abbr}} unless $oevent;

						unless ($oevent) {
							if ( $event->{abbr} eq "DX" || $event->{abbr} eq "DX") {
								$oevent = $tourn_event_by_abbr{USX};
							} elsif ($event->{abbr} eq "FX") {
								$oevent = $tourn_event_by_abbr{IX};
							} elsif ($event->{abbr} eq "BQD") {
								$oevent = $tourn_event_by_abbr{BQ};
							}
						}

						$oevent = $tourn_event_by_name{$event->{name}} unless $oevent;
					}

					if ($oevent && $oevent->category != $ocategory->id) {
						$oevent->category($ocategory->id);
						$oevent->update();
					}

					my $opattern = $translator{pattern}{$event->{pattern}};
					$opattern = 0 unless $opattern;

					my $orating_subset = $translator{rating_subset}{$event->{rating_subset}};
					$orating_subset = 0 unless $orating_subset;

					my $old_id = $event->{id};

					if ($oevent) {

						$oevent->category($ocategory->id);
						$oevent->name($event->{name});
						$oevent->abbr($event->{abbr});
						$oevent->type($event->{type});
						$oevent->fee($event->{fee});
						$oevent->pattern($opattern);
						$oevent->rating_subset($orating_subset);
						$oevent->update();

						# Prevent a double pump
						delete $event_by_id{$oevent->id};

					} else {

						&outlog("<p class='specific'> No event found for name ".$event->{name}." Abbr ".$event->{abbr}.". Creating</p>");

						$oevent = Tab::Event->create({
							tourn         => $tourn->id,
							category      => $ocategory->id,
							name          => $event->{name},
							abbr          => $event->{abbr},
							type          => $event->{type},
							fee           => $event->{fee},
							pattern       => $opattern,
							rating_subset => $orating_subset
						});
					}

					delete $event_by_id{$old_id};
					$translator{event}{$old_id} = $oevent;

					if ($event->{settings})  {
						&align_settings(
							$oevent->id,
							"event",
							$event_settings{$oevent->id},
							$event->{settings},
							$dbh
						);
					}
				}

				if ($jdata->{whole}) {

					&outlog("<h6>Data file was for whole tournament; restoration will prune unknown elements</h6>");

					my $delete_event = $dbh->prepare("
						delete from event where id = ?
					");

					foreach my $id (keys %event_by_id) {
						&outlog("<p class='action'> Pruned unused event ID $id </p>");
						$delete_event->execute($id);
					}

				}

			} elsif ($ocategory) {

				unless ($perms->{"owner"} || $perms->{"tabber"}) {
					next unless $perms->{category}{$ocategory} eq "tabber";
				}

				&outlog("<p class='action'> Using existing events </p>");

				foreach my $event ($ocategory->events()) {
					next if $translator{event}{$event->id};
					$translator{event}{$event->id} = $event;
				}
			}
		}

		if ($jdata->{whole}) {

			&outlog("<p class='action'> Pruning unused categories </p>");

			prune_unused(
				\%category_by_id,
				$translator{category},
				$jdata->{categories}
			);
		}

	} elsif ($perms->{"owner"} || $perms->{"tabber"}) {

		$translator{category} = \%category_by_id;
		my %event_by_id = map {$_->id => $_} $tourn->events();
		$translator{event} = \%event_by_id;

		foreach my $ocategory ($tourn->categories) {

			my @judges = $ocategory->judges();
			my %judge_by_id = map {$_->id => $_} @judges;

			if ($translator{judge}) {
				$translator{judge} = { %{$translator{judge}}, %judge_by_id};
			} else {
				$translator{judge} = \%judge_by_id;
			}

			my @rts = $ocategory->rating_tiers;
			my %rt_by_id = map {$_->id => $_} @rts;
			my %rt_by_name = map {$_->name => $_} @rts;

			if ($translator{rating_tier}) {
				$translator{rating_tier} = { %{$translator{rating_tier}}, %rt_by_id};
			} else {
				$translator{rating_tier} = \%rt_by_id;
			}
			$translator{rating_tier_name}{$ocategory->id} = \%rt_by_name;

			my @rss = $ocategory->rating_subsets;
			my %rs_by_id = map {$_->id => $_} @rss;
			my %rs_by_name = map {$_->name => $_} @rss;

			if ($translator{rating_subset}) {
				$translator{rating_subset} = { %{$translator{rating_subset}}, %rs_by_id};
			} else {
				$translator{rating_subset} = \%rs_by_id;
			}

			$translator{rating_subset_name}{$ocategory->id} = \%rs_by_name;
		}
	}

	# TIMESLOTS

	my @timeslots = $tourn->timeslots;
	my %timeslot_by_id = map {$_->id => $_} @timeslots;
	my %timeslot_by_name = map {$_->name => $_} @timeslots;

	if ($jdata->{timeslots}
		 && ($perms->{"owner"} || $perms->{"tabber"})
	) {

		foreach my $timeslot (@{$jdata->{timeslots}}) {

			my $otimeslot;
			$otimeslot = $timeslot_by_id{$timeslot->{id}};

			unless ($otimeslot) {
				$otimeslot = $timeslot_by_name{$timeslot->{name}};
			}

			my $start = parse_date($timeslot->{start});
			my $end = parse_date($timeslot->{end});

			unless ($otimeslot) {
				$otimeslot = Tab::Timeslot->create({
					name  => $timeslot->{name},
					tourn => $tourn->id,
					start => $start,
					end   => $end
				});
			} else {
				$otimeslot->name($timeslot->{name});
				$otimeslot->start($timeslot->{start});
				$otimeslot->end($timeslot->{end});
				$otimeslot->update();

				# Prevent a double pump
				delete $timeslot_by_id{$otimeslot->id};
			}

			$translator{timeslot}{$timeslot->{id}} = $otimeslot;
		}

	} else {

		$translator{timeslot} = \%timeslot_by_id;
	}

	# SITES

	if ($jdata->{sites}
		 && ($perms->{"owner"} || $perms->{"tabber"})
	) {

		foreach my $site (@{$jdata->{sites}}) {

			my $osite;
			$osite = $site_by_id{$site->{id}};

			unless ($osite) {
				$osite = $site_by_name{$site->{name}};
			}

			$site->{name} = $tourn->name." Site" unless $site->{name};

			if ($osite) {

				$osite->name($site->{name});
				$osite->update();

				# Double pump
				delete $site_by_id{$osite->id};

			} else {

				my $circuit = $tourn->circuits->first;
				$circuit = 6 unless $circuit;

				$osite = Tab::Site->create({
					name    => $site->{name},
					circuit => $circuit
				});
			}

			$translator{site}{$site->{id}} = $osite;
			$default_site = $osite unless $default_site;

			my @rooms = $osite->rooms;
			my %room_by_id = map {$_->id => $_} @rooms;
			my %room_by_name = map {$_->name => $_} @rooms;

			# ROOMS
			if ($site->{rooms}) {

				ROOM:
				foreach my $room (@{$site->{rooms}}) {

					my $oroom;
					$oroom = $room_by_id{$room->{id}};

					unless ($oroom) {
						$oroom = $room_by_name{$room->{name}};
					}

					if ($oroom) {
						if (
							$room_by_name{$room->{name}}
							&& ($room_by_name{$room->{name}} != $oroom)
						) {
							$oroom = $room_by_name{$room->{name}};
						}
					}

					foreach my $tag ("ada", "inactive") {
						$room->{$tag} = 0 unless $room->{$tag};
					}

					if ($oroom) {

						$oroom->name($room->{name});
						$oroom->rowcount($room->{rows});
						$oroom->seats($room->{seats});

						$oroom->ada($room->{ada});
						$oroom->inactive($room->{inactive});

						$oroom->quality($room->{quality});
						$oroom->capacity($room->{capacity});
						$oroom->notes($room->{notes});
						$oroom->url($room->{url});

						$oroom->update();

					} else {

						$oroom = Tab::Room->create({
							site     => $osite->id,
							name     => $room->{name},
							rowcount => $room->{rows},
							seats    => $room->{seats},
							ada      => $room->{ada},
							inactive => $room->{inactive},
							quality  => $room->{quality},
							capacity => $room->{capacity},
							notes    => $room->{notes},
							url      => $room->{url},
						});
					}

					$translator{room}{$room->{id}} = $oroom;
				}
			}
		}

	} else {

		$translator{site} = \%site_by_id;
		$default_site = $sites[0];

		my @rooms;
		foreach my $site ($tourn->sites) {
			push @rooms, $site->rooms;
		}

		%{$translator{room}} = map {$_->id => $_} @rooms;
		%{$translator{roomname}} = map {$_->name => $_} @rooms;
	}

	unless ($jdata->{round_only}) {
		if ($perms->{"owner"} || $perms->{"tabber"}) {

			# WEEKENDS
			my @weekends = $tourn->weekends;
			my %weekend_by_id = map {$_->id => $_} @weekends;
			my %weekend_by_name = map {$_->name => $_} @weekends;

			if ($jdata->{weekends}) {

				foreach my $weekend (@{$jdata->{weekends}}) {

					next unless $weekend->{name};
					my $oweekend;
					$oweekend = $weekend_by_id{$weekend->{id}};

					unless ($oweekend) {
						$oweekend = $weekend_by_name{$weekend->{name}};
					}

					my $start           = parse_date($weekend->{start});
					my $end             = parse_date($weekend->{end});
					my $reg_start       = parse_date($weekend->{reg_start});
					my $reg_end         = parse_date($weekend->{reg_end});
					my $fine_deadline   = parse_date($weekend->{fine_deadline});
					my $freeze_deadline = parse_date($weekend->{freeze_deadline});
					my $judge_deadline  = parse_date($weekend->{judge_deadline});
					my $drop_deadline   = parse_date($weekend->{drop_deadline});

					next unless $start;
					next unless $end;
					next unless $reg_start;
					next unless $reg_end;
					next unless $fine_deadline;
					next unless $freeze_deadline;
					next unless $judge_deadline;
					next unless $drop_deadline;

					my $site = $translator{site}{$weekend->{site}};
					$site = $default_site unless $site;
					$site = 0 unless $site;

					if ($oweekend) {

						$oweekend->name($weekend->{name});
						$oweekend->state($weekend->{state});
						$oweekend->city($weekend->{city});
						$oweekend->end($end);
						$oweekend->start($start);
						$oweekend->reg_end($reg_end);
						$oweekend->reg_start($reg_start);
						$oweekend->drop_deadline($drop_deadline);
						$oweekend->freeze_deadline($freeze_deadline);
						$oweekend->judge_deadline($judge_deadline);
						$oweekend->fine_deadline($fine_deadline);
						$oweekend->site($site);

					} else {

						$oweekend = Tab::Weekend->create({
							name            => $weekend->{name},
							end             => $end,
							tourn           => $tourn,
							start           => $start,
							reg_end         => $reg_end,
							reg_start       => $reg_start,
							drop_deadline   => $drop_deadline,
							freeze_deadline => $freeze_deadline,
							judge_deadline  => $judge_deadline,
							fine_deadline   => $fine_deadline,
							site            => $site
						});
					}

					$translator{weekend}{$weekend->{id}} = $oweekend;
				}

				prune_unused( \%weekend_by_id, $translator{weekend}, $jdata->{weekends});

			} else {
				$translator{weekend} = \%weekend_by_id;
			}

			my @regions = $m->comp("/funclib/tourn_regions.mas",
				tourn   => $tourn,
				circuit => $tourn_settings{"region_circuit"}
			);

			my %region_by_id = map {$_->id => $_} @regions;
			my %region_by_name = map {$_->name => $_} @regions;
			my %region_by_code = map {$_->code => $_} @regions;

			# Because tournaments might have both circuit regions and local ones

			if ($tourn_settings{"region_circuit"}) {
				$translator{region} = \%region_by_id;
			}

			# REGIONS
			if ($jdata->{regions}) {

				foreach my $region (@{$jdata->{regions}}) {

					my $oregion;
					$oregion = $region_by_id{$region->{id}};

					unless ($oregion) {
						$oregion = $region_by_code{$region->{code}};
					}

					unless ($oregion) {
						$oregion = $region_by_name{$region->{name}};
					}

					unless ($oregion) {

						$oregion = Tab::Region->create({
							tourn     => $tourn->id,
							name      => $region->{name},
							code      => $region->{code},
							circuit   => $region->{circuit},
						});

					} else {

						 $oregion->name($region->{name});
						 $oregion->code($region->{code});
						 $oregion->circuit($region->{circuit});
						 $oregion->update();
						delete $region_by_id{$oregion->id};
					}

					# REGION SETTINGS

					if ($region->{settings})  {
						Tab::RegionSetting->sql_rm_all->execute($oregion->id);
						foreach my $rsetting (@{$region->{settings}}) {
							my @reply = parse_setting($rsetting);
							$oregion->setting(@reply) if @reply;
						}
					}

					$translator{region}{$region->{id}} = $oregion;
				}

			}

			unless ($jdata->{"skip_content"}) {

				# CONCESSIONS

				my @concessions = $tourn->concessions;
				my %concession_by_id = map {$_->id => $_} @concessions;
				my %concession_by_name = map {$_->name => $_} @concessions;

				my %ctype_by_id;
				my %ctype_by_name;

				my %coption_by_id;
				my %coption_by_name;

				foreach my $concession (@concessions) {

					foreach my $ctype ($concession->types) {
						$ctype_by_id{$ctype->{id}} = $ctype;
						$ctype_by_name{$ctype->{name}} = $ctype;

						foreach my $option ($ctype->options) {
							$coption_by_id{$option->{id}} = $option;
							$coption_by_name{$option->{name}} = $option;
						}
					}
				}

				if ($jdata->{concessions}) {

					foreach my $concession (@{$jdata->{concessions}}) {

						my $oconcession = $concession_by_id{$concession->{id}};

						unless ($oconcession) {
							$oconcession = $concession_by_name{$concession->{name}};
						}

						unless ($oconcession) {
							$oconcession = Tab::Concession->create({
								name         => $concession->{name},
								price        => $concession->{price},
								description  => $concession->{description},
								deadline     => $concession->{deadline},
								cap          => $concession->{cap},
								school_cap   => $concession->{school_cap},
								billing_code => $concession->{billing_code}
							});

						} else {

							$oconcession->name($concession->{name});
							$oconcession->price($concession->{price});
							$oconcession->description($concession->{description});
							$oconcession->deadline($concession->{deadline});
							$oconcession->cap($concession->{cap});
							$oconcession->school_cap($concession->{school_cap});
							$oconcession->billing_code($concession->{billing_code});
							$oconcession->update();
						}

						$translator{concession}{$concession->{id}} = $oconcession;

						if ($concession->{types}) {

							foreach my $ctype (@{$concession->{types}}) {

								my $octype = $ctype_by_id{$ctype->{id}};

								unless ($octype) {
									$octype = $ctype_by_name{$ctype->{name}};
								}

								unless ($octype) {

									$octype = Tab::ConcessionType->create({
										name        => $ctype->{name},
										description => $ctype->{description},
										concession  => $oconcession->id
									});

								} else {

									$octype->name($ctype->{name});
									$octype->description($ctype->{description});
									$octype->concession($oconcession->id);
									$octype->update();

								}

								$translator{ctype}{$ctype->{id}} = $octype;

								foreach my $coption ($ctype->{options}) {

									next;

									my $ocoption = $coption_by_id{$coption->{id}};

									unless ($ocoption) {
										$ocoption = $coption_by_name{$coption->{name}};
									}

									unless ($ocoption) {

										$ocoption = Tab::ConcessionOption->create({
											name            => $ocoption->{name},
											description     => $ocoption->{description},
											disabled        => $ocoption->{disabled},
											concession_type => $octype->id
										});

									} else {

										$ocoption->name($ocoption->{name});
										$ocoption->description($ocoption->{description});
										$ocoption->disabled($ocoption->{disabled});
										$ocoption->concession_type($octype->id);
										$ocoption->update();
									}

									$translator{coption}{$coption->{id}} = $ocoption;

								}
							}
						}
					}

					prune_unused( \%concession_by_id, $translator{concession}, $jdata->{concessions});

				} else {
					$translator{concession} = \%concession_by_id;
					$translator{ctype} = \%ctype_by_id;
					$translator{coption} = \%coption_by_id;
				}
			}

			# Needed for school only uploads of judges and entries

			unless (keys %{$translator{event}}) {
				$translator{category} = \%category_by_id;
				my @events = $tourn->events();
				my %event_by_id = map {$_->id => $_} @events;
				$translator{event} = \%event_by_id;
			}

			my @schools = $tourn->schools();
			my %school_by_id = map {$_->id => $_} @schools;
			my %school_by_name = map {$_->name => $_} @schools;
			my %school_by_chapter;
			my %school_by_nsda;

			foreach my $school (@schools) {
				next unless $school->chapter > 0;
				$school_by_chapter{$school->chapter->id} = $school;
				next unless $school->chapter->nsda > 0;
				$school_by_nsda{$school->chapter->nsda} = $school;
			}

			Tab::Chapter->set_sql(by_tourn => "
				select chapter.*
					from chapter, school
				where school.tourn = ?
					and school.chapter = chapter.id
				order by chapter.name
			");

			my @chapters = Tab::Chapter->search_by_tourn($tourn->id);
			my %chapter_by_id = map {$_->id => $_} @chapters;
			my %chapter_by_name = map {$_->name => $_} @chapters;

			if ($jdata->{schools}) {

				&outlog("<h4 class='action'>REGISTRATION DATA</h4>");
				&outlog("<p class='action'> Importing ".scalar @{$jdata->{schools}}." school registrations</p>");

				my $school_settings_sth = $dbh->prepare("
					select
						ss.tag, ss.school, ss.value, ss.value_date, ss.value_text
					from school_setting ss, school
					where school.tourn = ?
					and school.id = ss.school
				");

				$school_settings_sth->execute($tourn->id);
				my $ss_ref = $school_settings_sth->fetchall_hash();

				my %school_settings;

				foreach my $ss (@{$ss_ref}) {
					if ($ss->{tag} eq "date") {
						$ss->{value_date} =~ s/Z//g;
						$ss->{value_date} =~ s/T/\ /g;
						$school_settings{$ss->{school}}{$ss->{tag}} = $ss->{value_date};
					} elsif ($ss->{tag} eq "json" || $ss->{tag} eq "text") {
						$school_settings{$ss->{school}}{$ss->{tag}} = $ss->{value_text};
					} else {
						$school_settings{$ss->{school}}{$ss->{tag}} = $ss->{value};
					}
				}

				my $update_student = $dbh->prepare("
					update student set first = ?, middle = ?, last = ?, nsda = ?, person = ?
					where id = ?
				");

				my $delete_es = $dbh->prepare("
					delete from entry_student where entry = ? and student = ?
				");

				&outlog("<p class='action'> Finding existing students </p>");

				my $students_sth = $dbh->prepare("
					select
						student.id, student.first, student.middle, student.last, student.nsda, student.grad_year, student.retired,
						school.id school, student.chapter
					from student, school
					where school.tourn = ?
						and school.chapter = student.chapter
						and student.retired = 0
				");

				$students_sth->execute($tourn->id);
				my $students = $students_sth->fetchall_hash();

				my %students;
				my %sc;

				foreach my $student (@{$students}) {
					$students{$student->{chapter}}{by_id}{$student->{id}} = $student;

					if ($student->{nsda} > 0) {
						$students{$student->{chapter}}{by_nsda}{$student->{nsda}} = $student;
					}
					$students{$student->{chapter}}{by_name}{$student->{first}."-".$student->{last}} = $student;
					$sc{$student->{chapter}} = $student->{chapter};
				}

				&outlog("<p class='action'> Finding existing entries </p>");

				my $entries_sth = $dbh->prepare("
					select entry.*
					from entry, event
					where event.tourn = ?
						and event.id = entry.event
				");

				$entries_sth->execute($tourn->id);
				my $ent_refs = $entries_sth->fetchall_hash();
				my @entries = @{$ent_refs};

				my %entry_by_id;
				my %entry_by_name;
				my %entry_by_code;

				foreach my $ent_ref (@entries) {
					$entry_by_id{$ent_ref->{event}}{$ent_ref->{id}} = $ent_ref;
					$entry_by_name{$ent_ref->{event}}{$ent_ref->{name}} = $ent_ref if $ent_ref->{name};
					$entry_by_code{$ent_ref->{event}}{$ent_ref->{code}} = $ent_ref if $ent_ref->{code};
				}

				my $entry_student_sth = $dbh->prepare("
					select
						es.student, es.entry
					from entry_student es, entry, school
					where school.tourn = ?
						and school.id = entry.school
						and entry.id = es.entry
				");

				$entry_student_sth->execute($tourn->id);
				my $esen = $entry_student_sth->fetchall_hash();
				my %entry_students;

				foreach my $es (@{$esen}) {
					$entry_students{$es->{entry}}{$es->{student}}++;
				}

				my %entry_settings = &find_settings(
					"entry",
					$tourn->id,
					" from entry_setting setting, entry, event",
					" where event.tourn = ? and entry.event = event.id and entry.id = setting.entry ",
					$dbh,
				);

				my $update_entry = $dbh->prepare("
					update entry
						set name = ?, code = ?, ada = ?, dropped = ?, waitlist = ?, unconfirmed = ?, created_at = ?, registered_by = ?
					where entry.id = ?
				");

				&outlog("<p class='action'> Processing schools </p>");

				# SCHOOLS

				SCHOOL:
				foreach my $school (@{$jdata->{schools}}) {

					my $oschool = $school_by_id{$school->{id}};

					unless ($oschool) {
						$oschool = $school_by_chapter{$school->{chapter}};
					}

					unless ($oschool) {
						$oschool = $school_by_nsda{$school->{nsda}};
					}

					unless ($oschool) {
						$oschool = $school_by_name{$school->{name}};
					}

					if ($oschool) {
						$translator{school}{$school->{id}} = $oschool;
					} else {
						&errorlog("NO SCHOOL FOUND FOR name ".$school->{name}." Chapter ".$school->{chapter}." NSDA ".$school->{nsda}." Searching.</p>");
					}

					my $region = $translator{region}{$school->{region}};

					#CHAPTER
					my $ochapter = $chapter_by_id{$school->{chapter}};

					unless ($ochapter) {
						$ochapter = Tab::Chapter->retrieve($school->{chapter}) if $school->{chapter};
					}

					unless ($ochapter) {
						if ($school->{nsda}) {
							$ochapter = Tab::Chapter->search(nsda => $school->{nsda})->first;
						}
					}

					if ($school->{nsda} && (not defined $ochapter)) {

						$ochapter = $m->comp("/funclib/nsda/school_import.mas",
							nsda_school_id => $school->{nsda},
							silent         => 1
						);

						if ($ochapter != int($ochapter)) {
							undef $ochapter;
							$ochapter = Tab::Chapter->search(nsda => $school->{nsda})->first;
						}
					}

					if ($ochapter && (not defined $oschool)) {

						$oschool = Tab::School->create({
							chapter  => $ochapter->id,
							name     => $ochapter->name,
							code     => $school->{code},
							tourn    => $tourn->id,
							onsite   => $school->{onsite} || 0,
							state    => $school->{state},
							region   => $school->{region},
							district => $school->{district}
						});

						$school_by_chapter{$school->{chapter}} = $oschool;
						$school_by_nsda{$school->{nsda}} = $oschool;
						$school_by_name{$school->{name}} = $oschool;

						&outlog("<p class='specific'>Created new school ".$school->{name}." for found chapter ".$ochapter->id."</p>");
					}

					unless ($ochapter) {

						$school->{nsda} = 0 unless $school->{nsda};
						$school->{district} = 0 unless $school->{district};

						$ochapter = Tab::Chapter->create({
							name     => $school->{name},
							state    => $school->{state},
							nsda     => $school->{nsda},
							district => $school->{district}
						});

						&outlog("<p class='specific'>No chapter with name ".$school->{name}." or NSDA ID ".$school->{nsda}." found.  Created $ochapter</p>");
					} else {

						eval {
							$ochapter->nsda($school->{nsda});
							$ochapter->update();
						}
					}

					$school->{onsite} = 0 unless $school->{onsite};

					unless ($oschool) {

						&outlog("<p class='specific'> Creating ".$school->{id}." ".$school->{name}." ");

						$oschool = Tab::School->create({
							name     => $school->{name},
							code     => $school->{code},
							onsite   => $school->{onsite},
							tourn    => $tourn,
							chapter  => $ochapter,
							state    => $school->{state},
							region   => $region,
							district => $school->{district}
						});

						push @actual_schools, $oschool;

					} else {

						&outlog("<p class='specific'>School ".$oschool->name." found for ".$school->{id}." ".$school->{name}." ");

						$oschool->name($school->{name});
						$oschool->code($school->{code});
						$oschool->state($school->{state});
						$oschool->onsite($school->{onsite});
						$oschool->region($region);
						$oschool->district($school->{district});
						$oschool->update();

						push @actual_schools, $oschool;

						# Double pump
						delete $school_by_id{$oschool->id};
					}

					$translator{school}{$school->{id}} = $oschool;

					if ($oschool) {

						# SCHOOL SETTINGS

						if ($school->{settings})  {
							&align_settings($oschool->id, "school", $school_settings{$oschool->id}, $school->{settings}, $dbh);
						}

						foreach my $student (@{$school->{students}}) {

							next unless $student->{first} && $student->{last};
							next if $translator{student}{$student->{id}};

							my $ostudent;
							$ostudent = $students{$student->{chapter}}{by_id}{$student->{id}};
							if ($student->{nsda}) {
								$ostudent = $students{$student->{chapter}}{by_nsda}{$student->{nsda}} unless $ostudent;
							}

							$ostudent = $students{$student->{chapter}}{by_name}{$student->{first}."-".$student->{last}} unless $ostudent;

							my $old_id = $student->{id};

							unless ($ostudent) {

								my $grad_year = $student->{grad_year};
								$grad_year = $default_year->year unless $grad_year;

								my $ostudent_obj = eval {
									return Tab::Student->create({
										chapter   => $student->{chapter},
										first     => $student->{first},
										last      => $student->{last},
										middle    => $student->{middle},
										nsda      => $student->{nsda},
										person    => $student->{person} || 0,
										grad_year => $grad_year
									});
								};

								if ($ostudent_obj) {
									$ostudent = $student;
									$ostudent->{id} = $ostudent_obj->id;
								}

							} else {

								my $delta;

								foreach my $tag ('first', 'middle', 'last', 'nsda', 'person') {
									if ($ostudent->{$tag} ne $student->{$tag}) {
										$delta++;
										last;
									}
								}

								if ($delta) {
									$student->{id} = $ostudent->{id};
									$update_student->execute(
										$student->{first},
										$student->{middle},
										$student->{last},
										$student->{nsda},
										$student->{person},
										$ostudent->{id}
									);

									$ostudent = $student;
								}
								delete $students{$oschool}{by_id}{$ostudent->{id}};
							}

							$translator{student}{$old_id} = $ostudent;
							delete $students{$oschool}{by_id}{$old_id};
						}

						my $found;
						my $created;

						my $total_update = 0;
						my $total_import = 0;
						my $total_prefs = 0;

						my %ratings;
						my $ratings_done;

						# SCHOOL ENTRIES
						if ($school->{entries}) {

							&outlog(" | ".scalar @{$school->{entries}}." entries | ");

							foreach my $event_id (keys %{$translator{event}}) {

								# Entries are imported by event because there can be
								# code overlaps otherwise and that screws up the
								# importer.

								my $oevent = $translator{event}{$event_id};

								foreach my $entry (@{$school->{entries}}) {

									next unless $entry->{event} == $event_id;

									my $oentry = $entry_by_id{$oevent->{id}}{$entry->{id}};

									if ($entry->{name}) {
										$oentry = $entry_by_name{$oevent->{id}}{$entry->{name}} unless $oentry;
									}

									if ($entry->{code}) {
										$oentry = $entry_by_code{$oevent->{id}}{$entry->{code}} unless $oentry;
									}

									my $created_at = parse_date($entry->{created_at});

									foreach my $tag ("ada", "active", "dropped", "waitlist", "unconfirmed") {
										$entry->{$tag} = 0 unless $entry->{$tag} > 0;
									}

									my $old_id = $entry->{id};

									unless ($oentry) {

										$total_import++;

										my $oentry_obj = Tab::Entry->create({
											school        => $oschool->id,
											event         => $oevent->id,
											name          => $entry->{name},
											code          => $entry->{code},
											ada           => $entry->{ada},
											created_at    => $created_at,
											dropped       => $entry->{dropped},
											waitlist      => $entry->{waitlist},
											unconfirmed   => $entry->{unconfirmed},
											registered_by => $entry->{registered_by}
										});

										$oentry = $entry;
										$oentry->{id} = $oentry_obj->id;

									} else {

										my $delta;

										foreach my $key ("name", "code", "ada", "dropped", "waitlist", "unconfirmed", "created_at", "registered_by") {
											if ($entry->{$key} ne $oentry->{$key}) {
												$delta++;
												last;
											}
										}

										if ($delta) {
											$total_update++;
											$update_entry->execute(
												$entry->{name},
												$entry->{code},
												$entry->{ada} || 0,
												$entry->{dropped} || 0,
												$entry->{waitlist} || 0,
												$entry->{unconfirmed} || 0,
												$entry->{created_at} || "0000-00-00 00:00:00",
												$entry->{registered_by} || 0,
												$oentry->{id}
											);
										}

										$entry->{id} = $oentry->{id};
										$oentry = $entry;
										delete $entry_by_id{$oentry->{id}};
									}

									delete $entry_by_id{$old_id};
									$translator{entry}{$old_id} = $oentry;

									# ENTRY SETTINGS
									if ($oentry->{id}) {
										&align_settings(
											$oentry->{id},
											"entry",
											$entry_settings{$oentry->{id}},
											$entry->{settings},
											$dbh
										);
									}

									#HYBRID STATUS
									my $hybrid_school;
									if ($entry->{hybrid}) {

										$hybrid_school = $translator{school}{$entry->{hybrid}};
										if ($hybrid_school) {

											unless (Tab::Strike->search(
												entry  => $oentry->{id},
												type   => "hybrid",
												school => $hybrid_school->id
											)) {

												Tab::Strike->create({
													entry  => $oentry->{id},
													type   => "hybrid",
													tourn  => $tourn,
													school => $hybrid_school->id
												});
											}
										}
									}

									#ENTRY STUDENTS
									my %done;

									STUDENT:
									foreach my $student_id (@{$entry->{students}}) {

										next unless $student_id;
										next if $done{$student_id}++;

										my $ostudent = $translator{student}{$student_id};

										unless ($ostudent && $ostudent->{id}) {
											&outlog("<p>WARN: No student found for record $student_id in entry ".$entry->{code}." ".$entry->{name}."</p>");
											next STUDENT;
										}

										if ($entry_students{$oentry->{id}}{$ostudent->{id}}) {
											delete $entry_students{$oentry->{id}}{$ostudent->{id}};
										} else {
											my $es = Tab::EntryStudent->create({
												entry   => $oentry->{id},
												student => $ostudent->{id}
											});

										}
									}

									foreach my $spare (keys %{$entry_students{$oentry->{id}}}) {
										$delete_es->execute($oentry->{id}, $spare);
										delete $entry_students{$oentry->{id}}{$spare};
									}

									#STRIKES
									if ($entry->{strikes}) {

										my $obj_entry = Tab::Entry->retrieve($oentry->{id});
										my @strikes = $obj_entry->strikes();
										my %strike_by_id = map {$_->id => $_} @strikes;
										my %strike_by_judge = map {$_->judge => $_} @strikes;
										my %strike_by_school = map {$_->school => $_} @strikes;

										STRIKE:
										foreach my $strike (@{$entry->{strikes}}) {

											my $ostrike;

											if ($strike->{tag} eq "hybrid") {

												my $oschool = $translator{school}{$strike->{school}};
												next STRIKE unless $oschool;

												$ostrike = $strike_by_id{$strike->{id}};
												$ostrike = $strike_by_school{$strike->{school}} unless $ostrike;

												if ($ostrike) {

													$ostrike->type($strike->{tag});
													$ostrike->conflict($strike->{conflict});
													$ostrike->conflictee($strike->{conflictee});
													$ostrike->registrant($strike->{registrant});
													$ostrike->school($oschool->id);
													$ostrike->entry($oentry->{id});
													$ostrike->update();

												} else {

													$ostrike = Tab::Strike->create({
														entry      => $oentry->{id},
														type       => $strike->{tag},
														conflict   => $strike->{conflict},
														conflictee => $strike->{conflictee},
														registrant => $strike->{registrant},
														school     => $oschool->id
													});
												}

											} else {

												my $ojudge = $translator{judge}{$strike->{judge}};
												next STRIKE unless $ojudge;

												$ostrike = $strike_by_id{$strike->{id}};
												$ostrike = $strike_by_judge{$strike->{judge}} unless $ostrike;

												if ($ostrike) {

													$ostrike->type($strike->{tag});
													$ostrike->conflict($strike->{conflict});
													$ostrike->conflictee($strike->{conflictee});
													$ostrike->registrant($strike->{registrant});
													$ostrike->judge($ojudge->{id});
													$ostrike->entry($oentry->{id});
													$ostrike->update();

												} else {

													$ostrike = Tab::Strike->create({
														entry      => $oentry->{id},
														type       => $strike->{tag},
														conflict   => $strike->{conflict},
														conflictee => $strike->{conflictee},
														registrant => $strike->{registrant},
														judge      => $ojudge->{id}
													});
												}
											}

											$translator{strike}{$strike->{id}} = $ostrike;
										}

										prune_unused( \%strike_by_id, $translator{strike}, $entry->{strikes});
									}

									# SCHOOL ENTRY RATINGS aka PREFS
									if ($entry->{ratings}) {

										unless ($ratings_done++) {
											$school_ratings_sth->execute($oschool);
											foreach my $result (@{$school_ratings_sth->fetchall_hash}) {
												$ratings{$result->{"entry"}}{$result->{"judge"}}{$result->{"side"}} = $result;
											}
											$school_ratings_sth->finish();
										}

										$total_prefs++;
										my $ocategory = $oevent->category;

										RATING:
										foreach my $rating (@{$entry->{ratings}}) {

											$rating = clean_rating($rating, $nowstring, \%translator, $ocategory);

											next RATING unless $rating->{entry};
											next RATING unless $rating->{judge};
											next RATING unless ($rating->{rating_tier} > 0 || $rating->{ordinal} > 0);
											next RATING if $filter{$rating->{entry}}{$rating->{judge}}{$rating->{side}}++;

											if ($ratings{$rating->{entry}}{$rating->{judge}}{$rating->{side}}{id}) {

												$update_rating_sth->execute(
													$rating->{ordinal},
													$rating->{percentile},
													$rating->{rating_tier},
													$rating->{subset},
													$rating->{side},
													$rating->{entry},
													$rating->{judge},
												);

												delete $ratings{$rating->{entry}}{$rating->{judge}}{$rating->{side}};

											} else {

												$insert_rating_sth->execute(
													$rating->{ordinal},
													$rating->{percentile},
													$rating->{rating_tier},
													$rating->{subset},
													$rating->{side},
													$rating->{entry},
													$rating->{judge},
												);
											}
										}
									}
								}
							}

							foreach my $entry (keys %ratings) {
								if ($ratings{$entry}) {
									foreach my $judge (keys %{$ratings{$entry}}) {
										if (keys %{$ratings{$entry}{$judge}}) {
											$delete_rating_sth->execute($entry, $judge);
										}
									}
								}
							}
						}

						#SCHOOL STRIKES
						if ($school->{strikes}) {

							my @strikes = $oschool->strikes(type => "school");
							my %strike_by_id = map {$_->id => $_} @strikes;
							my %strike_by_judge = map {$_->judge => $_} @strikes;
							my %strike_by_school = map {$_->school => $_} @strikes;

							STRIKE:
							foreach my $strike (@{$school->{strikes}}) {

								my $ostrike;
								my $ojudge = $translator{judge}{$strike->{judge}};

								next STRIKE unless $ojudge;

								$ostrike = $strike_by_id{$strike->{id}};
								$ostrike = $strike_by_judge{$strike->{judge}} unless $ostrike;

								if ($ostrike) {

									$ostrike->type($strike->{tag});
									$ostrike->conflict($strike->{conflict});
									$ostrike->conflictee($strike->{conflictee});
									$ostrike->registrant($strike->{registrant});
									$ostrike->judge($ojudge->{id});
									$ostrike->school($oschool->id);
									$ostrike->update();

								} else {

									$ostrike = Tab::Strike->create({
										school     => $oschool->id,
										type       => $strike->{tag},
										conflict   => $strike->{conflict},
										conflictee => $strike->{conflictee},
										registrant => $strike->{registrant},
										judge      => $ojudge->{id}
									});
								}

								$translator{strike}{$strike->{id}} = $ostrike;
							}

							prune_unused( \%strike_by_id, $translator{strike}, $school->{strikes});
						}

						&outlog(" Imported $total_import and updated $total_update entries</p>");
						if ($total_prefs) {
							&outlog(" Imported $total_prefs pref sheets</p>");
						}

						# SCHOOL JUDGES

						# Ordinarily the judges are stored with the categories to
						# account for neutral/hired judges but if you are importing a
						# school on its own this includes the judges here.

						if ($school->{judges}) {

							my %judge_settings = &find_settings(
								"judge",
								$oschool->id,
								" from judge_setting setting, school, judge",
								" where judge.school = ? and judge.id = setting.judge ",
								$dbh,
							);
							&outlog("<p class='specific'> Loading ".scalar @{$school->{judges}}." judges. | ");

							my $judge_count;
							undef %ratings;
							undef $ratings_done;

							foreach my $category_id (keys %{$translator{category}}) {

								my $ocategory = $translator{category}{$category_id};

								my $judge_sth = $dbh->prepare('
									select
										judge.id, judge.first, judge.middle, judge.last,
										judge.active, judge.ada, judge.obligation, judge.hired,
										judge.category, judge.alt_category, judge.covers, judge.person,
										judge.chapter_judge,
										person.id person_id, person.nsda nsda
									from judge
										left join person on person.id = judge.person
									where judge.category = ?
								');

								my $update_judge = $dbh->prepare("
									update judge
									set code         = ?,
										first        = ?,
										middle       = ?,
										last         = ?,
										active       = ?,
										ada          = ?,
										obligation   = ?,
										hired        = ?,
										category     = ?,
										alt_category = ?,
										covers       = ?,
										person       = ?
									where judge.id   = ?
								");

								my $update_judge_cj= $dbh->prepare("
									update judge
									set chapter_judge = ?
									where judge.id = ?
								");

								$judge_sth->execute($ocategory->id);
								my $judgerefs = $judge_sth->fetchall_hash();

								my %judge_by_id = map {$_->{id} => $_ } @{$judgerefs};
								my %judge_by_person = map {$_->{person_id} => $_ } @{$judgerefs};
								my %judge_by_nsda = map {$_->{nsda} => $_ } @{$judgerefs};

								foreach my $judge (@{$school->{judges}}) {

									next if $translator{judge}{$judge->{id}};
									my $ojudge = $judge_by_id{$judge->{id}};

									unless ($ojudge) {
										$ojudge = $judge_by_person{$judge->{person}} if $judge->{person} > 0;
									}

									unless ($ojudge) {
										$ojudge = $judge_by_nsda{$judge->{nsda}} if $judge->{nsda} > 0;
									}

									#nulls, whiny nulls.
									foreach my $flag ("active", "ada", "school", "person") {
										$judge->{$flag} = 0 unless $judge->{$flag} > 0;
									}

									$judge->{alt_category} = $translator{category}{$judge->{alt_category}} || 0;
									$judge->{covers} = $translator{category}{$judge->{covers}} || 0;

									my $old_id = $judge->{id};

									unless ($ojudge) {

										my $obj = Tab::Judge->create({
											code          => $judge->{code},
											middle        => $judge->{middle},
											first         => $judge->{first},
											last          => $judge->{last},
											active        => $judge->{active},
											ada           => $judge->{ada},
											obligation    => $judge->{obligation},
											hired         => $judge->{hired},
											person        => $judge->{person},
											school        => $oschool->{id},
											category      => $ocategory,
											alt_category  => $judge->{alt_category},
											covers        => $judge->{covers},
										});

										$judge->{id} = $obj->id;
										$ojudge = $judge;

									} else {

										my $delta;
										my @updates;

										foreach my $tag (
											"code", "first", "middle", "last",
											"active", "ada", "obligation", "hired",
											"category", "alt_category", "covers", "person",
										) {
											if ($judge->{$tag} ne $ojudge->{$tag}) {
												$delta++;
											}
											push @updates, $judge->{$tag};
										}

										if ($delta) {
											push @updates, $ojudge->{id};
											$update_judge->execute(@updates);
										}

									}

									$translator{judge}{$old_id} = $ojudge;
									delete $judge_by_id{$old_id};

									&align_settings(
										$ojudge->{id},
										"judge",
										$judge_settings{$ojudge->{id}},
										$judge->{settings},
										$dbh
									);

									#JUDGE STRIKES
									if ($judge->{strikes}) {

										my @strikes = $ojudge->strikes();
										my %strike_by_id = map {$_->id => $_} @strikes;
										my %strike_by_school = map {$_->school => $_} @strikes;
										my %strike_by_entry = map {$_->entry => $_} @strikes;

										STRIKE:
										foreach my $strike (@{$judge->{strikes}}) {

											my $ostrike;
											$ostrike = $strike_by_id{$strike->{id}};

											unless ($ostrike) {
												$ostrike = $strike_by_school{$strike->{school}} if $strike->{school};
											}

											unless ($ostrike) {
												$ostrike = $strike_by_entry{$strike->{entry}} if $strike->{entry};
											}

											my $oschool   = $translator{school}{$strike->{school}} if $strike->{school};
											my $oentry    = $translator{entry}{$strike->{entry}} if $strike->{entry};
											my $oevent    = $translator{event}{$strike->{event}} if $strike->{event};
											my $oregion   = $translator{region}{$strike->{region}} if $strike->{region};
											my $otimeslot = $translator{timeslot}{$strike->{timeslot}} if $strike->{timeslot};

											next STRIKE if $strike->{tag} eq "entry" && (not defined $oentry);
											next STRIKE if $strike->{tag} eq "event" && (not defined $oevent);
											next STRIKE if $strike->{tag} eq "school" && (not defined $oschool);
											next STRIKE if $strike->{tag} eq "region" && (not defined $oregion);
											next STRIKE if $strike->{tag} eq "timeslot" && (not defined $otimeslot);

											my $start_dt = parse_date($strike->{start});
											my $end_dt = parse_date($strike->{end});

											if ($ostrike) {

												$ostrike->judge($ojudge->id) if $ojudge;
												$ostrike->type($strike->{tag});
												$ostrike->conflict($strike->{conflict});
												$ostrike->conflictee($strike->{conflictee});
												$ostrike->registrant($strike->{registrant});

											} else {

												$ostrike = Tab::Strike->create({
													judge      => $ojudge->id,
													type       => $strike->{tag},
													conflict   => $strike->{conflict},
													conflictee => $strike->{conflictee},
													registrant => $strike->{registrant}
												});
											}

											$ostrike->school($oschool->id) if $oschool;
											$ostrike->entry($oentry->{id}) if $oentry;
											$ostrike->event($oevent->id) if $oevent;
											$ostrike->region($oregion->id) if $oregion;
											$ostrike->timeslot($otimeslot->id) if $otimeslot;
											$ostrike->start($start_dt) if $start_dt;
											$ostrike->end($end_dt) if $end_dt;

											$ostrike->district($strike->{district}) if $strike->{district};
											$ostrike->shift($strike->{shift}) if $strike->{shift};

											$ostrike->update();

											$translator{strike}{$strike->{id}} = $ostrike;
										}
										prune_unused( \%strike_by_id, $translator{strike}, $judge->{strikes});
									}

									# JUDGE BASED PREF SHEETS PREFS RATINGS

									if ($judge->{ratings}) {

										unless ($ratings_done++) {
											$school_judge_ratings_sth->execute($oschool);
											foreach my $result (@{$school_judge_ratings_sth->fetchall_hash}) {
												$ratings{$result->{"entry"}}{$result->{"judge"}}{$result->{"side"}} = $result;
											}
											$school_judge_ratings_sth->finish();
										}

										$total_prefs++;

										RATING:
										foreach my $rating (@{$judge->{ratings}}) {

											$rating = clean_rating($rating, $nowstring, \%translator, $ocategory);

											next RATING unless $rating->{entry};
											next RATING unless $rating->{judge};
											next RATING unless ($rating->{rating_tier} > 0 || $rating->{ordinal} > 0);
											next RATING if ($filter{$rating->{entry}}{$rating->{judge}}{$rating->{side}}++);

											if ($ratings{$rating->{entry}}{$rating->{judge}}{$rating->{side}}{id}) {

												$update_rating_sth->execute(
													$rating->{ordinal},
													$rating->{percentile},
													$rating->{rating_tier},
													$rating->{subset},
													$rating->{side},
													$rating->{entry},
													$rating->{judge},
												);

												delete $ratings{$rating->{entry}}{$rating->{judge}}{$rating->{side}};

											} else {

												$insert_rating_sth->execute(
													$rating->{ordinal},
													$rating->{percentile},
													$rating->{rating_tier},
													$rating->{subset},
													$rating->{side},
													$rating->{entry},
													$rating->{judge},
												);
											}
										}
									}
								}

								my $delete_judge = $dbh->prepare('
									delete from judge where id = ?
								');

								foreach my $jid (keys %judge_by_id) {
									$delete_judge->execute($jid);
								}
							}

							foreach my $entry (keys %ratings) {
								if ($ratings{$entry}) {
									foreach my $judge (keys %{$ratings{$entry}}) {
										if (keys %{$ratings{$entry}{$judge}}) {
											$delete_rating_sth->execute($entry, $judge);
										}
									}
								}
							}


							&outlog(" Found or created $judge_count judges. | ");
						}

						# INVOICES (NSDA ONLY)

						my @invoices = $oschool->invoices;
						my %invoice_by_id = map {$_->id => $_} @invoices;
						my %invoice_by_blusynergy = map {$_->blusynergy => $_} @invoices;

						if ($school->{invoices}) {

							foreach my $invoice (@{$school->{invoices}}) {

								my $oinvoice = $invoice_by_id{$invoice->{id}};
								next unless $invoice->{total} > 0;

								unless ($oinvoice) {
									$oinvoice = $invoice_by_blusynergy{$invoice->{blusynergy}};
								}

								unless ($oinvoice) {

									$oinvoice = Tab::Invoice->create({
										school     => $oschool->id,
										blusynergy => $invoice->{blusynergy},
										blu_number => $invoice->{blu_number},
										total      => $invoice->{total},
										paid       => $invoice->{paid},
										details    => $invoice->{details}
									});

								} else {

									$oinvoice->school($oschool->id);
									$oinvoice->blusynergy($invoice->{blusynergy});
									$oinvoice->blu_number($invoice->{blu_number});
									$oinvoice->total($invoice->{total});
									$oinvoice->paid($invoice->{paid});
									$oinvoice->details($invoice->{details});
									$oinvoice->update();
								}

								$translator{invoice}{$invoice->{id}} = $oinvoice;
							}
							prune_unused( \%invoice_by_id, $translator{invoice}, $school->{invoices});
						}

						# CONCESSION PURCHASES ORDERS

						my %purchase_by_id = map {$_->id => $_} $oschool->purchases;

						if ( (not defined $jdata->{"skip-content"}) && $school->{purchases}) {

							foreach my $purchase (@{$school->{purchases}}) {

								next unless $purchase->{quantity} > 0;
								my $opurchase = $purchase_by_id{$purchase->{id}};

								my $concession = $translator{concession}{$purchase->{concession}};
								next unless $concession;

								my $invoice = $translator{invoice}{$purchase->{invoice}};

								unless ($opurchase) {

									$opurchase = Tab::ConcessionPurchase->create({
										school     => $oschool->id,
										quantity   => $purchase->{quantity},
										placed     => $purchase->{placed},
										fulfilled  => $purchase->{fulfilled},
										concession => $concession->id,
										invoice    => $invoice
									});

								} else {

									$opurchase->school($oschool->id);
									$opurchase->quantity($purchase->{quantity});
									$opurchase->placed($purchase->{placed});
									$opurchase->fulfilled($purchase->{fulfilled});
									$opurchase->concession($concession->id);
									$opurchase->invoice($invoice);
									$opurchase->update();

								}

								$translator{purchase}{$purchase->{id}} = $opurchase;
								my %option_by_id = map {$_->concession_option->id => $_} $opurchase->purchase_options();
								my %done;

								foreach my $option ($purchase->{options}) {

									next if $option_by_id{$option};
									my $ooption = $translator{coption}{$option};
									next unless $ooption;
									$done{$ooption->id}++;

									Tab::ConcessionPurchaseOption->create({
										concession_purchase => $opurchase->id,
										concession_option   => $ooption->id,
									});
								}

								foreach my $option (keys %option_by_id) {
									next if $done{$option};
									$option_by_id{$option}->delete;
									delete $option_by_id{$option};
								}
							}
						}

						prune_unused( \%purchase_by_id, $translator{purchase}, $school->{purchases});
					}
				}

				my $delete_entry = $dbh->prepare("
					delete entry.* from entry where id = ?
				");

				foreach my $id (keys %entry_by_id) {
					$delete_entry->execute($id);
				}

				prune_unused( \%school_by_id, $translator{school}, $jdata->{schools}) if $jdata->{whole};

				# FINES FEES AND PAYMENTS
				my @fines = $tourn->fines;

				if ($jdata->{school_only}) {
					undef @fines;
					foreach my $school (@actual_schools) {
						push @fines, Tab::Fine->search(school => $school->{id});
					}
				}

				my %fine_by_id = map {$_->id => $_} @fines;
				my %fine_by_school_reason = map {$_->school."-".$_->reason => $_} @fines;

				if ($jdata->{fines}) {

					&outlog("<p class='action'>Importing payments and fees</p>");

					FINE:
					foreach my $fine (@{$jdata->{fines}}) {

						my $school = $translator{school}{$fine->{school}};

						if ($fine->{school} && (not defined $school)) {

							#Do not prune fines out of scope and move on

							delete $fine_by_id{$fine->{id}};
							next FINE;
						}

						my $region = $translator{region}{$fine->{region}};
						my $judge  = $translator{judge}{$fine->{judge}};

						my $ofine = $fine_by_id{$fine->{id}};

						unless ($ofine) {
							$ofine = $fine_by_school_reason{$fine->{school}."-".$fine->{reason}};
						}

						my $deleted_at = parse_date($fine->{deleted_at});
						my $levied_at = parse_date($fine->{levied_at});

						$fine->{deleted} = 0 unless $fine->{deleted};
						$fine->{payment} = 0 unless $fine->{payment};

						unless ($ofine) {

							$ofine = Tab::Fine->create({
								reason     => $fine->{reason},
								amount     => $fine->{amount},
								payment    => $fine->{payment},
								levied_by  => $fine->{levied_by},
								levied_at  => $levied_at,
								deleted    => $fine->{deleted},
								deleted_by => $fine->{deleted_by},
								deleted_at => $deleted_at,
								tourn      => $tourn->id,
								school     => $school,
								region     => $region,
								judge      => $judge,
								invoice    => $fine->{invoice}
							});

						} else {

							$ofine->reason($fine->{reason});
							$ofine->amount($fine->{amount});
							$ofine->payment($fine->{payment});
							$ofine->levied_at($levied_at);
							$ofine->levied_by($fine->{levied_by});
							$ofine->deleted($fine->{deleted});
							$ofine->deleted_by($fine->{deleted_by});
							$ofine->deleted_at($deleted_at);
							$ofine->tourn($tourn);
							$ofine->school($school);
							$ofine->region($region);
							$ofine->judge($judge);
							$ofine->invoice($fine->{invoice});
							$ofine->update();

							delete $fine_by_id{$ofine->id};
						}

						$translator{fine}{$fine->{id}} = $ofine;
					}

					foreach my $fine (@{$jdata->{fines}}) {
						next unless $fine->{parent};
						my $ofine = $translator{fine}{$fine->{id}};
						my $oparent = $translator{fine}{$fine->{parent}};

						if ($ofine && $oparent) {
							$ofine->parent($oparent);
							$ofine->update();
						}
					}

					prune_unused( \%fine_by_id, $translator{fine}, $jdata->{fines})
						if $jdata->{school_only};
				}

				prune_unused( \%fine_by_id, $translator{fine}, $jdata->{fines});

			} else {

				$translator{school} = \%school_by_id;
				$translator{region} = \%region_by_id;
				my %entry_by_id = $m->comp("/funclib/tourn_entries.mas", tourn => $tourn);
				$translator{entry} = \%entry_by_id;
			}

			if ($jdata->{whole} && (not defined $jdata->{"skip_content"})) {

				my @emails = $tourn->emails;
				my %email_by_id = map {$_->id => $_} @emails;
				my %email_by_subject = map {$_->subject => $_} @emails;

				#EMAILS
				if ($jdata->{emails}) {

					&outlog("<p class='action'>Importing tournament emails</p>");

					foreach my $email (@{$jdata->{emails}}) {

						my $oemail = $email_by_id{$email->{id}};

						unless ($oemail) {
							$oemail = $email_by_subject{$email->{subject}};
						}

						my $content = Tab::Utils::uncompress($email->{content}) if $email->{content};
						my $metadata = Tab::Utils::uncompress($email->{metadata}) if $email->{metadata};

						eval {
							unless ($oemail) {
								$oemail = Tab::Email->create({
									tourn	=> $tourn->id,
									subject  => $email->{subject},
									content  => $content,
									metadata => $metadata,
									sent_to  => $email->{sent_to},
									sent_at  => $email->{sent_at},
									sender   => $email->{sender}
								});
							} else {
								$oemail->subject($email->{subject});
								$oemail->content($content);
								$oemail->metadata($metadata);
								$oemail->sent_to($email->{sent_to});
								$oemail->sent_at($email->{sent_at});
								$oemail->sender($email->{sender});
								$oemail->update();
							}
						};
					}
				}

				prune_unused( \%email_by_id, $translator{email}, $jdata->{emails}) if $jdata->{whole};

				my @webpages = $tourn->webpages;
				my %webpage_by_id = map {$_->id => $_} @webpages;
				my %webpage_by_title = map {$_->title => $_} @webpages;

				#WEBPAGES
				if ($jdata->{webpages}) {

					&outlog("<p class='action'>Importing tournament website data</p>");

					foreach my $webpage (@{$jdata->{webpages}}) {

						my $owebpage = $webpage_by_id{$webpage->{id}};

						unless ($owebpage) {
							$owebpage = $webpage_by_title{$webpage->{title}};
						}

						$webpage->{published} = 0 unless $webpage->{published};

						my $content = Tab::Utils::uncompress($webpage->{content}) if $webpage->{content};

						unless ($owebpage) {

							$owebpage = Tab::Webpage->create({
								tourn       => $tourn->id,
								title       => $webpage->{title},
								content     => $content,
								published   => $webpage->{published},
								special     => $webpage->{special},
								page_order  => $webpage->{page_order},
								last_editor => $webpage->{last_editor},
							});

						} else {

							$owebpage->title($webpage->{title});
							$owebpage->content($content);
							$owebpage->published($webpage->{published});
							$owebpage->special($webpage->{special});
							$owebpage->page_order($webpage->{page_order});
							$owebpage->last_editor($webpage->{last_editor});
							$owebpage->update();
						}

						$translator{webpage}{$webpage->{id}} = $owebpage;
					}

					foreach my $webpage (@{$jdata->{webpages}}) {
						next unless $webpage->{parent};
						my $owebpage = $translator{webpage}{$webpage->{id}};
						my $oparent = $translator{webpage}{$webpage->{parent}};
						$owebpage->parent($oparent);
						$owebpage->update();
					}
				}

				prune_unused( \%webpage_by_id, $translator{webpage}, $jdata->{webpages})
			}
		}
	}

	# EVENTS PART DEUX: ROUNDS AND RESULTS

	if ($jdata->{categories} && (not defined $jdata->{school_only})) {

		unless ($jdata->{event_only} || $jdata->{round_only}) {
			&outlog("<h4 class='martop action'>JUDGES</h4>");
		}

		my %judge_settings = &find_settings(
			"judge",
			$tourn->id,
			" from judge_setting setting, judge, category",
			" where judge.category = category.id and category.tourn = ? and judge.id = setting.judge ",
			$dbh,
		);

		my $cj_sth = $dbh->prepare('
			select
				cj.id, cj.first, cj.middle, cj.last,
				cj.chapter,
				cj.person, person.nsda nsda
			from (chapter_judge cj, school)
				left join person on person.id = cj.person
			where school.tourn = ?
				and school.chapter = cj.chapter
		');

		$cj_sth->execute($tourn->id);
		my $cjrefs = $cj_sth->fetchall_hash();

		my %cj_by_id = map {$_->{id} => $_ } @{$cjrefs};
		my %cj_by_person = map {$_->{chapter}."-".$_->{person} => $_ } @{$cjrefs};
		my %cj_by_nsda = map {$_->{chapter}."-".$_->{nsda} => $_ } @{$cjrefs};
		my %cj_by_name = map {$_->{chapter}."-".$_->{first}."-".$_->{last} => $_ } @{$cjrefs};

		CATEGORY:
		foreach my $category (@{$jdata->{categories}}) {

			my $ocategory = $translator{category}{$category->{id}};

			unless ($ocategory) {
				&outlog("<p class='error'> No category found for ID ".$category->{id}."?  Error in data, skipping</p>");
				next CATEGORY;
			}

			my $judge_sth = $dbh->prepare('
				select
					judge.id, judge.first, judge.middle, judge.last,
					judge.active, judge.ada, judge.obligation, judge.hired,
					judge.category, judge.alt_category, judge.covers, judge.person,
					person.id person_id, person.nsda nsda
				from (judge)
					left join person on person.id = judge.person
				where judge.category = ?
			');

			$judge_sth->execute($ocategory->id);
			my $judgerefs = $judge_sth->fetchall_hash();

			&outlog("<p class='specific'> I have ".scalar @{$judgerefs}." judges already in category ".$ocategory->abbr."</p>");

			my %judge_by_id = map {$_->{id} => $_ } @{$judgerefs};

			my %judge_by_person = map {$_->{person_id} => $_ } @{$judgerefs};
			my %judge_by_nsda = map {$_->{nsda} => $_ } @{$judgerefs};

			if ($category->{judges}
				&& (not defined $jdata->{event_only})
				&& (not defined $jdata->{round_only})
				&& ($perms->{"owner"} || $perms->{"tabber"} || $perms->{category}{$ocategory} eq "tabber")
			) {

				# CATEGORY JUDGES.  This is the ordinary way judges are imported
				# unless this is a single school import, to account for
				# neutral/hires.

				my $update_judge = $dbh->prepare("
					update judge
					set code         = ?,
						first        = ?,
						middle       = ?,
						last         = ?,
						active       = ?,
						ada          = ?,
						obligation   = ?,
						hired        = ?,
						category     = ?,
						alt_category = ?,
						covers       = ?,
						person       = ?
					where judge.id   = ?
				");

				my $update_judge_cj= $dbh->prepare("
					update judge
					set chapter_judge = ?
					where judge.id = ?
				");

				my %ratings;
				my $ratings_done;
				my $counter;

				&outlog("<p class='action'> Importing ".scalar @{$category->{judges}}." judges into category ".$ocategory->abbr."</p>");

				foreach my $judge (@{$category->{judges}}) {

					next if $translator{judge}{$judge->{id}};
					my $ojudge = $judge_by_id{$judge->{id}};

					unless ($ojudge) {
						$ojudge = $judge_by_person{$judge->{person}} if $judge->{person} > 0;
					}

					unless ($ojudge) {
						$ojudge = $judge_by_nsda{$judge->{nsda}} if $judge->{nsda} > 0;
					}

					# Nulls, whiny nulls.
					foreach my $flag ("active", "ada", "school", "person") {
						$judge->{$flag} = 0 unless $judge->{$flag} > 0;
					}

					$judge->{school}       = $translator{school}{$judge->{school}} || 0;
					my $oschool            = $translator{school}{$judge->{school}} || 0;
					$judge->{alt_category} = $translator{category}{$judge->{alt_category}} || 0;
					$judge->{covers}       = $translator{category}{$judge->{covers}} || 0;

					my $old_id = $judge->{id};
					my $chapter;

					if ($oschool > 0) {
						$chapter = $oschool->chapter->id;
					}

					my $cj;

					if ($oschool && $chapter) {
						$cj = $cj_by_id{$judge->{chapter_judge}};
					}

					if ((not defined $cj) && $oschool && $chapter && $judge->{person}) {
						$cj = $cj_by_person{$chapter."-".$judge->{person}};
					}

					if ((not defined $cj) && $oschool && $chapter && $judge->{nsda}) {
						$cj = $cj_by_nsda{$oschool->{chapter}."-".$judge->{nsda}};
					}

					if ((not defined $cj) && $oschool && $chapter && $judge->{first}) {
						$cj = $cj_by_name{$chapter."-".$judge->{first}."-".$judge->{last}};
					}

					my $cj_id = 0;

					if ($cj && $cj->{id}) {
						$cj_id = $cj->{id};

						if ($cj->{person} && ( (not defined $judge->{person}) || $judge->{person} < 1)) {
							$judge->{person} = $cj->{person};
						}
					}

					unless ($ojudge) {

						my $obj = Tab::Judge->create({
							code          => $judge->{code},
							middle        => $judge->{middle},
							first         => $judge->{first},
							last          => $judge->{last},
							active        => $judge->{active},
							ada           => $judge->{ada},
							obligation    => $judge->{obligation},
							hired         => $judge->{hired},
							person        => $judge->{person},
							school        => $judge->{school},
							category      => $ocategory->id,
							alt_category  => $judge->{alt_category},
							covers        => $judge->{covers},
							chapter_judge => $cj_id
						});

						$judge->{id} = $obj->id;
						$ojudge = $judge;

					} else {

						my $delta;
						my @updates;

						$judge->{category} = $ocategory->id;

						foreach my $tag (
							"code", "first", "middle", "last",
							"active", "ada", "obligation", "hired",
							"category", "alt_category", "covers", "person",
						) {
							if ($judge->{$tag} ne $ojudge->{$tag}) {
								$delta++;
							}
							push @updates, $judge->{$tag};
						}

						if ($delta) {
							push @updates, $ojudge->{id};
							$update_judge->execute(@updates);
						}

						if ($cj_id && $cj_id ne $ojudge->{chapter_judge}) {
							$update_judge_cj->execute($cj_id, $ojudge->{id});
						}

						delete $judge_by_id{$ojudge->{id}};
					}

					if ($old_id) {
						$translator{judge}{$old_id} = $ojudge;
						delete $judge_by_id{$old_id};
					}

					&align_settings(
						$ojudge->{id},
						"judge",
						$judge_settings{$ojudge->{id}},
						$judge->{settings},
						$dbh
					);

					unless ($counter < 5 || $counter % 10) {
						&outlog("<p class='action'> Imported ".$counter." judges so far.  Just did ".$judge->{"last"}."</p>");
						$m->flush_buffer() unless $no_return;
					}

					$counter++;
				}

			} else {

				foreach my $jid (keys %judge_by_id) {
					$translator{judge}{$jid} = $judge_by_id{$jid};
				}
				undef %judge_by_id;
			}

			my $delete_judge = $dbh->prepare('
				delete from judge where id = ?
			');

			foreach my $jid (keys %judge_by_id) {
				my $judge = $judge_by_id{$jid};
				$delete_judge->execute($jid);
			}
		}

		unless ($jdata->{event_only} || $jdata->{round_only}) {
			&outlog("<h4 class='martop action'>EVENT ROUNDS AND RESULTS</h4>");
		}

		CATEGORY:
		foreach my $category (@{$jdata->{categories}}) {

			my $ocategory = $translator{category}{$category->{id}};

			unless ($ocategory) {
				&outlog("<p class='error'> No category found for ID ".$category->{id}."?  Error in data, skipping</p>");
				next CATEGORY;
			}

			EVENT:
			foreach my $event (@{$category->{events}}) {

				my $oevent = $translator{event}{$event->{id}};

				unless(
					$perms->{"owner"}
					|| $perms->{"tabber"}
					|| $perms->{category}{$ocategory} eq "tabber"
					|| $perms->{event}{$oevent} eq "tabber"
				) {
					&outlog("<p class='error'> You do not have permission to upload to event ".$event->{id}.".  Skipping</p>");
					next EVENT;
				}

				unless ($oevent) {
					&outlog("<p class='error'> No event found for ID ".$event->{id}." ".$event->{name}."?  Error in data, skipping</p>");
					next EVENT;
				}

				# EVENT ENTRIES:
				# If this is an event or category only file and therefore contains entries

				my $imported_entries = 0;
				my $updated_entries = 0;
				my $pref_count = 0;

				if ($event->{entries}) {

					&outlog("<h5 class='martop action'>ENTRIES</h5>");
					&outlog("<p class='action'> Importing ".scalar @{$event->{entries}}." entries for ".$oevent->name."</p>");

					my $update_student = $dbh->prepare("
						update student set first = ?, middle = ?, last = ?, nsda = ?, person = ?
							where id = ?
					");

					my $delete_es = $dbh->prepare("
						delete from entry_student where entry = ? and student = ?
					");

					&outlog("<p class='action'> Finding existing students </p>");

					my $students_sth = $dbh->prepare("
						select
							student.id, student.first, student.middle, student.last, student.nsda, student.grad_year, student.retired,
							school.id school, student.chapter
						from student, school
						where school.tourn = ?
							and school.chapter = student.chapter
					");

					$students_sth->execute($tourn->id);
					my $students = $students_sth->fetchall_hash();

					my %students;
					my %sc;

					foreach my $student (@{$students}) {
						$students{$student->{school}}{by_id}{$student->{id}} = $student;
						if ($student->{nsda}) {
							$students{$student->{school}}{by_nsda}{$student->{nsda}} = $student;
						}
						$students{$student->{school}}{by_name}{$student->{first}."-".$student->{last}} = $student;
						$sc{$student->{chapter}} = $student->{chapter};
					}

					&outlog("<p class='action'> Finding existing entries </p>");

					my $entries_sth = $dbh->prepare("
						select entry.*
						from entry
						where event = ?
					");

					$entries_sth->execute($oevent->id);

					my $ent_refs = $entries_sth->fetchall_hash();
					my @entries = @{$ent_refs};

					my %entry_by_id;
					my %entry_by_name;
					my %entry_by_code;

					foreach my $ent_ref (@entries) {
						$entry_by_id{$ent_ref->{event}}{$ent_ref->{id}} = $ent_ref;
						if ($ent_ref->{code}) {
							$entry_by_code{$ent_ref->{event}}{$ent_ref->{code}} = $ent_ref;
						}
						$entry_by_name{$ent_ref->{event}}{$ent_ref->{name}} = $ent_ref;
					}

					my $entry_student_sth = $dbh->prepare("
						select
							es.student, es.entry
						from entry_student es, entry
						where entry.event = ?
							and entry.id = es.entry
					");

					$entry_student_sth->execute($oevent->id);
					my $esen = $entry_student_sth->fetchall_hash();
					my %entry_students;

					foreach my $es (@{$esen}) {
						$entry_students{$es->{entry}}{$es->{student}}++;
					}

					my $entry_settings_sth = $dbh->prepare("
						select
							es.tag, es.entry, es.value, es.value_date, es.value_text
						from entry_setting es, entry
						where entry.event = ?
							and entry.id = es.entry
					");

					$entry_settings_sth->execute($tourn->id);
					my $es_ref = $entry_settings_sth->fetchall_hash();

					my %entry_settings;

					my $update_entry = $dbh->prepare("
						update entry
							set name = ?, code = ?, ada = ?, dropped = ?, waitlist = ?, unconfirmed = ?, created_at = ?, registered_by = ?
						where entry.id = ?
					");

					foreach my $es (@{$es_ref}) {
						if ($es->{tag} eq "date") {
							$es->{value_date} =~ s/Z//g;
							$es->{value_date} =~ s/T/\ /g;
							$entry_settings{$es->{entry}}{$es->{tag}} = $es->{value_date};
						} elsif ($es->{tag} eq "json" || $es->{tag} eq "text") {
							$entry_settings{$es->{entry}}{$es->{tag}} = $es->{value_text};
						} else {
							$entry_settings{$es->{entry}}{$es->{tag}} = $es->{value};
						}
					}

					my %ratings;
					my $ratings_done;

					ENTRY:
					foreach my $entry (@{$event->{entries}}) {

						my $oschool = $translator{school}{$entry->{school}};

						unless ($oschool) {
							&errorlog("NO SCHOOL FOUND FOR ENTRY ".$entry->{code}." ".$entry->{name}." with School ID ".$entry->{school}." Skipping.</p>");
							next ENTRY;
						}

						my $oentry;
						$oentry = $entry_by_id{$oevent->{id}}{$entry->{id}};
						if ($entry->{code}) {
							$oentry = $entry_by_code{$oevent->{id}}{$entry->{code}} unless $oentry;
						}
						$oentry = $entry_by_name{$oevent->{id}}{$entry->{name}} unless $oentry;

						my $old_id = $entry->{id};

						unless ($oentry) {

							$imported_entries++;

							my $oentry_obj = Tab::Entry->create({
								school      => $oschool->id,
								event       => $oevent->{id},
								name        => $entry->{name},
								code        => $entry->{code},
								ada         => $entry->{ada} || 0,
								dropped     => $entry->{dropped} || 0,
								waitlist    => $entry->{waitlist} || 0,
								created_at  => $entry->{created_at} || "0000-00-00 00:00:00",
								unconfirmed => $entry->{unconfirmed} || 0,
							});

							$oentry = $entry;
							$oentry->{id} = $oentry_obj->id;

						} else {

							my $delta;

							foreach my $tag ("name", "code", "ada", "dropped", "waitlist", "unconfirmed", "registered_by") {
								if ($entry->{$tag} ne $oentry->{$tag}) {
									$delta++;
								}
							}

							if ($delta && $oentry->{id} && $entry->{name} && $entry->{code}) {
								$updated_entries++;

								$entry->{id} = $oentry->{id};

								$update_entry->execute(
									$entry->{name},
									$entry->{code},
									$entry->{ada} || 0,
									$entry->{dropped} || 0,
									$entry->{waitlist} || 0,
									$entry->{unconfirmed} || 0,
									$entry->{created_at} || "0000-00-00 00:00:00",
									$entry->{registered_by} || 0,
									$oentry->{id},
								);

								$oentry = $entry;
							}
							delete $entry_by_id{$oentry->{id}};
						}

						delete $entry_by_id{$old_id};
						$translator{entry}{$old_id} = $oentry;

						# ENTRY SETTINGS
						if ($oentry->{id}) {
							&align_settings(
								$oentry->{id},
								"entry",
								$entry_settings{$oentry->{id}},
								$entry->{settings},
								$dbh
							);
						}

						#HYBRID STATUS
						my $hybrid_school;
						if ($entry->{hybrid}) {

							$hybrid_school = $translator{school}{$entry->{hybrid}};
							if ($hybrid_school) {

								unless (Tab::Strike->search(
									entry  => $oentry->{id},
									type   => "hybrid",
									school => $hybrid_school->id
								)) {

									Tab::Strike->create({
										entry  => $oentry->{id},
										type   => "hybrid",
										tourn  => $tourn,
										school => $hybrid_school->id
									});
								}
							}
						}

						#ENTRY STUDENTS
						my %done;
						my $ochapter = $oschool->chapter;

						STUDENT:
						foreach my $student (@{$entry->{students}}) {

							next if $done{$student->{id}}++;

							my $ostudent = $students{$entry->{school}}{by_id}{$student->{id}};

							if ($student->{nsda}) {
								$ostudent = $students{$entry->{school}}{by_nsda}{$student->{nsda}} unless $ostudent;
							}

							$ostudent = $students{$entry->{school}}{by_name}{$student->{first}."-".$student->{last}} unless $ostudent;

							unless ($ostudent) {

								my $grad_year = $student->{grad_year};
								$grad_year = $default_year->year unless $grad_year;

								my $student_chapter = $ochapter;
								$student_chapter = $hybrid_school->chapter if $student->{hybrid} && $hybrid_school;

								my $ostudent_obj = Tab::Student->create({
									chapter   => $student_chapter->id,
									first     => $student->{first},
									last      => $student->{last},
									middle    => $student->{middle},
									nsda      => $student->{nsda},
									grad_year => $grad_year
								});

								$ostudent = $student;
								$ostudent->{id} = $ostudent_obj->id;

							} else {

								my $delta;

								foreach my $tag ("first", "middle", "last", "nsda", "person") {
									unless ($ostudent->{$tag} eq $student->{$tag}) {
										$delta++;
										last;
									}
								}

								if ($delta) {

									$update_student->execute(
										$student->{first},
										$student->{middle},
										$student->{last},
										$student->{nsda},
										$student->{person},
										$ostudent->{id}
									);

									$student->{id} = $ostudent->{id};
									$ostudent = $student;
								}
							}

							$translator{student}{$student->{id}} = $ostudent;
							delete $students{$student->{school}}{$ostudent->{id}};

							if ($entry_students{$oentry->{id}}{$ostudent->{id}}) {
								delete $entry_students{$oentry->{id}}{$ostudent->{id}};
							} else {
								eval {
									Tab::EntryStudent->create({
										entry   => $oentry->{id},
										student => $ostudent->{id}
									});
								};
							}
						}

						foreach my $spare (keys %{$entry_students{$oentry->{id}}}) {
							$delete_es->execute($oentry->{id}, $spare);
							delete $entry_students{$oentry->{id}}{$spare};
						}

						#STRIKES
						if ($entry->{strikes}) {

							my $obj_entry = Tab::Entry->retrieve($oentry->{id});
							my @strikes = $obj_entry->strikes();
							my %strike_by_id = map {$_->id => $_} @strikes;
							my %strike_by_judge = map {$_->judge => $_} @strikes;
							my %strike_by_school = map {$_->school => $_} @strikes;

							STRIKE:
							foreach my $strike (@{$entry->{strikes}}) {

								my $ostrike;

								if ($strike->{tag} eq "hybrid") {

									my $oschool = $translator{school}{$strike->{school}};
									next STRIKE unless $oschool;

									$ostrike = $strike_by_id{$strike->{id}};
									$ostrike = $strike_by_school{$strike->{school}} unless $ostrike;

									if ($ostrike) {

										$ostrike->type($strike->{tag});
										$ostrike->conflict($strike->{conflict});
										$ostrike->conflictee($strike->{conflictee});
										$ostrike->registrant($strike->{registrant});
										$ostrike->school($oschool->id);
										$ostrike->entry($oentry->{id});
										$ostrike->update();

									} else {

										$ostrike = Tab::Strike->create({
											type       => $strike->{tag},
											entry      => $oentry->{id},
											conflict   => $strike->{conflict},
											conflictee => $strike->{conflictee},
											registrant => $strike->{registrant},
											school     => $oschool->id
										});
									}

								} else {

									my $ojudge = $translator{judge}{$strike->{judge}};

									next STRIKE unless $ojudge;

									$ostrike = $strike_by_id{$strike->{id}};
									$ostrike = $strike_by_judge{$strike->{judge}} unless $ostrike;

									if ($ostrike) {

										$ostrike->type($strike->{tag});
										$ostrike->conflict($strike->{conflict});
										$ostrike->conflictee($strike->{conflictee});
										$ostrike->registrant($strike->{registrant});
										$ostrike->judge($ojudge->{id} || int($ojudge));
										$ostrike->entry($oentry->{id});
										$ostrike->update();

									} else {

										$ostrike = Tab::Strike->create({
											entry      => $oentry->{id},
											type       => $strike->{tag},
											conflict   => $strike->{conflict},
											conflictee => $strike->{conflictee},
											registrant => $strike->{registrant},
											judge      => $ojudge->{id}
										});
									}
								}

								$translator{strike}{$strike->{id}} = $ostrike;
							}

							prune_unused( \%strike_by_id, $translator{strike}, $entry->{strikes});
						}

						# EVENT ENTRY RATINGS aka PREFS
						if ($entry->{ratings}) {

							unless ($ratings_done++) {
								$event_ratings_sth->execute($oevent);
								foreach my $result (@{$event_ratings_sth->fetchall_hash}) {
									$ratings{$result->{"entry"}}{$result->{"judge"}}{$result->{"side"}} = $result;
								}
								$event_ratings_sth->finish();
							}

							RATING:
							foreach my $rating (@{$entry->{ratings}}) {

								$rating = clean_rating($rating, $nowstring, \%translator, $ocategory);

								next RATING unless $rating->{entry};
								next RATING unless $rating->{judge};
								next RATING unless ($rating->{rating_tier} > 0 || $rating->{ordinal} > 0);
								next RATING if $filter{$rating->{entry}}{$rating->{judge}}{$rating->{side}}++;

								if ($ratings{$rating->{entry}}{$rating->{judge}}{$rating->{side}}{id}) {

									$update_rating_sth->execute(
										$rating->{ordinal},
										$rating->{percentile},
										$rating->{rating_tier},
										$rating->{subset},
										$rating->{side},
										$rating->{entry},
										$rating->{judge},
									);

									delete $ratings{$rating->{entry}}{$rating->{judge}}{$rating->{side}};

								} else {
									$insert_rating_sth->execute(
										$rating->{ordinal},
										$rating->{percentile},
										$rating->{rating_tier},
										$rating->{subset},
										$rating->{side},
										$rating->{entry},
										$rating->{judge},
									);
								}
							}
						}
					}

					foreach my $entry (keys %ratings) {
						if ($ratings{$entry}) {
							foreach my $judge (keys %{$ratings{$entry}}) {
								if (keys %{$ratings{$entry}{$judge}}) {
									$delete_rating_sth->execute($entry, $judge);
								}
							}
						}
					}

					prune_unused( \%entry_by_id, $translator{entry}, $event->{entries});

					&outlog("<h5 class='martop action'>ROUNDS AND RESULTS</h5>");

					if ($pref_count > 0) {
						&outlog(" Imported $imported_entries and updated $updated_entries entries with $pref_count pref sheets</p>");
					} else {
						&outlog(" Imported $imported_entries and updated $updated_entries entries</p>");
					}

				} elsif ($jdata->{round_only} || $jdata->{event_only}) {

					%{$translator{entry}} = map {$_->id => $_} $oevent->entries();
					%{$translator{judge}} = map {$_->id => $_} $m->comp("/funclib/tourn_judges.mas", tourn => $tourn);
				}

				if ($event->{rounds}) {

					&outlog("<p class='action'> Importing ".scalar @{$event->{rounds}}." rounds in ".$oevent->name." </p>");

					my $round_sth = $dbh->prepare("
						select
							round.*
						from round where event = ?
					");

					$round_sth->execute($oevent->id);
					my $rounds_ref = $round_sth->fetchall_hash();

					my %round_by_id = map {$_->{id} => $_ } @{$rounds_ref};
					my %round_by_name = map {$_->{name} => $_ } @{$rounds_ref};

					my $update_round = $dbh->prepare("
						update round set
							type = ?, name = ?, label = ?, flighted = ?, published = ?, post_primary = ?, post_secondary = ?,
							post_feedback = ?, created_at = ?, start_time = ?, timeslot = ?, site = ?, protocol = ?, runoff = ?
						where round.id = ?
					");

					my $delete_round = $dbh->prepare("
						delete from round where id = ?
					");

					# Force the upload of a round into this spot whether it's the original or no.
					if ($round_id && $jdata->{round_only} )  {
						my $target = $round_by_id{$round_id};
						$round_by_id{$jdata->{round_only}} = $target;
					}

					my %round_settings = &find_settings(
						"round",
						$oevent->id,
						" from round_setting setting, round",
						" where round.event = ? and round.id = setting.round ",
						$dbh,
					);

					&outlog("<p style='padding-left: 32px;' class='action'>");
					my $haz_letters;

					# ROUNDS

					ROUND:
					foreach my $round (sort {$a->{name} <=> $b->{name}} @{$event->{rounds}}) {

						&outlog("Round ".$round->{name}." ".$round->{label}." -- ");
						my $oround = $round_by_id{$round->{id}};

						#This section avoids the constraint against two of the same round number in the same event
						if ($oround) {
							my $other_round = $round_by_name{$round->{name}};
							if ($other_round && $other_round->{id} != $oround->{id}) {
								delete $round_by_id{$other_round->{id}};
								delete $round_by_name{$other_round->{name}};
								$delete_round->execute($other_round->{id});
							}
						} else {
							$oround = $round_by_name{$round->{name}};
						}

						my $timeslot = $translator{timeslot}{$round->{timeslot}};

						unless ($timeslot) {

							my $start = parse_date($round->{start_time});
							&outlog("<p class='error'> No timeslot found for ID ".$round->{timeslot}."?");

							if ($start) {
								my $end = $start->clone;
								$end->add(minutes => 90);

								$timeslot = Tab::Timeslot->create({
									name  => "Round ".$round->{name},
									tourn => $tourn->id,
									start => $start,
									end   => $end
								});

								$translator{timeslot}{$round->{timeslot}} = $timeslot;
								&outlog("<p>Created timeslot for round</p>");
							} else {
								&outlog("<p>Error in data, skipping round ".$round->{name}."</p>");
								next ROUND;
							}
						}

						my $site = $translator{site}{$round->{site}};
						$site = $default_site unless $site;

						unless ($round->{protocol}) {
							$round->{protocol} = $round->{tiebreak_set};
							$round->{protocol_name} = $round->{tiebreak_set_name};
						}

						my $protocol = $translator{protocol}{$round->{protocol}};

						# This snippet facilitates importing foreign Districts results from Speechwire
						unless ($protocol) {
							$protocol = $protocol_by_name{$round->{protocol_name}};
						}

						unless ($protocol) {
							&outlog("<p class='error'> No tiebreak set found for ID ".$round->{protocol}." name ".$round->{protocol_name}."?  Error in data, skipping round ".$round->{name}."</p>");
							next ROUND;
						}

						my $start_time = parse_date($round->{start_time});
						my $created    = parse_date($round->{created});

						$round->{event}    = $oevent->id;
						$round->{protocol} = $protocol->id;
						$round->{timeslot} = $timeslot->id;
						$round->{site}     = int($site) || 0;

						if ($round->{created}) {
							$round->{created_at} = $round->{created};
							delete $round->{created};
						}

						my $old_id = $round->{id};

						if ($oround) {

							my $delta;
							my @update;

							foreach my $tag (
								"type", "name", "label", "flighted", "published", "post_primary", "post_secondary",
								"post_feedback", "created_at", "start_time", "timeslot", "site", "protocol", "runoff"
							) {
								if ($round->{$tag} && $round->{$tag} ne $oround->{$tag}) {
									$delta++;
									&outlog("Corresponding round found for ".$round->{name}." but change in $tag found: ".$round->{$tag}." vs ".$oround->{$tag}.".  Updating.");
								}

								push @update, ($round->{$tag} || undef);
							}

							if ($round->{created_at} == 0) {
								$round->{created_at} = undef;
							}

							if ($delta) {
								push @update, $oround->{id};
								$round->{id} = $oround->{id};
								$update_round->execute(@update);
								$oround = $round;
							}

							#Prevent a double pump
							delete $round_by_id{$oround->{id}};

						} else {

							&outlog("No round found for ID ".$round->{id}." name ".$round->{name}." so creating one");

							$round->{created_at} = $created;
							$round->{start_time} = $start_time;
							delete $round->{id};
							delete $round->{settings};
							delete $round->{flights};
							delete $round->{sections};

							my $round_obj = Tab::Round->create({
								name     => $round->{name},
								type     => $round->{type},
								label    => $round->{label},
								flighted => $round->{flighted},
								event    => $round->{event},
								protocol => $round->{protocol},
								timeslot => $round->{timeslot},
								site     => $round->{site},
							});

							$round->{id} = $round_obj->id;
							$oround = $round;
						}

						$translator{round}{$old_id} = $oround;
						&align_settings($oround->{id}, "round", $round_settings{$old_id}, $round->{settings}, $dbh);

						Tab::Score->sql_rm_all->execute($oround->{id});
						Tab::Ballot->sql_rm_all->execute($oround->{id});
						Tab::PanelSetting->sql_rm_all->execute($oround->{id});
						Tab::Panel->sql_rm_all->execute($oround->{id});

						if ($old_id != $oround->{id}){
							Tab::Score->sql_rm_all->execute($old_id);
							Tab::Ballot->sql_rm_all->execute($old_id);
							Tab::PanelSetting->sql_rm_all->execute($old_id);
							Tab::Panel->sql_rm_all->execute($old_id);
						}

						my $section_count;

						#SECTIONS PANELS AND FUN
						if ($round->{sections}) {

							foreach my $section (@{$round->{sections}}) {

								my $oroom = $translator{room}{$section->{room}};

								# Also to help foreign imports and Speechwire
								unless ($oroom) {
									$oroom = $translator{roomname}{$section->{room_name}};
								}

								if ( (not defined $oroom) && $section->{room_name} && $site) {
									$oroom = Tab::Room->create({
										site     => $site->id,
										name     => $section->{room_name},
										ada      => 0,
										inactive => 0
									});
								}

								my $flight = $section->{flight} if $section->{flight} > 0;
								$flight = 1 unless $flight;

								if ($section->{letter}) {
									$haz_letters++;
								}

								my $started_dt = eval {
									return parse_date($section->{started});
								};

								my $osection = Tab::Panel->create({
									room    => $oroom,
									round   => $oround->{id},
									letter  => $section->{letter},
									flight  => $flight,
									bye     => $section->{bye} || 0,
									publish => $section->{publish} || 0,
									bracket => $section->{bracket} || 0,
									started => $started_dt || undef,
								});

								foreach my $psetting (@{$section->{settings}}) {
									my @reply = parse_setting($psetting);
									$osection->setting(@reply) if @reply;
								}

								$translator{section}{$section->{id}} = $osection;
								my %done;

								#BALLOTS and SCORES

								if ($section->{ballots}) {

									my %taken;

									foreach my $ballot (@{$section->{ballots}}) {

										my $oentry = $translator{entry}{$ballot->{entry}};
										my $ojudge = $translator{judge}{$ballot->{judge}};

										next unless $oentry;

										unless (
											$ojudge
											|| $ballot->{bye}
											|| $ballot->{forfeit}
											|| $osection->bye
										) {
											next;
										}

										while ($taken{$ballot->{judge}."-".$ballot->{side}."-".$ballot->{speakerorder}}) {
											if ($oevent->type eq "debate" || $oevent->type eq "wsdc") {
												$ballot->{side}++
											} else {
												$ballot->{speakerorder}++;
											}
										}

										$taken{$ballot->{judge}."-".$ballot->{side}."-".$ballot->{speakerorder}}++;

										my $judge_started_dt = eval {
											return parse_date($ballot->{judge_started});
										};

										if ($person->id == 1 && $ojudge < 1 && (defined $ballot->{judge})) {
											$ojudge = $ballot->{judge};
										}

										next if $done{$ojudge}{$oentry->{id}}{$osection}++;

										my $oballot_ref = {
											panel         => $osection->id,
											side          => $ballot->{side} || 0,
											speakerorder  => $ballot->{speakerorder} || 0,
											judge_started => $judge_started_dt || undef,
											bye           => $ballot->{bye} || 0,
											chair         => $ballot->{chair} || 0,
											audit         => $ballot->{audit} || 0,
											forfeit       => $ballot->{forfeit} || 0,
											tv            => $ballot->{tv}  || 0,
										};

										if ($oentry->{id}) {
											$oballot_ref->{entry} = $oentry->{id};
										}
										if ($ojudge->{id}) {
											$oballot_ref->{judge} = $ojudge->{id};
										}
										if ($ballot->{started_by}) {
											$oballot_ref->{started_by} = $ballot->{started_by};
										}

										my $oballot = Tab::Ballot->create($oballot_ref);

										if ($ballot->{scores}) {

											foreach my $score (@{$ballot->{scores}}) {

												next unless (defined $score->{value});
												next unless $score->{tag};

												foreach my $tag ("speech", "position", "student", "speaker") {
													$score->{$tag} = 0 unless $score->{$tag} > 0;
												}

												my $oscore = Tab::Score->create({
													ballot   => $oballot->id,
													tag      => $score->{tag},
													value    => $score->{value},
													student  => $score->{speaker},
													speech   => $score->{speech},
													topic    => $score->{topic},
													content  => $score->{content},
													position => $score->{position}
												});
											}
										}
									}
								}

								if ($section->{student_votes}) {

									my %taken;
									Tab::StudentVote->sql_rm_all->execute($osection->id);

									foreach my $vote (@{$section->{student_votes}}) {

										my $oentry = $translator{entry}{$vote->{entry}};
										next unless $oentry;

										my $ovoter = $translator{entry}{$vote->{voter}};
										next unless $ovoter;

										my $entered_at = parse_date($vote->{entered_at});

										my $sv = Tab::StudentVote->create({
											tag        => $vote->{tag},
											panel      => $osection->id,
											value      => $vote->{value},
											entry      => $vote->{entry},
											voter      => $vote->{voter},
											entered_by => $vote->{entered_by},
											entered_at => $entered_at
										});
									}
								}
								$section_count++;
							}
						}

						unless ($haz_letters) {
							$m->comp("/funclib/panel_letters.mas", round => Tab::Round->retrieve($oround->{id}));
						}

						&outlog(" $section_count sections done. <br />");
						$m->flush_buffer() unless $no_return;
					}

					unless ($jdata->{round_only}) {
						prune_unused(\%round_by_id, $translator{round}, $event->{rounds});
					}

				} else {
					&outlog("<p class='error'> No rounds for event ".$event->{abbr}.". Not importing ballots</p>");
				}

				#RESULT SETS

				my @rsets = $oevent->result_sets();
				my %rset_by_id =  map {$_->id => $_ } @rsets;
				my %rset_by_label =  map {$_->label => $_ } @rsets;

				if ($event->{result_sets}) {

					my @result_sets = eval {
						return @{$event->{result_sets}};
					};

					unless (@result_sets) {
						if ($event->{result_sets}{label}) {
							push @result_sets, $event->{result_sets};
						}
					}

					&outlog("<p class='action'> Importing ".scalar @result_sets." result sets in ".$oevent->name." </p>");

					foreach my $rset (@result_sets) {

						my $oresult_set;
						$oresult_set = $rset_by_id{$rset->{id}};

						unless ($oresult_set) {
							$oresult_set = $rset_by_label{$rset->{label}};
						}

						my $generated_dt = parse_date($rset->{generated});

						unless ($oresult_set) {

							$oresult_set = Tab::ResultSet->create({
								event     => $oevent->id,
								label     => $rset->{label},
								bracket   => $rset->{bracket},
								published => $rset->{published},
								coach     => $rset->{coach},
								generated => $generated_dt,
								tourn     => $tourn->id
							});

						} else {

							$oresult_set->event($oevent->id);
							$oresult_set->label($rset->{label});
							$oresult_set->bracket($rset->{bracket});
							$oresult_set->published($rset->{published});
							$oresult_set->coach($rset->{coach});
							$oresult_set->generated($generated_dt);
							$oresult_set->tourn($tourn->id);
							$oresult_set->update();

							#Prevent a double pump
							delete $rset_by_id{$oresult_set->id};

						}

						$translator{result_set}{$rset->{id}} = $oresult_set;

						my @results = $oresult_set->results();
						my %result_by_id = map {$_->id => $_} @results;

						my @result_keys = $oresult_set->result_keys();
						my %rkey_by_id = map {$_->id => $_} @result_keys;
						my %rkey_by_tag = map {$_->tag => $_} @result_keys;

						my %keys;

						if ($rset->{result_keys}) {

							my $okey;

							foreach my $rkey (@{$rset->{result_keys}}) {

								if ($rkey_by_id{$rkey->{id}}) {

									$okey = $rkey_by_id{$rkey->{id}};

									$okey->tag($rkey->{tag});
									$okey->description($rkey->{description});
									$okey->no_sort($rkey->{no_sort});
									$okey->sort_desc($rkey->{sort_desc});
									$okey->update();

									$keys{$rkey->{id}} = $okey;

								} elsif ($rkey_by_tag{$rkey->{tag}}) {

									$okey = $rkey_by_tag{$rkey->{tag}};

									$okey->description($rkey->{description});
									$okey->no_sort($rkey->{no_sort});
									$okey->sort_desc($rkey->{sort_desc});
									$okey->update();

									$keys{$rkey->{id}} = $okey;

								} else {

									$okey = Tab::ResultKey->create({
										result_set  => $oresult_set->id,
										tag         => $rkey->{tag},
										description => $rkey->{description},
										no_sort     => $rkey->{no_sort},
										sort_desc   => $rkey->{sort_desc}
									});

									$keys{$rkey->{id}} = $okey;
								}
							}

						} else {

							%keys = map { $_->id => $_ } $oresult_set->result_keys();
						}

						$translator{result_key} = \%keys;

						my $id = 1000;
						my $rkey_rank;

						if ($rset->{results}) {

							foreach my $result (@{$rset->{results}}) {

								unless ($result->{id}) {
									$result->{id} = $id++;
								};

								my $oentry   = $translator{entry}{$result->{entry}};
								my $ostudent = $translator{student}{$result->{student}};
								my $oschool  = $translator{school}{$result->{school}};
								my $oround   = $translator{round}{$result->{round}};

								my $oresult = $result_by_id{$result->{id}};

								unless ($oresult) {

									$oresult = Tab::Result->create({
										result_set => $oresult_set,
										entry      => $oentry->{id},
										student    => $ostudent->{id},
										school     => $oschool,
										round      => $oround->{id},
										rank       => $result->{rank},
										place      => $result->{place},
										percentile => $result->{percentile}
									});

								} else {

									$oresult->result_set($oresult_set);
									$oresult->entry($oentry->{id});
									$oresult->student($ostudent->{id});
									$oresult->school($oschool);
									$oresult->round($oround->{id});
									$oresult->rank($result->{rank});
									$oresult->place($result->{place});
									$oresult->percentile($result->{percentile});
									$oresult->update();
									delete $result_by_id{$oresult->id};
								}

								$translator{result}{$result->{id}} = $oresult;

								my @values = $oresult->values();
								my %value_by_id = map {$_->id => $_} @values;
								my %value_by_priority = map {$_->priority => $_} @values;

								if ($result->{values}) {

									foreach my $value (@{$result->{values}}) {

										my $ovalue = $value_by_id{$value->{id}};

										unless ($ovalue) {
											$ovalue = $value_by_priority{$value->{priority}};
										}

										$value->{no_sort} = 0 unless $value->{no_sort};
										$value->{sort_desc} = 0 unless $value->{sort_desc};

										my $rkey = $translator{'result_key'}{$value->{result_key}};

										unless ($value->{protocol}) {
											$value->{protocol} = $value->{tiebreak_set};
										}
										my $protocol = $translator{'protocol'}{$value->{protocol}};

										$protocol = 0 unless $protocol;
										$rkey = 0 unless $rkey;

										unless ($ovalue) {

											$ovalue = Tab::ResultValue->create({
												result       => $oresult->id,
												value        => $value->{value},
												priority     => $value->{priority},
												result_key   => $rkey,
												protocol => $protocol
											});

										} else {

											$ovalue->result($oresult->id);
											$ovalue->value($value->{value});
											$ovalue->priority($value->{priority});
											$ovalue->result_key($rkey);
											$ovalue->protocol($protocol);
											$ovalue->update();

											delete $value_by_id{$ovalue->id};
										}

										$translator{value}{$value->{id}} = $ovalue;
									}

								} else {

									unless ($rkey_rank) {
										$rkey_rank = Tab::ResultKey->create({
											result_set  => $oresult_set->id,
											tag         => "Ranking",
											description => "Placement in Ranking",
											no_sort     => 0,
											sort_desc   => 0
										});
									}

									my $ovalue = Tab::ResultValue->create({
										result       => $oresult->id,
										value        => $result->{rank},
										priority     => 1,
										result_key   => $rkey_rank,
										protocol => 0
									});
								}

								prune_unused( \%value_by_id, $translator{value}, $result->{values});
							}
						}
						prune_unused( \%result_by_id, $translator{result}, $rset->{results});
					}
					prune_unused( \%rset_by_id, $translator{result_set}, $event->{result_sets});
				}
				&outlog(" ...Event Done</p>");
				$m->flush_buffer() unless $no_return;
			}

			if ($category->{judge_pools}) {
				$category->{jpools} = $category->{judge_pools};
			}

			if ($category->{jpools}) {

				&outlog("<p class='action'> Importing ".scalar @{$category->{jpools}}." judge pools for category ".$ocategory->abbr." </p>");

				#JPOOL JUDGE POOLS
				my $jpool_sth = $dbh->prepare("
					select
						jpool.id, jpool.name, jpool.site, jpool.parent
					from jpool
					where jpool.category = ?
				");

				$jpool_sth->execute($ocategory);

				my $jpool_refs = $jpool_sth->fetchall_hash();
				my %jpool_by_id = map {$_->{id} => $_} @{$jpool_refs};
				my %jpool_by_name = map {$_->{name} => $_} @{$jpool_refs};

				my %jpool_settings  = &find_settings(
					"jpool",
					$ocategory->id,
					" from jpool_setting setting, jpool ",
					" where jpool.category = ? and jpool.id = setting.jpool ",
					$dbh,
				);

				#JPool Rounds
				my $jpr_sth = $dbh->prepare("
					select
						jpr.round, jpr.jpool
					from jpool_round jpr, jpool
					where jpool.category = ?
					and jpool.id = jpr.jpool
				");

				$jpr_sth->execute($ocategory);
				my $jpr_refs = $jpr_sth->fetchall_hash();
				my %jprs;

				foreach my $jpr (@{$jpr_refs}) {
					my $round = $translator{round}{$jpr->{round}} || $jpr->{round};
					$jprs{$jpr->{jpool}}{$round}++;
				}

				#JPool Judges
				my $jpj_sth = $dbh->prepare("
					select
						jpj.judge, jpj.jpool
					from jpool_judge jpj, jpool
					where jpool.category = ?
					and jpool.id = jpj.jpool
				");

				$jpj_sth->execute($ocategory);
				my $jpj_refs = $jpj_sth->fetchall_hash();
				my %jpjs;

				foreach my $jpj (@{$jpj_refs}) {
					my $judge = $translator{judge}{$jpj->{judge}} || $jpj->{judge};
					$jpjs{$jpj->{jpool}}{$judge}++;
				}

				my $update_jp = $dbh->prepare("
					update jpool set name = ?, site = ?, parent = NULL where id = ?
				");

				my $delete_jpj = $dbh->prepare("delete jpj.* from jpool_judge jpj where jpj.jpool = ? and jpj.judge = ?");
				my $delete_jpr = $dbh->prepare("delete jpr.* from jpool_judge jpr where jpr.jpool = ? and jpr.judge = ?");

				my @need_parent;

				foreach my $jpool (@{$category->{jpools}}) {

					&outlog("<p class='action'> Importing ".$jpool->{name}." with ".scalar @{$jpool->{judges}}." judges  </p>");

					my $ojpool = $jpool_by_id{$jpool->{id}};
					$ojpool = $jpool_by_name{$jpool->{name}} unless $ojpool;

					my $site = $translator{site}{$jpool->{site}};
					my $old_id = $jpool->{id};

					if ($ojpool) {
						unless (
							$ojpool->{name} eq $jpool->{name}
							&& $ojpool->{site} eq $jpool->{site}
						) {
							$update_jp->execute($jpool->{name}, $jpool->{site}, $jpool->{id});
						}
						$jpool->{id} = $ojpool->{id};
						$ojpool = $jpool;
						delete $jpool_by_id{$ojpool->{id}};
					} else {
						my $obj = Tab::JPool->create({
							name     => $jpool->{name},
							category => $ocategory,
							site     => $site || 0
						});
						$ojpool = $jpool;
						$ojpool->{id} = $obj->id;
					}

					$translator{jpool}{$old_id} = $ojpool->{id};
					delete $jpool_by_id{$old_id};

					if ($jpool->{parent}) {
						push @need_parent, $jpool;
					}

					&align_settings($ojpool->{id}, "jpool", $jpool_settings{$ojpool->{id}}, $jpool->{settings}, $dbh);

					if ($jpool->{rounds}) {
						foreach my $round (@{$jpool->{rounds}}) {
							my $oround = $translator{round}{$round};
							unless ($jprs{$old_id}{$oround->{id}}) {

								Tab::JPoolRound->create({
									round => $oround->{id},
									jpool => $ojpool->{id}
								});
							}
							delete $jprs{$old_id}{$oround->{id}};
							delete $jprs{$old_id}{$round};
						}
					}

					if ($jpool->{judges}) {
						foreach my $judge (@{$jpool->{judges}}) {
							my $ojudge = $translator{judge}{$judge};
							next unless $ojudge;
							unless ($jpjs{$old_id}{$ojudge->{id}}) {
								Tab::JPoolJudge->create({
									judge => $ojudge->{id},
									jpool => $ojpool->{id}
								});
							}
							delete $jpjs{$old_id}{$ojudge->{id}};
							delete $jpjs{$old_id}{$judge};
						}
					}

					foreach my $key (keys %{$jpjs{$old_id}}) {
						my $judge = $translator{judge}{$key};
						if ($old_id && $judge) {
							$delete_jpj->execute($old_id, $judge);
						}
					}

					foreach my $key (keys %{$jprs{$old_id}}) {
						my $round = $translator{round}{$key};
						if ($old_id && $round) {
							$delete_jpr->execute($old_id, $round);
						}
					}
				}

				my $update_parent = $dbh->prepare("
					update jpool set parent = ? where id = ?
				");

				foreach my $jpool (@need_parent) {
					my $new_id = $translator{jpool}{$jpool->{id}};
					my $parent_id = $translator{jpool}{$jpool->{parent}};
					$update_parent->execute($parent_id, $new_id);
				}
			}
		}

		unless ($jdata->{round_only}) {

			#ROOM POOLS

			my @rpools = $tourn->rpools;
			my %rpool_by_id = map { $_->id => $_ } @rpools;
			my %rpool_by_name = map { $_->name => $_ } @rpools;

			&outlog("<p class='action'> Importing global room pools </p>");

			if ($jdata->{room_pools}) {

				RPOOL:
				foreach my $rpool (@{$jdata->{room_pools}}) {

					my $orpool = $rpool_by_id{$rpool->{id}};

					unless ($orpool) {
						$orpool = $rpool_by_name{$rpool->{name}};
					}

					my $site = $translator{site}{$rpool->{site}};
					$site = 0 unless $site;

					unless ($orpool) {

						$orpool = Tab::RPool->create({
							tourn => $tourn->id,
							name  => $rpool->{name}
						});

					} else {

						$orpool->name($rpool->{name});
						$orpool->update();
						delete $rpool_by_id{$orpool->id};
					}

					$translator{rpool}{$rpool->{id}} = $orpool;
					next unless $orpool;

					#RPOOL ROUNDS

					my %rpool_rounds = map { $_->round->id => $_ }
						Tab::RPoolRound->search(rpool => $orpool->id);

					if ($rpool->{rounds}) {
						foreach my $round (@{$rpool->{rounds}}) {

							my $oround = $translator{round}{$round};
							next unless $oround && $oround->{id};

							if ($rpool_rounds{$oround->{id}}) {
								delete $rpool_rounds{$oround->{id}};
							} else {
								Tab::RPoolRound->create({
									round => $oround->{id},
									rpool => $orpool->id
								});
							}
						}
					}

					#RPOOL ROOMS

					my %rpool_rooms = map { $_->room->id => $_ }
						Tab::RPoolRoom->search(rpool => $orpool->id);

					if ($rpool->{rooms}) {

						foreach my $room (@{$rpool->{rooms}}) {

							my $oroom = $translator{room}{$room};
							next unless $oroom > 0;

							if ($rpool_rooms{$oroom}) {
								delete $rpool_rooms{$oroom};
							} else {
								Tab::RPoolRoom->create({
									room  => $oroom->id,
									rpool => $orpool->id
								});
							}
						}
					}

					foreach my $key (keys %rpool_rooms) {
						$rpool_rooms{$key}->delete();
						delete $rpool_rooms{$key};
					}

					foreach my $key (keys %rpool_rounds) {
						$rpool_rounds{$key}->delete();
						delete $rpool_rounds{$key};
					}
				}
				prune_unused( \%rpool_by_id, $translator{rpool}, $jdata->{room_pools});
			}

			#ROOM TIMEBLOCKS AND EVENT BLOCKS
			foreach my $site (@{$jdata->{sites}}) {

				my $osite = $translator{site}{$site->{id}};
				next unless $osite;

				my @blocks = Tab::RoomStrike->search_by_site($osite->id, $tourn->id);
				my %block_by_id = map {$_->id => $_} @blocks;

				if ($site->{blocks}) {

					foreach my $block (@{$site->{blocks}}) {

						my $oblock;
						$oblock = $block_by_id{$block->{id}};

						if ($oblock) {

							$oblock->type($block->{tag});
							$oblock->room($block->{room});

						} else {
							$oblock = Tab::RoomStrike->create({
								type => $block->{tag},
								room => $block->{room},
							});
						}

						my $start_dt = parse_date($block->{start});
						my $end_dt = parse_date($block->{end});

						$oblock->start($start_dt);
						$oblock->end($end_dt);

						foreach my $key ("event", "judge", "entry") {
							if ($block->{$key}) {
								my $obj = $translator{$key}{$block->{$key}};
								$oblock->$key($obj->id) if $obj > 0;
							}
						}
						$oblock->update();
						delete $block_by_id{$oblock->id};

						$translator{roomblock}{$block->{id}} = $oblock;
					}
					prune_unused( \%block_by_id, $translator{roomblock}, $site->{blocks});
				}
			}
		}
	}

	$m->flush_buffer() unless $no_return;

	if ($no_return eq "speechwire") {
		my $msg = "File uploaded";
		$m->redirect("/tabbing/publish/swdistrict.mhtml?msg=$msg");
	}

	$m->print("</span>");

	&outlog("<h5 class='centeralign redtext'>Data Upload Complete!</h5>");
	$m->print("</div>");
	$m->print("</div>");
	$m->print("</div>");
	$m->flush_buffer() unless $no_return;

	if ($round_id) {
		my $msg = "Round restored from backup";
		my $round = Tab::Round->retrieve($round_id);
        $m->comp("/funclib/round_audit.mas", round => $round);
		$m->redirect("/panel/schemat/show.mhtml?round_id=".$round->id."&msg=$msg");
	}

	$m->flush_buffer() unless $no_return;

	undef $no_return;

	sub parse_date {
		my $string = shift;
		$string =~ s/Z$//g;
		$string =~ s/T/ /g;

		my $dt = eval {
			return DateTime::Format::MySQL->parse_datetime($string);
		};
		return $dt;
	}

	sub parse_setting {

		my $json_ref = shift;

		return unless $json_ref->{tag};
		return unless $json_ref->{value};

		if ($json_ref->{meta} eq "date") {
			my $dt = parse_date($json_ref->{value});
			return unless $dt;
			return ($json_ref->{tag}, $json_ref->{meta}, $dt);
		} elsif ($json_ref->{meta} eq "text" || $json_ref->{meta} eq "json") {
			chomp $json_ref->{value};
			my $value = Tab::Utils::uncompress($json_ref->{value}) if $json_ref->{value};
			my $json = eval { return JSON::decode_json($value); };
			return ($json_ref->{tag}, $json_ref->{meta}, $json);
		} else {
			return ($json_ref->{tag}, $json_ref->{value});
		}
	}

	sub prune_unused {

		my ($objects, $translator, $json) = @_;

		my %taken;

		if (reftype($json) eq "ARRAY") {
			foreach my $value (@{$json}) {
				next unless $translator->{$value->{id}} > 0;
				$taken{$translator->{$value->{id}}}++;
			}
		} elsif (reftype($json) eq "HASH") {
			unless ($translator->{$json->{id}} > 0) {
				$taken{$translator->{$json->{id}}}++;
			}
		}

		my $count;

		if (reftype($objects) eq "HASH") {
			foreach my $key (keys %{$objects}) {
				next if $taken{$key};

				eval {
					$objects->{$key}->delete;
					$count++;
				};
				delete $objects->{$key};
			}
		}

		return $count;
	}

	sub errorlog {
		my $text = shift;
		$m->print('<span class="redtext semibold">');
		$m->print($text);
		$m->print('</span>');
		$m->flush_buffer() unless $no_return;
	}

	sub outlog {
		my $text = shift;
		$m->print($text);
		$m->flush_buffer() unless $no_return;
	}

	sub clean_rating {

		my ($rating, $nowstring, $translator, $category) = @_;

		my $entered = eval {
			return parse_date($rating->{entered});
		};

		unless ($entered) {
			$entered = $nowstring;
		}

		if ($rating->{rating_tier}) {
			my $tier = $translator->{rating_tier}{$rating->{rating_tier}};

			unless ($tier) {
				$tier = $translator->{rating_tier_name}{$category}{$rating->{rating_tier_name}};
			}

			if ($tier) {
				$rating->{rating_tier} = $tier;
			} else {
				$rating->{rating_tier} = 0;
			}
		} else {
			$rating->{rating_tier} = 0;
		}

		if ($rating->{rating_subset}) {
			my $subset = $translator->{rating_subset}{$rating->{rating_subset}};
			unless ($subset) {
				$subset = $translator->{rating_subset_name}{$category}{$rating->{rating_subset}};
			}
			if ($subset) {
				$rating->{rating_subset} = $subset;
			} else {
				$rating->{rating_subset} = 0;
			}
		} else {
			$rating->{rating_subset} = 0;
		}

		unless ($rating->{side}) {
			$rating->{side} = 0;
		}

		if ($translator->{entry}{$rating->{entry}}) {
			$rating->{entry} = $translator->{entry}{$rating->{entry}};
		} else {
			delete $rating->{entry};
		}

		if ($translator->{judge}{$rating->{judge}}) {
			$rating->{judge} = $translator->{judge}{$rating->{judge}};
		} else {
			delete $rating->{judge};
		}

		return $rating;
	}

	sub find_settings {

		my ($target, $target_id, $from, $where, $dbh) = @_;

		my $setting_sth = $dbh->prepare("
			select
				setting.id, setting.tag, setting.".$target.", setting.value, setting.value_date, setting.value_text
			$from
			$where
		");

		$setting_sth->execute($target_id);
		my $set_refs = $setting_sth->fetchall_hash();

		my %settings;

		foreach my $set (@{$set_refs}) {

			if ($set->{value} eq "date") {
				$set->{value_date} =~ s/Z//g;
				$set->{value_date} =~ s/T/\ /g;
				$settings{$set->{$target}}{$set->{tag}} = $set->{value_date};
			} elsif ($set->{value} eq "json" || $set->{value} eq "text") {
				$settings{$set->{$target}}{$set->{tag}} = $set->{value_text};
			} else {
				$settings{$set->{$target}}{$set->{tag}} = $set->{value};
			}
		}

		return %settings;
	}

	sub align_settings  {

		my ($id, $target, $current, $json, $dbh) = @_;

		my $update_ts = $dbh->prepare("update ".$target."_setting set value = ?, value_date = ?, value_text = ? where ".$target." = ? and tag = ?");
		my $insert_ts = $dbh->prepare("insert into ".$target."_setting (value, value_date, value_text, ".$target.", tag) values (?, ?, ?, ?, ?)");
		my $delete_ts = $dbh->prepare("delete ts.* from ".$target."_setting ts where ts.".$target." = ? and ts.tag = ?");

		foreach my $jsetting (@{$json}) {

			unless ($current->{$jsetting->{tag}} eq $jsetting->{value}) {

				if ($jsetting->{meta}) {
					if ($jsetting->{meta} eq "date") {
						$jsetting->{value_date} = $jsetting->{value};
						$jsetting->{value_date} =~ s/Z//g;
						$jsetting->{value_date} =~ s/T/\ /g;
						$jsetting->{value}      = $jsetting->{meta};
					} elsif ($jsetting->{meta} eq "json") {
						chomp $jsetting->{value};
						$jsetting->{value_text} = Tab::Utils::uncompress($jsetting->{value});
						$jsetting->{value}      = $jsetting->{meta};
					} elsif ($jsetting->{meta} eq "text") {
						chomp $jsetting->{value};
						$jsetting->{value_text} = Tab::Utils::uncompress($jsetting->{value});
						$jsetting->{value}      = $jsetting->{meta};
					} else {
					}
				}

				if ($current->{$jsetting->{tag}}) {
					eval {
						$update_ts->execute(
							$jsetting->{value},
							$jsetting->{value_date} || undef,
							$jsetting->{value_text} || undef,
							$id,
							$jsetting->{tag}
						);
					};

				} else {
					$delete_ts->execute($id, $jsetting->{tag});

					eval {
						$insert_ts->execute(
							$jsetting->{value},
							$jsetting->{value_date} || undef,
							$jsetting->{value_text} || undef,
							$id,
							$jsetting->{tag}
						);
					};
				}
			}

			delete $current->{$jsetting->{tag}};
		}

		foreach my $tag (keys %{$current}) {
			$delete_ts->execute($id, $tag);
		}
	}

</%init>
