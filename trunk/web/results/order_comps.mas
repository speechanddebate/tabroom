<%args>
	$tourn
	$basis
	$event
	$nonadv => undef
	$round => undef
	$breaks_only => undef
	$finals_only => undef
	$no_prep => undef
	$debug => 1
</%args>
<%init>

	Tab::debuglog("Ordering system called with debugging on") if $debug == 1;
	Tab::debuglog("Basis is $basis") if $debug == 1;
	Tab::debuglog("Event is ".$event->id." ".$event->name) if $debug == 1;

	# use these if you want to mark in the sql log what is going on:
	#		Tab::Entry->set_sql( mark_seven => "select \"mark seven\"");
	#		Tab::Entry->sql_mark_seven->execute;

	# WARNING:  This script contains a metric shitload of SQL queries and not
	# much Perl.  it's the only way to get things running with acceptable speed
	# and also to have dynamic rulesets.

	# So I'm going to be doing a lot of SELECTing and not much $foo->bar(baz).
	# If you can't cope with that, you're in for a lot of disappointment in
	# life and need to learn how to handle it anyway.

	# Initialize everything by setting all the ranks and points back to the
	# real_ranks and real_points, to make sure that if settings have altered
	# since last we ran this, we can restore everything to the pristine state. 

	$m->comp("prep_ballots.mas", tourn => $tourn, event_id => $event->id) unless $no_prep;

	Tab::Entry->set_sql(clean_tbs => "
			update entry
			set tb0 = 0,
			tb1 = 0,
			tb2 = 0,
			tb3 = 0,
			tb4 = 0,
			tb5 = 0,
			tb6 = 0,
			tb7 = 0,
			tb8 = 0,
			tb9 = 0
			where event = ".$event->id);

	#Clean out all existing tiebreak numbers out of the entry entries.
	Tab::Entry->sql_clean_tbs->execute;

	# Get all the tiebreakers used in this type of results printing, and then
	# order them based on priority, and get a listing of all tiers of priority	
	my $tb_basis = $basis;

	# stupid inconsistent nomenclature.  plurals are evil!  I am stupid!
	$tb_basis = "prelim" if $tb_basis eq "prelims";  
	$tb_basis = "elim" if $tb_basis eq "elims";  

	my @tiebreakers = $tourn->method->tiebreaks(covers => $tb_basis);

	my $err = "You have not defined tiebreakers for the level $basis.  Do so and try
			   again" unless @tiebreakers || $basis eq "all";

	$m->redirect("$Tab::url_prefix/setup/rules/tiebreaks.mhtml?err=$err")
		unless @tiebreakers;

	# This hash will turn into an array of tiebreakers at each priority level.
	# I need to do it this way since sometimes tiebreakers are added together
	# (Such as wanting finals to count twice and other elims to count once).
	my %tiebreaker_priorities = ();

	# This allows you to set judge preference twice and only entryare still-tied
	# kids the 2nd time around.
	my $already_judgepreffed;

	my @subs;

	foreach my $tb (@tiebreakers) { 
		push (@{$tiebreaker_priorities{$tb->priority}}, $tb);
	}

	my @priorities = sort keys %tiebreaker_priorities;

	# Begin to assemble the select statement that will determine which
	# tiebreaks go into the field for this particular tiebreaker.  

	# We do this because we populate the fields in the competitor records with
	# tiebreakers first, and then do a select based on those fields to get the
	# competitors in order.  However, some tiebreakers are going to be largest
	# is best (eg points, recips), and others are going to be smallest is best
	# (eg ranks)

	my $select_statement = "select distinct entry.*";
	my $subquery;

	# We always filter by last-round-entryeted unless we're is breaking out of
	# prelims.  In other words, no one not in semis can break to finals, no one
	# not in finals can place above those who are.  We also put the last round
	# into the entry object here because the results meister wants to know for
	# awards ceremony reasons.

	my $tb_count = 0;
	my $order = 0;

	unless ($basis eq "prelim") {

		$order++;
		my $tb_key = "tb".$tb_count;

		Tab::debuglog("Setting $tb_key to last round") if $debug == 1;

		$select_statement .=",rlast.id as last_round
					from entry,round as rlast
					where entry.dropped != 1
					and entry.waitlist != 1
					and entry.dq != 1
					and entry.event = ".$event->id."
					and rlast.name = entry.$tb_key and rlast.event = ".$event->id;

		# Only tell me the last round for kids who have broken to elims if
		# that's what the calling program wanted:

		$select_statement .=" and rlast.type != \"prelim\" " if $breaks_only;
		$select_statement .=" and rlast.type = \"final\" " if $finals_only;

		#only tell me kids who didn't break if this is nonadvacers.
		$select_statement .=" and rlast.type = \"prelim\" " if $nonadv;
		
		$select_statement .=" order by $tb_key DESC";
			
		Tab::Entry->set_sql(last_round => "
				update entry set $tb_key = (select MAX(round.name) 
				from round,ballot,panel
				where ballot.entry = entry.id
				and ballot.panel = panel.id
				and panel.round = round.id)
				where event = ".$event->id);
			
		Tab::Entry->sql_last_round->execute;
			
		$tb_count++;

	} else { 
	
		$select_statement .=" from entry 
						where event=".$event->id." 
						and entry.dq != 1
						and entry.waitlist != 1
						and dropped != 1 order by ";

	}


	# If students who have noshowed to rounds are categorically forbidden from
	# breaking, make sure you make it so.

	if ($tourn->method->noshows_never_break == 1) { 
		
		my $tb_key = "tb".$tb_count;

		Tab::debuglog("Setting $tb_key to noshows") if $debug == 1;

		$select_statement .=", " if $order;
		$select_statement .=" $tb_key ";
		Tab::Entry->set_sql( no_shows => "
			update entry set $tb_key = 1 where exists ( 
				select id from ballot where ballot.entry = entry.id
				and ballot.noshow = 1) and event =".$event->id);
		Tab::Entry->sql_no_shows->execute;
		$tb_count++;	
		$order++;

	}

	my $ballot_zero_name = "ballot_".$event->id;

	# Now, for each priority level, we calculate out the results based on
	# ranks, reciprocals and the like.  Woot.
	
	# This is a special case governing the rank in round tiebreaker.  This
	# tiebreaker is basically a cumulative score of how the student placed in
	# each given elim round.
	
	# What we do is calculate first the various tiebreakers in the round set up
	# by the user.  Then we'll go through each panel after all that's done and
	# update this tiebreaker with the rank in the round that each kid gets
	# based on the other tiebreakers.  This is then updated into the ballot for
	# each kid for the panel so that they can be used in future rounds as a
	# tiebreaker.  This is mostly for NCFL Nationals.  

	my $rank_in_round_tb;
	my $cume_tb_key;
	my $panel_letter_tb;

	PRIORITY:
	foreach my $pri (@priorities) { 

		my $tb_key = "tb".$tb_count;
	
		$select_statement .= ", " if $order;
		$order++;

		my @tbs = @{$tiebreaker_priorities{$pri}};

		Tab::debuglog("Setting $tb_key to ".$tbs[0]->tiebreaker) if $debug == 1;
	
		if ($tbs[0]->tiebreaker eq "reciprocals" || 
			$tbs[0]->tiebreaker eq "points" || 
			$tbs[0]->tiebreaker eq "judgepref" ) {

				# These are the tiebreakers where more is better.  So sort them
				# in descending order
				Tab::debuglog("$tb_key is a backwards tiebreaker.  Setting DESC") if $debug == 1;
				$select_statement .=" $tb_key DESC" 

		} else { 

				# Otherwise, less is more.
				$select_statement .=" $tb_key" 
		}


		$tb_count++;

		$subquery = "update entry set $tb_key = "; 

		my $i;

		Tab::debuglog("$tb_key has ".scalar @tbs." tiebreakers at the tier.") if $debug == 1;

		foreach my $tb (@tbs) { 

			Tab::debuglog("$tb_key tiebreaker is ".$tb->tiebreaker." in ".$tb->covers) if $debug == 1;

			if ($tb->tiebreaker eq "roundrank") { 

				# This determines the rank in *this* round; it allows the other
				# tiebreakers to run first, and then afterwards updates this
				# tiebreaker to reflect the student's rank in this round and
				# then runs the Giant Ordering Select again to reflect the rank
				# in the round.   Whee.  It also then updates the ballots for
				# the kid to show their rank in the round so that it can be
				# used in future tiebreakers (per NCFL).

				# Set the variable that will signal the later functions below
				# to do their thing.  I can't do anything until the whole
				# shebang is done anyway.
			
				$rank_in_round_tb = $tb_key;
				next PRIORITY;
			}

			if ($tb->tiebreaker eq "panelletter") { 

				# THIS IS AN UGLY HACK.  SHIELD YOUR EYES IF YOU CARE ABOUT
				# THAT SORT OF THING.  

				# So the NCFL has you seed speaker order in elims based on
				# prior panel letters, so as to prevent students from hitting
				# other students from their previous elimination rounds in a
				# fair manner.  I like this, it's a good idea.  However, it
				# means we have to introduce panel letter into our sort order,
				# but *after* we've sorted everything else out.  Therefore,
				# we'll want panel letter to be a tiebreaker for rank in round,
				# but only *after* we do the first select to determine the rank
				# in round.  Since it's not actually a tiebreaker.  So we push
				# this one off for later.

				# Set the variable that will signal the later functions below
				# to do their thing and make panel letters work properly.

				$panel_letter_tb = $tb_key;

				next PRIORITY;

			}

			if ($tb->tiebreaker eq "rankinround") { 

				# This tiebreaker uses the work we did in earlier rounds for
				# the "roundrank" thingy.  It basically adds in the ranks the
				# student achieved within previous elim rounds.  NOTE that this
				# is NOT the actual ballot ranks, but rather their placement
				# within their elim panels (They were 1st in their quarter, 3rd
				# in their semi, etc)
	
				$subquery = $subquery." + " if $i;
				$subquery = $subquery." (

						select sum(ballot.rankinround)/count(distinct ballot.id) * count(distinct panel.id)
								from ballot,panel 
							  	where ballot.entry = entry.id 
							  	and ballot.panel = panel.id";

				# Limit it to the area we're counting of the ranks. (Elims, prelims, etc).

				$subquery = $subquery." and panel.type = \"".$tb->count ."\" " 
					unless $tb->count eq "all" || $tb->count eq "last elim"; 

				# Only count the most recent elimination round if that's your thing.

				$subquery = $subquery." and panel.round = (select round.id
										from round where round.type = \"elim\" 
										and round.preset != 1
										and round.event = panel.event
										order by round.name DESC
										limit 1) " 
										if $tb->count eq "last elim";
										
				$subquery = $subquery." ) * ".$tb->multiplier." ";

			}
			
			if ($tb->tiebreaker eq "ranks") {   # RANKS

				Tab::debuglog("Calculating cume score ") if $debug == 1;
				
				#This is useful later when we need to access cumes directly
				$cume_tb_key = $tb_key;  

				my $cume_query;
			
				$cume_query .=" + " if $i;
				$cume_query .=" (
								select sum(ballot.rank) 
								from ballot,panel 
							  	where ballot.entry = entry.id 
							  	and ballot.panel = panel.id ";

				$cume_query .=" and panel.type = \"".$tb->count ."\" " unless $tb->count eq "all" || $tb->count eq "last elim"; 

				$cume_query .=" and panel.round = (select round.id
										from round 
										where round.type = \"elim\" 
										and round.preset != 1
										and round.event = panel.event
										order by round.name DESC
										limit 1) " 
										if $tb->count eq "last elim";

				$cume_query .=" ) * ".$tb->multiplier." ";

				Tab::debuglog("Cume score query is $cume_query") if $debug == 1;

				$subquery .= $cume_query;

			}

			if ($tb->tiebreaker eq "reciprocals") {   # RECIPROCALS
				$subquery = $subquery." + " if $i;
				$subquery = $subquery." (select sum(1/ballot.rank) from ballot,panel 
							  where ballot.entry = entry.id 
							  and ballot.panel = panel.id ";
				$subquery = $subquery." and panel.type = \"".$tb->count ."\" "
					unless $tb->count eq "all" || $tb->count eq "last elim"; 

				$subquery = $subquery." and panel.round = (select round.id
										from round where round.type = \"elim\" 
										and round.preset != 1
										and round.event = panel.event
										order by round.name DESC
										limit 1
										) " 
										if $tb->count eq "last elim";

				$subquery = $subquery." ) * ".$tb->multiplier." ";
			}

			if ($tb->tiebreaker eq "entryetition") {   # QUALITY OF COMPETITION

				# This calculates  the average ranks of the students that each
				# student entryeted against; the lower the cumulative score
				# here, the better the students entryeted against were.

				$subquery .= " (select sum(ballot3.real_rank)/count(ballot3.id) 
							  	from ballot as ballot1, ballot as ballot2, 
							  	ballot as ballot3";
				$subquery .= ", panel " unless $tb->count eq "all" || $tb->count eq "last elim"; 
				$subquery .= "where ballot1.entry = entry.id 
							  and ballot1.panel = ballot2.panel
							  and ballot3.entry = ballot2.entry";

				$subquery = $subquery." and ballot1.panel = panel.id and panel.type = \"".$tb->count ."\" "
					unless $tb->count eq "all" || $tb->count eq "last elim"; 

				$subquery = $subquery." and panel.round = (select round.id
										from round where round.type = \"elim\" 
										and round.preset != 1
										and round.event = panel.event
										order by round.name DESC
										limit 1
										) " 
										if $tb->count eq "last elim";


				$subquery = $subquery." ) * ".$tb->multiplier." ";
			}

			if ($tb->tiebreaker eq "points") {   # QUALITY POINTS
				$subquery = $subquery." + " if $i;
				$subquery = $subquery." (select sum(ballot.points) from ballot,panel 
							  where ballot.entry = entry.id 
							  and ballot.panel = panel.id ";
				$subquery = $subquery." and panel.type = \"".$tb->count ."\" "
					unless $tb->count eq "all" || $tb->count eq "last elim"; 

				$subquery = $subquery." and panel.round = (select round.id
										from round where round.type = \"elim\" 
										and round.preset != 1
										and round.event = panel.event
										order by round.name DESC
										limit 1
										) " 
										if $tb->count eq "last elim";

				$subquery = $subquery." ) * ".$tb->multiplier." ";
			}

			# Neither of these tiebreakers permit any other at the same
			# priority level.  For that reason, any prior subqueries are simply
			# deleted, as if there are more than one tiebreak at this priority,
			# they're doing something actively wrong and deserve what they get.  

			if ($tb->tiebreaker eq "judgepref") {  

				# JUDGE'S PREFERENCE.  
				my $round;
				my @panels;
	
				if ($tb->count eq "last elim") {

					my @rounds = Tab::Round->search_max_round( $event->id, "elim");
					$round = shift @rounds if @rounds;
					Tab::debuglog("Max round is ".$round->name) if $debug == 1 && $round;  
					@panels = $round->panels if $round;

				} elsif ($tb->count eq "final") { 

					my @rounds = Tab::Round->search( type => "final", event => $event->id);

					if (scalar @rounds > 1) { 

						$err = "You have two rounds marked as finals in ".$event->name.".  This makes it impossible
							to do a judges' preference tiebreaker since there are two
							separate finals.  Either delete one of the finals or remove this
							as a tiebreaker based on finals.";

						$m->redirect("$Tab::url_prefix/setup/rules/tiebreaks.mhtml?err=$err");

					}

					$round = shift @rounds if @rounds;	
					@panels = $round->panels if $round;

					unless ($round) { 

						next PRIORITY;

					}

				} else {

					next PRIORITY;

				}

				foreach my $panel (@panels) { 
	
					my @entries = $panel->entries;

					# Create a hash with the score as the key and the value an array
					# of the entries with that score.

					my %entries_by_value = ();

					foreach my $c (@entries) { 

						push (@{$entries_by_value{$c->$cume_tb_key}}, $c) if $cume_tb_key;
					}

					# If no score has two & only two competitors in it, then we
					# skip this mess.  Otherwise, for each one, we have to do this
					# tiebreaker.

					my @tied_values;
						
					VALUE:
					foreach my $value (keys %entries_by_value) { 

						my @ties; 

						if( $already_judgepreffed ) { 
							
							@ties = Tab::Entry->search_tied($panel->id);
							Tab::debuglog("Ties second: ".scalar @ties) if $debug == 1;

						} else { 

							@ties = @{$entries_by_value{$value}};

						}

						next VALUE if scalar @ties != 2;

						my $tie1 = shift @ties;
						my $tie2 = shift @ties;

						Tab::debuglog("$tb_key tie with ".$tie1->code ." and ".$tie2->code) if $debug == 1;

						# First, check to make sure they're tied on all
						# existing tiebreakers, not just the 1st.   No point in
						# doing judge's preference without a tie; in fact it is
						# meaningless without a tie. 

						# Note to the gentle reader: the following brute force
						# approach sucks sufficient moose wang that as you read
						# it, you may hear every moose in a hundred mile radius
						# simultaneously bellow in ecstacy.
		
						next VALUE unless $tie1->tb0 == $tie2->tb0;			
						next VALUE unless $tie1->tb1 == $tie2->tb1;			
						next VALUE unless $tie1->tb2 == $tie2->tb2;			
						next VALUE unless $tie1->tb3 == $tie2->tb3;			
						next VALUE unless $tie1->tb4 == $tie2->tb4;			
						next VALUE unless $tie1->tb5 == $tie2->tb5;			
						next VALUE unless $tie1->tb6 == $tie2->tb6;			
						next VALUE unless $tie1->tb7 == $tie2->tb7;			
						next VALUE unless $tie1->tb8 == $tie2->tb8;			
						next VALUE unless $tie1->tb9 == $tie2->tb9;			

						# OK, glad that's done with.   Now, make sure they were
						# in the same panel for the last round.

						my @rounds = Tab::Round->search( event => $event->id,
													 name  => $tie1->tb0 );

						my $round = shift @rounds if @rounds;

						next VALUE unless $round;
	
						my @ballots1 = Tab::Ballot->search_round_ballots( $tie1->id, $round->id);
						my @ballots2 = Tab::Ballot->search_round_ballots( $tie2->id, $round->id);

						# They cannot be entryared unless they were on the same panel
						next VALUE unless @ballots1;
						next VALUE unless @ballots2;
						next VALUE unless $ballots1[0]->panel->id == $ballots2[0]->panel->id;

						my $wins1_sql = "update entry set $tb_key = (select count(b1.id)
  	 						from ballot as b1, ballot as b2
    						where b1.judge = b2.judge
    						and b1.rank < b2.rank
    						and b1.panel = ".$ballots1[0]->panel->id."
    						and b2.panel = ".$ballots1[0]->panel->id."
	 						and b1.entry = ". $tie1->id ."
							and b2.entry = ". $tie2->id.") where entry.id = ".$tie1->id;
					
						Tab::Entry->set_sql( tiebreak => $wins1_sql);
						Tab::Entry->sql_tiebreak->execute;
					
						my $wins2_sql = "update entry set $tb_key = (select count(b2.id)
   							from ballot as b1, ballot as b2
    						where b1.judge = b2.judge
    						and b2.rank < b1.rank
    						and b1.panel = ".$ballots1[0]->panel->id."
    						and b2.panel = ".$ballots1[0]->panel->id."
		 					and b1.entry = ". $tie1->id ."
							and b2.entry = ". $tie2->id.") where entry.id = ".$tie2->id;

						Tab::Entry->set_sql( tiebreak => $wins2_sql);
						Tab::Entry->sql_tiebreak->execute;
					
						#each competitor has a lower rank than the other, and put it in 
						#the tb. 

						} # end of foreach value

					}


					# This allows future 3 way ties to be broken once one
					# competitor has been spun out.
					$already_judgepreffed++;

					# For this one we skip the rigamarole at the end.
					$i++;
					next PRIORITY; 

			} # end of judges' preference 

			if ($tb->tiebreaker eq "coinflip") {   # RANDOM NUMBER

				# We need to generate a random number that nonetheless
				# stays consisitent each time that the results page is
				# pulled up.  

				# The seed is the epoch of the date the tournament starts
				# plus the kid's competitor ID. 
				my $seed = $tourn->start->epoch;
				$subquery =  "update entry set $tb_key = (select RAND(entry.id + $seed))"  

			}

			$i++;
	
		} #end of foreach tb

		$subquery = $subquery." where event =".$event->id;

		Tab::Entry->set_sql( tiebreak => $subquery);
		Tab::Entry->sql_tiebreak->execute;

		push (@subs, $subquery);

	} #end of foreach priority

	Tab::Entry->set_sql( ordered => $select_statement.",entry.code" );

	if ($rank_in_round_tb) { 

		# roundrank
		my @entries = Tab::Entry->search_ordered;

		my @max_rounds = Tab::Round->search_max_round($event->id, $basis);
		my $max_round = shift @max_rounds;

		Tab::debuglog("Max round is ".$max_round->name) if $max_round && $debug;  

		my @max_entries = Tab::Entry->search_by_round($max_round->id) if $max_round && $max_round->id;

		my %entry_in_panel = ();

		foreach my $mc (@max_entries) { 
			$entry_in_panel{$mc->id} = $mc->panel_in_round($max_round);
		}

		my %panels_rank = ();

		foreach my $entry (@entries) {

			next unless $entry_in_panel{$entry->id};

			my $rank = $panels_rank{$entry_in_panel{$entry->id}};

			$panels_rank{$entry_in_panel{$entry->id}}++ unless $rank > 0;
			$rank++ unless $rank > 0;

			$panels_rank{$entry_in_panel{$entry->id}}++;

			$entry->$rank_in_round_tb($rank);

			Tab::Ballot->set_sql(update_ballot => 
					"update ballot set rankinround = ". $rank."
					 where panel = ". $entry_in_panel{$entry->id} ."
					 and entry = ". $entry->id);

			Tab::Ballot->sql_update_ballot->execute;

			if ($panel_letter_tb) { 
				#panelletter

				my $lett = $entry_in_panel{$entry->id}->letter;

				my $letter = 1 if $lett eq "A";
				$letter = 2 if $lett eq "B";
				$letter = 3 if $lett eq "C";
				$letter = 4 if $lett eq "D";
				$letter = 5 if $lett eq "E";
				$letter = 6 if $lett eq "F";
				$letter = 7 if $lett eq "G";
				$letter = 8 if $lett eq "H";
 
				$entry->$panel_letter_tb($letter);
			}
			
			$entry->update;
			
		}

	}

	return Tab::Entry->search_ordered;

</%init>
