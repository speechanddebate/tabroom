<%args>
    $round_id
</%args>
<%init>

    my $round = Tab::Round->retrieve($round_id);
    my $timeslot = $round->timeslot;
	my $tourn = $timeslot->tourn;
	
    my $any_problem;
    my $double_booked_judges;
    my $sides_uneven;
    my $unscheduled_teams;
    my $double_scheduled_teams;
    my $same_school_debates;
    my $judgeless_debates;
    my $roomless_panels;
    my $hit_before;
    my $judge_preclusion;
    my $judge_timestrike;
    
    my $dbh = Tab::DBI->db_Main();
    
    #DOUBLE-BOOKED JUDGES

    my $double_judges_sth = $dbh->prepare("
        select distinct judge.* from judge, panel, panel clonepanel, ballot, ballot cloneballot
        where panel.round = $round_id
        and clonepanel.round = panel.round
        and panel.flight = clonepanel.flight
        and panel.id != clonepanel.id
        and panel.id = ballot.panel
        and ballot.judge = judge.id
        and clonepanel.id = cloneballot.panel
        and cloneballot.judge = judge.id
    ");

    $double_judges_sth->execute();

    while (my ($judge, $panel, $clonepanel, $ballot, $cloneballot)  = $double_judges_sth->fetchrow_array() ) {
        my $judge_info = Tab::Judge->retrieve($judge);
        $double_booked_judges .= $judge_info->first." ".$judge_info->last." is double-booked!<br>";
    }
    
    #RIGHT NUMBER OF AFF/NEGS
    
    unless ($round->name%2) {
        #pull last 2 rounds
        my $event_id = $round->event;
        my $last_rd = $round->name - 1;
        my $curr_rd = $round->name;
        my $sides_sth = $dbh->prepare("
            select entry, side, panel.bye, round.name
            from ballot, panel, round
            where panel.round = round.id
            and round.event = $event_id
            and round.name >= $last_rd
            and round.name <= $curr_rd
            and ballot.panel=panel.id
            and round.type != 'prelim'
            and round.type != 'final'
            order by entry, round.name
        ");
    
        $sides_sth->execute();
    
        my $last_entry; my $aff; my $neg; my $had_bye;
        
        while (my ($entry, $side, $bye, $name)  = $sides_sth->fetchrow_array() ) {
            if ( $side == 1 ) { $aff++; }
            if ( $side == 2 ) { $neg++; }
            if ( $bye == 1 ) { $had_bye = 1 }
            #print "round=$name side=$side entry=$entry had_bye=$had_bye aff=$aff neg=$neg bye=$bye<br>";
            if ($last_entry == $entry && $entry > 0) {
                if ($aff != $neg && $had_bye == 0) {
                    my $entry_rec = Tab::Entry->retrieve($entry);
                    $sides_uneven .= $entry_rec->code." has $aff affs and $neg negs in the last 2 rounds<br>" if $entry_rec;
                }
            }
            if ($last_entry == $entry || $entry == 0) {
                $aff=0; $neg=0; $had_bye=0;
            }
            $last_entry=$entry;
        }
    }
    #UNSCHEDULED TEAMS
   
    my @entries = Tab::Entry->search( event => $round->event, dropped => 0, dq => 0 );
    my @ballots = $m->comp('/funclib/round_ballots.mas', round => $round);
    foreach my $entry (@entries) {
        my $ok=0;
        foreach my $ballot (@ballots) {
            $ok=1 if $ballot->entry == $entry;
        }
        if ( $ok == 0 ) { $unscheduled_teams.= $entry->code. " is NOT scheduled<br>"; }
    }
        
    #TEAMS SCHEDULED TOO MANY TIMES
    my $last_entry; 
	my $last_flight;

    @ballots = sort {$b->entry <=> $a->entry } @ballots;

	my %entry_panel;
    foreach my $ballot (@ballots) {

		$double_scheduled_teams.= $ballot->entry->code. " is scheduled twice in the same flight<br>" 
			if $entry_panel{$ballot->entry} && $entry_panel{$ballot->entry} != $ballot->panel->id;

		$entry_panel{$ballot->entry} = $ballot->panel->id;
    }
    
    #MEETING OWN SCHOOL & DEBATES WITH NO JUDGES

	my %panel_entries;

    foreach my $ballot (@ballots) {

		my $entry = $ballot->entry;

		foreach my $other (@{$panel_entries{$ballot->panel->id}}) { 
			next if $entry->id == $other->id;
            $same_school_debates.= $entry->code." and ".$other->code." are from the same school!<br>" if $entry->school->id == $other->school->id;
		}

		push @{$panel_entries{$ballot->panel->id}}, $entry;

    }

    #ROOMS: DEBATES WITH NO ROOMS    
    my @panels = $m->comp('/funclib/round_panels.mas', round => $round);
    my $dummy=0;
    foreach my $panel (@panels) {
        if ( $panel->room == 0 && $panel->bye == 0 ) {
            $dummy ++;
        }
    }
    $roomless_panels = $dummy." panels without rooms<br>" if $dummy;
    
    #TEAMS PREVIOUS MET
    my ($entry_by_id_hash_ref, $precluded_hash_ref) = $m->comp("/funclib/make_pairing_hash.mas", round_id => $round->id);			

    my %entry_by_id = %{$entry_by_id_hash_ref};
    my %precluded = %{$precluded_hash_ref};
    foreach my $panel (@panels) {
        my @entries = $m->comp("/funclib/panel_entries.mas", panel => $panel);
        #print $entries[0]->code." vs ".$entries[1]->code."<br>";
        if ( $precluded{$entries[0]}{$entries[1]} == 1 || $precluded{$entries[1]}{$entries[0]} == 1 ) {
            $hit_before .= $entries[0]->code." and ".$entries[1]->code." have hit before<br>";        
        }
    }

    #JUDGES: HEARING A BLOCKED TEAM/SCHOOL
    #check to make sure this honors school preclusions
    my $strikes_sth = $dbh->prepare("
        select strike.judge, strike.entry, strike.school, entry.school as entry_school, strike.type, strike.start, strike.end
        from strike
        left join entry on strike.entry=entry.id
        where strike.tourn = ".$tourn."
        order by strike.id
    ");

    $strikes_sth->execute();
        
    while (my ($judge, $entry, $school, $entry_school, $type, $start, $end)  = $strikes_sth->fetchrow_array() ) {
        foreach my $ballot (@ballots) {
            if ($judge == $ballot->judge) {
                if ( $entry == $ballot->entry || $school == $ballot->entry->school ) {
                    $judge_preclusion.= $ballot->judge->first." ".$ballot->judge->last." is judging ".$ballot->entry->code." but there is a school or entry preclusion!<br>";
                }
            }
        }
    }

    my $time_strikes_sth = $dbh->prepare("
        select strike.tourn, strike.start, strike.end, strike.type, strike.judge from strike, timeslot
        where strike.tourn = ".$tourn."
        and strike.type = 'time'
        and timeslot.id=".$round->timeslot."
	and strike.start <= timeslot.end 		
	and strike.end >= timeslot.start
    ");

    $time_strikes_sth->execute();

    while (my ($tourn, $start, $end, $type, $judge)  = $time_strikes_sth->fetchrow_array() ) {
        foreach my $ballot (@ballots) {
            if ($judge == $ballot->judge) {
                $judge_timestrike.= $ballot->judge->first." ".$ballot->judge->last." is judging but is unavailable for this timeslot!<br>";
            }
        }
    }

	my $hired_judging_me;

	if ($round->event->judge_group->setting("auto_conflict_hires")) { 

		Tab::JudgeHire->set_sql( "hires_judging_me" => "
			select distinct judge_hire.*
			from judge, ballot, judge_hire, entry, panel
			where panel.round = ? 
			and panel.id = ballot.panel
			and ballot.judge = judge.id
			and ballot.entry = entry.id
			and entry.school = judge_hire.school
			and judge.id = judge_hire.judge
			group by entry.id
		");

		my @judge_hire_conflict = Tab::JudgeHire->search_hires_judging_me($round_id);

		foreach my $conflict (@judge_hire_conflict) { 
			$hired_judging_me = $conflict->judge->first." ".$conflict->judge->last." is judging ".$conflict->school->name." who has hired them.";
		}

	}
    
    #JUDGES: HEARD TEAM BEFORE
    #JUDGES: SHOULD HAVE ROUND OFF
    #JUDGES: HEARING BLOCKED DIVISION
    #ROOMS: ROOMS USED TOO MANY TIMES
    #ROOMS: NOT AVAILABLE
    
    #print $double_booked_judges."<br>" if $double_booked_judges;
    #print $sides_uneven."<br>" if $sides_uneven;
    $any_problem = "OK";
    $any_problem = "NEED TO FIX THIS!" if $double_booked_judges || $sides_uneven || $unscheduled_teams || $double_scheduled_teams || $judgeless_debates || $roomless_panels || $hit_before;
    $any_problem = "NEED TO FIX THIS!" if $judge_preclusion || $judge_timestrike;
        
    return $any_problem, $double_booked_judges, $sides_uneven, $unscheduled_teams, $double_scheduled_teams, $same_school_debates, $judgeless_debates, $roomless_panels, $hit_before, $judge_preclusion, $judge_timestrike, $hired_judging_me;
        
</%init>

