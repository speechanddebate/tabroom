<%args>
	$round_id
</%args>
<%perl>

	# returns 3 basic global hash/arrays; this allows the functions to access
	# the information they need @entries is a global array of all entries in
	# the event; %entries is a hash with record and SOP information in it
	# %precluded stores which teams can't hit each other; 
	
	use POSIX;
	use List::Util 'shuffle';
	use Time::HiRes qw( time );

	my $debug=0;
	print "<strong>In make_pairing_hash.mas<br></strong>" if $debug;
			
	my $round = Tab::Round->retrieve($round_id);
	my $event = $round->event;

	my $oddround=1;
	$oddround = 0 if int($round->name/2) == $round->name/2; 

	$oddround = 1 if $event->setting("no_side_constraints");

	#use this round to seed
	my @round_dummy = Tab::Round->search( name => $round->name-1, event => $round->event );	

	# print "This round ID:".$round->id." this round
	# name:".$round->name."<br>"; print "round for seeding
	# id:".$round_dummy[0]->id." round for seeding
	# name:".$round_dummy[0]->name."<br>";

	my $round_for_seeding;
	my $panel = 0; 
	my $team1; 
	my $team2; 
	my $pullup1; 
	my $pullup2;
	my $side;

	if ( scalar(@round_dummy) > 0 ) {
		$round_for_seeding = Tab::Round->retrieve( $round_dummy[0]->id );
	}

	my $start = time(); 
	my $end = time();

	Tab::Entry->set_sql( pairing_entries => "
		select entry.* from entry 
		where unconfirmed = 0
		and waitlist = 0
		and dropped = 0
		and dq = 0
		and event = ? 
		order by code ");

	my @entries = Tab::Entry->search_pairing_entries($event->id);

	my $ncfl++ if $event->tourn->setting("ncfl");
	my %school_region;

	my $school_debates_self++ if $event->setting("school_debates_self");

	if ($ncfl) { 
		my @schools = $m->comp("/funclib/event_schools.mas", event => $event);
		%school_region = map {$_->id => $_->region->id} @schools;
	}

	# create a hash that stores a boolean value indicating whether teams can
	# debate each other, marked false for same school, hit before, etc.
	my %precluded; 

	# CREATE A 2-DIMENSIONAL HASH WITH ALL THE STUFF YOU NEED TO PAIR
	
	#STEP ONE: create hash and put in entry info
	my %entries;
	undef %entries;

	foreach my $entry (@entries) {

		$entries{$entry->id}{'code'} = $entry->code;
		$entries{$entry->id}{'school'} = $entry->school;
		$entries{$entry->id}{'school'} = $school_region{$entry->school} if $ncfl;

		if ($school_debates_self) { 
			$entries{$entry->id}{'school'} = $entry->id;
		}

		$entries{$entry->id}{'placement'} = $entry->placement;
		$entries{$entry->id}{'seed'} = $entry->seed;
	}

	#only process if there are results
	if ( $round_for_seeding ) {	

		# STEP TWO: now load the number of wins
		my %winloss;
		%winloss = $m->comp("/funclib/entry_wins.mas", event => $event, round => $round_for_seeding);

		foreach my $key ( sort { $entries{$a} <=> $entries{$b} } keys %entries ) {
			$entries{$key}{'wins'} = $winloss{$key}; 
			if ( not $winloss{$key} ) { $entries{$key}{'wins'} = 0; }
		}

		# Load the number of opp wins and the first tiebreaker for non-SOP pairing; should use seed-nowins for pairing, but next_tb is useful

		my ($points_entries_ref, $points_tbs_ref, @junk) = $m->comp("/tabbing/results/order_entries.mas", long_names => 1, round => $round_for_seeding);

		foreach my $key (sort {$a <=> $b} keys %{$points_entries_ref}) { 
			foreach my $entry_id (@{${$points_entries_ref}{$key}}) { 
				$entries{$entry_id}{'next_tb'} = ${$points_tbs_ref}{$entry_id."-2"};
			}
		}
	
		my ($oppwins_entries_ref, $oppwins_tbs_ref, @junque) = $m->comp("/tabbing/results/order_entries.mas", long_names => 1, round => $round_for_seeding, opp_wins_only => "yep");

		foreach my $key (sort {$a <=> $b} keys %{$points_entries_ref}) { 
			foreach my $entry_id (@{${$oppwins_entries_ref}{$key}}) { 
				$entries{$entry_id}{'opp_wins'} = ${$oppwins_tbs_ref}{$entry_id."-1"};
			}
		}

		#STEP THREE: assign the seeds

		if ($round->type ne "prelim") {

			my ($entries_ref, $tbs_ref, $desc_ref, $noshow_ref, $meh, $panrank_ref, $panletter_ref, $long_desc_ref) = $m->comp("/tabbing/results/order_entries.mas", long_names => 1, round => $round_for_seeding);

			my $counter;
			foreach my $key (sort {$a <=> $b} keys %{$entries_ref}) { 
				$counter++;
				foreach my $entry_id (@{${$entries_ref}{$key}}) { 
					$entries{$entry_id}{'seed'} = $counter;
				}
			}
		}	

		#STEP 3.5: assign the seeds without wins. next_tb will display the next tiebreaker but won't fully re-seed

		if ($round->type ne "prelim") {

			my ($entries_ref, $tbs_ref, $desc_ref, $noshow_ref, $meh, $panrank_ref, $panletter_ref, $long_desc_ref) = $m->comp("/tabbing/results/order_entries.mas", long_names => 1, round => $round_for_seeding, skip_wins => 42);

			my $counter;
			foreach my $key (sort {$a <=> $b} keys %{$entries_ref}) { 
				$counter++;
				foreach my $entry_id (@{${$entries_ref}{$key}}) { 
					$entries{$entry_id}{'seed_nowins'}=$counter;
				}
			}
		}	

		if ($debug) {
			$end = time();
			print "First 3.5 steps done:  "; printf("%.2f\n", $end - $start); print "<br>";
		}			

		#STEP FOUR: calculate oppseeds.  Also marks debeted before preclusions and pullups
	
		#Start by pulling all the rounds
		my $rd_name=$round->name;
		if ($debug) {$m->print( "Seeding through round ".$round_for_seeding->name." and pulling opponents through ".($rd_name-1)."<br>" ) ; }

		Tab::Ballot->columns(TEMP => qw/panel_bye/);
				
		Tab::Ballot->set_sql(pull_ballots => "
			select ballot.entry, ballot.panel, ballot.side, ballot.pullup, ballot.bye, panel.id as panelid, panel.bye as panel_bye
			from ballot, panel, round
			where ballot.panel=panel.id
			and panel.round=round.id
			and round.name < $rd_name
			and round.event = $event
			order by round.name, ballot.panel
		");

		my @pairings = Tab::Ballot->search_pull_ballots;
		print "Loaded ".scalar(@pairings)." prior debates<br>" if $debug;

		if ($debug) {
			$end = time();
			print "Loaded ballots before step 4 processing:  "; printf("%.2f\n", $end - $start); print "<br>";
		}			

#		print the pairings, just for debugging	
#		foreach my $pairing (@pairings) {
# 		print "Panel: ".$pairing->panel." entry:".$pairing->entry." ".$entries{$pairing->entry}{'code'}." side=".$pairing->side."<br>";
#		}
	
		# now loop through each team; this ALSO marks opponents as having debated so they don't hit in the future, and sets pullups 
	
		my $counter;
		foreach my $pairing (@pairings) {
		
			if ( $pairing->panel_bye) {
				$precluded{$pairing->entry->id}{-1} = 1; #mark as ineligible to hit b/c they debated before
			}
				
			$counter++;
			if ($panel && ($panel != $pairing->panelid || $counter == scalar @pairings ) ) { 
			

			    	#unless ($pairing->panel_bye) { #not sure who coded this, but this loads the prior debate into the hash
				    				#and this line prevents it if the curret line is a bye...I think line below
				    				#fixes this	

				unless ( $team1 == 0 || $team2 ==0 ) {
				    
					if ($counter == scalar(@pairings) and $team2 == 0) {
						$team2 = $pairing->entry->id;
						$pullup2 = $pairing->pullup;
					}
					
					$entries{$team1}{'n_opp'}++;
					$entries{$team1}{'tot_opp_seed'} += $entries{$team2}{'seed'};
					$entries{$team1}{'pullup'} += $pullup1;
					$entries{$team1}{'pullup'} -= $pullup2; #substract, means you've been pulled down once
					$entries{$team2}{'n_opp'}++;
					$entries{$team2}{'tot_opp_seed'} += $entries{$team1}{'seed'};
					$entries{$team2}{'pullup'} += $pullup2;
					$entries{$team2}{'pullup'} -= $pullup1; 
					$precluded{$team1}{$team2} = 1; #mark as ineligible to hit b/c they debated before
				}
				
				$team1 = 0; 
				$team2 = 0;	
					
			}

			if ($team1 == 0 and $team2 == 0) { 
				$team1 = $pairing->entry->id if $pairing->entry;
				$pullup1 = $pairing->pullup; 
			} elsif ($team1 > 0 and $team2 == 0 ) {
				$team2 = $pairing->entry->id if $pairing->entry;
				$pullup2 = $pairing->pullup; 
			}
	
			$side = 1;

			if ( $pairing->side == 1 ) { 
				$side = 2; 
			}

			$entries{$pairing->entry}{'sidedue'} = $side;

			if ( $oddround == 1 ) { $entries{$pairing->entry}{'sidedue'} = 0; }

			$panel = $pairing->panel;
		}

		#if there's some data detritus for teams paired against dropped opponents it adds them to the %entries hash
		#so this thing cleans it up
	
		foreach my $key ( keys %entries ) {
			if (not $entries{$key}{'code'} ) { 
				delete $entries{$key}; 
			}
		}
	
		foreach my $key ( keys %entries ) {
			if ( $entries{$key}{'n_opp'} > 0 ) {
				$entries{$key}{'oppseed'} = $entries{$key}{'tot_opp_seed'} / $entries{$key}{'n_opp'} ;
				$entries{$key}{'SOP'} = $entries{$key}{'oppseed'} + $entries{$key}{'seed'} ;
			}
			if ( $entries{$key}{'n_opp'} == 0 ) {
#				print "Entry with no opponents: ".$entries{$key}{'code'}." ".$entries{$key}{'tot_opp_seed'}." ".$entries{$key}{'n_opp'}."<br>";
			}
		}
	}
	
	if ($debug) {
		$end = time();
		print "Finished fourth step/SOP and pullups:  "; printf("%.2f\n", $end - $start); print "<br>";
	}			

	
	# CREATE HASH THAT KNOWS WHO CAN DEBATE WHO; hit before constraint added
	# above; hash declared at the very top, so we only need school conflicts

	unless ($school_debates_self) {

		#pull hybrid school conflicts
		my @strikes = Tab::Strike->search( tourn => $round->event->tourn, type => 'hybrid' );	

		my %school_entries;

		foreach my $entry (@entries) { 
			push @{$school_entries{$entry->school->id}}, $entry->id;
		}

		foreach my $strike (@strikes) { 
			push @{$school_entries{$strike->school->id}}, $strike->entry->id;
		}

		foreach my $school (keys %school_entries) { 
			foreach my $entry (@{$school_entries{$school}}) { 
				foreach my $teammate (@{$school_entries{$school}}) { 
					$precluded{$entry}{$teammate} = 1;
				}
			}
		}
	}

	if ($debug) {
		$end = time();
		print "Finished school conflicts:  "; printf("%.2f\n", $end - $start); print "<br>";
	}			

	# LOAD CURRENT PAIRINGS AND STORE THEM IN THE HASH

	Tab::Ballot->columns(TEMP => qw/bye/);

	Tab::Ballot->set_sql(current_ballots => "
		select ballot.id, ballot.entry, ballot.panel, ballot.side, panel.bye as bye
		from ballot, panel, round
		where ballot.panel = panel.id
		and panel.round = round.id
		and round.id = $round_id
		order by round.name, panel.id
	");
	
	my @pairings_current = Tab::Ballot->search_current_ballots;

	my $bye;

	my %panel_entries;
	my %entry_panel;
	my @current_entries;
	
	foreach my $pairing (@pairings_current) {

		next unless $pairing->entry && $pairing->entry->id;

		my $me = $pairing->entry->id;

		push @current_entries, $me;
		$entry_panel{$me} = $pairing->panel->id;

		push @{$panel_entries{$pairing->panel->id}}, $me;

		$entries{$me}{'side'} = $pairing->side;
		$entries{$me}{'opponent'}= -1 if $pairing->bye; 
		$entries{$me}{'panel'}= $pairing->panel->id; 
	}

	foreach my $me (@current_entries) {
		foreach my $other (@{$panel_entries{$entry_panel{$me}}}) { 
			next if $me == $other;
			$entries{$me}{'opponent'}= $other;
		}
	}

	if ($debug) {
		$end = time();
		print "finished final loop and <STRONG>make_pairing_hash DONE</STRONG>:  "; printf("%.2f\n", $end - $start); print "<br>";
	}			

	return \%entries, \%precluded ;

</%perl>
