<%args>
	$round_id
</%args>
<%doc>

	Check the bottom for the hash definitions.  Init blocks always are run
	first.  There's no need to create a separate module file for code that will
	never be called by something other than this screen. 

</%doc>
<%init>

	my $round = Tab::Round->retrieve($round_id);
    my $timeslot = $round->timeslot;
	my $tourn = $timeslot->tourn;

	my %tags; 
	my %problems;
	
    my $dbh = Tab::DBI->db_Main();
    
    #DOUBLE-BOOKED JUDGES

	$tags{"double_booked_judges"} = "Double-booked judges this round";

    my $double_judges_sth = $dbh->prepare("
        select distinct judge.* from judge, panel, panel clonepanel, ballot, ballot cloneballot
        where panel.round = $round_id
        and clonepanel.round = panel.round
        and panel.flight = clonepanel.flight
        and panel.id != clonepanel.id
        and panel.id = ballot.panel
        and ballot.judge = judge.id
        and clonepanel.id = cloneballot.panel
        and cloneballot.judge = judge.id
    ");

    $double_judges_sth->execute();

    while (my ($judge, $panel, $clonepanel, $ballot, $cloneballot)  = $double_judges_sth->fetchrow_array() ) {
        my $judge_info = Tab::Judge->retrieve($judge);
        $problems{"double_booked_judges"} .= $judge_info->first." ".$judge_info->last." is double-booked!<br>";
    }
    
    #RIGHT NUMBER OF AFF/NEGS

	$tags{"sides_uneven"} = "Side equalizations";
    
    unless ($round->name%2 || $round->type eq "elim" || $round->type eq "final") {
        #pull last 2 rounds
        my $event_id = $round->event;
        my $last_rd = $round->name - 1;
        my $curr_rd = $round->name;
        my $sides_sth = $dbh->prepare("
            select entry, side, panel.bye, round.name
            from ballot, panel, round
            where panel.round = round.id
            and round.event = $event_id
            and round.name >= $last_rd
            and round.name <= $curr_rd
            and ballot.panel=panel.id
            and round.type != 'prelim'
            and round.type != 'final'
            order by entry, round.name
        ");
    
        $sides_sth->execute();
    
        my %sides; my $rd1; my $rd2;
        
        while (my ($entry, $side, $bye, $name)  = $sides_sth->fetchrow_array() ) {
            $sides{$entry}{$name} = $side; 
            if ( $bye == 1 ) { $sides{$entry}{$name} = "bye"; }
            if ( $rd1 && $name != $rd1 ) { $rd2 = $name; }
            $rd1 = $name unless $rd1;
        }
        
        #print "Round 1 is $rd1 and Round 2 is $rd2<br>";
        
        foreach my $key (keys %sides ) {
            if ($sides{$key}{$rd1} == $sides{$key}{$rd2} && $sides{$key}{$rd1} ne "bye" && $sides{$key}{$rd2} ne "bye" ) {
                my $entry_rec = Tab::Entry->retrieve($key);
                #print $entry_rec->code." ".$key." ".$sides{$key}{$rd1}." ".$sides{$key}{$rd2}."<br>";
                $problems{"sides_uneven"} .= $entry_rec->code." should be on the opposite side this round!<br>";
            }
        }
    }

    #UNSCHEDULED ENTRIES
	$tags{"unscheduled_entries"} = "Entries not on the pairing";
   
    my @entries = Tab::Entry->search( event => $round->event, dropped => 0, dq => 0 );
    my @ballots = $m->comp('/funclib/round_ballots.mas', round => $round);
    unless ($round->type eq "elim" || $round->type eq "final") {
        foreach my $entry (@entries) {
            my $ok=0;
            foreach my $ballot (@ballots) {
                $ok=1 if $ballot->entry == $entry;
            }
            if ( $ok == 0 ) { $problems{"unscheduled_entries"}.= $entry->code. " is NOT scheduled<br>"; }
        }
    }
    
    #ENTRIES SCHEDULED TOO MANY TIMES
	$tags{"double_scheduled_entries"} = "Entries on the pairing twice";
    
    my $last_entry; my $last_flight; my $last_panel;
    @ballots = sort {$b->entry <=> $a->entry } @ballots;

	my %entry_panel;
    foreach my $ballot (@ballots) {
        if ( $ballot->entry->id == $last_entry && $ballot->panel->flight == $last_flight && $ballot->entry->id > 0 && $ballot->panel != $last_panel ) {
            my $entry_rec = Tab::Entry->retrieve($ballot->entry->id) if $ballot->entry;
            $problems{"double_scheduled_entries"}.= $entry_rec->code. " is scheduled twice in the same flight<br>";
        }
        $last_entry = $ballot->entry->id;
        $last_flight = $ballot->panel->flight;
        $last_panel = $ballot->panel;
    }
    
    #MEETING OWN SCHOOL & DEBATES WITH NO JUDGES
	$tags{"same_school_debates"} = "Entries debating their own program";
	$tags{"judgeless_debates"} = "Debates without judges";

    my $last_school; 
    @ballots = sort {$b->panel <=> $a->panel } @ballots;
    foreach my $ballot (@ballots) {
        if ( $ballot->entry->school == $last_school && $ballot->panel == $last_panel && $ballot->entry != $last_entry ) {
            my $entry_rec = Tab::Entry->retrieve($ballot->entry->id) if $ballot->entry;
            my $entry_rec_2 = Tab::Entry->retrieve($last_entry) if $last_entry;
            $problems{"same_school_debates"}.= $entry_rec->code." and ".$entry_rec_2->code." are from the same school!<br>";
        }
        if ( $ballot->judge == 0 && $ballot->bye == 0 && $ballot->panel->bye == 0 && $ballot->panel ==  $last_panel ) {
            $problems{"judgeless_debates"}.= $ballot->entry->code." vs. ".$last_entry->code." have no judge!<br>";
        }
        $last_entry = $ballot->entry->id;
        $last_school = $ballot->entry->school;
        $last_panel = $ballot->panel;
    }

    #ROOMS: DEBATES WITH NO ROOMS    
	$tags{"roomless_panels"} = "Debates without rooms";
    my @panels = $m->comp('/funclib/round_panels.mas', round => $round);
    my $dummy=0;
    foreach my $panel (@panels) {
        if ( $panel->room == 0 && $panel->bye == 0 ) {
            $dummy ++;
        }
    }
    $problems{"roomless_panels"} = $dummy." panels without rooms<br>" if $dummy;
    
    #ENTRIES PREVIOUS MET
	$tags{"hit_before"} = "Debaters who have debated before";

    my ($entry_by_id_hash_ref, $precluded_hash_ref) = $m->comp("/funclib/make_pairing_hash.mas", round_id => $round->id);			

    my %entry_by_id = %{$entry_by_id_hash_ref};
    my %precluded = %{$precluded_hash_ref};
    foreach my $panel (@panels) {
        my @entries = $m->comp("/funclib/panel_entries.mas", panel => $panel);
        #print $entries[0]->code." vs ".$entries[1]->code."<br>";
        if ( $precluded{$entries[0]}{$entries[1]} == 1 || $precluded{$entries[1]}{$entries[0]} == 1 ) {
            $problems{"hit_before"} .= $entries[0]->code." and ".$entries[1]->code." have hit before<br>";        
        }
    }

    #JUDGES: HEARING A BLOCKED TEAM/SCHOOL
	$tags{"judge_preclusion"} = "Judge constraints/preclusions violated";

    #check to make sure this honors school preclusions
    my $strikes_sth = $dbh->prepare("
        select strike.judge, strike.entry, strike.school, entry.school as entry_school, strike.type, strike.start, strike.end
        from strike
        left join entry on strike.entry=entry.id
        where strike.tourn = ".$tourn."
        order by strike.id
    ");

    $strikes_sth->execute();
        
    while (my ($judge, $entry, $school, $entry_school, $type, $start, $end)  = $strikes_sth->fetchrow_array() ) {
        foreach my $ballot (@ballots) {
            if ($judge == $ballot->judge) {
                if ( $entry == $ballot->entry || $school == $ballot->entry->school ) {
                    $problems{"judge_preclusion"}.= $ballot->judge->first." ".$ballot->judge->last." is judging ".$ballot->entry->code." but there is a school or entry preclusion!<br>";
                }
            }
        }
    }

    #JUDGES NOT AVAILABLE THIS ROUND
	$tags{"judge_timestrike"} = "Judges not currently available";

    my $time_strikes_sth = $dbh->prepare("
        select strike.tourn, strike.start, strike.end, strike.type, strike.judge from strike, timeslot
        where strike.tourn = ".$tourn."
        and strike.type = 'time'
        and timeslot.id=".$round->timeslot."
	and strike.start <= timeslot.end 		
	and strike.end >= timeslot.start
    ");

    $time_strikes_sth->execute();

    while (my ($tourn, $start, $end, $type, $judge)  = $time_strikes_sth->fetchrow_array() ) {
        foreach my $ballot (@ballots) {
            if ($judge == $ballot->judge) {
                $problems{"judge_timestrike"}.= $ballot->judge->first." ".$ballot->judge->last." is unavailable for this round!<br>";
            }
        }
    }

	# MY OWN HIRES

	if ($round->event->judge_group->setting("auto_conflict_hires")) { 
	
		$tags{"hired_judging_me"} = "Hires judging the program paying them";

		Tab::JudgeHire->set_sql( "hires_judging_me" => "
			select distinct judge_hire.*
			from judge, ballot, judge_hire, entry, panel
			where panel.round = ? 
			and panel.id = ballot.panel
			and ballot.judge = judge.id
			and ballot.entry = entry.id
			and entry.school = judge_hire.school
			and judge.id = judge_hire.judge
			group by entry.id
		");

		my @judge_hire_conflict = Tab::JudgeHire->search_hires_judging_me($round_id);

		foreach my $conflict (@judge_hire_conflict) { 
			$problems{"hired_judging_me"} = $conflict->judge->first." ".$conflict->judge->last." is judging ".$conflict->school->name." who has hired them.";
		}

	}
    
    # JUDGES: HEARD TEAM BEFORE
    # JUDGES: SHOULD HAVE ROUND OFF
    # JUDGES: HEARING BLOCKED DIVISION
    # ROOMS: ROOMS USED TOO MANY TIMES
    # ROOMS: NOT AVAILABLE
    
</%init>

<div class="main">

	<h2><% $round->realname %> disaster checks</h2>

%	my $switch;

%	foreach my $tag (keys %tags) { 

		<div class="<% ($switch++ % 2) ? "odd" : "even" %> full">

			<span class="half">
				<% $tags{$tag} %> 
			</span>

			<span class="half">
				<% $problems{$tag} ? $problems{$tag} : '<span class="rightalign nospace greentext"> OK! </span>' %>
			</span>
		</div>

% 	}

</div>

<div class="menu">

	<div class="sidenote">
		<a class="full blue" href="/panel/schemat/show.mhtml?round_id=<% $round_id %>">
			Return to Pairings
		</a>
	</div>

</div>
