<%args>
	$round
	$debug          => undef
	$lag_pair_round => undef
</%args>
<%init>

	my $event = $round->event;
	my $tourn = $event->tourn;

	my $tz = $tourn->tz;
	$tz = "UTC" unless $tz;

	my $now = DateTime->now(time_zone => $tz);

	my $pullup_method = $event->setting("pullup_method");
	my $pullup_repeat = $event->setting("pullup_repeat");
	my $school_debates_self = $event->setting("school_debates_self");
	my $powermatch_method = $event->setting("powermatch");

	# Erase any current round already in place
	$m->comp("/funclib/round_dump.mas", round => $round);

	# Find the round whose seeding to base this round powermatching on. 
	my $previous_round = Tab::Round->retrieve($lag_pair_round) if $lag_pair_round;

	my %entry_round_record = (); 
	my $round_count;
	my $highest_round;

	foreach my $other_round (sort {$b->name <=> $a->name} $event->rounds) { 
		next if $other_round->name >= $round->name;
		$round_count++;
		$highest_round = $other_round unless $highest_round;
	}

	my $before; 

	foreach my $other_round (sort {$a->name <=> $b->name} $event->rounds) { 

		next if $other_round->name >= $round->name;

		if ($before && $other_round->type ne "prelim") { 
			#Generate the hash for the next round;
			my %record = $m->comp("/funclib/entry_wins.mas", round => $before, event => $event);
			$entry_round_record{$other_round->id} = \%record;
		}

		$before = $other_round; 
	}

	$previous_round = $highest_round unless $previous_round;

	# This enables side constrained rounds in even numbered debates unless
	# otherwise disabled (IE for Public Forum or a similar event); 

	my $side_constraints++ if $round_count % 2;  #Odd number of previous rounds means we're side constrained.
	undef $side_constraints if $event->setting("no_side_constraints");

	# Entries in seed order based on the previous round
	my ($entries_ref, $tbs_ref, $desc_ref, $noshow_ref, $tier_dir, $panrank_ref, $panletter_ref, $long_desc_ref)
		= $m->comp("/tabbing/results/order_entries.mas", round => $previous_round);

	my %entry_record = $m->comp("/funclib/entry_wins.mas", round => $round, event => $event);

	my @entries = $event->entries( dropped => 0, waitlist => 0, unconfirmed => 0 );

	my %entry_by_id = map {$_->id => $_} @entries;
	my %entry_code = map {$_->id => $_->code} @entries;
	my %entry_school = map {$_->id => $_->school->id} @entries;

	# Rework the entries array to just be an array of IDs.  This will increase
	# speed a lot.
	@entries = keys %entry_by_id;

	# Sort out the seed order of each entry and also the remaining tiebreakers
	# to sort out where in the bracket pullups should live. 

	my %entry_seed = ();

	foreach my $key (sort {$a <=> $b} keys %{$entries_ref}) {
		foreach my $entry (@{${$entries_ref}{$key}}) {
			$entry_seed{$entry} = $key;
		}
	}

	my %entry_opponents = ();

	my $dbh = Tab::DBI->db_Main();

	my $opponents_sth = $dbh->prepare("
		select entry.id, opponent.id, ballot.side, round.id, round.type, round.name
			from entry, entry opponent, ballot, ballot oppballot, panel, round
			where round.event = ".$event->id."
			and round.name <= ".$highest_round->name."
			and round.id = panel.round
			and panel.id = ballot.panel
			and panel.id = oppballot.panel
			and oppballot.entry != ballot.entry
			and oppballot.entry = opponent.id
			and ballot.entry = entry.id
			and ballot.bye != 1
			and oppballot.bye != 1
			and panel.bye != 1
			order by round.name");

	$opponents_sth->execute;

	my %side_due = ();
	my %met_before = ();
	my %opp_wins = ();
	my %pullup_count = ();

	while (my ( $entry, $opp, $side, $round_id, $round_type, $round_name) = $opponents_sth->fetchrow_array() ) {

		push @{$entry_opponents{$entry}}, $opp;
		$met_before{$entry}{$opp}++;

		$opp_wins{$entry}{"record"} += $entry_record{$opp};
		$opp_wins{$entry}{"count"}++;

		unless ($round_type eq "prelim") { 
			Tab::debuglog("Entry $entry_code{$entry} record $entry_round_record{$round_id}{$entry} vs $entry_code{$opp} record $entry_round_record{$round_id}{$opp} in round $round_name id $round_id") if $entry == 663505;

			if ($entry_round_record{$round_id}{$entry} < $entry_round_record{$round_id}{$opp}) { 
				$pullup_count{$entry}++;
			}
		}

		next unless $side_constraints && $round_id == $highest_round->name;

		$side_due{$entry} = 2 if $side == 1;
		$side_due{$entry} = 1 if $side == 2;
	}

	# For SOP you must also enter in the entry's opponent seeds into their
	# bracket position.  For seed order it stays the same.

	my %entry_sop = ();
	my %bracket_entries = ();

	foreach my $entry (@entries) { 

		my $counter;
		my $total;

		push @{$bracket_entries{$entry_record{$entry}}}, $entry;

		$entry_sop{$entry} = $entry_seed{$entry};

		foreach my $opp (@{$entry_opponents{$entry}}) { 
			$total += $entry_seed{$opp};
			$counter++;
		}

		$entry_sop{$entry} += ($total / $counter);
	}

	# Sort the debaters in the bracket without winloss as a factor to determine
	# pullup positions

	foreach my $key (sort {$a <=> $b} keys %{$desc_ref}) {

		next if ${$desc_ref}{$key} eq "W";

		@entries = sort { int(100 * ${$tbs_ref}{$a."-".$key}) <=> int(100 * ${$tbs_ref}{$b."-".$key})  } @entries 
			if ${$tier_dir}{$key} eq "up"; 

		@entries = sort { int(100 * ${$tbs_ref}{$b."-".$key}) <=> int(100 * ${$tbs_ref}{$a."-".$key})  } @entries 
			if ${$tier_dir}{$key} eq "down";
	}

	my %entry_hilo = map { $_ => $entries[$_] } 0..$#entries;

	my %entry_position = %entry_hilo if $powermatch_method eq "seed";
	%entry_position = %entry_sop if $powermatch_method ne "seed";

	my %pullup_score = ();
	my $num_entries = scalar @entries;

	# Score each debater based on how likely they can be pulled up.   Big
	# penalty for being pulled up, smaller penalty in order for being out of
	# position.

	foreach my $entry (@entries) { 

		$pullup_score{$entry} = 1;

		#Prevent someone from getting pulled up twice unless there's little other choice.
		if ($pullup_count{$entry} && not defined $pullup_repeat) {
			$pullup_score{$entry} += 10000 * $pullup_count{$entry};
		}

		if ($pullup_method eq "oppwin" || $pullup_method eq "middle" ) { 

			$pullup_score{$entry} += $opp_wins{$entry};

		} elsif ($pullup_method eq "lowseed") { 

			# This is the method used by APDA infidels.  Higher scores to the
			# people who shouldn't be pulled up.
			$pullup_score{$entry} += ($num_entries * 2) - $entry_seed{$entry};  

		} else { 

			# Default is to use SOP.  Higher scores to the people who shouldn't
			# be pulled up as often. 
			$pullup_score{$entry} += ($num_entries * 2) - $entry_sop{$entry};
		}

	}

	@entries = sort {$entry_position{$a}  <=> $entry_position{$b}} @entries;

	my $worst_entry = pop @entries;
	my $worst_position = $entry_position{$worst_entry};
	push @entries, $worst_entry;

	# If there's an uneven number of debaters we assign a bye.  

	if ($num_entries % 2) { 

		my %byes = $m->comp("/funclib/entry_byes.mas", event => $event, round => $round);

		my $aff_count;
		my $neg_count;

		foreach my $entry (@entries) { 

			$met_before{$entry}{"BYE"} += $byes{$entry};

			# Have to do it twice or else it'll be a lower penalty than
			# debating the same person twice. 
			$met_before{"BYE"}{$entry} += $byes{$entry};  

			$aff_count++ if $side_due{$entry} == 1;
			$neg_count++ if $side_due{$entry} == 2;
		}

		# Adds a bye into the mix to pair a debater with.
		unshift @entries, "BYE";   				  

		# Put the bye into the worst bracket
		unshift @{$bracket_entries{0}}, "BYE";    

		# Byes have no wins of course since their opponents shouldn't either. 
		$entry_record{"BYE"} = 0;
		$entry_code{"BYE"} = "BYE";

		# Bye is placed at the top of the bracket so it gets the lowest possible seed. 
		$entry_position{"BYE"} = 1;  

		# Make sure the bye goes to the short side if it's side constrained
		$side_due{"BYE"} = 1 if $aff_count && $neg_count && $aff_count < $neg_count;
		$side_due{"BYE"} = 2 if $aff_count && $neg_count && $aff_count > $neg_count;

	}

	my %opponent_score = (); 

	foreach my $entry (@entries) { 

		foreach my $opponent (@entries) { 

			next if $opponent == $entry; 

			my $log++ if $entry_record{$opponent} == 5; 

			# Same school debates are the worst outcome
			$opponent_score{$entry}{$opponent} += 1000000000000 
				if $entry_school{$opponent} == $entry_school{$entry} && not defined $school_debates_self;
			Tab::debuglog("1 Entry score is $opponent_score{$entry}{$opponent} against $entry_code{$opponent}") if $entry == 606194;

			# If the debaters have debated before penalize them but not as much
			# as same schools.
			$opponent_score{$entry}{$opponent} += 10000000000 * $met_before{$entry}{$opponent};
			Tab::debuglog("2 Entry score is $opponent_score{$entry}{$opponent} against $entry_code{$opponent}") if $entry == 606194;

			# Wrong side debates are undesirable as long as they're clean.
			$opponent_score{$entry}{$opponent} += 250000000 if $side_due{$entry} && $side_due{$entry} == $side_due{$opponent};
			Tab::debuglog("3 Entry score is $opponent_score{$entry}{$opponent} against $entry_code{$opponent}") if $entry == 606194;

		}

	}

	# Now figure out how far off position every debater is against entry. 

	foreach my $tier (sort {$b <=> $a} keys %bracket_entries) {  

		my @bracket_entries = @{$bracket_entries{$tier}};

		# Top of bracket gets the worst opponents...
		@bracket_entries = sort {$entry_position{$a} <=> $entry_position{$b}} @bracket_entries;

		# Unless it's a high high round.
		@bracket_entries = sort {$entry_position{$b} <=> $entry_position{$a}} @bracket_entries if $round->type eq "highhigh";

		my $num_bracket = scalar @bracket_entries; 

		my $rank;

		foreach my $be (@bracket_entries) { 

			$rank++;

			foreach my $opponent (@entries) { 

				next if $opponent == $be;
			
				my $log++ if $entry_record{$opponent} == 5; 

				# Bracket pullups get a penalty proportional to how many
				# times they'd be pulled up and their pullup score (based
				# on whether they've been pulled up before and their oppwin
				# or seed position.

				$opponent_score{$be}{$opponent} += abs($entry_record{$opponent} - $tier) * 10000 * $pullup_score{$opponent}; 
				Tab::debuglog("4 Entry score is $opponent_score{$be}{$opponent} against $entry_code{$opponent}") if $be == 606194;
		
				# And they get a score based on where in the bracket they
				# are.  This is multiplied by the rank within the bracket
				# of the entry so that the top entry will get the most
				# desirable opponent (lowest seed) possible within the
				# bounds of the other constraints. 

				$opponent_score{$be}{$opponent} += ($worst_position - $entry_position{$opponent}) * $rank;
				Tab::debuglog("5 Entry score is $opponent_score{$be}{$opponent} against $entry_code{$opponent}") if $be == 606194;

			}
		}
	}

	my %debates;
	my @opponents = @entries;

	foreach my $entry (@entries) { 

		next if $debates{$entry};

		@opponents = sort {$opponent_score{$entry}{$a} <=> $opponent_score{$entry}{$b}} @opponents;

		my $opponent;

		foreach my $candidate (@opponents) { 
			next if $candidate == $entry;
			next if $debates{$candidate};
			$opponent = $candidate;
			last if $opponent;
		}

		$debates{$entry} = $opponent;
		$debates{$opponent} = $entry;

	}

	foreach my $pass (1 .. 1) { 

		foreach my $entry (sort {$entry_position{$b} <=> $entry_position{$a}} keys %debates) { 
				
			my $opponent = $debates{$entry};

			if ($entry == 606194) { 
				Tab::debuglog(" ");
				Tab::debuglog("================");
				Tab::debuglog("Pass $pass Bogaty starts by debating $entry_code{$opponent}");
				Tab::debuglog("================");
				Tab::debuglog(" ");
			}

			foreach my $swap_entry (keys %debates) { 

				next if $swap_entry == $entry;		# don't swap me with myself.
				next if $swap_entry == $opponent;   # don't swap me with my opponent; 

				my $swap_opponent = $debates{$swap_entry};

				next if $swap_opponent == $entry;   # don't swap me with my existing opponent either
				next if $swap_opponent == $opponent;   # don't swap me with my existing opponent either

				my $score1 = $opponent_score{$entry}{$opponent} + $opponent_score{$opponent}{$entry};
				my $score2 = $opponent_score{$swap_entry}{$swap_opponent} + $opponent_score{$swap_opponent}{$swap_entry};

				# Calculate the score of the other debate

				my $score3 = $opponent_score{$swap_entry}{$opponent} + $opponent_score{$opponent}{$swap_entry};
				my $score4 = $opponent_score{$entry}{$swap_opponent} + $opponent_score{$swap_opponent}{$entry};

				if ($score2 < $score1 && $score4 < $score3) { 

					if ($entry == 606194) { 
						Tab::debuglog("   For $entry_code{$entry}, $score2 is lower against $entry_code{$swap_opponent} than $score1 against $entry_code{$opponent}");
						Tab::debuglog("   For $entry_code{$swap_entry}, $score4 is lower against $entry_code{$opponent} than $score3 against $entry_code{$swap_opponent}");
					}

					$opponent = $swap_opponent; 
				}

			}

			if ($opponent != $debates{$entry}) { 

				my $swap_entry = $debates{$opponent};
				my $swap_opponent = $debates{$entry};

				Tab::debuglog("I HAVE SUCCESS.  Doing the swap.  $entry_code{$entry} now debates against $entry_code{$opponent}, $entry_code{$swap_entry} vs $entry_code{$swap_opponent}") if $entry == 606194;

				$debates{$entry} = $opponent;
				$debates{$opponent} = $entry;

				$debates{$swap_entry} = $swap_opponent;
				$debates{$swap_opponent} = $swap_entry; 

			}

		}

	}

	# If this is not a sidelocked debate we snake the sides so the good teams
	# don't all end up aff and thus wreak havoc on the next round's bracket.

	my $sides;  

	my $letter = 1;
	$letter = "A" if $event->setting("panel_labels") eq "letters";

	my %done;

	foreach my $entry (keys %debates) { 

		next if $done{$entry}++;
		my $opponent = $debates{$entry};
		next if $done{$opponent}++;

		my $bye = 0;
		$bye++ if $opponent eq "BYE";
		$bye++ if $entry eq "BYE";
		next if $bye > 1;

		unless ($side_due{$entry}) { 
			$side_due{$entry} = ($side_due{$opponent} % 2) + 1;
			$side_due{$entry} = ($sides++ % 2) + 1 unless $side_due{$entry};
		}

		unless ($side_due{$opponent}) { 
			$side_due{$opponent} = ($side_due{$entry} % 2) + 1;
		}

		my $bracket = $entry_record{$entry};
		$bracket = $entry_record{$opponent} if $entry_record{$opponent} > $bracket;

		my $score = $opponent_score{$entry}{$opponent} + $opponent_score{$opponent}{$entry};
		
		my $panel = Tab::Panel->create({
			round   => $round->id,
			bye     => $bye,
			letter  => $letter,
			flight  => 1,
			bracket => $bracket,
			score   => $score
		});

		if ($entry ne "BYE") { 

			my $pullup++ if $entry_record{$entry} < $entry_record{$opponent};

			Tab::Ballot->create({
				panel  => $panel->id,
				judge  => 0,
				bye    => $bye,
				audit  => $bye,
				entry  => $entry,
				side   => $side_due{$entry},
				seed   => $entry_position{$entry},
				pullup => $pullup
			});

		}
	
		if ($opponent ne "BYE") { 

			my $pullup++ if $entry_record{$opponent} < $entry_record{$entry};

			Tab::Ballot->create({
				panel  => $panel->id,
				judge  => 0,
				bye    => $bye,
				audit  => $bye,
				entry  => $opponent,
				side   => $side_due{$opponent},
				seed   => $entry_position{$opponent},
				pullup => $pullup
			});

		}

	}


</%init>

