<%args>
	$round
	$debug          => undef
	$lag_pair_round => undef
</%args>
<%init>

	use List::Util 'shuffle';

	my $event = $round->event;
	my $tourn = $event->tourn;

	my $tz = $tourn->tz;
	$tz = "UTC" unless $tz;

	my $now = DateTime->now(time_zone => $tz);

	my $pullup_method = $event->setting("pullup_method");
	my $pullup_repeat = $event->setting("pullup_repeat");
	my $school_debates_self = $event->setting("school_debates_self");
	my $powermatch_method = $event->setting("powermatch");

	# Erase any current round already in place
	$m->comp("/funclib/round_dump.mas", round => $round);

	# Find the round whose seeding to base this round powermatching on. 
	my $previous_round = Tab::Round->retrieve($lag_pair_round) if $lag_pair_round;

	my %entry_round_record = (); 
	my $round_count;

	unless ($previous_round) { 
		foreach my $other_round (sort {$b->name <=> $a->name} $event->rounds) { 
			next if $other_round->name >= $round->name;
			$round_count++;
			$previous_round = $other_round unless $previous_round;

			# This hash is later used to identify who was pulled up in the past
			# to prevent it in the future if necessary.
			my %entry_round_record{$other_round->id} = $m->comp("/funclib/entry_wins.mas", round => $other_round, event => $event);
		}
	}

	# This enables side constrained rounds in even numbered debates unless
	# otherwise disabled (IE for Public Forum or a similar event); 

	my $side_constraints++ unless $round_count % 2; 
	undef $side_constraints if $event->setting("no_side_constraints");

	# Entries in seed order based on the previous round
	my ($entries_ref, $tbs_ref, $desc_ref, $noshow_ref, $tier_dir, $panrank_ref, $panletter_ref, $long_desc_ref)
		= $m->comp("/tabbing/results/order_entries.mas", round => $previous_round);

	my %entry_record = $m->comp("/funclib/entry_wins.mas", round => $round, event => $event);

	my @entries = $event->entries( dropped => 1, waitlist => 1, unconfirmed => 1 );

	my %entry_by_id = map {$_->id => $_} @entries;
	my %entry_school = map {$_->id => $_->school->id} @entries;

	# Rework the entries array to just be an array of IDs.  This will increase
	# speed a lot.
	@entries = keys %entry_by_id;

	# Sort out the seed order of each entry and also the remaining tiebreakers
	# to sort out where in the bracket pullups should live. 

	my %entry_seed = ();

	foreach my $key (sort {$a <=> $b} keys %{$entries_ref}) {
		foreach my $entry (@{${$entries_ref}{$key}}) {
			$entry_seed{$entry} = $key;
		}
	}

	my %entry_opponents = ();

	my $dbh = Tab::DBI->db_Main();

	my $opponents_sth = $dbh->prepare("
		select entry.id, opponent.id, ballot.side, round.name
			from entry, entry opponent, ballot, ballot oppballot, panel, round
			where round.event = ".$event->id."
			and round.name <= ".$previous_round->name."
			and round.id = panel.round
			and panel.id = ballot.panel
			and panel.id = oppballot.panel
			and oppballot.entry != ballot.entry
			and oppballot.entry = opponent.id
			and ballot.entry = entry.id
			and ballot.bye != 1
			and oppballot.bye != 1
			and panel.bye != 1 ");

	$opponents_sth->execute;

	my %side_due = ();
	my %met_before = ();
	my %opp_wins = ();
	my %pullup_count = ();

	while (my ( $entry, $opp, $side, $roundname) = $opponents_sth->fetchrow_array() ) {

		push @{$entry_opponents{$entry}}, $opp;
		$met_before{$entry}{$opp}++;

		$opp_wins{$entry}{"record"} += $entry_record{$opp};
		$opp_wins{$entry}{"count"}++ $entry_record{$opp};

		$pullup_count{$entry}++ if $entry_round_record{$roundmame}{$entry} < $entry_round_record{$roundname}{$opp};

		next unless $side_constraints;

		$side_due{$entry} = 2 if $side == 1;
		$side_due{$entry} = 1 if $side == 2;
	}

	# For SOP you must also enter in the entry's opponent seeds into their
	# bracket position.  For seed order it stays the same.

	my %entry_sop = ();
	my %bracket_entries = ();

	foreach my $entry (@entries) { 

		my $counter;
		my $total;

		push @{$bracket_entries{$entry_record{$entry}}}, $entry;

		$entry_sop{$entry} = $entry_seed{$entry};

		foreach my $opp (@{$entry_opponents{$entry}}) { 
			$total += $entry_seed{$opp};
			$counter++;
		}

		$entry_sop{$entry} += ($total / $counter);
	}

	# Sort the debaters in the bracket without winloss as a factor to determine
	# pullup positions

	foreach my $key (sort {$a <=> $b} keys %{$desc_ref}) {

		next if ${$desc_ref}{$key} eq "W";

		@entries = sort { int(100 * ${$tbs_ref}{$a."-".$key}) <=> int(100 * ${$tbs_ref}{$b."-".$key})  } @entries 
			if ${$tier_dir}{$key} eq "up"; 

		@entries = sort { int(100 * ${$tbs_ref}{$b."-".$key}) <=> int(100 * ${$tbs_ref}{$a."-".$key})  } @entries 
			if ${$tier_dir}{$key} eq "down";
	}

	my %entry_hilo = map { $_ => $entries[$_] } 0..$#entries;

	my %entry_position = %entry_hilo if $powermatch_method eq "seed";
	%entry_position = %entry_sop if $powermatch_method ne "seed";

	my %pullup_score = ();

	# Score each debater based on how likely they can be pulled up.   Big
	# penalty for being pulled up, smaller penalty in order for being out of
	# position.

	foreach my $entry (@entries) { 

		#Prevent someone from getting pulled up twice unless there's little other choice.
		$pullup_score{$entry} += 1000 * $pullup_count{$entry}  if $pullup_repeat;

		if ($pullup_method eq "oppwin" || $pullup_method eq "middle" ) { 

			$pullup_score{$entry} = $opp_wins{$entry};

		} elsif ($pullup_method eq "lowseed") { 

			# This is the method used by APDA infidels
			$pullup_score{$entry} = $entry_seed{$entry};

		} else { 

			#Default is to use SOP 
			$pullup_score{$entry} = $entry_sop{$entry};
		}

	}

	@entries = sort {$entry_position{$a}  <=> $entry_position{$b}} @entries;

	# If there's an uneven number of debaters we assign a bye.  
	my $num_entries = scalar @entries;

	if ($num_entries % 2) { 

		my %byes = $m->comp("/funclib/entry_byes.mas", event => $event, round => $round);

		my $aff_count;
		my $neg_count;

		foreach my $entry (@entries) { 

			$met_before{$entry}{"BYE"} += $byes{$entry};

			# Have to do it twice or else it'll be a lower penalty than
			# debating the same person twice. 
			$met_before{"BYE"}{$entry} += $byes{$entry};  

			$aff_count++ if $side_due{$entry} == 1;
			$neg_count++ if $side_due{$entry} == 2;
		}

		# Adds a bye into the mix to pair a debater with.
		unshift @entries, "BYE";   				  

		# Put the bye into the worst bracket
		unshift @{$bracket_entries{0}}, "BYE";    

		# Byes have no wins of course since their opponents shouldn't either. 
		$entry_record{"BYE"} = 0;

		# Bye is placed at the top of the bracket so it gets the lowest possible seed. 
		$entry_position{"BYE"} = 1;  

		# Make sure the bye goes to the short side if it's side constrained
		$side_due{"BYE"} == 1 if $aff_count && $neg_count && $aff_count < $neg_count;
		$side_due{"BYE"} == 2 if $aff_count && $neg_count && $aff_count > $neg_count;

	}

	my %opponent_score = (); 

	foreach my $entry (@entries) { 

		foreach my $opponent (@entries) { 

			next if $opponent == $entry; 

			# Same school debates are the worst outcome
			$opponent_score{$entry}{$opponent} += 1000000000000 
				if $entry_school{$opponent} == $entry_school{$entry} && not defined $school_debates_self;

			# If the debaters have debated before penalize them but not as much
			# as same schools.
			$opponent_score{$entry}{$opponent} += 10000000000 * $met_before{$entry}{$opponent};

			# Wrong side debates are undesirable as long as they're clean.
			$opponent_score{$entry}{$opponent} += 250000000 
				if $side_due{$entry} && $side_due{$entry} == $side_due{$opponent};

		}

		# Start with the top bracket.  No real reason why. 
		foreach my $tier (sort {$b <=> $a} keys %bracket_entries) {  

			my @bracket_entries = @{$bracket_entries{$tier}};
			push @bracket_entries, $entry unless $tier == $entry_record{$entry};

			# Top of bracket gets the worst opponents...
			@bracket_entries = sort {$entry_position{$a} <=> $entry_position{$b}} @bracket_entries;

			# Unless it's a high high round.
			@bracket_entries = sort {$entry_position{$b} <=> $entry_position{$a}} @bracket_entries if $round->type eq "highhigh";

			my $num_bracket = scalar @bracket_entries; 

			my $rank;

			foreach my $be (@bracket_entries) { 

				$rank++;

				foreach my $opponent (@entries) { 

					# Bracket pullups get a penalty proportional to how many
					# times they'd be pulled up and their pullup score (based
					# on whether they've been pulled up before and their oppwin
					# or seed position.

					$opponent_score{$be}{$opponent} += abs($entry_record{$opponent} - $bracket * 100000) * $pullup_score{$opponent}; 

					# And they get a score based on where in the bracket they
					# are.  This is multiplied by the rank within the bracket
					# of the entry so that the top entry will get the most
					# desirable opponent (lowest seed) possible within the
					# bounds of the other constraints. 

					$opponent_score{$be}{$opponent} += $entry_position{$opponent} * $rank;

				}

			}

		}

	}

	my %debates;
	my @opponents = @entries;

	foreach my $entry (@entries) { 

		next if $debate{$entry};

		@opponents = sort {$opponent_score{$entry}{$a} <=> $opponent_score{$entry}{$b}} @opponents;
		my $opponent = shift @opponents;

		$debate{$entry} = $opponent;
		$debate{$opponent} = $entry;

	}

	foreach (1 .. 7) { 

		foreach my $entry (keys %debates) { 

			my $opponent = $debates{$entry};

			my $swap_with;
			my $swap_diff; 
		
			foreach my $entry2 (keys %debates) { 

				next if $entry2 == $entry;		# don't swap me with myself.
				my $opponent2 = $debates{$entry};
				next if $opponent2 == $entry;   # don't swap me with my existing opponent either

				my $score1 = $opponent_score{$entry}{$opponent} + $opponent_score{$opponent}{$entry} 
					+ $opponent_score{$entry2}{$opponent2} + $opponent_score{$opponent2}{$entry2};

				# Calculate the score of the other debate; 

				my $score2 = $opponent_score{$entry2}{$opponent} + $opponent_score{$opponent2}{$entry} 
					+ $opponent_score{$entry}{$opponent2} + $opponent_score{$opponent}{$entry2};

				if ($score2 < $score1) { 
					# I am an improvement!  
					if (($score1 - $score2) > $swap_diff) { 
						$swap_diff = $score1 - $score2; 
						$swap_with = $entry2; 
					}
				}

			}

			if ($swap_with) { 
				my $swap_opponent = $debates{$swap_with};
				$debates{$entry} = $swap_opponent;
				$debates{$swap_opponent} = $entry;
				$debates{$swap_with} = $opponent;
				$debates{$opponent} = $swap_with;
			}

		}

	}

	# If this is not a sidelocked debate we snake the sides so the good teams
	# don't all end up aff and thus wreak havoc on the next round's bracket.

	my $sides;  
	my %done;

	my $letter = 1;
	$letter = "A" if $event->setting("panel_labels") eq "letters";

	foreach my $entry (shuffle(keys %debates)) { 

		next if $done{$entry}++;
		my $opponent = $debates{$opponent};
		next if $done{$opponent}++;

		my $bye = 0;
		$bye++ if $opponent eq "BYE";
		$bye++ if $entry eq "BYE";
		next if $bye > 1;

		my $side_one = $side_due{$entry};
		my $side_two = $side_due{$opponent};

		unless ($side_one) { 
			$side_one = 1 if $side_two == 2;
			$side_one = 2 if $side_two == 1;
			$side_one = ($switch++ % 2) + 1 unless $side_one;
		}
		
		unless ($side_two) { 
			$side_two = 1 if $side_one == 2;
			$side_two = 2 if $side_one == 1;
		}

		my $panel = Tab::Panel->create({
			round   => $round->id,
			bye     => $bye,
			letter  => $letter,
			flight  => 1,
			bracket => $entry_record{$entry}
		});

		if ($entry ne "BYE") { 

			my $pullup++ if $entry_record{$entry} < $entry_record{$opponent};

			Tab::Ballot->create({
				panel  => $panel->id,
				judge  => 0,
				bye    => $bye,
				audit  => $bye,
				entry  => $entry,
				side   => $side_one,
				seed   => $entry_position{$entry},
				pullup => $pullup
			});

		}
	
		if ($opponent ne "BYE") { 

			my $pullup++ if $entry_record{$opponent} < $entry_record{$entry};

			Tab::Ballot->create({
				panel  => $panel->id,
				judge  => 0,
				bye    => $bye,
				audit  => $bye,
				opponent  => $opponent,
				side   => $side_one,
				seed   => $entry_position{$opponent},
				pullup => $pullup
			});

		}

	}


</%init>

