<%args>
	$round    => undef
	$round_id => undef
	$attempt  => undef
</%args>
<%perl>

	use POSIX;
	use List::Util 'shuffle';

	$round = Tab::Round->retrieve($round_id) unless $round > 0;
	my $event = $round->event;

	Tab::Round->set_sql(reset_prelim => 'update round set type="prelim" where type="preset" and event = ?');
	Tab::Round->sql_reset_prelim->execute($event->id);

	my $round_type = $round->type;
	my $round_limit = "and round.name < ".$round->name if $round_type eq "highlow" || $round_type eq "highhigh";
	$round_limit = 'and round.type = "prelim" and round.name != '.$round->name if $round_type eq "prelim";

	my $sidelock_against = $round->setting("sidelock_against");

	my $no_side_constraints++ if $event->setting("no_side_constraints");
	$no_side_constraints++ if $sidelock_against eq "NONE";

	my $dbh = Tab::DBI->db_Main();

	my $entry_sth = $dbh->prepare('
		select distinct entry.id, school.region, school.id, entry.code
		from entry, school
		where entry.event = '.$event->id.'
		and entry.school = school.id
		and entry.dq = 0
		and entry.dropped = 0
		and entry.waitlist = 0
	');

	my @entries;

	my %entry_school;
	my %entry_region;
	my %school_size;

	our %entry_code;
	my %seed_count;
	my %entry_needs;
	my %entry_position;
	my %entry_position_need;
	my %needs_print;

	$entry_sth->execute();

	while( my ($entry_id, $region, $school, $code) = $entry_sth->fetchrow_array() ) {

		next unless $entry_id;

		push @entries, $entry_id;

		$entry_region{$entry_id} = $region;
		$entry_school{$entry_id} = $school;
		$school_size{$school}++;

		$entry_code{$entry_id} = $code;
	}

	my @seed_settings = $m->comp("/funclib/event_entry_settings.mas", tag => "pairing_seed", event => $event);
	my %entry_seed = map {$_->entry->id => $_->value} @seed_settings;
	my @seeds;
	my $max_seed;

	my @pods;
	my @pod_settings = $m->comp("/funclib/event_entry_settings.mas", tag => "pod", event => $event);
	my %entry_pod = map {$_->entry->id => $_->value} @pod_settings;

	foreach my $entry (@entries) { 
		$entry_seed{$entry} = 0 unless $entry_seed{$entry};
		$seed_count{$entry_seed{$entry}}++;
		$max_seed = $entry_seed{$entry} if $entry_seed{$entry} > $max_seed;
		push @seeds, $entry_seed{$entry};
		push @pods, $entry_pod{$entry};
	}

	my %seen = (); 
	@pods = grep { ! $seen{$_} ++ } @pods;

	my $ballot_sth = $dbh->prepare('
		select distinct entry.id, opponent.id, opp_school.id, opp_school.region, ballot.side
		from entry, entry as opponent, ballot, panel, round, ballot as opp_ballot, school as opp_school
		where entry.event = '.$event->id.'
		and entry.id = ballot.entry
		and ballot.panel = panel.id
		and panel.round = round.id
		'.$round_limit.'
		and round.id != ? 
		and opp_ballot.panel = ballot.panel
		and opp_ballot.entry = opponent.id
		and opponent.school = opp_school.id
		and opponent.id != entry.id
		and panel.bye != 1
		and ballot.bye != 1
	');

	$ballot_sth->execute($round->id);

	my %entry_hits;
	my %entry_opps;
	my %entry_opp_side;
	my %entry_school_hit;
	my %entry_region_hit;

	while( my ($entry_id, $opp_id, $opp_school, $opp_region, $side) = $ballot_sth->fetchrow_array() ) {
		$entry_hits{$entry_id."-".$opp_id}++;
		$entry_opp_side{$entry_id."-".$opp_id."-".$side}++ unless $no_side_constraints;
		$entry_school_hit{$entry_id."-".$opp_school}++;
		$entry_region_hit{$entry_id."-".$opp_region}++;
		push @{$entry_opps{$entry_id}}, $opp_id;
	}

	my %entry_negs;
	my %entry_affs;
	my %entry_byes;
	my $seed_byes_as;

	unless ($no_side_constraints) { 

		my $round_side;
		my $round_care;

		if ($sidelock_against) { 

			$round_side = " and round.id = ".$sidelock_against;
			$round_care = $sidelock_against;

		} elsif ($round->name % 2 ) { 

			# Odd presets mean I care about the next prelim round in case we're
			# repaneling for seeding, if it exists 

			my $round_name = $round->name;
			foreach my $oround (sort {$a->name <=> $b->name} $event->rounds)	{ 
				$round_care = $oround->id if $oround->name > $round->name && $oround->type eq "prelim";
				last if $round_care;
			}
		} else { 

			# Even presets sidelock against the last round
			my $round_name = $round->name;
			foreach my $oround (sort {$b->name <=> $a->name} $event->rounds)	{ 
				$round_care = $oround->id if $oround->name < $round->name && $oround->type eq "prelim";
				last if $round_care;
			}
		}

		my $sides_sth = $dbh->prepare('
			select distinct ballot.entry, ballot.side, ballot.bye, panel.bye, round.id
			from ballot, panel, entry, round
			where ballot.entry = entry.id
			and entry.event = '.$event->id.'
			and ballot.panel = panel.id
			and panel.round = round.id
			'.$round_side.'
		');

		$sides_sth->execute();

		while (my ($entry_id, $side, $bye, $panel_bye, $round) = $sides_sth->fetchrow_array() ) { 
			$entry_byes{$entry_id}++ if $bye || $panel_bye;
			next if $bye || $panel_bye;
			next if $round != $round_care;
			$entry_affs{$entry_id}++ if $side == 1;
			$entry_negs{$entry_id}++ if $side == 2;
		}

	}

	my %s_seen = (); 
	@seeds = grep { ! $s_seen{$_} ++ } @seeds;   #uniq

	my %e_seen = (); 
	@entries = grep { ! $e_seen{$_} ++ } @entries;   #uniq

	my $seed_presets = $event->setting("seed_presets");
	my $round_robin++ if $event->setting("round_robin");

	our $region_constrain++ if $event->setting("region_constrain");
	$region_constrain++ if $event->tourn->setting("ncfl");
	our $region_avoid++ if $event->setting("region_avoid");

	my $best_score;
	my $bye;

	if ($round_robin) { 

		my @rounds = $event->rounds( type => "prelim");

		# In a round robin, seeds are pods
		my $num_pods = scalar @pods;
		next unless $num_pods;

		my $pod_size = ceil(scalar @entries / $num_pods);

		$pod_size++ if $pod_size % 2;
		my $num_rounds = $pod_size -1; 

		unless ($num_rounds == scalar @rounds) { 
			my $err = "You do not have the correct number of preset rounds for ".scalar @entries." debaters for $num_pods pods.  Please make sure you have $num_rounds presets";
			$m->redirect("/setup/schedule/event.mhtml?event_id=".$event->id."&err=$err");
		}

		my %round_panels = ();
		my %panel_entries = ();
		my %panel_pod = ();
		my $tick;

		foreach my $pod (@pods) { 

			my @pod;

			foreach my $entry (@entries) { 
				push @pod, $entry if $entry_pod{$entry} == $pod;
			}

			# Make sure it's an even number.  Fill blanks with byes
			my $bye_present;

			if ( (scalar @pod) % 2 ) { 
				push @pod, "BYE";
				$bye_present++;
			}

			foreach my $round (@rounds) { 

				foreach ( 1 .. (scalar @pod) / 2 ) { 
					$tick++;
					push @{$round_panels{$round->id}}, $tick;
					$panel_pod{$tick} = $pod;
				}

				# Remove the second entry and push them to the end.  The RR
				# pairing algorithm is that you keep the first slot stationary
				# and rotate everyone else around them to get a full pairing.

				my $second = splice(@pod, 1, 1);
				push @pod, $second;

				my @copy = @pod;

				my $counter = $round->name - 1;

				foreach my $panel (@{$round_panels{$round->id}}) { 
					
					next unless $panel_pod{$panel} == $pod;

					if ($counter++ % 3) { 
						$panel_entries{$panel}{"aff"} = shift @copy;
						$panel_entries{$panel}{"neg"} = pop @copy;
					} else { 
						$panel_entries{$panel}{"aff"} = pop @copy;
						$panel_entries{$panel}{"neg"} = shift @copy;
					}
				}
			}

			my %aff_count;
			my %neg_count;

			foreach my $round (@rounds) { 

				foreach my $panel (@{$round_panels{$round->id}}) { 
					next if $panel_entries{$panel}{"neg"} eq "BYE";
					next if $panel_entries{$panel}{"aff"} eq "BYE";
					$neg_count{$panel_entries{$panel}{"neg"}}++;
					$aff_count{$panel_entries{$panel}{"aff"}}++;
				}

			}

			my $lowest;
			my $highest;

			my $num_debates = scalar @rounds;
			$num_debates -= $bye_present;

			if ( $num_debates % 2 ) { 
				$highest = ceil($num_debates / 2);
				$highest = floor($num_debates / 2);
			} else { 
				$highest = $num_debates / 2;
				$lowest = $num_debates / 2;
			}

			my $not_ok = 1;

			# There is surely an algorithm that would do this properly but I'm
			# not going to waste any more time finding it.  So brute force the
			# fucker 50 times and call it a day.

			foreach (1 .. 50) { 

				next unless $not_ok;
				undef $not_ok;

				my %side_counter;

				my $lowest = floor(scalar @rounds / 2);
				my $highest = ceil(scalar @rounds / 2);

				foreach my $round (@rounds) { 
					foreach my $panel (@{$round_panels{$round->id}}) { 

						my $aff = $panel_entries{$panel}{"aff"};
						my $neg = $panel_entries{$panel}{"neg"};

						next if $aff eq "BYE" || $neg eq "BYE"; # doesn't count

						if ($aff_count{$aff} > $neg_count{$aff} + 1 && $neg_count{$neg} > $aff_count{$neg} + 1 ) { 

							next if $aff_count{$neg} <= $lowest;
							next if $neg_count{$neg} <= $lowest;

							$panel_entries{$panel}{"aff"} = $neg;
							$panel_entries{$panel}{"neg"} = $aff;

							$neg_count{$aff}++;
							$aff_count{$neg}++;

							$neg_count{$neg}--;
							$aff_count{$aff}--;
					
						} 
					}
				}

				my %side_row;

				# Attempt to make sure no one is on a side 3x in a row

				foreach my $round (@rounds, @rounds) { 

					foreach my $panel (shuffle @{$round_panels{$round->id}}) { 

						my $aff = $panel_entries{$panel}{"aff"};
						my $neg = $panel_entries{$panel}{"neg"};

						next if $aff eq "BYE" || $neg eq "BYE";

						if ($side_row{$aff}{"side"} eq "aff") { 

							push @{$side_row{$aff}{"panels"}}, $panel;

							if (scalar @{$side_row{$aff}{"panels"}} > 2) { 

								$not_ok++;

								my @panels = shuffle @{$side_row{$aff}{"panels"}};

								my $swap_neg = $panel_entries{$panels[0]}{"neg"};
								my $swap_aff = $panel_entries{$panels[0]}{"aff"};

								$neg_count{$swap_aff}++;
								$aff_count{$swap_neg}++;

								$neg_count{$swap_neg}--;
								$aff_count{$swap_aff}--;
					
								$panel_entries{$panels[0]}{"neg"} = $swap_aff;
								$panel_entries{$panels[0]}{"aff"} = $swap_neg;
								undef @{$side_row{$aff}{"panels"}};
							}

						} else { 
							$side_row{$aff}{"side"} = "aff";
							@{$side_row{$aff}{"panels"}} = ($panel);
						}

						if ($side_row{$neg}{"side"} eq "neg") { 

							push @{$side_row{$neg}{"panels"}}, $panel;

							if (scalar @{$side_row{$neg}{"panels"}} > 2) { 

								$not_ok++;

								my @panels = shuffle @{$side_row{$neg}{"panels"}};

								my $swap_aff = $panel_entries{$panels[0]}{"aff"};
								my $swap_neg = $panel_entries{$panels[0]}{"neg"};
					
								$panel_entries{$panels[0]}{"aff"} = $swap_neg;
								$panel_entries{$panels[0]}{"neg"} = $swap_aff;

								$neg_count{$swap_aff}++;
								$aff_count{$swap_neg}++;

								$neg_count{$swap_neg}--;
								$aff_count{$swap_aff}--;
					
								undef @{$side_row{$neg}{"panels"}};
							}

						} else { 

							$side_row{$neg}{"side"} = "neg";
							@{$side_row{$neg}{"panels"}} = ($panel);
						}
					}
				}


				foreach my $round (@rounds, @rounds) { 

					foreach my $panel (shuffle @{$round_panels{$round->id}}) { 

						my $aff = $panel_entries{$panel}{"aff"};
						my $neg = $panel_entries{$panel}{"neg"};

						next if $aff eq "BYE" || $neg eq "BYE"; #doesn't count

						if ($aff_count{$aff} >= $highest || $neg_count{$neg} >= $highest ) { 

							next if $aff_count{$neg} <= $lowest;
							next if $neg_count{$neg} <= $lowest;

							$panel_entries{$panel}{"aff"} = $neg;
							$panel_entries{$panel}{"neg"} = $aff;

							$neg_count{$aff}++;
							$aff_count{$neg}++;

							$neg_count{$neg}--;
							$aff_count{$aff}--;
					
						} 
					}
				}

				foreach my $entry (@entries) { 
					if ($aff_count{$entry} < $lowest || $aff_count{$entry} > $highest) {
						$not_ok++ 
					}
				}

			}

		}

		foreach my $round (@rounds) { 

			my %final_panels = ();
			my @byes;

			foreach my $panel (@{$round_panels{$round->id}}) { 
				push @byes, $panel_entries{$panel}{"aff"} if $panel_entries{$panel}{"neg"} eq "BYE";
				push @byes, $panel_entries{$panel}{"neg"} if $panel_entries{$panel}{"aff"} eq "BYE";
			}

			foreach my $panel (@{$round_panels{$round->id}}) { 
				next if $panel_entries{$panel}{"aff"} eq "BYE";
				next if $panel_entries{$panel}{"neg"} eq "BYE";
				push @{$final_panels{$panel}}, $panel_entries{$panel}{"aff"};
				push @{$final_panels{$panel}}, $panel_entries{$panel}{"neg"};
			}

			write_round($round, \%final_panels, 0, \@byes);

		}

	} else { 

		my %final_panels = ();
		my %round_score;

		foreach my $pass (1 .. 10) { 

			my %panels;

			@entries = shuffle(@entries);
			@entries = sort {$entry_school{$b} <=> $entry_school{$a}} @entries;
			@entries = sort {$school_size{$entry_school{$b}} <=> $school_size{$entry_school{$a}}} @entries;

			my %bye_seed;
			my $seed_aim;

			if ($seed_presets eq "balance") { 

				@entries = sort {$entry_seed{$a} <=> $entry_seed{$b}} @entries;

				my $position = 1;
				foreach my $entry (@entries) { 
					$entry_seed{$entry} = $position++;
				}

				my %opp_position;
				my $opps_taken;

				foreach my $entry (@entries) { 

					foreach my $opp (@{$entry_opps{$entry}}) { 
						$opp_position{$entry} += $entry_seed{$opp};
						$opps_taken++;
					}

					if ($entry_byes{$entry}) { 
						$opp_position{$entry} += scalar @entries;
					}

				}

				@entries = sort {$opp_position{$b} <=> $opp_position{$a}} @entries if $opps_taken;

				$position = 1;

				foreach my $entry (@entries) { 
					$entry_position_need{$entry} = $position++ if $opp_position{$entry} || $entry_byes{$entry};
				}

			} elsif ($seed_presets eq "all") {

				foreach my $entry (@entries) { 
					SEED:
					foreach my $seed (@seeds) { 
						foreach my $opp (@{$entry_opps{$entry}}) { 
							next SEED if $seed eq $entry_seed{$opp};
						}
						$entry_needs{$entry."-".$seed}++;
						$needs_print{$entry} .= " ".$seed unless $needs_print{$entry} eq " ".$seed;
					}
				}

				my $top_count;

				foreach my $seed (@seeds) { 
					$top_count = $seed_count{$seed} if $seed_count{$seed} > $top_count;
				}

				foreach my $seed (@seeds) { 
					$bye_seed{$seed}++ if $seed_count{$seed} == $top_count;
				}

				$seed_byes_as = scalar @entries + 1;

			} elsif ($seed_presets eq "inverse") {

				my $got_bye;

				foreach my $entry (@entries) { 

					my @seeds = (2,3) if ($entry_seed{$entry} == 1 || $entry_seed{$entry} == 4);
					@seeds = (1,4) if ($entry_seed{$entry} == 2 || $entry_seed{$entry} == 3);
					
					if ($entry_byes{$entry}) { 
						$entry_needs{$entry."-2"}++ if $entry_seed{$entry} == 4 || $entry_seed{$entry} == 1;
						$entry_needs{$entry."-1"}++ if $entry_seed{$entry} == 2 || $entry_seed{$entry} == 3;
						$needs_print{$entry} .= " nobye";
						$got_bye = $entry_seed{$entry};
					}

					SEED:
					foreach my $seed (@seeds) { 
						foreach my $opp (@{$entry_opps{$entry}}) { 
							next SEED if $seed eq $entry_seed{$opp};
						}
						$entry_needs{$entry."-".$seed}++;
						$needs_print{$entry} .= " ".$seed;
					}
				}

				if ( ($seed_count{1} + $seed_count{4}) < ($seed_count{2} + $seed_count{3}) ) {
					if ($got_bye == 3) { 
						$bye_seed{2}++;
					} else { 
						$bye_seed{3}++;
					}
					$seed_byes_as = 4;
				}

				if ( ($seed_count{1} + $seed_count{4}) > ($seed_count{2} + $seed_count{3}) ) {
					if ($got_bye == 4) { 
						$bye_seed{1}++;
					} else { 
						$bye_seed{4}++;
					}
					$seed_byes_as = 3;
				}

			}

			@entries = shuffle @entries;

			my @due_aff;
			my @due_neg;
			my @due_whatever;

			my %due;

			foreach my $entry (@entries) { 

				next if $entry == $bye;

				if ($entry_negs{$entry} > $entry_affs{$entry}) { 
					push @due_aff, $entry;
					$due{$entry} = 1;
				} elsif ($entry_negs{$entry} < $entry_affs{$entry}) { 
					push @due_neg, $entry;
					$due{$entry} = 2;
				} elsif ($seed_presets eq "inverse" &! $entry_byes{$entry}) { 
					push @due_neg, $entry if $entry_seed{$entry} == 2 || $entry_seed{$entry} == 3;
					push @due_aff, $entry if $entry_seed{$entry} == 1 || $entry_seed{$entry} == 4;
				} else { 
					push @due_whatever, $entry;
					$due{$entry} = 0;
				}
			}

			my %used;

			if ((scalar @entries) % 2) { 

				# Pull a bye from whatever entry randomly shuffled to the top
				# from among those who have not had a bye.  

				my @tried;

				my @candidates;

				@candidates = @due_aff if scalar @due_aff > scalar @due_neg;
				@candidates = @due_neg if scalar @due_aff < scalar @due_neg;
				@candidates = @entries if scalar @due_aff == scalar @due_neg;

				if ($seed_presets eq "balance") {
					my $average = (scalar @entries) / 2;
					@candidates = sort { abs($entry_seed{$a} - $average) <=> abs($entry_seed{$b} - $average) } @candidates;
					#this sorts the candidates so that the bye is more likely to come from the middle
					@candidates = sort {$entry_position_need{$b} <=> $entry_position_need{$a}} @candidates if $entry_position_need{$entries[0]};
				}

				while (not defined $bye) { 

					unless (@candidates) { 
						@tried = shuffle @tried;
						$bye = shift @tried;
					}

					my $test = shift @candidates;

					if ($test) { 

						my $nope;

						$nope++ if $entry_byes{$test};

						if (keys %bye_seed) { 
							unless ($bye_seed{$entry_seed{$test}}) { 
								push @tried, $test;
								$nope++;
							}
						}

						if ($seed_presets eq "inverse" ) { 
							unless ($entry_needs{$test."-".$seed_byes_as} > 0) { 
								push @tried, $test;
								$nope++;
							}
						}

						$bye = $test unless $nope;
					}

				}

				if ($bye) { 

					undef $due{$bye};
					$used{$bye}++;

					my $index = 0;
					$index++ until $due_aff[$index] eq $bye || $index > scalar @due_aff;
					splice(@due_aff, $index, 1);

					$index = 0;
					$index++ until $due_neg[$index] eq $bye || $index > scalar @due_neg;
					splice(@due_neg, $index, 1);

					$index = 0;
					$index++ until $due_whatever[$index] eq $bye || $index > scalar @due_whatever;
					splice(@due_whatever, $index, 1);

				}

			}

			my %seen = (); 
			@due_whatever = grep { ! $seen{$_} ++ } @due_whatever;
			@due_aff = grep { ! $seen{$_} ++ } @due_aff;
			@due_neg = grep { ! $seen{$_} ++ } @due_neg;

			my %partner;
			my $average = (scalar @entries) / 2;

			if ($seed_presets eq "balance") {
				@due_whatever = sort { abs($entry_seed{$a} - $average) <=> abs($entry_seed{$b} - $average) } @due_whatever;
			}

			WHATEVER:
			while (@due_whatever) { 

				# Randomly sprinkle the whatevers until both sides are even.
				# We do this now instead of waiting until the end to prevent
				# the byes from always hitting one another, since if there are
				# multiple byes at this point, they're almost certainly
				# screwups who don't deserve that kind of consideration.

				@due_whatever = shuffle @due_whatever unless $seed_presets eq "balance";

				my $pull = shift @due_whatever;
				next if $used{$pull}++;

				my $partner = pop @due_whatever if @due_whatever && $seed_presets eq "balance";
				$used{$partner}++;

				$partner{$pull} = $partner;
				$partner{$partner} = $pull;

				my $opp1;
				my $opp2;

				if (scalar @due_neg < scalar @due_aff) { 
					push @due_neg, $pull;
					push @due_aff, $partner if $partner;
				} else { 
					push @due_aff, $pull;
					push @due_neg, $partner if $partner;
				}

			}

			@due_aff = shuffle @due_aff;
			@due_neg = shuffle @due_neg;

			while (scalar @due_aff > scalar @due_neg) { 
				#Shift some poor suckers over
				push @due_neg, shift @due_aff;
			}

			while (scalar @due_aff < scalar @due_neg) { 
				#Shift some poor suckers over
				push @due_aff, shift @due_neg;
			}

			my %is_due_aff = map {$_ => 1} @due_aff;
			my %is_due_neg = map {$_ => 1} @due_neg;

			my $aff_string;
			my $neg_string;

			foreach my $aff (@due_aff) { 
				$aff_string .= " ".$entry_code{$aff};
			}

			foreach my $neg (@due_neg) { 
				$neg_string .= " ".$entry_code{$neg};
			}

			my $counter = 1;
			my @panel_keys;

			if ($seed_presets eq "protect") { 
				@due_aff = sort {$entry_seed{$a} <=> $entry_seed{$b}} @due_aff;
				@due_neg = sort {$entry_seed{$b} <=> $entry_seed{$a}} @due_neg;
			}

			if ($seed_presets eq "balance") { 
				@due_aff = sort { abs($entry_seed{$a} - $average) <=> abs($entry_seed{$b} - $average) } @due_aff;
				@due_neg = sort { abs($entry_seed{$b} - $average) <=> abs($entry_seed{$a} - $average) } @due_neg;
			}

			my %done;
			my $negs;

			foreach my $aff (@due_aff) { 

				next if $done{$aff}++;
				my $neg;

				if ($needs_print{$aff}) { 

					# This segment manages seeded presets and matches people based
					# on ideal seeding needs.  Only invoked for inverse & all
					# seed_protect settings.

					@due_neg = shuffle @due_neg unless $seed_presets eq "balance";

					foreach my $debate_me_maybe (@due_neg) { 
						next if $done{"maybe_".$debate_me_maybe};
						next unless $entry_needs{$debate_me_maybe."-".$entry_seed{$aff}};
						next unless $entry_needs{$aff."-".$entry_seed{$debate_me_maybe}};

						next if $entry_school{$aff} == $entry_school{$debate_me_maybe};
						next if $entry_school{$aff} == $entry_school{$partner{$debate_me_maybe}};
						next if $entry_school{$debate_me_maybe} == $entry_school{$partner{$aff}};

						if ($region_constrain || $region_avoid) { 
							next if $entry_region{$aff} == $entry_region{$debate_me_maybe};
						}

						# If we made it this far, WE NEED ONE ANOTHER.  IT IS DESTINY.
						$neg = $debate_me_maybe;
						$done{"maybe_".$debate_me_maybe}++;
						last if $neg;
					}

					# I found no opponent who is not a perfect fit.  So, I cope as
					# best I can.  Find someone whose need I fit while not fitting
					# mine, if such exists.	

					unless ($neg) { 
						foreach my $debate_me_maybe (@due_neg) { 
							next unless $entry_needs{$neg."-".$entry_seed{$aff}};
							$neg = $debate_me_maybe;
							$done{"maybe_".$debate_me_maybe}++;
							last if $neg;
						}
					}

					# All right, try the inverse if that didn't work.
					unless ($neg) { 
						foreach my $debate_me_maybe (@due_neg) { 
							next unless $entry_needs{$aff."-".$entry_seed{$neg}};
							$neg = $debate_me_maybe;
							$done{"maybe_".$debate_me_maybe}++;
							last if $neg;
						}
					}

					# If we're still doomed the next bit will just pick any old
					# neg.  If this is just because randomization doomed us, the
					# swapper later will help.

				}

				Tab::debuglog("$aff seed $entry_seed{$aff} first hits $neg seed $entry_seed{$neg}");

				if ($seed_presets eq "balance") {

					my $need = $entry_position_need{$aff};
					my $current_diff;
					my $current_clash = 8301239291;

					foreach my $maybe_neg (@due_neg) { 

						next if $done{$maybe_neg};

						my $clash;

						$clash++ if $entry_school{$aff} == $entry_school{$maybe_neg};
						$clash++ if $entry_school{$aff} == $entry_school{$partner{$maybe_neg}};
						$clash++ if $entry_school{$maybe_neg} == $entry_school{$partner{$aff}};

						if ($region_avoid || $region_constrain) { 
							$clash++ if $entry_region{$aff} == $entry_region{$maybe_neg};
							$clash++ if $entry_region{$aff} == $entry_region{$partner{$maybe_neg}};
							$clash++ if $entry_region{$maybe_neg} == $entry_region{$partner{$aff}};
						}

						my $diff; 

						if ($entry_position_need{$aff}) { 
							$diff = abs($entry_position_need{$aff} - $entry_seed{$maybe_neg});
							$diff += abs($entry_position_need{$maybe_neg} - $entry_seed{$aff});
						}

						if ($clash < $current_clash) { 
							$neg = $maybe_neg;
							$current_clash = $clash;
							$current_diff = $diff;
						} elsif ($clash == $current_clash && $diff < $current_diff) {
							$neg = $maybe_neg;
							$current_diff = $diff;
						}

						last if $neg && $clash == 0 and $diff == 0;

					}

				}

				unless ($neg) { 
					foreach my $test_neg (@due_neg) { 
						$neg = $test_neg unless $done{$test_neg};
						last if $neg;
					}
				}

				$done{$neg}++;
				$negs++;

				push @{$panels{$counter}}, $aff;
				push @{$panels{$counter}}, $neg;

				Tab::debuglog("$aff seed $entry_seed{$aff} now hits $neg seed $entry_seed{$neg}");

				push @panel_keys, $counter++;

				if ($partner{$aff} && $partner{$neg} &! $done{$partner{$aff}} &! $done{$partner{$neg}}) { 

					if ($is_due_aff{$partner{$aff}} && $is_due_neg{$partner{$neg}}) { 
					
						if ($entry_school{$partner{$aff}} != $entry_school{$partner{$neg}} &&
							($region_constrain && $entry_region{$partner{$aff}} != $entry_region{$partner{$neg}})) { 

							push @{$panels{$counter}}, $partner{$aff};
							push @{$panels{$counter}}, $partner{$neg};
							push @panel_keys, $counter++;
							$done{$partner{$aff}}++;
							$done{$partner{$neg}}++;
							$negs++;
						}
					}
				}
			}

			my $no_improvement = 1;

			foreach my $counter (1 .. 5) {

				next if $no_improvement == 0;
				$no_improvement = 0;

				foreach my $panel_key (shuffle @panel_keys) {

					my @panel = @{$panels{$panel_key}};

					my $current_diff;
					my $swap_key;
					my $swap_cross;

					my $baseline_panel1_score = score_panel(\@panel, \%entry_school, \%entry_hits, \%entry_opp_side, \%entry_school_hit,\%entry_region, \%entry_region_hit, $seed_presets, \%entry_seed, \%entry_needs, \%entry_position_need);

					next if $baseline_panel1_score < 1;

					my $aff1 = shift @panel;
					my $neg1 = shift @panel;

					OTHERPANEL:
					foreach my $other_key (@panel_keys) {
					
						next if $other_key == $panel_key;

						my @panel2 = @{$panels{$other_key}};
						my $baseline_panel2_score = score_panel(\@panel2, \%entry_school, \%entry_hits, \%entry_opp_side, \%entry_school_hit,\%entry_region, \%entry_region_hit, $seed_presets, \%entry_seed, \%entry_needs, \%entry_position_need);

						my $aff2 = shift @panel2;
						my $neg2 = shift @panel2;

						if ($seed_presets eq "protect" || $seed_presets eq "inverse") { 
							if ( ($entry_seed{$aff1} != $entry_seed{$aff2}) || ($entry_seed{$neg1} != $entry_seed{$neg2})) { 
								#Cannot swap due to seeding conflicts
								@panel2 = ($aff2, $neg2);
								next OTHERPANEL;
							}
						}

						my @new_1 = ($aff1, $neg2);
						my @new_2 = ($aff2, $neg1);

						my $swap_panel1_score = score_panel(\@new_1, \%entry_school, \%entry_hits, \%entry_opp_side, \%entry_school_hit,\%entry_region, \%entry_region_hit, $seed_presets, \%entry_seed, \%entry_needs, \%entry_position_need);
						my $swap_panel2_score = score_panel(\@new_2, \%entry_school, \%entry_hits, \%entry_opp_side, \%entry_school_hit,\%entry_region, \%entry_region_hit, $seed_presets, \%entry_seed, \%entry_needs, \%entry_position_need); 


						my $new_score = $swap_panel1_score + $swap_panel2_score;
						my $baseline = $baseline_panel1_score + $baseline_panel2_score;
						my $diff = $baseline - $new_score;


						if ( $diff >= 0 && $diff >= $current_diff) {
							$current_diff = $diff;
							$swap_key = $other_key;
							undef $swap_cross;
							last OTHERPANEL if $new_score == 0;
						}


						# Attempt various cross side swaps if that makes things better and they're not side constrained.

						unless ($due{$aff1} == 1 || $due{$neg2} == 2)  { 

							my @new_1 = ($neg2, $neg1);
							my @new_2 = ($aff2, $aff1);

							my $dont;

							if ($seed_presets eq "protect") { 
								if ($entry_seed{$neg2} != $entry_seed{$aff1}) { 
									#Cannot swap due to seeding conflicts
									@panel2 = ($aff2, $neg2);
									$dont++;
								}
							}

							unless ($dont) { 

								my $swap_panel1_score = score_panel(\@new_1, \%entry_school, \%entry_hits, \%entry_opp_side, \%entry_school_hit,\%entry_region, \%entry_region_hit, $seed_presets, \%entry_seed, \%entry_needs, \%entry_position_need);
								my $swap_panel2_score = score_panel(\@new_2, \%entry_school, \%entry_hits, \%entry_opp_side, \%entry_school_hit,\%entry_region, \%entry_region_hit, $seed_presets, \%entry_seed, \%entry_needs, \%entry_position_need); 

								my $new_score = $swap_panel1_score + $swap_panel2_score;
								my $baseline = $baseline_panel1_score + $baseline_panel2_score;
								my $diff = $baseline - $new_score;


								if ( $diff >= 0 && $diff >= $current_diff) {
									$current_diff = $diff;
									$swap_key = $other_key;
									$swap_cross = 1;
								}
							}

						}

						unless ($due{$aff2} == 1 || $due{$neg1} == 2)  { 

							my @new_1 = ($aff1, $aff2);
							my @new_2 = ($neg1, $neg2);

							my $dont;

							if ($seed_presets eq "protect") { 
								if ($entry_seed{$neg1} != $entry_seed{$aff2}) { 
									#Cannot swap due to seeding conflicts
									@panel2 = ($aff2, $neg2);
									$dont++;
								}
							}

							unless ($dont) { 

								my $swap_panel1_score = score_panel(\@new_1, \%entry_school, \%entry_hits, \%entry_opp_side, \%entry_school_hit,\%entry_region, \%entry_region_hit, $seed_presets, \%entry_seed, \%entry_needs, \%entry_position_need);
								my $swap_panel2_score = score_panel(\@new_2, \%entry_school, \%entry_hits, \%entry_opp_side, \%entry_school_hit,\%entry_region, \%entry_region_hit, $seed_presets, \%entry_seed, \%entry_needs, \%entry_position_need); 

								my $new_score = $swap_panel1_score + $swap_panel2_score;
								my $baseline = $baseline_panel1_score + $baseline_panel2_score;
								my $diff = $baseline - $new_score;


								if ( $diff >= 0 && $diff >= $current_diff) {
									$current_diff = $diff;
									$swap_key = $other_key;
									$swap_cross = 2;
								}
							}

						}
					}

					
					if ($swap_key) { 


						my @new_1;
						my @new_2;

						my @swap_panel = @{$panels{$swap_key}};

						my $aff2 = shift @swap_panel;
						my $neg2 = shift @swap_panel;


						if ($swap_cross == 1) { 
							@new_1 = ($neg2, $neg1);
							@new_2 = ($aff2, $aff1);
						} elsif ($swap_cross == 2) { 
							@new_1 = ($aff1, $aff2);
							@new_2 = ($neg1, $neg2);
						} else { 
							@new_1 = ($aff1, $neg2);
							@new_2 = ($aff2, $neg1);
						}

						@{$panels{$panel_key}} = @new_1;
						@{$panels{$swap_key}} = @new_2;

						$no_improvement++;  # Fail

					}

				}

				foreach my $panel_key (shuffle @panel_keys) {

					#Try some triple swaps;
					my @panel = @{$panels{$panel_key}};

					my $current_diff;

					my $swap_key_1;
					my $swap_cross_1;

					my $swap_key_2;
					my $swap_cross_2;

					my $swap_key_3;
					my $swap_cross_3;

					my $baseline_panel1_score = score_panel(\@panel, \%entry_school, \%entry_hits, \%entry_opp_side, \%entry_school_hit,\%entry_region, \%entry_region_hit, $seed_presets, \%entry_seed, \%entry_needs, \%entry_position_need);
					next if $baseline_panel1_score < 1;

					my $aff1 = shift @panel;
					my $neg1 = shift @panel;

					my $aff2;
					my $neg2;

					my $baseline_panel2_score;
					my $swapped_panel2_score;

					OTHERPANEL:
					foreach my $other_key (@panel_keys) {

						next if $other_key == $panel_key;

						my @panel2 = @{$panels{$other_key}};
						$baseline_panel2_score = score_panel(\@panel2, \%entry_school, \%entry_hits, \%entry_opp_side, \%entry_school_hit,\%entry_region, \%entry_region_hit, $seed_presets, \%entry_seed, \%entry_needs, \%entry_position_need);

						$aff2 = shift @panel2;
						$neg2 = shift @panel2;

						my @new2 = ($aff1, $neg2);
						$swapped_panel2_score = score_panel(\@new2, \%entry_school, \%entry_hits, \%entry_opp_side, \%entry_school_hit,\%entry_region, \%entry_region_hit, $seed_presets, \%entry_seed, \%entry_needs, \%entry_position_need);

						my $diff = $baseline_panel2_score - $swapped_panel2_score;

						if ($diff >= $current_diff) { 
							$swap_key_2 = $other_key;
							$current_diff = $diff;
						}
					}

					if ($swap_key_2) { 

						undef $current_diff;

						OTHERPANEL:
						foreach my $other_key (@panel_keys) {

							next if $other_key == $panel_key;
							next if $other_key == $swap_key_2;

							my @panel3 = @{$panels{$other_key}};
							my $baseline_panel3_score = score_panel(\@panel3, \%entry_school, \%entry_hits, \%entry_opp_side, \%entry_school_hit,\%entry_region, \%entry_region_hit, $seed_presets, \%entry_seed, \%entry_needs, \%entry_position_need);

							my $aff3 = shift @panel3;
							my $neg3 = shift @panel3;

							my @new3 = ($aff2, $neg3);
							my $swapped_panel3_score = score_panel(\@new3, \%entry_school, \%entry_hits, \%entry_opp_side, \%entry_school_hit,\%entry_region, \%entry_region_hit, $seed_presets, \%entry_seed, \%entry_needs, \%entry_position_need);

							my @new1 = ($aff3, $neg1);
							my $swapped_panel1_score = score_panel(\@new1, \%entry_school, \%entry_hits, \%entry_opp_side, \%entry_school_hit,\%entry_region, \%entry_region_hit, $seed_presets, \%entry_seed, \%entry_needs, \%entry_position_need);

							my $baseline = $baseline_panel1_score + $baseline_panel2_score + $baseline_panel3_score;
							my $swapped = $swapped_panel1_score + $swapped_panel2_score + $swapped_panel3_score;

							my $diff = $baseline - $swapped;

							if ($diff >= $current_diff) { 
								$swap_key_3 = $other_key;
								$current_diff = $diff;
							}
						}
					}

					if ($swap_key_2 && $swap_key_3) { 


						my @new_1;
						my @new_2;
						my @new_3;

						my @swap_2_panel = @{$panels{$swap_key_2}};
						my @swap_3_panel = @{$panels{$swap_key_3}};

						my $aff2 = shift @swap_2_panel;
						my $neg2 = shift @swap_2_panel;

						my $aff3 = shift @swap_3_panel;
						my $neg3 = shift @swap_3_panel;

						@new_1 = ($aff3, $neg1);
						@new_2 = ($aff1, $neg2);
						@new_3 = ($aff2, $neg3);

						@{$panels{$panel_key}} = @new_1;
						@{$panels{$swap_key_2}} = @new_2;
						@{$panels{$swap_key_3}} = @new_3;

						$no_improvement++;  # Fail

					}

				}

			}

			my $new_score;

			foreach my $panel_key (shuffle @panel_keys) {
				$new_score += score_panel(\@{$panels{$panel_key}}, \%entry_school, \%entry_hits, \%entry_opp_side, \%entry_school_hit,\%entry_region, \%entry_region_hit, $seed_presets, \%entry_seed, \%entry_needs, \%entry_position_need);
			}

			if ($new_score < $best_score || not defined $best_score) { 
				%final_panels  = %panels;
				%round_score = $new_score;
				$best_score = $new_score;
			}

		}

		my @byes;
		push @byes, $bye;

		write_round($round, \%final_panels, $round_score{$round->id}, \@byes);
	}

	undef $region_constrain;
	undef $region_avoid;
	undef %entry_code;

	sub write_round {

		my ($round, $final_panref, $score, $byeref) = @_;

		my @byes = @{$byeref};

		#Out with the old.

		Tab::BallotValue->set_sql( delete_round => "
			delete ballot_value from ballot_value, ballot, panel
			where panel.round = ?
			and panel.id = ballot.panel
			and ballot.id = ballot_value.ballot
		");

		Tab::Ballot->set_sql( delete_round => "
			delete ballot from ballot, panel
			where panel.round = ?
			and panel.id = ballot.panel
		");

		Tab::Panel->set_sql( delete_round => "
			delete from panel where round = ?
		");

		Tab::BallotValue->sql_delete_round->execute($round->id);
		Tab::Ballot->sql_delete_round->execute($round->id);
		Tab::Panel->sql_delete_round->execute($round->id);

		my $letter = 1;
		$letter = "A" if $round->event->setting("panel_labels") eq "letters";

		my %used;

		my @keys = sort {$a <=> $b} keys %{$final_panref};

		foreach my $key (@keys) { 
					
			my $panel = Tab::Panel->create({
				round  => $round->id,
				letter => $letter,
				flight => 1,
				score  => $score
			});

			if ($letter eq "Z") { 
				$letter = "AA";
			} elsif ($letter eq "AZ") { 
				$letter = "BA";
			} elsif ($letter eq "BZ") {
				$letter = "CA";
			} elsif ($letter eq "CZ") {
				$letter = "DA";
			} elsif ($letter eq "DZ") {
				$letter = "EA";
			} elsif ($letter eq "EZ") {
				$letter = "FA";
			} else { 
				$letter++;
			}

			my $aff = shift @{${$final_panref}{$key}};
			my $neg = shift @{${$final_panref}{$key}};


			my $aff_ballot = Tab::Ballot->create({
				panel => $panel->id,
				judge => 0,
				entry => $aff,
				side  => 1
			}) unless $used{$aff}++;

			my $neg_ballot = Tab::Ballot->create({
				panel => $panel->id,
				judge => 0,
				entry => $neg,
				side  => 2
			}) unless $used{$neg}++;

		}

		foreach my $bye (@byes) { 

			my $panel = Tab::Panel->create({
				round  => $round->id,
				letter => $letter++,
				bye    => 1,
				flight => 1
			});

			my $bye_ballot = Tab::Ballot->create({
				panel => $panel->id,
				judge => 0,
				entry => $bye,
				side  => 1,
				audit => 1
			});

		}

		my $now = DateTime->now;
		$round->created($now);
		$round->update;
	}

    sub score_panel {

        my ($panref, $schref, $hitref, $hit_side_ref, $hit_school_ref, $regref, $hit_region_ref, $seed_presets, $seed_ref, $need_seed_ref, $need_position_ref) = @_; 

		return unless @{$panref};
		my $aff = shift @{$panref};

		return unless @{$panref};
		my $neg = shift @{$panref};

        my $score = 0;

		if (${$schref}{$neg} == ${$schref}{$aff}) { 
			# We are from the same school.  Highest penalty.
			$score += 10000;   
		}   

		if (${$hitref}{$neg} == ${$hitref}{$aff}) { 
			# We have debated against each other previously
			$score += 1000 * ${$hitref}{$aff."-".$neg};
			$score += 1000 * ${$hitref}{$neg."-".$aff};
		}

		if (${$hit_side_ref}{$aff."-".$neg."-1"}) { 
			# We have debated against each other on this side.
			$score += 100;   
		}   

		if ($region_avoid) { 
			if (${$regref}{$neg} == ${$regref}{$aff}) { 
				# We are from the same region.  Moderate penalty to avoid.
				$score += 50;
			}
			$score += ${$hit_region_ref}{$aff."-".${$regref}{$neg}} * 5;
			$score += ${$hit_region_ref}{$neg."-".${$regref}{$aff}} * 5;
		}

		if ($region_constrain) { 
			if (${$regref}{$neg} == ${$regref}{$aff}) { 
				# We are from the same region.  Treating penalties as schools here
				$score += 10000;
			}
			$score += ${$hit_region_ref}{$aff."-".${$regref}{$neg}};
			$score += ${$hit_region_ref}{$neg."-".${$regref}{$aff}};
		}

		if ($seed_presets eq "all") { 
			$score += 10 unless ${$need_seed_ref}{$aff."-".${$seed_ref}{$neg}};
			$score += 10 unless ${$need_seed_ref}{$neg."-".${$seed_ref}{$aff}};
		}

		if ($seed_presets eq "balance") { 
			my $aff_diff = abs(${$need_position_ref}{$aff} - ${$seed_ref}{$neg});
			my $neg_diff = abs(${$need_position_ref}{$neg} - ${$seed_ref}{$aff});
			$score += 10 * $aff_diff if ${$need_position_ref}{$aff};
			$score += 10 * $neg_diff if ${$need_position_ref}{$neg};
		}

		# We have debated against someone else from that same school.  Lowest
		# penalty.

		$score += ${$hit_school_ref}{$aff."-".${$schref}{$neg}};
		$score += ${$hit_school_ref}{$neg."-".${$schref}{$aff}};

		@{$panref} = ($aff, $neg);

        return $score;

    }   


</%perl>
