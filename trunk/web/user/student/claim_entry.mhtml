<%args>
	$account
	$entry_id
</%args>
<%init>

	#STEP ONE: pull the student and entry records
	my @students = Tab::Student->search( account => $account->id );
	
	#bail if there's no student record
	unless (@students)  {
		$m->redirect("/user/student/index.mhtml?err=Operation cancelled: No student records associated with this account&msg=");
	}
	
	#didn't bail, so pull the student record
	my $student = shift @students;
	my $entry = Tab::Entry->retrieve($entry_id);
	
	#check that student is not already entered in the event
	#OR, my @students = $m->comp("/funclib/event_student.mas", event=>$event);

	Tab::EntryStudent->set_sql(test_student_in_event => "
		select entry_student.* from entry_student, entry where entry.event = ?
		and entry.id=entry_student.entry
		and entry_student.student=?
	");
		
	my $es = Tab::EntryStudent->search_test_student_in_event($entry->event, $student->id);
	if (scalar($es) > 0) {
		$m->redirect("/user/student/index.mhtml?err=Add cancelled -- already entered in this event&msg=");
	}
	
	#check the number of students in the entry and bail if there are no empty spots
	my @entry_students = $entry->students;
	#print "n entries=".length(@entry_students)." max allowed is ".$entry->event->setting("max_entry"); 

	if (scalar(@entry_students) >= $entry->event->setting("max_entry")) {
		$m->redirect("/user/student/index.mhtml?err=Can't add -- all spots for this entry are filled&msg=");
	}
			
	#STEP TWO: create a new entry_student record for the entry
	SaveStudentEntry($entry->id, $student->id);
	$m->redirect("/user/student/index.mhtml?err=&msg=entry saved");
	
	#Now the sub.  Why the sub, you ask, Chris?  Easier to disable while I was debugging...
	sub SaveStudentEntry {

		my ($entry_id, $student_id) = @_;

		my $entryobject = Tab::EntryStudent->create( {
			entry => $entry_id,
			student => $student_id
		});

	}
</%init>
