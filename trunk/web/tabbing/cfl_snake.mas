<%args>
	$basis
	$type
	$event
	@breaks
	$numpanels
	$round
	$debug => undef
</%args>
<%init> 

	if ($basis eq "prelim") { 

		#From Prelim rounds, the CFL does a seeded snake, and it will adjust
		#where possible among students with equal ranks to preserve diocesan
		#balance.

		$m->comp(
           "elim_panel_snake_ncfl.mas",
             breaks => \@breaks,
             event => $event, 
             type => $type, 
             basis => $basis, 
             round => $round, 
             numpanels => $numpanels
       );

	} else { 

	use POSIX;

	# Snaking involves putting students in panels based on power.  They should
	# already be in order by seeding.  

	my $letter = "A";

	# Preset panels
    my @panels = $round->panels;

	my $num_at_level = $numpanels * 2;
	my $num_levels = ceil ((scalar @breaks)/$num_at_level);

	system "/usr/bin/logger Number at each level is $num_at_level." if $debug == 1;
	system "/usr/bin/logger Number of levels is $num_levels." if $debug == 1;
	system "/usr/bin/logger Number of panels is $numpanels." if $debug == 1;

	my %kids_at_level = ();

	my @reordered_breaks;

	foreach my $level (1 .. $num_levels) { 

		foreach (1 .. $num_at_level) { 	
			push (@{$kids_at_level{$level}}, shift @breaks);
		}

#		Take the first few kids off of the front of the first sublevel and
#		put them into the back so that the paneling rules are followed.

		foreach my $shift (2 .. $level) { 
			my $deorder = shift @{$kids_at_level{$level}};
			push (@{$kids_at_level{$level}}, $deorder);
		}

		push (@reordered_breaks, @{$kids_at_level{$level}});

	}
	
	PANEL:
	foreach my $key (1 .. $numpanels) { 

		$key--;

       #If there's already a panel here, use that instead
        if ($panels[$key]) {
            $letter = $panels[$key]->letter;
            next PANEL;
        }
	
		my $newpanel = Tab::Panel->create({ 
			letter => $letter,
			round => $round->id,
			event => $event->id,
			type => $type
		});

		$letter++;
		push (@panels, $newpanel); 
	} 

	my @tmp_panels;
	my $seed;

	foreach my $break (@reordered_breaks) { 	

		next unless $break;

		unless (@tmp_panels) { #if tmp_panels doesn't exist, reload the hopper
			$seed++;
			if ($seed == 5 && $numpanels == 2) {  # That funny thing with semis
				@tmp_panels = reverse @panels;
			} else { 
				@tmp_panels =  @panels;
			}
		}

		my $panel = shift @tmp_panels;

		my @judges = $panel->judges;

		if ($panel->judges) { 


			foreach my $judge ($panel->judges) { 

				my $ballot = Tab::Ballot->create({
					panel => $panel->id,
					entry  => $break->id,
					judge => $judge->id,
					speechnumber => 1,
					seed => $seed,
				});

			}

		} else {

			my $ballot = Tab::Ballot->create({
				panel => $panel->id,
				entry  => $break->id,
				speechnumber => 1,
				seed => $seed,
			});

		}

	} 
	
	}

    foreach ($round->empties) { $_->delete; }
    $round->preset(0);
    $round->update;

	return;

</%init> 
